<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>quadGEN v1.1</title>
  <meta name="description" content="quadGEN - Generate Epson P900/P800 QuadToneRIP .quad files with 256-step ramps per channel." />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Always show number input arrows */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: inner-spin-button !important;
      opacity: 1 !important;
    }
    
    input[type="number"] {
      -moz-appearance: textfield;
    }
    
    input[type="number"]::-moz-number-spin-box {
      -moz-appearance: spin-textfield !important;
    }

    /* Slider toggle styles */
    .slider-toggle {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }

    .slider-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #10b981;
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #10b981;
    }

    input:checked + .slider:before {
      transform: translateX(20px);
    }

    input:disabled + .slider {
      background-color: #e5e5e5;
      cursor: not-allowed;
    }

    input:disabled + .slider:before {
      background-color: #f5f5f5;
    }

    /* Custom scrollbar styling for file preview */
    #previewFull::-webkit-scrollbar {
      width: 24px;
    }

    #previewFull::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 12px;
    }

    #previewFull::-webkit-scrollbar-thumb {
      background: #ffffff;
      border-radius: 12px;
      border: 3px solid #2d3748;
      min-height: 60px;
    }

    #previewFull::-webkit-scrollbar-thumb:hover {
      background: #f7fafc;
    }

    #previewFull::-webkit-scrollbar-thumb:active {
      background: #e2e8f0;
    }

    /* Instant tooltip for linearization buttons */
    .per-channel-btn, #globalLinearizationBtn {
      position: relative;
    }

    .per-channel-btn:hover::after, #globalLinearizationBtn:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #1f2937;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 1000;
      margin-bottom: 4px;
      pointer-events: none;
    }

    .per-channel-btn:hover::before, #globalLinearizationBtn:hover::before {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #1f2937;
      z-index: 1000;
      pointer-events: none;
    }
  </style>
</head>
<body class="min-h-screen bg-gray-50 p-6">
  <main class="mx-auto max-w-6xl">
    <section class="bg-white rounded-2xl shadow-lg p-6 md:p-8">
      <header class="mb-6">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 items-center mb-2">
          <div class="flex items-center gap-4 lg:col-span-2">
            <svg id="quadgenLogo" xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 160 160" role="img" aria-labelledby="quadgenTitle quadgenDesc">
              <title id="quadgenTitle">quadGEN icon (CMYK)</title>
              <desc id="quadgenDesc">Four CMYK bars with a rising Bezier-style curve and nodes, flat design.</desc>
              <!-- baseline -->
              <path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round"/>
              <!-- CMYK bars -->
              <rect id="cyanBar" x="20" y="90" width="20" height="40" rx="6" ry="6" fill="#00B5E2"/>
              <rect id="magentaBar" x="52" y="70" width="20" height="60" rx="6" ry="6" fill="#FF2A8A"/>
              <rect id="yellowBar" x="84" y="50" width="20" height="80" rx="6" ry="6" fill="#FFD400"/>
              <rect id="blackBar" x="116" y="22" width="20" height="110" rx="6" ry="6" fill="#1A1A1A"/>
              <!-- Bezier-like curve -->
              <path id="logoPath" d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18"
                    fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
              <!-- curve nodes -->
              <circle id="node1" cx="30" cy="88" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node2" cx="62" cy="68" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node3" cx="94" cy="48" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node4" cx="126" cy="18" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
            </svg>
            <div>
              <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">
                quadGEN
                <span class="text-gray-400 text-lg">v1.1</span>
              </h1>
              <p class="text-gray-400 text-sm -mt-1">by David Marsh</p>
            </div>
            
            <!-- Compact printer selector -->
            <div class="flex items-center gap-2 bg-gray-50 rounded-lg border border-gray-200 px-3 py-2 ml-auto">
              <label for="printerSelect" class="text-sm font-medium text-gray-700">Printer:</label>
              <select id="printerSelect" class="text-sm rounded border border-gray-300 px-2 py-1">
                <option value="P700">P700</option>
                <option value="P800">P800</option>
                <option value="P900" selected>P900</option>
              </select>
              <p id="channelInfo" class="text-xs text-gray-600 ml-1"></p>
            </div>
          </div>
          
          <!-- Status Display -->
          <div class="lg:col-span-1">
            <div class="bg-gray-50 rounded-lg border border-gray-200 px-3 py-2 text-center">
              <span id="status" class="text-xs text-gray-600 font-medium transition-opacity duration-500 ease-in-out">&nbsp;</span>
            </div>
          </div>
        </div>
        <p id="printerDescription" class="text-gray-600 mt-1"></p>
      </header>

      <!-- Ink Limits Graph and Linearization -->
      <div class="mb-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- Graph Section -->
        <div class="lg:col-span-2">
          <div class="bg-white border border-gray-200 rounded-xl p-4">
            <div class="bg-gray-50 rounded-lg p-4">
              <canvas id="inkChart" width="950" height="700" class="w-full h-auto max-h-none"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Linearization Section -->
        <div class="lg:col-span-1 space-y-4">
          <!-- Global Linearization -->
          <div class="bg-white border border-gray-200 rounded-xl p-3">
            <h3 class="text-lg font-semibold mb-2">Global Linearization Data</h3>
            <p class="text-xs text-gray-600 mb-2">Apply correction curves to modify all ink channels uniformly.</p>
            
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-2 mb-3">
              <p class="text-xs text-blue-800 font-medium mb-1">File Format Info:</p>
              <p class="text-xs text-blue-700">
                <strong>.txt (Color Muse):</strong> Raw measurements → calculates correction curve<br>
                <strong>.cube:</strong> Pre-made correction curves → applies directly
              </p>
            </div>
            
            <!-- Linearization Controls -->
            <div class="space-y-3">              
              <!-- File Upload -->
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Data Source</label>
                <div id="globalLinearizationInfo" class="text-xs text-gray-600 mb-2 hidden">
                  <span id="globalLinearizationFilename" class="font-medium"></span>
                  <span id="globalLinearizationDetails" class="text-gray-500"></span>
                </div>
                <div class="inline-flex items-center gap-2">
                  <input type="file" id="linearizationFile" accept=".cube,.txt" class="hidden">
                  <button id="globalLinearizationBtn" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded border border-gray-300 transition-colors" data-tooltip="Load global linearization">load file</button>
                  <label class="slider-toggle" title="Enable/disable global linearization">
                    <input type="checkbox" id="globalLinearizationToggle" disabled>
                    <span class="slider"></span>
                  </label>
                </div>
                <p class="text-xs text-gray-500 mt-1">accepts .cube or .txt (Color Muse) files</p>
              </div>
            </div>
          </div>
          
          <!-- Interpolation Method -->
          <div class="bg-white border border-gray-200 rounded-xl p-3">
            <h3 class="text-lg font-semibold mb-2">Interpolation Method</h3>
            
            <div class="space-y-3">
              <!-- Smoothing Method -->
              <div>
                <select id="curveSmoothingMethod" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" disabled>
                  <option value="cubic">Cubic Spline</option>
                  <option value="catmull">Catmull-Rom</option>
                  <option value="pchip" selected>PCHIP (monotonic)</option>
                  <option value="linear">Linear (none)</option>
                </select>
                <p id="interpolationDescription" class="text-xs text-gray-500 mt-1">Monotonic interpolation preserves data trends</p>
                
                <!-- Catmull-Rom Tension Control -->
                <div class="mt-2" id="catmullTensionContainer" style="display: none;">
                  <label class="block text-sm font-medium text-gray-700 mb-1">Curve Tension</label>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-500">Tight</span>
                    <input type="range" id="catmullTension" min="0" max="100" value="50" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" disabled>
                    <span class="text-xs text-gray-500">Loose</span>
                  </div>
                  <p class="text-xs text-gray-500 mt-1">Adjust how curvy the interpolation becomes</p>
                </div>
                
              </div>
            </div>
          </div>
          
        </div>
      </div>


      <!-- Apply-to-all controls -->
      <div class="grid md:grid-cols-3 gap-4 items-end">
        <div>
          <label class="block text-sm font-medium text-gray-700">Apply percent to all (0–100)</label>
          <div class="flex gap-2">
            <input id="applyPercent" type="number" step="1" min="0" max="100" value="33" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
            <button id="btnApplyPercent" class="rounded-lg px-4 py-2 bg-black text-white hover:bg-black/90">Apply</button>
          </div>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Apply end value to all (0–64,000)</label>
          <div class="flex gap-2">
            <input id="applyEnd" type="number" step="1" min="0" max="64000" value="21120" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
            <button id="btnApplyEnd" class="rounded-lg px-4 py-2 bg-black text-white hover:bg-black/90">Apply</button>
          </div>
        </div>
        <div class="text-sm text-gray-600">
          Edit either <em>Percent</em> or <em>End</em> – they stay in sync. A value of <strong>0</strong> disables the channel (all zeros).
        </div>
      </div>

      <!-- Channel table -->
      <div class="mt-6 overflow-auto">
        <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden">
          <thead class="bg-gray-50 text-gray-700">
            <tr>
              <th class="text-center px-3 py-2">
                <button id="disableAllBtn" class="px-2 py-1 text-xs bg-red-100 text-red-700 hover:bg-red-200 rounded border border-red-300 transition-colors" title="Disable all channels (set all to 0)">
                  Disable All
                </button>
              </th>
              <th class="text-left px-3 py-2">Channel</th>
              <th class="text-left px-3 py-2">Per-Channel</th>
              <th class="text-left px-3 py-2">Percent (0–100)</th>
              <th class="text-left px-3 py-2">End (0–64,000)</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>

      <!-- Actions -->
      <div class="mt-6">
        <div class="flex items-center gap-2">
          <button id="downloadBtn" class="inline-flex items-center justify-center rounded-lg px-5 py-2 font-medium shadow-sm bg-black text-white hover:bg-black/90">
            ↓ Download .quad
          </button>
          <label for="filenameInput" class="text-sm font-medium text-gray-700">Filename:</label>
          <input id="filenameInput" type="text" placeholder="P900_K33_C33_M33..." class="flex-1 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
          <span class="text-sm text-gray-500">.quad</span>
        </div>
      </div>

      <!-- Configuration Notes -->
      <div class="mt-6">
        <div class="bg-white border border-gray-200 rounded-xl p-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-lg font-semibold">📝 Configuration Notes</h3>
            <button id="notesToggle" class="px-2 py-1 bg-gray-100 hover:bg-gray-200 text-gray-600 hover:text-gray-800 rounded border transition-colors" title="Expand/collapse notes">
              <svg id="notesChevron" class="w-5 h-5 transform transition-transform duration-200" style="transform: rotate(180deg)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
              </svg>
            </button>
          </div>
          
          <div id="notesContent">
            <div>
              <textarea id="userNotes" placeholder="Add notes to be added as comments to the generated .quad file" class="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400 resize-none" rows="4"></textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- Full Preview -->
      <div class="mt-8">
        <h2 class="text-lg font-semibold">Full file preview</h2>
        <p class="text-sm text-gray-600 mb-3">This shows the complete file exactly as it will be saved.</p>
        <div class="border border-gray-200 rounded-xl overflow-hidden">
          <div class="bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700">Preview</div>
          <pre id="previewFull" class="p-4 text-sm leading-6 overflow-auto max-h-[70vh] bg-black text-white font-mono">–</pre>
        </div>
      </div>
    </section>
  </main>

  <script>
    const TOTAL = 64000;
    const N = 256;
    const DENOM = N - 1;

    const PRINTERS = {
      P700: { name: "Epson P700", channels: ["K","C","M","Y","LC","LM","LK","LLK","V","MK"] },
      P800: { name: "Epson P800", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      P900: { name: "Epson P900", channels: ["K","C","M","Y","LC","LM","LK","LLK","V","MK"] }
    };

    const INK_COLORS = {
      K: "#111111",
      C: "#00AEEF",
      M: "#EC008C",
      Y: "#FFF200",
      LC: "#8FD3FF",
      LM: "#FF9AD5",
      LK: "#777777",
      LLK: "#BBBBBB",
      V: "#7F00FF",
      MK: "#000000"
    };


    // Cache DOM elements
    const elements = {
      rows: document.getElementById('rows'),
      printerSelect: document.getElementById('printerSelect'),
      channelInfo: document.getElementById('channelInfo'),
      printerDescription: document.getElementById('printerDescription'),
      applyPercent: document.getElementById('applyPercent'),
      btnApplyPercent: document.getElementById('btnApplyPercent'),
      applyEnd: document.getElementById('applyEnd'),
      btnApplyEnd: document.getElementById('btnApplyEnd'),
      downloadBtn: document.getElementById('downloadBtn'),
      previewFull: document.getElementById('previewFull'),
      status: document.getElementById('status'),
      inkChart: document.getElementById('inkChart'),
      filenameInput: document.getElementById('filenameInput'),
      linearizationFile: document.getElementById('linearizationFile'),
      globalLinearizationBtn: document.getElementById('globalLinearizationBtn'),
      globalLinearizationToggle: document.getElementById('globalLinearizationToggle'),
      curveSmoothingMethod: document.getElementById('curveSmoothingMethod'),
      catmullTension: document.getElementById('catmullTension'),
      catmullTensionContainer: document.getElementById('catmullTensionContainer'),
      userNotes: document.getElementById('userNotes'),
      notesToggle: document.getElementById('notesToggle'),
      notesContent: document.getElementById('notesContent'),
      notesChevron: document.getElementById('notesChevron'),
      disableAllBtn: document.getElementById('disableAllBtn'),
      interpolationDescription: document.getElementById('interpolationDescription'),
      globalLinearizationInfo: document.getElementById('globalLinearizationInfo'),
      globalLinearizationFilename: document.getElementById('globalLinearizationFilename'),
      globalLinearizationDetails: document.getElementById('globalLinearizationDetails'),
    };

    // Input validation utilities
    class InputValidator {
      static clampPercent(p) { 
        const num = parseFloat(p);
        return isNaN(num) ? 0 : Math.min(100, Math.max(0, num)); 
      }
      
      static clampEnd(e) { 
        const num = parseInt(e);
        return isNaN(num) ? 0 : Math.min(64000, Math.max(0, num)); 
      }
      
      static computeEndFromPercent(p) { 
        return Math.round((TOTAL * p) / 100); 
      }
      
      static computePercentFromEnd(e) { 
        return (e / TOTAL) * 100; 
      }

      static validateInput(input, validator) {
        const originalValue = input.value;
        const validatedValue = validator(originalValue);
        const isValid = validatedValue.toString() === originalValue || Math.abs(parseFloat(originalValue) - validatedValue) < 0.01;
        
        input.classList.toggle('border-red-300', !isValid);
        input.classList.toggle('border-gray-300', isValid);
        
        if (!isValid) {
          input.value = validatedValue.toString();
        }
        
        return validatedValue;
      }
    }

    // Debounce function to prevent excessive updates
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function showStatus(message) {
      elements.status.textContent = message;
      elements.status.style.opacity = '1';
      setTimeout(() => {
        if (elements.status.textContent === message) {
          elements.status.style.opacity = '0';
          setTimeout(() => {
            if (elements.status.style.opacity === '0') {
              elements.status.innerHTML = "&nbsp;";
              elements.status.style.opacity = '1';
            }
          }, 500); // Wait for fade transition to complete
        }
      }, 6000);
    }
    
    function animateLogoBars() {
      const cyanBar = document.getElementById('cyanBar');
      const magentaBar = document.getElementById('magentaBar');
      const yellowBar = document.getElementById('yellowBar');
      const blackBar = document.getElementById('blackBar');
      const logoPath = document.getElementById('logoPath');
      const node1 = document.getElementById('node1');
      const node2 = document.getElementById('node2');
      const node3 = document.getElementById('node3');
      const node4 = document.getElementById('node4');
      
      if (!cyanBar || !magentaBar || !yellowBar || !blackBar) return;
      
      // Original values
      const originalHeights = { cyan: 40, magenta: 60, yellow: 80, black: 110 };
      const originalYs = { cyan: 90, magenta: 70, yellow: 50, black: 22 };
      
      let animationStep = 0;
      const maxSteps = 32; // Number of back-and-forth movements
      
      function animateStep() {
        if (animationStep >= maxSteps) {
          // Final return to original state
          cyanBar.setAttribute('height', originalHeights.cyan);
          cyanBar.setAttribute('y', originalYs.cyan);
          magentaBar.setAttribute('height', originalHeights.magenta);
          magentaBar.setAttribute('y', originalYs.magenta);
          yellowBar.setAttribute('height', originalHeights.yellow);
          yellowBar.setAttribute('y', originalYs.yellow);
          blackBar.setAttribute('height', originalHeights.black);
          blackBar.setAttribute('y', originalYs.black);
          logoPath.setAttribute('d', 'M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 32, 126 22');
          node1.setAttribute('cy', '88');
          node2.setAttribute('cy', '68');
          node3.setAttribute('cy', '48');
          node4.setAttribute('cy', '18');
          return;
        }
        
        // Generate oscillating variations that get smaller over time
        const damping = 1 - (animationStep / maxSteps) * 0.7; // Reduce intensity over time
        const frequency = Math.sin(animationStep * 0.8) * damping; // Oscillating pattern
        
        const cyanVariation = originalHeights.cyan + frequency * 12;
        const magentaVariation = originalHeights.magenta + frequency * 15;
        const yellowVariation = originalHeights.yellow + frequency * 18;
        const blackVariation = originalHeights.black + frequency * 25;
        
        // Update bar heights and positions
        cyanBar.setAttribute('height', Math.max(5, cyanVariation));
        cyanBar.setAttribute('y', 132 - Math.max(5, cyanVariation));
        
        magentaBar.setAttribute('height', Math.max(5, magentaVariation));
        magentaBar.setAttribute('y', 132 - Math.max(5, magentaVariation));
        
        yellowBar.setAttribute('height', Math.max(5, yellowVariation));
        yellowBar.setAttribute('y', 132 - Math.max(5, yellowVariation));
        
        blackBar.setAttribute('height', Math.max(5, blackVariation));
        blackBar.setAttribute('y', 132 - Math.max(5, blackVariation));
        
        // Update curve and nodes to match bar heights
        const newCyanY = 132 - Math.max(5, cyanVariation) + 2;
        const newMagentaY = 132 - Math.max(5, magentaVariation) + 2;
        const newYellowY = 132 - Math.max(5, yellowVariation) + 2;
        const newBlackY = 132 - Math.max(5, blackVariation) + 2;
        
        // Update curve path
        const newPath = `M30 ${newCyanY} C 44 ${newCyanY-4}, 50 ${newMagentaY+4}, 62 ${newMagentaY} S 86 ${newYellowY+2}, 94 ${newYellowY} S 118 ${newBlackY+10}, 126 ${newBlackY}`;
        logoPath.setAttribute('d', newPath);
        
        // Update node positions
        node1.setAttribute('cy', newCyanY);
        node2.setAttribute('cy', newMagentaY);
        node3.setAttribute('cy', newYellowY);
        node4.setAttribute('cy', newBlackY);
        
        animationStep++;
        setTimeout(animateStep, 100); // 100ms between each step
      }
      
      animateStep(); // Start the animation sequence
    }
    

    function updatePreview() {
      requestAnimationFrame(() => {
        try {
          const fileText = buildFile();
          elements.previewFull.textContent = fileText;
          updateInkChart();
          updateFilename(); // Update filename when preview updates
          showStatus("Preview updated");
        } catch (error) {
          console.error('Preview update error:', error);
          showStatus("Error updating preview");
        }
      });
    }

    function updateInkChart() {
      if (elements.rows.children.length === 0) return;
      
      const canvas = elements.inkChart;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Set up coordinate system
      const padding = 60;
      const leftPadding = padding - 6; // Shift chart 6px left
      const rightPadding = padding + 6; // Maintain total width
      const chartWidth = width - leftPadding - rightPadding;
      const chartHeight = height - 2 * padding;
      
      // Draw grid
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      
      // Vertical grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Horizontal grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const y = padding + (i * chartHeight / 10);
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(leftPadding + chartWidth, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(leftPadding, padding);
      ctx.lineTo(leftPadding, height - padding);
      ctx.lineTo(leftPadding + chartWidth, height - padding);
      ctx.stroke();
      
      // Draw axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      
      // X-axis labels (0% to 100%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        const value = i * 10;
        // Make 0 and 100 bold
        if (value === 0 || value === 100) {
          ctx.font = 'bold 12px system-ui';
        } else {
          ctx.font = '12px system-ui';
        }
        ctx.fillText(`${value}`, x, height - padding + 20);
      }
      
      // Y-axis labels (0% to 100%)
      ctx.textAlign = 'right';
      for (let i = 0; i <= 10; i++) {
        const y = height - padding - (i * chartHeight / 10);
        const value = i * 10;
        // Make 0 and 100 bold
        if (value === 0 || value === 100) {
          ctx.font = 'bold 12px system-ui';
        } else {
          ctx.font = '12px system-ui';
        }
        ctx.fillText(`${value}`, leftPadding - 10, y + 4);
      }
      
      // Axis titles
      ctx.textAlign = 'center';
      ctx.font = '14px system-ui';
      ctx.fillText('Input Level (1-100)', width / 2, height - 10);
      
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Ink Limit Percentage', 0, 0);
      ctx.restore();
      
      // Draw curves and collect label info
      const labels = [];
      
      Array.from(elements.rows.children).forEach((row, index) => {
        const channelName = row.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(row.querySelector('.end-input').value);
        
        if (endVal === 0) return; // Skip disabled channels
        
        const percent = InputValidator.computePercentFromEnd(endVal);
        const inkColor = INK_COLORS[channelName] || '#000000';
        
        // Generate the 256 values
        const values = make256(endVal, channelName, true); // Apply linearization if enabled
        const maxValue = TOTAL; // 64000
        
        ctx.strokeStyle = inkColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        // Plot the curve
        for (let i = 0; i < values.length; i++) {
          const x = leftPadding + (i / (values.length - 1)) * chartWidth;
          const valuePercent = (values[i] / maxValue) * 100;
          const y = height - padding - (valuePercent / 100) * chartHeight;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        
        // Store label info for later positioning
        const actualEndValue = values[values.length - 1];
        const actualEndPercent = (actualEndValue / maxValue) * 100;
        const endY = height - padding - (actualEndPercent / 100) * chartHeight;
        
        labels.push({
          channelName,
          percent: Math.round(percent),
          inkColor,
          endY
        });
      });
      
      // Draw labels with collision avoidance
      if (labels.length > 0) {
        labels.sort((a, b) => a.endY - b.endY); // Sort by Y position
        
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        
        const minSpacing = 20; // Minimum spacing between labels
        const endX = leftPadding + chartWidth; // Position labels at the right edge of chart
        
        // Adjust label positions to avoid overlaps
        for (let i = 0; i < labels.length; i++) {
          let labelY = labels[i].endY + 4;
          
          // Check for overlap with previous label
          if (i > 0) {
            const prevLabelY = labels[i-1].adjustedY || (labels[i-1].endY + 4);
            if (labelY - prevLabelY < minSpacing) {
              labelY = prevLabelY + minSpacing;
            }
          }
          
          // Store adjusted position
          labels[i].adjustedY = labelY;
          
          // Draw the label with background for better readability
          const labelText = `${labels[i].channelName} (${labels[i].percent}%)`;
          const textMetrics = ctx.measureText(labelText);
          const textWidth = textMetrics.width;
          const textHeight = 18; // Background height for 12px text with padding
          
          // Draw solid white background
          ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
          ctx.fillRect(endX, labelY - textHeight + 2, textWidth + 4, textHeight + 2);
          
          // Calculate centered text position within the background
          const textCenterY = labelY - (textHeight / 2) + 2 + (textHeight / 2);
          
          // Draw text shadow first
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillText(labelText, endX + 3, textCenterY + 1);
          
          // Draw the text
          ctx.fillStyle = labels[i].inkColor;
          ctx.fillText(labelText, endX + 2, textCenterY);
        }
      }
      
      // Animate logo bars when chart is redrawn
      animateLogoBars();
    }

    // Generate filename based on current settings
    function generateFilename() {
      const p = PRINTERS[elements.printerSelect.value];
      let parts = [p.name.replace(/\s+/g, '')]; // Start with printer name
      
      // Add active channels with their percentages
      Array.from(elements.rows.children).forEach((tr) => {
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        
        if (endVal > 0) {
          const percent = Math.round(InputValidator.computePercentFromEnd(endVal));
          parts.push(name + percent);
        }
      });
      
      return parts.join('_');
    }

    // Update filename input with current settings
    function updateFilename() {
      if (!elements.filenameInput.dataset.userEdited) {
        elements.filenameInput.value = generateFilename();
        // Trigger validation styling
        elements.filenameInput.dispatchEvent(new Event('input'));
      }
    }
    function sanitizeFilename(filename) {
      // Remove or replace invalid characters for Windows and Mac
      // Invalid: \ / : * ? " < > |
      return filename
        .replace(/[\\/:*?"<>|]/g, '_')  // Replace invalid chars with underscore
        .replace(/\s+/g, '_')          // Replace spaces with underscores
        .replace(/_{2,}/g, '_')        // Replace multiple underscores with single
        .replace(/^_+|_+$/g, '')       // Trim underscores from start/end
        .substring(0, 200);            // Limit length to 200 chars
    }

    // ---- Linearization utilities ----
    const clamp01 = (x) => Math.max(0, Math.min(1, x));

    // Linearization data storage
    let linearizationData = null;
    let linearizationApplied = false;
    
    // Check if any linearization is available (global or per-channel)
    function hasAnyLinearization() {
      return (linearizationData && linearizationApplied) || 
             Object.keys(perChannelLinearization).length > 0;
    }
    
    // Update interpolation description based on selected method
    function updateInterpolationDescription() {
      const method = elements.curveSmoothingMethod.value;
      const descriptions = {
        'cubic': 'Smooth curves with natural transitions',
        'catmull': 'Catmull-Rom splines - passes through control points like GIMP',
        'pchip': 'Monotonic interpolation preserves data trends', 
        'linear': 'Direct point-to-point connections'
      };
      elements.interpolationDescription.textContent = descriptions[method];
    }
    
    // Update interpolation controls based on linearization availability
    function updateInterpolationControls() {
      const hasLinearization = hasAnyLinearization();
      elements.curveSmoothingMethod.disabled = !hasLinearization;
      elements.catmullTension.disabled = !hasLinearization;
      
      // Show/hide tension control for Catmull-Rom
      const method = elements.curveSmoothingMethod.value;
      const showTension = hasLinearization && method === 'catmull';
      elements.catmullTensionContainer.style.display = showTension ? 'block' : 'none';
      
      // Update description
      updateInterpolationDescription();
    }
    
    // Per-channel linearization storage
    let perChannelLinearization = {};
    let perChannelEnabled = {};
    let perChannelFilenames = {};
    
    // Channel previous values storage (for restore after enable)
    let channelPreviousValues = {};

    /**
     * Parse a .cube file string as a 1D LUT.
     * Returns { domainMin, domainMax, samples } where samples are floats (usually 0..1).
     */
    function parseCube1D(cubeText) {
      const lines = cubeText.split(/\r?\n/);
      let domainMin = 0.0;
      let domainMax = 1.0;
      let declaredSize = null;
      const samples = [];

      // Check for 3D LUT indicators early
      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;
        
        // Detect 3D LUT file format
        if (/^LUT_3D_SIZE/i.test(s)) {
          throw new Error("3D LUT files are not supported. Please use a 1D LUT (.cube) file for linearization.");
        }
      }

      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;

        if (/^LUT_1D_SIZE/i.test(s)) {
          const m = s.match(/LUT_1D_SIZE\s+(\d+)/i);
          if (m) declaredSize = parseInt(m[1], 10);
          continue;
        }
        if (/^DOMAIN_MIN/i.test(s)) {
          // 1 or 3 numbers; for 1D we take the first
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMin = parseFloat(parts[1]);
          continue;
        }
        if (/^DOMAIN_MAX/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMax = parseFloat(parts[1]);
          continue;
        }

        // Numeric row: could be 1–3 floats. For 1D LUTs, many files still list RGB triplets.
        const nums = s.split(/\s+/).map(Number);
        if (nums.every((v) => Number.isFinite(v)) && nums.length >= 1 && nums.length <= 3) {
          samples.push(nums[0]); // take the first channel for 1D
        }
      }

      // After parsing, check if this looks like 3D LUT data
      if (samples.length > 100) {
        // 3D LUTs typically have many more data points than 1D LUTs
        // 1D LUTs usually have 16-256 points, 3D LUTs have thousands
        throw new Error("This file contains too many data points for a 1D LUT. It appears to be a 3D LUT file which is not supported. Please use a 1D LUT file for ink linearization.");
      }

      if (declaredSize !== null && samples.length >= declaredSize) {
        samples.length = declaredSize;
      }
      if (!Number.isFinite(domainMin) || !Number.isFinite(domainMax) || domainMin === domainMax) {
        domainMin = 0.0; domainMax = 1.0;
      }
      if (!samples.length) {
        throw new Error("No 1D samples found in .cube text.");
      }

      // Create inverse mapping: swap input and output relationship
      // Cube shows where each input position maps to
      // We need where each output value should come from
      const inverseSamples = new Array(samples.length);
      
      // For each original sample, find where it should be placed in inverse
      for (let i = 0; i < samples.length; i++) {
        const inputPos = i / (samples.length - 1); // 0 to 1
        const outputVal = samples[i]; // where this input maps to
        
        // Find the closest index for this output value
        const outputIndex = Math.round(outputVal * (samples.length - 1));
        const clampedIndex = Math.max(0, Math.min(samples.length - 1, outputIndex));
        
        // At output position, store what input created it
        inverseSamples[clampedIndex] = inputPos;
      }
      
      // Fill any gaps with linear interpolation
      for (let i = 0; i < inverseSamples.length; i++) {
        if (inverseSamples[i] === undefined) {
          // Find nearest defined values
          let prev = i - 1, next = i + 1;
          while (prev >= 0 && inverseSamples[prev] === undefined) prev--;
          while (next < inverseSamples.length && inverseSamples[next] === undefined) next++;
          
          if (prev >= 0 && next < inverseSamples.length) {
            // Interpolate between prev and next
            const t = (i - prev) / (next - prev);
            inverseSamples[i] = inverseSamples[prev] + t * (inverseSamples[next] - inverseSamples[prev]);
          } else if (prev >= 0) {
            inverseSamples[i] = inverseSamples[prev];
          } else if (next < inverseSamples.length) {
            inverseSamples[i] = inverseSamples[next];
          } else {
            inverseSamples[i] = i / (inverseSamples.length - 1); // fallback to linear
          }
        }
      }
      
      return { domainMin, domainMax, samples: inverseSamples };
    }

    /**
     * Parse a Color Muse data file (tab-separated format)
     * Expected format:
     * GRAY	LAB_L	LAB_A	LAB_B
     * 0	97.50	0.20	-0.50
     * 5	93.40	0.30	-0.70
     * ...
     * Returns { domainMin: 0, domainMax: 1, samples } where samples are normalized 0..1
     */
    function parseColorMuseData(fileContent, filename) {
      const lines = fileContent.split(/\r?\n/);
      const dataPoints = [];
      let headerFound = false;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        // Skip empty lines
        if (!trimmed) continue;
        
        // Check for Color Muse header
        if (trimmed.includes('GRAY') && trimmed.includes('LAB_L')) {
          headerFound = true;
          continue;
        }
        
        // Skip other comment lines
        if (trimmed.startsWith('#') || trimmed.startsWith('//')) continue;
        
        // Parse data lines (tab-separated: GRAY LAB_L LAB_A LAB_B)
        const parts = trimmed.split(/\s+/);
        if (parts.length >= 2) {
          const grayPercent = parseFloat(parts[0]);
          const labL = parseFloat(parts[1]);
          
          // Validate the parsed values
          if (!isNaN(grayPercent) && !isNaN(labL) && 
              grayPercent >= 0 && grayPercent <= 100 && 
              labL >= 0 && labL <= 100) {
            dataPoints.push({ input: grayPercent, lab: labL });
          }
        }
      }
      
      if (dataPoints.length < 2) {
        throw new Error("Not enough valid Color Muse data points found. Expected format: GRAY\\tLAB_L\\tLAB_A\\tLAB_B");
      }
      
      // Sort by gray percentage
      dataPoints.sort((a, b) => a.input - b.input);
      
      // For linearization correction, we need to create an inverse curve
      // The measured data shows: input% -> actual LAB L* 
      // We want: desired LAB L* -> corrected input%
      
      // First, convert LAB L* to expected density (invert L* since high L* = light)
      const measuredPoints = dataPoints.map(point => ({
        input: point.input,
        density: (100 - point.lab) / 100  // Convert L* to density (0=light, 1=dark)
      }));
      
      // Create ideal linear response (what we want)
      const idealPoints = dataPoints.map(point => ({
        input: point.input,
        density: point.input / 100  // Linear: 0% input = 0 density, 100% input = 1 density
      }));
      
      // Create correction samples by interpolating the inverse relationship
      // We want to find: for each ideal density, what input% actually produces that density?
      const samples = idealPoints.map(ideal => {
        // Find the input% that produces the ideal density in our measurements
        const targetDensity = ideal.density;
        
        // Linear interpolation to find what input% gives us this density
        for (let i = 0; i < measuredPoints.length - 1; i++) {
          const p1 = measuredPoints[i];
          const p2 = measuredPoints[i + 1];
          
          if (targetDensity >= p1.density && targetDensity <= p2.density) {
            // Interpolate between p1 and p2
            const t = (targetDensity - p1.density) / (p2.density - p1.density);
            const correctedInput = p1.input + t * (p2.input - p1.input);
            return correctedInput / 100;  // Normalize to 0-1
          }
        }
        
        // Handle edge cases
        if (targetDensity <= measuredPoints[0].density) {
          return measuredPoints[0].input / 100;
        }
        if (targetDensity >= measuredPoints[measuredPoints.length - 1].density) {
          return measuredPoints[measuredPoints.length - 1].input / 100;
        }
        
        return ideal.input / 100;  // Fallback to linear
      });
      
      // Create normalized input domain (0-1 corresponding to 0%-100%)
      const domainMin = 0.0;
      const domainMax = 1.0;
      
      return {
        domainMin,
        domainMax, 
        samples,
        originalData: dataPoints, // Keep original for reference
        format: 'Color Muse'
      };
    }


    /**
     * Detect file type and parse appropriately
     * For text files, pass the file content as string
     */
    async function parseLinearizationFile(fileContentOrFile, filename) {
      const extension = filename.toLowerCase().split('.').pop();
      
      if (extension === 'cube') {
        return parseCube1D(fileContentOrFile);
      } else if (extension === 'txt') {
        // Check if it's Color Muse format by looking for the header
        if (fileContentOrFile.includes('GRAY') && fileContentOrFile.includes('LAB_L')) {
          return parseColorMuseData(fileContentOrFile, filename);
        } else {
          throw new Error('TXT file format not recognized. Expected Color Muse format with GRAY and LAB_L columns.');
        }
      } else {
        throw new Error(`Unsupported file format: ${extension}. Use .cube or .txt files.`);
      }
    }

    /**
     * Natural cubic spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCubicSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Use clamped cubic spline with estimated end derivatives for more curvature
      const h = new Array(n - 1);
      const alpha = new Array(n);
      const l = new Array(n);
      const mu = new Array(n);
      const z = new Array(n);
      const c = new Array(n);
      const b = new Array(n);
      const d = new Array(n);
      
      // Step 1: Calculate h
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
      }
      
      // Step 2: Set up alpha with clamped boundary conditions
      // Estimate end derivatives to allow more curvature
      const firstDerivative = (y[1] - y[0]) / h[0];
      const lastDerivative = (y[n-1] - y[n-2]) / h[n-2];
      
      alpha[0] = 3 * ((y[1] - y[0]) / h[0] - firstDerivative);
      alpha[n-1] = 3 * (lastDerivative - (y[n-1] - y[n-2]) / h[n-2]);
      
      for (let i = 1; i < n - 1; i++) {
        alpha[i] = (3 / h[i]) * (y[i + 1] - y[i]) - (3 / h[i - 1]) * (y[i] - y[i - 1]);
      }
      
      // Step 3: Solve tridiagonal system with clamped conditions
      l[0] = 2 * h[0];
      mu[0] = 0.5;
      z[0] = alpha[0] / l[0];
      
      for (let i = 1; i < n - 1; i++) {
        l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
        mu[i] = h[i] / l[i];
        z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
      }
      
      l[n - 1] = h[n - 2] * (2 - mu[n - 2]);
      z[n - 1] = (alpha[n - 1] - h[n - 2] * z[n - 2]) / l[n - 1];
      c[n - 1] = z[n - 1];
      
      // Step 4: Back substitution
      for (let j = n - 2; j >= 0; j--) {
        c[j] = z[j] - mu[j] * c[j + 1];
        b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
        d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
      }
      
      // Return interpolation function
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Evaluate cubic polynomial - clamped cubic spline interpolation
        const dt = t - x[i];
        return y[i] + b[i] * dt + c[i] * dt * dt + d[i] * dt * dt * dt;
      };
    }

    /**
     * Catmull-Rom spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCatmullRomSpline(x, y, tension = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Get the four control points (with boundary handling)
        const p0 = y[Math.max(0, i - 1)];
        const p1 = y[i];
        const p2 = y[Math.min(n - 1, i + 1)];
        const p3 = y[Math.min(n - 1, i + 2)];
        
        // Normalize t to 0-1 within the segment
        const t_norm = (t - x[i]) / (x[i + 1] - x[i]);
        const t2 = t_norm * t_norm;
        const t3 = t2 * t_norm;
        
        // Parameterized Catmull-Rom basis functions with tension control
        // tension = 0.0: very tight (close to linear)
        // tension = 0.5: standard Catmull-Rom
        // tension = 1.0: very loose/curvy
        const q0 = -tension * t3 + 2 * tension * t2 - tension * t_norm;
        const q1 = (2 - tension) * t3 + (tension - 3) * t2 + 1;
        const q2 = (tension - 2) * t3 + (3 - 2 * tension) * t2 + tension * t_norm;
        const q3 = tension * t3 - tension * t2;
        
        // Catmull-Rom interpolation with adjustable tension
        return p0 * q0 + p1 * q1 + p2 * q2 + p3 * q3;
      };
    }

    /**
     * Bezier curve interpolation using cubic Bezier segments
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createBezierSpline(x, y, intensity = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate control points for smooth Bezier curves
      const segments = [];
      
      for (let i = 0; i < n - 1; i++) {
        const p0 = { x: x[i], y: y[i] };
        const p3 = { x: x[i + 1], y: y[i + 1] };
        
        // Calculate control points based on neighboring points
        let p1, p2;
        
        if (i === 0) {
          // First segment - use forward difference
          const slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + slope * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - slope * dist };
        } else if (i === n - 2) {
          // Last segment - use backward difference
          const slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + slope * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - slope * dist };
        } else {
          // Middle segments - use centered differences for smooth transitions
          const prevSlope = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);
          const nextSlope = (y[i + 2] - y[i + 1]) / (x[i + 2] - x[i + 1]);
          const currentSlope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          
          // Smooth the slopes for continuity
          const smoothSlope1 = (prevSlope + currentSlope) / 2;
          const smoothSlope2 = (currentSlope + nextSlope) / 2;
          
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + smoothSlope1 * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - smoothSlope2 * dist };
        }
        
        segments.push({ p0, p1, p2, p3 });
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find the segment
        let segmentIndex = 0;
        while (segmentIndex < segments.length - 1 && x[segmentIndex + 1] < t) {
          segmentIndex++;
        }
        
        const segment = segments[segmentIndex];
        
        // Normalize t within the segment (0 to 1)
        const segmentT = (t - segment.p0.x) / (segment.p3.x - segment.p0.x);
        
        // Cubic Bezier formula: B(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃
        const u = 1 - segmentT;
        const tt = segmentT * segmentT;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * segmentT;
        
        const interpolated = uuu * segment.p0.y +
               3 * uu * segmentT * segment.p1.y +
               3 * u * tt * segment.p2.y +
               ttt * segment.p3.y;
        
        // Blend between linear and interpolated based on intensity
        const linear = segment.p0.y + (segment.p3.y - segment.p0.y) * segmentT;
        return linear + intensity * (interpolated - linear);
      };
    }

    /**
     * PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) - Monotonic cubic spline
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createPCHIPSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate slopes (derivatives) at each point
      const slopes = new Array(n);
      const h = new Array(n - 1);
      const delta = new Array(n - 1);
      
      // Calculate intervals and finite differences
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
        delta[i] = (y[i + 1] - y[i]) / h[i];
      }
      
      // Calculate slopes using PCHIP method
      slopes[0] = delta[0]; // First point - use forward difference
      slopes[n - 1] = delta[n - 2]; // Last point - use backward difference
      
      for (let i = 1; i < n - 1; i++) {
        // Interior points - use monotonic slope calculation
        if (delta[i - 1] * delta[i] <= 0) {
          // Data changes direction - use zero slope to avoid overshooting
          slopes[i] = 0;
        } else {
          // Data is monotonic - use weighted harmonic mean for smooth monotonic interpolation
          const w1 = 2 * h[i] + h[i - 1];
          const w2 = h[i] + 2 * h[i - 1];
          slopes[i] = (w1 + w2) / (w1 / delta[i - 1] + w2 / delta[i]);
        }
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Normalize t within the interval
        const dt = t - x[i];
        const h_i = h[i];
        const t_norm = dt / h_i;
        
        // Hermite basis functions
        const h00 = 2 * t_norm * t_norm * t_norm - 3 * t_norm * t_norm + 1;
        const h10 = t_norm * t_norm * t_norm - 2 * t_norm * t_norm + t_norm;
        const h01 = -2 * t_norm * t_norm * t_norm + 3 * t_norm * t_norm;
        const h11 = t_norm * t_norm * t_norm - t_norm * t_norm;
        
        // PCHIP interpolation formula
        return y[i] * h00 + h_i * slopes[i] * h10 + y[i + 1] * h01 + h_i * slopes[i + 1] * h11;
      };
    }

    /**
     * Apply a 1D LUT to a list of integers using linear, cubic spline, Catmull-Rom, Bezier, or PCHIP interpolation.
     * Preserves the endpoint values - always starts at 0 and ends at the original max value.
     * @param {number[]} values - input integers in [0..maxValue]
     * @param {number[]} lut - samples (floats), typically 0..1
     * @param {number} domainMin - LUT input domain min (typically 0)
     * @param {number} domainMax - LUT input domain max (typically 1)
     * @param {number} maxValue - the maximum value from the original linear ramp
     * @param {string} interpolationType - 'cubic', 'catmull', or 'linear'
     * @returns {number[]} adjusted integer outputs with preserved endpoints
     */
    function apply1DLUT(values, lut, domainMin = 0, domainMax = 1, maxValue = 64000, interpolationType = 'cubic') {
      const K = lut.length;
      if (K < 2) return values; // Not enough points for interpolation
      
      // Ensure LUT starts at 0 and we know the end value
      const lutStart = lut[0];
      const lutEnd = lut[K - 1];
      
      // Create x coordinates for LUT points
      const lutX = new Array(K);
      for (let i = 0; i < K; i++) {
        lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
      }
      
      let interpolationFunction;
      
      if (interpolationType === 'cubic') {
        // Cubic spline interpolation for smoothest curves - pure interpolation
        interpolationFunction = createCubicSpline(lutX, lut);
      } else if (interpolationType === 'catmull') {
        // Catmull-Rom spline interpolation - passes through control points like GIMP
        const tension = elements.catmullTension.value / 100; // Convert 0-100 to 0-1
        interpolationFunction = createCatmullRomSpline(lutX, lut, tension);
      } else if (interpolationType === 'pchip') {
        // PCHIP interpolation for monotonic, shape-preserving curves
        interpolationFunction = createPCHIPSpline(lutX, lut);
      } else {
        // Linear interpolation for exact point-to-point behavior
        const denom = (domainMax - domainMin) || 1;
        interpolationFunction = (t) => {
          const tNorm = clamp01((t - domainMin) / denom);
          const u = tNorm * (K - 1);
          const i0 = Math.floor(u);
          const i1 = Math.min(i0 + 1, K - 1);
          const a = u - i0;
          return (1 - a) * lut[i0] + a * lut[i1];
        };
      }
      
      return values.map((v, index) => {
        // FORWARD APPLICATION: Use input value to look up LUT output directly
        const t = (v / maxValue) * (domainMax - domainMin) + domainMin;
        const lutValue = interpolationFunction(t);
        
        // Scale LUT value directly to maxValue range
        return Math.round(clamp01(lutValue) * maxValue);
      });
    }

    const debouncedPreviewUpdate = debounce(updatePreview, 300);

    // Optimized 256 value generation with optional linearization
    function make256(endValue, channelName, applyLinearization = false) {
      if (endValue === 0) return new Array(N).fill(0);
      
      let arr = new Array(N);
      const step = endValue / DENOM;
      
      for (let i = 0; i < N; i++) {
        arr[i] = Math.round(i * step);
      }
      
      const interpolationType = elements.curveSmoothingMethod.value;
      
      // Step 1: Apply per-channel linearization if available
      if (channelName && perChannelLinearization[channelName] && perChannelEnabled[channelName]) {
        arr = apply1DLUT(arr, perChannelLinearization[channelName].samples, perChannelLinearization[channelName].domainMin, perChannelLinearization[channelName].domainMax, endValue, interpolationType);
      }
      
      // Step 2: Apply global linearization if enabled
      if (applyLinearization && linearizationData && linearizationApplied) {
        arr = apply1DLUT(arr, linearizationData.samples, linearizationData.domainMin, linearizationData.domainMax, endValue, interpolationType);
      }
      
      return arr;
    }

    // Randomized starting ink limits for visual variety
    function getRandomInkLimit(inkName) {
      // Define realistic ranges for different ink types - all with 100% upper bound for maximum variation
      const inkRanges = {
        K: [30, 100],     // Black: 30-100%
        C: [35, 100],     // Cyan: 35-100%
        M: [30, 100],     // Magenta: 30-100%
        Y: [40, 100],     // Yellow: 40-100%
        LC: [20, 100],    // Light Cyan: 20-100%
        LM: [20, 100],    // Light Magenta: 20-100%
        LK: [25, 100],    // Light Black: 25-100%
        LLK: [15, 100],   // Light Light Black: 15-100%
        V: [25, 100],     // Violet: 25-100%
        MK: [20, 100]     // Matte Black: 20-100%
      };
      
      const range = inkRanges[inkName] || [25, 45]; // Default range if ink not found
      const min = range[0];
      const max = range[1];
      
      // Generate random percentage within range
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // Extract channel row creation
    function createChannelRow(name) {
      const randomPercent = getRandomInkLimit(name);
      const randomEndValue = InputValidator.computeEndFromPercent(randomPercent);
      
      const tr = document.createElement('tr');
      tr.className = "border-t border-gray-200";
      tr.innerHTML = `
        <td class="px-3 py-2 text-center">
          <input type="checkbox" class="channel-enable-checkbox w-4 h-4" title="Enable/disable channel" checked>
        </td>
        <td class="px-3 py-2 font-medium">
          <span class="inline-flex items-center gap-2">
            <span class="inline-block w-3.5 h-3.5 rounded-sm border border-black/10" style="background-color: ${INK_COLORS[name] || '#000'}"></span>
            <span class="w-8">${name}</span>
            <span class="text-xs text-gray-500 invisible" data-disabled>(disabled)</span>
          </span>
        </td>
        <td class="px-3 py-2">
          <div class="inline-flex items-center gap-2">
            <input type="file" id="perChannel_${name}" accept=".cube" class="hidden per-channel-file">
            <button class="per-channel-btn px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded border border-gray-300 transition-colors" data-channel="${name}" data-tooltip="Load per-channel linearization">load file</button>
            <label class="slider-toggle" title="Enable/disable per-channel linearization">
              <input type="checkbox" class="per-channel-toggle" data-channel="${name}" disabled>
              <span class="slider"></span>
            </label>
          </div>
        </td>
        <td class="px-3 py-2">
          <input type="number" step="1" min="0" max="100" value="${randomPercent}" class="percent-input w-28 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
        <td class="px-3 py-2">
          <input type="number" step="1" min="0" max="64000" value="${randomEndValue}" class="end-input w-28 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
      `;
      
      return tr;
    }

    function setupChannelRow(tr) {
      const percentInput = tr.querySelector('.percent-input');
      const endInput = tr.querySelector('.end-input');
      const disabledTag = tr.querySelector('[data-disabled]');
      const enableCheckbox = tr.querySelector('.channel-enable-checkbox');
      const perChannelBtn = tr.querySelector('.per-channel-btn');
      const perChannelFile = tr.querySelector('.per-channel-file');
      const perChannelToggle = tr.querySelector('.per-channel-toggle');
      const channelName = tr.dataset.channel;

      function refreshDisplay() {
        const endVal = InputValidator.clampEnd(endInput.value);
        endInput.value = String(endVal);
        
        const isUserDisabled = tr.hasAttribute('data-user-disabled');
        const isAtZero = endVal === 0;
        
        // Show disabled label if channel is at 0 (either user-disabled or set to 0%)
        disabledTag.classList.toggle('invisible', !isAtZero);
        
        // Update channel label opacity and row compactness
        const channelLabel = tr.querySelector('td:nth-child(2) span');
        const allCells = tr.querySelectorAll('td');
        const linearizationCell = tr.querySelector('td:nth-child(3)');
        const percentCell = tr.querySelector('td:nth-child(4)');
        const endCell = tr.querySelector('td:nth-child(5)');
        
        if (isAtZero) {
          channelLabel.style.opacity = '0.33';
          // Make row more compact when disabled
          allCells.forEach(cell => {
            cell.className = cell.className.replace('py-2', 'py-1');
          });
          // Hide linearization controls when disabled
          linearizationCell.style.visibility = 'hidden';
          // Reduce input sizes when disabled
          percentCell.style.opacity = '0.5';
          endCell.style.opacity = '0.5';
        } else {
          channelLabel.style.opacity = '1';
          // Restore normal padding when enabled
          allCells.forEach(cell => {
            cell.className = cell.className.replace('py-1', 'py-2');
          });
          // Show linearization controls when enabled
          linearizationCell.style.visibility = 'visible';
          // Restore input opacity when enabled
          percentCell.style.opacity = '1';
          endCell.style.opacity = '1';
        }
        
        // Update checkbox state based on channel status
        enableCheckbox.checked = !isAtZero;
      }
      
      // Store refreshDisplay function on the tr element for access from apply functions
      tr.refreshDisplayFn = refreshDisplay;

      // Channel enable/disable checkbox functionality
      const handleCheckboxChange = () => {
        const currentEndVal = InputValidator.clampEnd(endInput.value);
        const currentPercentVal = InputValidator.clampPercent(percentInput.value);
        
        if (enableCheckbox.checked) {
          // Enable: restore previous values or default to 33%
          const channelName = tr.dataset.channel;
          const previousValues = channelPreviousValues[channelName];
          
          if (previousValues && previousValues.percent > 0) {
            // Restore previous values
            percentInput.value = previousValues.percent.toString();
            endInput.value = previousValues.endValue.toString();
            showStatus(`Enabled ${channelName} (restored to ${previousValues.percent}%)`);
          } else {
            // Default to 33% if no previous value stored
            percentInput.value = '33';
            endInput.value = String(InputValidator.computeEndFromPercent(33));
            showStatus(`Enabled ${channelName} (set to default 33%)`);
          }
          
          tr.removeAttribute('data-user-disabled'); // Mark as not disabled by user
        } else {
          // Disable: store current values first, then set to 0
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: currentPercentVal,
            endValue: currentEndVal
          };
          
          percentInput.value = '0';
          endInput.value = '0';
          tr.setAttribute('data-user-disabled', 'true'); // Mark as disabled by user
          showStatus(`Disabled ${channelName} (saved ${currentPercentVal}% for restore)`);
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      };
      
      enableCheckbox.addEventListener('change', handleCheckboxChange);

      // Use debounced updates to prevent excessive recalculations
      percentInput.addEventListener('input', () => {
        const p = InputValidator.validateInput(percentInput, InputValidator.clampPercent);
        const endVal = InputValidator.computeEndFromPercent(p);
        endInput.value = String(endVal);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (endVal > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (endVal > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: endVal
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      endInput.addEventListener('input', () => {
        const e = InputValidator.validateInput(endInput, InputValidator.clampEnd);
        const p = InputValidator.computePercentFromEnd(e);
        percentInput.value = p.toFixed(1);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (e > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (e > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: e
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      // Per-channel linearization button
      perChannelBtn.addEventListener('click', () => {
        perChannelFile.click();
      });
      
      // Per-channel file upload
      perChannelFile.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
          // Per-channel only supports pre-made curves (.cube)
          const extension = file.name.toLowerCase().split('.').pop();
          
          if (extension === 'txt') {
            throw new Error('TXT files (Color Muse) are not supported for per-channel linearization. Use only .cube files with pre-calculated corrections.');
          }
          
          const fileInput = await file.text();
          const parsed = await parseLinearizationFile(fileInput, file.name);
          perChannelLinearization[channelName] = parsed;
          perChannelEnabled[channelName] = true;
          perChannelFilenames[channelName] = file.name;
          
          // Enable and check toggle
          perChannelToggle.disabled = false;
          perChannelToggle.checked = true;
          
          // Update button tooltip with filename
          perChannelBtn.setAttribute('data-tooltip', `Loaded: ${file.name} (${parsed.samples.length} points)`);
          
          // Update interpolation controls since we now have linearization data
          updateInterpolationControls();
          
          showStatus(`Loaded per-channel linearization for ${channelName}: ${parsed.samples.length} points`);
          debouncedPreviewUpdate();
        } catch (error) {
          console.error('Per-channel cube file error:', error);
          showStatus(`Error loading ${channelName} linearization: ${error.message}`);
          
          // Reset state on error
          delete perChannelLinearization[channelName];
          delete perChannelFilenames[channelName];
          perChannelEnabled[channelName] = false;
          perChannelToggle.disabled = true;
          perChannelToggle.checked = false;
          
          // Reset button tooltip
          perChannelBtn.setAttribute('data-tooltip', 'Load per-channel linearization');
          
          // Update interpolation controls since linearization may no longer be available
          updateInterpolationControls();
        }
      });
      
      // Per-channel toggle slider
      perChannelToggle.addEventListener('change', (e) => {
        if (perChannelLinearization[channelName]) {
          perChannelEnabled[channelName] = e.target.checked;
          if (perChannelEnabled[channelName]) {
            showStatus(`Enabled per-channel linearization for ${channelName}`);
          } else {
            showStatus(`Disabled per-channel linearization for ${channelName}`);
          }
          debouncedPreviewUpdate();
        }
      });
      
      // Initialize per-channel state
      perChannelEnabled[channelName] = false;
      
      // Initial sync
      const initialP = InputValidator.clampPercent(percentInput.value);
      percentInput.value = initialP.toString();
      endInput.value = String(InputValidator.computeEndFromPercent(initialP));
      refreshDisplay();
    }

    // Optimized setPrinter with DocumentFragment
    function setPrinter(key) {
      try {
        const p = PRINTERS[key];
        const fragment = document.createDocumentFragment();
        
        p.channels.forEach(ch => {
          const tr = createChannelRow(ch);
          tr.dataset.channel = ch; // Add channel name to dataset
          fragment.appendChild(tr);
        });
        
        // Clear and update DOM in one operation
        elements.rows.innerHTML = "";
        elements.rows.appendChild(fragment);
        
        // Setup event listeners after DOM update
        Array.from(elements.rows.children).forEach(setupChannelRow);

        elements.channelInfo.innerHTML = "Channels: " + p.channels.map(ch => `<strong>${ch}</strong>`).join(", ");
        elements.printerDescription.innerHTML = "";
        
        // Use requestAnimationFrame for smooth UI update
        requestAnimationFrame(() => {
          updatePreview();
          updateInkChart();
          updateFilename(); // Update filename when printer changes
        });
        showStatus(`Switched to ${p.name}`);
      } catch (error) {
        console.error('Error setting printer:', error);
        showStatus("Error changing printer");
      }
    }

    function buildLimitsSummary() {
      const lines = ["# Limits summary:"];
      
      Array.from(elements.rows.children).forEach((tr) => {
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const e = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        const p = InputValidator.computePercentFromEnd(e);
        
        if (e === 0) {
          lines.push("#   " + name + ": disabled");
        } else {
          const isWhole = Math.abs(p - Math.round(p)) < 1e-9;
          const percentFormatted = isWhole ? String(Math.round(p)) : p.toFixed(1);
          lines.push("#   " + name + ": = " + percentFormatted + "%");
        }
      });
      
      return lines;
    }

    function buildFile() {
      const p = PRINTERS[elements.printerSelect.value];
      const lines = [
        "## QuadToneRIP " + p.channels.join(","),
        "# Printer: " + p.name,
        "# quadGEN v1.1 by David Marsh"
      ];
      
      // Add user notes if provided
      const userNotes = elements.userNotes.value.trim();
      if (userNotes) {
        lines.push("#");
        // Split notes by lines and add # prefix to each line
        userNotes.split('\n').forEach(line => {
          lines.push("# " + line.trim());
        });
      }
      
      // Add linearization information
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      if (hasLinearization) {
        lines.push("#");
        lines.push("# Linearization Applied:");
        
        // Global linearization
        if (linearizationData && linearizationApplied) {
          const globalFilename = linearizationData.filename || "unknown file";
          lines.push(`# - Global: ${globalFilename} (${linearizationData.samples.length} points, affects all channels)`);
        }
        
        // Per-channel linearization
        const perChannelList = [];
        Object.keys(perChannelLinearization).forEach(channelName => {
          if (perChannelEnabled[channelName]) {
            const filename = perChannelFilenames[channelName] || "unknown file";
            const points = perChannelLinearization[channelName].samples.length;
            perChannelList.push(`${channelName}: ${filename} (${points} points)`);
          }
        });
        
        if (perChannelList.length > 0) {
          lines.push("# - Per-channel:");
          perChannelList.forEach(item => {
            lines.push(`#   ${item}`);
          });
        }
        
        // Interpolation method
        const method = elements.curveSmoothingMethod.value;
        const methodNames = {
          'cubic': 'Cubic Spline',
          'pchip': 'PCHIP (monotonic)',
          'linear': 'Linear (none)'
        };
        lines.push(`# - Interpolation: ${methodNames[method]}`);
        
        // Cubic splines now use pure interpolation (no intensity control)
      }
      
      lines.push(...buildLimitsSummary());

      // Build channel blocks efficiently
      p.channels.forEach((ch, idx) => {
        const row = elements.rows.children[idx];
        const e = InputValidator.clampEnd(row.querySelector('.end-input').value);
        const arr = make256(e, ch, true); // Apply linearization if enabled
        lines.push("# " + ch + " curve");
        lines.push(...arr.map(String));
      });

      return lines.join("\n") + "\n";
    }

    // Apply-to-all with improved performance and error handling
    elements.btnApplyPercent.addEventListener('click', () => {
      try {
        const val = InputValidator.clampPercent(elements.applyPercent.value);
        const endVal = InputValidator.computeEndFromPercent(val);
        
        Array.from(elements.rows.children).forEach(tr => {
          // Skip channels that were intentionally disabled by the user
          if (tr.hasAttribute('data-user-disabled')) {
            return;
          }
          
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          percentInput.value = val.toString();
          endInput.value = String(endVal);
          
          // Trigger proper display update using the row's refreshDisplay function
          // We need to manually call refreshDisplay for each row
          const refreshDisplay = tr.refreshDisplayFn;
          if (refreshDisplay) {
            refreshDisplay();
          }
        });
        
        updatePreview();
        showStatus(`Applied ${val}% to all channels`);
      } catch (error) {
        console.error('Error applying percentage:', error);
        showStatus("Error applying percentage");
      }
    });

    elements.btnApplyEnd.addEventListener('click', () => {
      try {
        const val = InputValidator.clampEnd(elements.applyEnd.value);
        const percentVal = InputValidator.computePercentFromEnd(val);
        
        Array.from(elements.rows.children).forEach(tr => {
          // Skip channels that were intentionally disabled by the user
          if (tr.hasAttribute('data-user-disabled')) {
            return;
          }
          
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          endInput.value = String(val);
          percentInput.value = percentVal.toFixed(1);
          
          // Trigger proper display update using the row's refreshDisplay function
          const refreshDisplay = tr.refreshDisplayFn;
          if (refreshDisplay) {
            refreshDisplay();
          }
        });
        
        updatePreview();
        showStatus(`Applied ${val} end value to all channels`);
      } catch (error) {
        console.error('Error applying end value:', error);
        showStatus("Error applying end value");
      }
    });

    // Download with enhanced error handling
    elements.downloadBtn.addEventListener('click', () => {
      try {
        const text = buildFile();
        const p = PRINTERS[elements.printerSelect.value];
        
        // Get custom filename or use default
        let filename;
        const customName = elements.filenameInput.value.trim();
        if (customName) {
          // Remove .quad extension if user added it, then sanitize
          const cleanName = customName.replace(/\.quad$/, '');
          const sanitizedName = sanitizeFilename(cleanName);
          
          // If sanitization removed everything, fall back to default
          if (!sanitizedName) {
            filename = p.name.replace(/\s+/g, '') + "_linear.quad";
            showStatus("Invalid filename, using default");
          } else {
            filename = sanitizedName + '.quad';
            
            // Show warning if filename was changed
            if (sanitizedName !== cleanName) {
              showStatus(`Filename sanitized: ${filename}`);
            }
          }
        } else {
          // Use default naming
          filename = p.name.replace(/\s+/g, '') + "_linear.quad";
        }
        
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus(`Downloaded ${filename}`);
      } catch (error) {
        console.error('Download error:', error);
        showStatus("Error downloading file");
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 's':
            e.preventDefault();
            elements.downloadBtn.click();
            break;
          case 'r':
            e.preventDefault();
            updatePreview();
            break;
        }
      }
    });


    // Initialize
    elements.printerSelect.addEventListener('change', (e) => setPrinter(e.target.value));
    
    // Add real-time filename validation
    elements.filenameInput.addEventListener('input', (e) => {
      const input = e.target;
      const value = input.value.trim();
      
      // Mark as user-edited if they've typed something different from auto-generated
      if (value !== generateFilename()) {
        input.dataset.userEdited = 'true';
      } else {
        delete input.dataset.userEdited;
      }
      
      if (value) {
        const cleanName = value.replace(/\.quad$/, '');
        const sanitized = sanitizeFilename(cleanName);
        const hasInvalidChars = sanitized !== cleanName;
        
        // Visual feedback for invalid characters
        input.classList.toggle('border-yellow-300', hasInvalidChars);
        input.classList.toggle('bg-yellow-50', hasInvalidChars);
        input.classList.toggle('border-gray-300', !hasInvalidChars);
        input.classList.toggle('bg-white', !hasInvalidChars);
        
        if (hasInvalidChars) {
          input.title = `Will be saved as: ${sanitized}.quad`;
        } else {
          input.title = '';
        }
      } else {
        input.classList.remove('border-yellow-300', 'bg-yellow-50');
        input.classList.add('border-gray-300', 'bg-white');
        input.title = '';
      }
    });

    // Linearization event listeners
    
    // Global linearization button click
    elements.globalLinearizationBtn.addEventListener('click', () => {
      elements.linearizationFile.click();
    });

    elements.linearizationFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Read file content as text
        const extension = file.name.toLowerCase().split('.').pop();
        const fileInput = await file.text();
        
        const parsed = await parseLinearizationFile(fileInput, file.name);
        parsed.filename = file.name; // Store filename for documentation
        linearizationData = parsed;
        linearizationApplied = true; // Auto-apply when file is loaded
        
        // Update button tooltip and enable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${file.name} (${parsed.samples.length} points)`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        
        // Show file info below Data Source label
        elements.globalLinearizationFilename.textContent = file.name;
        const formatInfo = parsed.format ? ` (${parsed.format})` : '';
        elements.globalLinearizationDetails.textContent = ` - ${parsed.samples.length} points${formatInfo}`;
        elements.globalLinearizationInfo.classList.remove('hidden');
        
        // Update interpolation controls
        updateInterpolationControls();
        
        showStatus(`Loaded and applied ${parsed.samples.length} data points from ${file.name}`);
        debouncedPreviewUpdate(); // Update preview to show the applied linearization
      } catch (error) {
        console.error('Cube file parsing error:', error);
        showStatus(`Error loading file: ${error.message}`);
        linearizationData = null;
        linearizationApplied = false;
        
        // Reset button tooltip and disable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', 'Load global linearization');
        elements.globalLinearizationToggle.disabled = true;
        elements.globalLinearizationToggle.checked = false;
        
        // Hide file info
        elements.globalLinearizationInfo.classList.add('hidden');
        
        // Update interpolation controls
        updateInterpolationControls();
      }
    });

    // Global linearization toggle
    elements.globalLinearizationToggle.addEventListener('change', (e) => {
      if (linearizationData) {
        linearizationApplied = e.target.checked;
        if (linearizationApplied) {
          showStatus('Global linearization enabled');
        } else {
          showStatus('Global linearization disabled');
        }
        
        // Update interpolation controls
        updateInterpolationControls();
        
        debouncedPreviewUpdate();
      }
    });

    // Curve smoothing method selection
    elements.curveSmoothingMethod.addEventListener('change', (e) => {
      const method = e.target.value;
      
      // Update interpolation controls (including intensity slider visibility and description)
      updateInterpolationControls();
      
      if (hasAnyLinearization()) {
        const methodNames = {
          'cubic': 'Cubic Spline',
          'catmull': 'Catmull-Rom',
          'pchip': 'PCHIP (monotonic)',
          'linear': 'Linear (none)'
        };
        showStatus(`Curve method: ${methodNames[method]}`);
        debouncedPreviewUpdate(); // Update preview with new smoothing setting
      }
    });
    
    // Catmull-Rom tension slider
    elements.catmullTension.addEventListener('input', (e) => {
      if (hasAnyLinearization() && elements.curveSmoothingMethod.value === 'catmull') {
        const tension = Math.round(e.target.value);
        showStatus(`Catmull-Rom tension: ${tension}%`);
        debouncedPreviewUpdate(); // Update preview with new tension setting
      }
    });
    
    // Notes toggle functionality
    elements.notesToggle.addEventListener('click', () => {
      const isHidden = elements.notesContent.classList.contains('hidden');
      
      if (isHidden) {
        // Expand
        elements.notesContent.classList.remove('hidden');
        elements.notesChevron.style.transform = 'rotate(180deg)';
      } else {
        // Collapse
        elements.notesContent.classList.add('hidden');
        elements.notesChevron.style.transform = 'rotate(0deg)';
      }
    });
    
    // Disable all channels functionality
    elements.disableAllBtn.addEventListener('click', () => {
      try {
        let disabledCount = 0;
        
        Array.from(elements.rows.children).forEach(tr => {
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          const channelName = tr.dataset.channel;
          
          // Store current values before disabling (if not already 0)
          const currentEndVal = InputValidator.clampEnd(endInput.value);
          const currentPercentVal = InputValidator.clampPercent(percentInput.value);
          
          if (currentEndVal > 0) {
            channelPreviousValues[channelName] = {
              percent: currentPercentVal,
              endValue: currentEndVal
            };
          }
          
          // Set to 0 and mark as user-disabled
          percentInput.value = '0';
          endInput.value = '0';
          tr.setAttribute('data-user-disabled', 'true');
          
          // Use proper state management
          const refreshDisplay = tr.refreshDisplayFn;
          if (refreshDisplay) {
            refreshDisplay();
          }
          
          disabledCount++;
        });
        
        updatePreview();
        showStatus(`Disabled all ${disabledCount} channels`);
      } catch (error) {
        console.error('Error disabling all channels:', error);
        showStatus("Error disabling channels");
      }
    });
    
    // Initial setup with error handling
    try {
      setPrinter('P900');
    } catch (error) {
      console.error('Initialization error:', error);
      showStatus("Initialization error. Please refresh the page.");
    }
  </script>
</body>
</html>