<!doctype html>
<html lang="en">

<!--
MIT License

Copyright (c) 2025 David Marsh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Scope: This license applies to this HTML file (quadgen.html) only.
-->

<!--
================================================================================
QUADGEN TECHNICAL SPECIFICATION
================================================================================

VERSION: v1.8.5
REVISION DATE: 2025-09-03
PREVIOUS: v1.8.4 (2025-09-04)

================================================================================
⚠️⚠️⚠️ CRITICAL INTERPOLATION REQUIREMENTS ⚠️⚠️⚠️
================================================================================
SMOOTH INTERPOLATION **MUST** USE PCHIP (Piecewise Cubic Hermite Interpolating Polynomial)
- This is the ONLY approved method for natural language curve generation
- VERIFIED WORKING in v1.5 - DO NOT REPLACE with other methods  
- Avoids: horizontal flattening, sharp corners, overshooting
- Linear interpolation acceptable for 'linear' mode only
- If curve issues reported, check PCHIP implementation BEFORE changing algorithms

SYSTEM OVERVIEW
================================================================================
QuadGEN generates QuadToneRIP .quad files for Epson inkjet printer systems. 
Implementation provides 256-step linearization curves with configurable ink 
limits, linearization data processing, and interpolation algorithms.

SUPPORTED HARDWARE (newest → oldest):
 - P700-P900: 10-channel configuration (K,C,M,Y,LC,LM,LK,LLK,V,MK)
 - P5-7-9000: 10-channel configuration (K,C,M,Y,LC,LM,LK,LLK,OR,GR)
 - P600-P800: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)
 - P400: 6-channel configuration (K,C,M,Y,LC,LM)
 - x900: 10-channel configuration (K,C,M,Y,LC,LM,LK,LLK,OR,GR)
 - 3880-7880: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)
 - x800-x890: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)
 - P4-6-8000: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)

================================================================================
ARCHITECTURAL IMPLEMENTATION
================================================================================

CURVE PROCESSING PIPELINE:
1. Base curve initialization: Loaded .quad data or linear ramp generation
2. Per-channel linearization: .cube/.txt file application when loaded
3. Global linearization: .cube/.txt file application when loaded
4. Interpolation processing: Sparse data expansion via selected algorithm

⚠️  CRITICAL: INTERPOLATION METHOD REQUIREMENTS ⚠️
- SMOOTH INTERPOLATION MUST USE PCHIP (Piecewise Cubic Hermite Interpolating Polynomial)
- PCHIP is the ONLY method that provides smooth curves through control points WITHOUT:
  * Horizontal flattening around key points (smoothstep problem)
  * Sharp corners at control points (linear problem)  
  * Overshooting between points (spline problem)
- VERIFIED: Smooth Smart Curves use PCHIP with numeric key points (natural‑language presets deprecated)
- DO NOT REPLACE with smoothstep, cosine, Catmull-Rom, or other methods
- Linear interpolation acceptable for 'linear' mode only
- If curve issues reported, check PCHIP implementation BEFORE changing algorithms

⚠️  CRITICAL: SMART CURVE CREATION POLICY ⚠️
- Lab Tech must compute explicit numeric key points based on user intent and apply them with set_ai_key_points.
- Do NOT rely on built-in presets or pre-defined curves; generate_curve_from_description is deprecated.
- Photography terms (e.g., 'S-curve', 'lift shadows', 'salt print range') may guide intent, but the assistant must choose actual numeric key points.
- Interpolation: PCHIP (smooth) is required for smooth curves; Linear allowed only for technical cases.

INTERPOLATION ALGORITHMS:
- Activation condition: Linearization data loaded with sparse control points
- Disabled condition: Loaded .quad files (256-point complete datasets)
- Available methods: Cubic, Catmull-Rom (tension parameter), PCHIP, Linear
- Control point source: LAB data uses original measurements, .cube uses file samples
- Linear interpolation: Handles non-evenly spaced control points via interval search

DATA POINT SMOOTHING SYSTEM:
- Purpose: Reduce control point count while preserving curve characteristics  
- Method: Smoothing Splines (mathematical curve smoothing with automatic lambda selection)
- Range: 0-90% reduction, disabled at 0%
- LAB data processing: Operates on original sparse measurements (0%, 5%, 10%, etc.)
- .cube data processing: Operates on original file sample points
- Control point output: Always generates sparse points to enable interpolation methods

CHANNEL MANAGEMENT SYSTEM:
- State control: Enable/disable via checkbox interface
- Disabled channel behavior: Value set to 0, previous state stored
- Function scope: Apply-to-all operations exclude disabled channels
- UI feedback: Opacity reduction and compact layout for disabled states

FILE FORMAT SPECIFICATIONS:
- .quad: 256-point curve datasets (bidirectional input/output)
- 1DLUT (.cube): 1D LUT linearization correction data
- 3DLUT (.cube): 3D LUT with neutral axis extraction for linearization
- LAB data (.txt): LAB measurement measurement datasets for linearization
- .acv: Adobe Photoshop curve files (binary format, cubic spline interpolation of RGB composite curve)

LINEARIZATION DATA PROCESSING:
- Global LAB data: Applied uniformly to all ink channels via single correction curve
- Per-channel LAB data: Individual correction curves per ink channel for precise control
- 3D LUT processing: Neutral axis extraction (R=G=B diagonal) via trilinear interpolation
- LAB data processing: CIE density mapping + Gaussian local-σ reconstruction (Target density = position)
- ACV curve processing: Binary format parsing with cubic spline interpolation of control points
- File processing: parseLinearizationFile() routes files through appropriate parsers (text/binary detection)
- 3D LUT extraction: Samples 256 points along neutral axis, ignores color information
- ACV curve extraction: Uses RGB composite curve (first curve) with smooth interpolation between control points
- Data validation: Format detection and comprehensive error handling
- Coordinate systems: All formats normalized to quadGEN's printing coordinate system
- Interpolation method selection: Intelligent detection prevents double-smoothing on Smart Curves while preserving PCHIP for measurement data
- Data source detection: Smart Curves use linear interpolation, measurement data (LAB/sample) uses user-selected method (PCHIP/Linear)

================================================================================
QUICK REFERENCE - KEY FUNCTIONS & LOCATIONS
================================================================================

CHANNEL MANAGEMENT:
- refreshDisplay(): Visual state management for enabled/disabled channels (~6633)
- handleCheckboxChange(): Channel enable/disable event handler (~6679)  
- _applyCurveToChannel(): Apply Smart Curves to channels (~3042)
- createChannelRow(): Initialize channel table rows with event handlers (~6534)

PROCESSING DETAILS:
- updateProcessingDetail(): Update processing labels (~6011)
- updateProcessingDetailForce(): Force update of processing labels (~5860)
- Info icon: decorative ⓘ shown next to label

SMART CURVE GENERATION:
- generateCustomCurve(): Create curves from numeric key points (~2530)
- setAIKeyPoints(): Apply numeric key points for Smart Curves (~3760)
- adjustAIKeyPointByIndex(): Nudge or set a single point by ordinal (~3807)
- insertAIKeyPointAt()/Between(): Insert new points by X or between ordinals (~3910)
- Natural-language parser removed (deprecated)
- _pchipInterpolate(): PCHIP smooth interpolation algorithm (~2925)

UNDO/HISTORY SYSTEM:
- CurveHistory object: Action-based undo/redo with individual channel tracking (~4865)
- Individual Actions: Track single channel changes (enable, percentage, end, curve) (~5025)
- Batch Actions: Group multiple channel changes from single assistant commands (~5063)
- CurveHistory.recordChannelAction(): Record individual channel state changes (~5025)
- CurveHistory.recordBatchAction(): Record multiple channels as single undoable action (~5063)
- CurveHistory.undo(): Restore previous actions with proper UI refresh (~5150)
- CurveHistory.redo(): Re-apply undone actions maintaining UI state (~5535)
- undoIndividualAction(): Process single channel undos within batch operations (~5365)
- redoIndividualAction(): Process single channel redos within batch operations (~5470)
- Batch Operation Flag: Prevents individual action recording during batch operations (~5557)
- Button State Management: Real-time undo/redo button enabling based on history (~5787)

FILE OPERATIONS:
- buildFile(): Generate .quad file content from current settings (~5490)
- parseQuadFile(): Parse loaded .quad files and extract channel data (~7953)
- parseLinearizationFile(): Handle .cube/.txt/.acv file processing (~8200)
- loadQuadFile(): Load .quad files and update all channel settings (~8045)

APPLY-TO-ALL OPERATIONS:
- Apply percentage buttons: Mass-update all enabled channels (~7020)
- Apply end value buttons: Mass-update all enabled channel limits (~7070)
- Enable/disable all channels: Toggle all channel states with state preservation (~7820)

LAB TECH INTEGRATION:
- LabTech.executeFunction(): Route Lab Tech commands to quadGEN actions (~3720)
- LabTech.sendMessage(): Process user messages and execute assistant responses (~3850)
- LabTech function definitions: 25 specialized functions for system control (~3540)

================================================================================
LAB TECH INTEGRATION
================================================================================

SYSTEM OVERVIEW:
Built-in Lab Tech assistant provides natural language control over quadGEN operations.
Accessible via expandable interface panel with real-time chat functionality.
Supports 25 specialized functions for complete system control without manual interface interaction.

FUNCTION CATEGORIES:

CHANNEL CONTROL FUNCTIONS:
- set_channel_value: Set ink limit percentage for specific channel (0-100%)
- set_channel_end_value: Set ink limit end value for specific channel (0-65535)
- apply_to_all_channels: Apply same ink limit percentage to all enabled channels (creates batch undo)
- apply_end_to_all_channels: Apply same ink limit end value to all enabled channels (creates batch undo)
- enable_disable_channel: Enable/disable individual ink channels
- batch_channel_operations: Multiple enable/disable operations in single call (creates batch undo)

INK LIMIT VALUE SYSTEM:
- Percentages (0-100%) and end values (0-65535) are mathematically linked
- 0% = 0 end value, 33% ~ 21627 end value, 50% = 32768 end value, 100% = 65535 end value
- Use set_channel_value for percentage-based requests ("set to 50%")
- Use set_channel_end_value for direct end value requests ("set to 32000")

BATCH UNDO INTEGRATION:
- AI operations affecting multiple channels automatically create batch undo actions
- batch_channel_operations: Records only channels with actual state changes
- apply_to_all_channels: Groups percentage changes across multiple enabled channels
- generate_global_custom_curve: Groups custom curve changes across multiple channels
- generate_global_custom_curve: Groups custom curve changes across multiple channels  
- Single undo button press reverts entire batch operation across all affected channels
- Prevents individual action recording during batch operations via isBatchOperation flag
- TIMING CRITICAL: Batch flag maintained for 1.5 seconds to prevent debounced handlers from creating individual actions
- Direct UI updates during batch operations bypass debounced handlers to prevent timing conflicts
- Maintains proper UI state synchronization including graph updates and compact display

FILE OPERATION FUNCTIONS:
- open_global_linearization_file_picker: Open file dialog for global linearization
- open_per_channel_linearization_file_picker: Open file dialog for per-channel linearization
- load_sample_lab_file: Load built-in sample LAB measurement data for testing
- load_sample_cube_file: Load built-in sample LUT cube file for testing
- generate_and_download_quad_file: Generate final .quad file and download to user
- set_filename: Set output filename for generated .quad file (auto-sanitized)

DATA LOADING FUNCTIONS:
- load_lab_data_global: Process pasted LAB measurement text for global linearization
- load_lab_data_per_channel: Process pasted LAB measurement text for specific channel
- load_cube_data_global: Process pasted .cube LUT text for global linearization  
- load_cube_data_per_channel: Process pasted .cube LUT text for specific channel

LINEARIZATION CONTROL FUNCTIONS:
- set_global_linearization: Enable/disable global linearization processing
- set_per_channel_linearization: Enable/disable linearization for specific channel

CURVE GENERATION FUNCTIONS:
- set_smart_key_points (alias: set_ai_key_points): Apply explicit numeric key points (Smart Curves)
- adjust_smart_key_point_by_index: Adjust a single key point by ordinal (1-based, endpoints included)
- get_smart_key_points: Inspect currently stored Smart key points
- insert_smart_key_point_at: Insert a new key point at a given input (X), optional output (Y)
- insert_smart_key_point_between: Insert a new key point between two adjacent ordinals
- generate_custom_curve: Create curve from explicit numerical control points (single channel)
- copy_curve_to_channel: Copy existing curve from source channel to target channel
- generate_global_custom_curve: Create curves from numerical points for multiple channels (batch)
  * Channel filters: 'all' (all printer channels), 'enabled' (only enabled channels)
  * Creates single batch undo action for all affected channels
  * Handles percentage adjustments and channel enabling as needed
  * Full UI synchronization with immediate graph updates

SYSTEM CONTROL FUNCTIONS:
- set_interpolation_method: Select interpolation algorithm (pchip/linear)
- set_smoothing_percentage: Control data point smoothing (0-90% reduction)
- change_printer: Switch between P600-P800 and P700-P900 printer configurations

UTILITY FUNCTIONS:
- get_current_state: Retrieve complete system state for analysis
- undo_last_change: Revert to previous state (integrated with CurveHistory system)
- get_history_summary: Get summary of recent changes for reference

⚠️  CRITICAL LAB TECH INTEGRATION NOTES:
- All functions include comprehensive input validation and error handling
- Function execution results are logged to chat interface for user feedback
- Do NOT use pre-defined/preset curve mappings; generate_curve_from_description is deprecated.
- Lab Tech must compute numeric key points and use set_smart_key_points (set_ai_key_points alias also supported), or generate_global_custom_curve for multiple channels.
- Rate limiting implemented: 10 requests/minute, 100 requests/hour (via Cloudflare Worker)
- Model: Claude Sonnet 4 (claude-sonnet-4-0) - Latest snapshot alias for optimal performance
- Function results integrate with CurveHistory system for undo functionality
- All channel operations respect current printer configuration (P600-P800 vs P700-P900)

⚠️  GLOBAL CURVE GENERATION IMPLEMENTATION NOTES:
- Batch operation flag (CurveHistory.isBatchOperation) prevents individual undo actions during global operations
- 1.5-second timing delay ensures debounced input handlers don't create conflicting undo actions
- Events dispatched during batch operations maintain UI/internal state synchronization
- Automatic percentage adjustments based on curve maximum values (Math.max(...curve) / TOTAL * 100)
- Channel enabling handled automatically for disabled channels receiving curves
- All UI elements synchronized: input fields, graphs, compact display, per-channel toggles
- Error handling maintains batch flag state to prevent orphaned batch operations

================================================================================
PROCESSING LABEL SYSTEM
================================================================================

FEATURE OVERVIEW:
Always-visible channel processing label that summarizes the active processing \
for each ink channel. Uses a ⓘ icon and italic text. When multiple corrections \
are applied, each appears on its own new line.

UI COMPONENTS:
- Info Icon: ⓘ next to each channel name (decorative)
  * Conveys informational context
  * Tooltip: "Processing details"
- Processing Label: italic; multi-line when stacked corrections are present
  * Shows concise pipeline summary, one line per layer
  * Full combined text available on hover via `title`

PIPELINE INFORMATION DISPLAYED:
- Smart Curve: shows key-point count when present (e.g., "Smart Curve (N key points)")
- Per-Channel: format • filename (count) when enabled
- Global: format • filename (count) when enabled
- Linear ramp when no processing is applied
Applied segments are shown as separate lines in order of application.

TECHNICAL IMPLEMENTATION:
Functions:
- updateProcessingDetail(channelName): Updates label for a channel
- updateProcessingDetailForce(channelName): Always recomputes and writes label
- Real-time updates triggered by all data loading operations

Auto-Update Triggers:
- Smart Curve generation (via _applyCurveToChannel)
- Per-channel file loading and toggle changes
- Global linearization file loading and toggle changes  
- Sample data button usage (LAB and cube)

DOM Structure:
- Inline: <span class="processing-label" data-channel="{name}"> ... </span>
- Proper channel identification via data-channel selectors

WORKFLOW INTEGRATION:
- Helps identify double-processing scenarios (Smart + per-channel)
- Shows processing order: Base → Per-Channel → Global
- Always visible; updates immediately when data changes
- Integrates with undo/history system

PERFORMANCE CHARACTERISTICS:
- Event-driven updates; no polling
- Lightweight DOM queries using data-channel attributes
- Minimal memory footprint

⚠️  INTEGRATION NOTES:
- Channel iteration uses array.forEach() not Object.keys() (channels are arrays)
- Works with all data sources: Smart, manual files, sample buttons
- Respects printer configuration (P600-P800 vs P700-P900 channels)

================================================================================
UNDO & HISTORY SYSTEM
================================================================================

SYSTEM OVERVIEW:
Comprehensive state management system providing full undo functionality for all quadGEN operations.
Captures complete system snapshots before every modification, enabling precise state restoration.
Integrated with Lab Tech assistant, manual controls, and file operations for seamless workflow.

CURVHISTORY ARCHITECTURE:
- State storage: Ring buffer with 20-state maximum capacity (oldest automatically removed)
- Capture scope: Complete system state including channels, curves, linearization settings
- Restoration: Full system state rollback with UI synchronization
- Memory management: Automatic cleanup and efficient JSON serialization

STATE CAPTURE SYSTEM:
Automatic state capture triggered by:
- Channel ink limit modifications (individual or batch operations)
- Channel enable/disable operations
- Custom curve generation and copying operations
- Linearization file loading and toggle changes
- Apply-to-all operations (percentage or end values)
- Lab Tech assistant function executions
- Manual user interface interactions

CAPTURED STATE COMPONENTS:
- Channel Configuration: Ink limits, end values, enable/disable status
- Curve Data: Custom curves for each channel (complete 256-point arrays)
- Linearization Data: Global and per-channel linearization settings and data
- UI State: All interface toggles, checkboxes, and form values
- Metadata: Timestamp, action description, system configuration

UNDO FUNCTIONALITY:
- Manual Undo: Physical "↶ Undo" button in main interface
- AI Integration: undo_last_change function callable via Lab Tech assistant
- Smart Button State: Dynamic tooltip showing most recent action available for undo
- Visual Feedback: Button opacity and disable state reflects undo availability
- Error Handling: Graceful failure recovery with user feedback

HISTORY QUERYING:
- getHistorySummary(): Returns structured data for Lab Tech assistant analysis
- State Inspection: Access to last 5 actions with timestamps
- Undo Availability: Boolean flag for interface state management
- Action Descriptions: Human-readable descriptions of each captured state

DEBOUNCED CAPTURE OPTIMIZATION:
User input operations (typing in fields) use 1-second debounce to prevent:
- Excessive state captures during continuous typing
- Memory bloat from intermediate values
- Performance degradation during rapid changes
Final state captured 1 second after user stops interaction

INTEGRATION POINTS:
- QuadGenActions: All programmatic operations automatically capture state
- Manual Controls: Input fields, checkboxes, and buttons trigger state capture
- File Operations: Loading quad/linearization files captures before and after states
- AI Assistant: Every function execution preceded by state capture
- Error Recovery: Failed operations do not corrupt history chain

PERFORMANCE CHARACTERISTICS:
- Capture Time: <5ms for complete system state (synchronous operation)
- Memory Usage: ~2-4KB per state (JSON serialized channel configurations)
- Storage Limit: Maximum 80KB total history storage (20 states × ~4KB average)
- Restoration Time: <10ms for complete system restoration with UI update

⚠️  CRITICAL USAGE NOTES:
- Initial state automatically captured on application startup
- State capture occurs BEFORE modification, not after
- Manual undo button reflects most recent undoable action in tooltip
- Lab Tech assistant undo commands return success/failure status with descriptive messages
- History survives printer configuration changes (P600-P800 ↔ P700-P900)
- Curve data restoration preserves interpolation and smoothing settings

================================================================================
VERSION HISTORY
================================================================================

NOTE: Version history is now centralized in the VERSION_HISTORY JavaScript object.
To update changelog content, modify the VERSION_HISTORY data structure in the JavaScript code.
Both internal documentation and About dialog are generated from this single source.

v1.6 (2025-08-31) - Lab Tech Assistant & Processing Visibility:
ADDED:
- Lab Tech AI assistant with 25 specialized functions for natural language control
- Processing detail panels showing Base Curves → Per-Channel → Global pipeline per channel
- Professional communication style with markdown formatting support
- Quick reference documentation with function locations
ENHANCED:
- Smart Curve generation with natural language descriptions ("palladium curve", "S-curve")
- Undo system integration for Smart‑generated curves
- Visual state restoration for disabled channels
FIXED:
- Disabled channel transparency when Lab Tech adds curves
- Processing panel updates now immediate (no manual refresh needed)
- Channel iteration bug causing incorrect references
- Smart Curve undo functionality integration

v1.6 (2025-01-30) - Global AI Curve Generation with Batch Undo:
ADDED:
- generate_global_custom_curve: Apply numeric key points to multiple channels simultaneously
- generate_global_custom_curve: Apply custom curve key points to multiple channels simultaneously
- Comprehensive batch undo system: Single undo action reverts all channels affected by global curve operations
- Channel filter support: Target 'all' printer channels or 'enabled' channels only
- Automatic percentage adjustment: Intelligently adjusts channel percentages based on curve range requirements
- Synchronized UI updates: Real-time graph updates and state synchronization across all affected channels

IMPROVED:
- Batch operation timing: 1.5-second flag duration prevents debounced handler conflicts with undo system
- Event handling during batch operations: Maintains UI/internal state consistency while preventing individual undo actions
- Error handling: Robust error management maintains batch flag state integrity
- User experience: Global curve generation provides immediate visual feedback with proper undo support

TECHNICAL:
- CurveHistory.isBatchOperation flag prevents individual undo action creation during batch operations  
- Debounced input handler coordination ensures proper batch undo action recording
- _applyCurveToChannel enhanced with batch-aware event dispatching
- Full integration with existing single-channel curve generation and undo systems

v1.5 (2025-08-29) - Adobe Photoshop .acv Curve File Support:
ADDED:
- Adobe Photoshop .acv file format support: Complete binary format parser for curve presets
- Cubic spline interpolation: Smooth curve generation matching Photoshop's behavior between control points  
- ACV format detection: Automatic binary vs text file handling in parseLinearizationFile()
- RGB composite curve extraction: Uses first curve from multi-curve .acv files for linearization
- Binary data parsing: DataView-based parser supporting Adobe's int16 big-endian format specification
- File input support: .acv files accepted in both global and per-channel linearization inputs
- UI integration: Updated tooltips and file format descriptions to include .acv curve file support
IMPROVED:
- File format documentation: Comprehensive .acv technical specifications in internal documentation
- Linearization workflow: Seamless integration with existing .cube and .txt file processing pipeline

v1.4.1 (2025-08-29) - Smoothing Algorithm Refinements & .quad File Improvements:
ADDED:
- Smoothing Splines algorithm: Mathematical curve smoothing with automatic lambda parameter selection
- Visual curve comparison: Original curve overlay (gray dashed line) shows smoothing effects on all channels
- Simplified curve algorithms: Focused on Uniform Sampling and Smoothing Splines
- Accurate .quad file maximum detection: Uses actual curve maximum instead of endpoint value
REFINED:
- Streamlined algorithm selection: Focused on reliable smoothing methods
- Simplified interpolation options: Hidden Cubic Spline and Catmull-Rom from UI to reduce complexity
- Default algorithm changed: Uniform Sampling now default with Smoothing Splines as advanced option
- UI cleanup: Removed monotonicity preservation option (PCHIP handles this appropriately)
IMPROVED:
- Curve visualization: Original vs smoothed comparison works with multiple channels simultaneously
- Algorithm focus: Concentrated on reliable, predictable smoothing methods for production use
- .quad file scaling: Proper scaling based on actual maximum value for non-monotonic curves

v1.4 (2025-08-29) - 3D LUT Support & Per-Channel LAB Data:
ADDED:
- 3D LUT neutral axis extraction: Automatic processing of 3D .cube files via trilinear interpolation
- Per-channel LAB data support: Individual LAB measurement .txt file loading per ink channel
- Dual format support: Per-channel linearization now accepts both .cube and .txt files
- Individual channel precision: Apply LAB corrections to specific inks for fine-tuned control
- 3D LUT format detection: Automatic routing between 1D and 3D LUT parsers
FIXED:
- Linear interpolation now properly handles non-evenly spaced control points
- LAB data now uses wedgie-style inversion to a linear target; optional smoothing can be applied after inversion
- LAB data uses selected interpolation immediately upon loading; smoothing is optional
- Curve simplification algorithm coordinate handling improved
- Curve simplification data type mismatch resolved for LAB measurement data
ENHANCED:
- Enhanced curve simplification methods for better performance
- Sample data now bundled in application (LAB measurements and Gamma 2.2 curve)
- UI layout reorganized into compact two-column design for better space utilization
- Sample data buttons now include download functionality for external use
- Consistent dropdown styling applied across all UI elements
TECHNICAL:
- 3D LUT neutral axis extraction uses trilinear interpolation with coordinate system normalization
- Per-channel LAB processing reuses proven parseLinearizationFile() architecture
- Removed explicit .txt file blocking from per-channel linearization function
- 3D LUT processing preserves existing 1D LUT pipeline without modifications
- Smoothing path is unified: interpolation/smoothing apply to samples from any source (LAB/Manual/ACV/LUT)
- Linear interpolation uses interval search for non-evenly spaced lutX coordinates
- Smoothing algorithms preserve curve characteristics while reducing data points
- Control points generated from original measurements, not pre-interpolated 256-point curves
================================================================================
v1.3 (2025-08-28) - Linearization Correction Fix:
FIXED:
- LAB measurement linearization correction algorithm now matches industry standard
- Manual L* data entry linearization correction algorithm now matches industry standard  
- .cube file linearization corrected to use original samples directly
- Wedgie-style inversion applied to measurement data (LAB .txt files and Manual L* entry)
- Removed erroneous inverse mapping logic from .cube file parsing

TECHNICAL:
- LAB measurement & Manual L* Entry: Applied horizontal and vertical flip transformations
- .cube files: Use original samples without any coordinate transformation
- Different file types require different coordinate system treatments
- Added comprehensive documentation explaining why different treatments are necessary

VALIDATION:
- Empirically validated against industry standard tools using LAB-Data-Data.txt
- All linearization methods now produce correct industry-standard behavior

v1.2 (2025-01-27) - Major Feature Release:
ADDED:
- Complete .quad file loading with curve preservation
- Layered processing system (base curves + linearization)
- Enhanced file validation and error handling
- Info popup with version information
- Compact UI controls and improved UX

CHANGED:
- Merged P700/P900 into single "P700-P900" option (identical 10-channel config)
- Interpolation controls now properly disabled for loaded .quad files
- Apply-to-all functions respect disabled channel checkboxes
- Enhanced scrollbar styling for file preview (24px, bright white, 60px min)

RESTORED:
- ACV file support (Photoshop curve files) - full binary format parsing for RGB composite curves
REMOVED:
- Smoothing intensity controls (pure interpolation preferred)

TECHNICAL:
- Loaded .quad data stored in loadedQuadData global variable
- make256() function uses Math.max() to find actual curve maximum for proper scaling
- hasAnyLinearization() determines when interpolation controls are relevant
- updateInterpolationControls() manages UI state and visual feedback
- Non-monotonic curve detection: Automatic maximum value identification across all input levels

v1.1 (Previous):
- Catmull-Rom spline interpolation with tension parameter
- Channel memory system for disabled channels
- Cube file inverse mapping corrections
- Tension controls for spline customization

v1.0 (Initial):
- Basic linear ramp generation
- Printer configuration support
- File download functionality
- Chart visualization

================================================================================
IMPLEMENTATION SPECIFICATIONS
================================================================================

CURVE DATA PROCESSING:
- Linear ramp generation: Mathematical progression 0→endValue across 256 steps
- Loaded curve scaling: Proportional adjustment based on actual maximum value (not endpoint)
- Non-monotonic curve support: Proper handling of curves where maximum occurs before 100% input
- Linearization application: Lookup table transformation methodology
- Value constraints: 0-65535 range compliance (QuadToneRIP specification)

INTERPOLATION PROCESSING:
- Application scope: Sparse control point linearization data only
- Processing method: apply1DLUT() function implementation
- Mapping algorithm: Forward input value → LUT lookup → output value
- Algorithm impact: Method selection affects sparse data expansion characteristics

SMOOTHING (DATA POINT REDUCTION):
- Implementation: CurveSimplification object with multiple algorithm support
- Control interface: Horizontal slider (0-90%) with visible simplification method dropdown
- Available methods: Smoothing Splines (mathematical smoothing, default) and Uniform Sampling (even distribution)
- LAB data support: Both methods now work with LAB measurement data (previously uniform-only)
- Method switching: Real-time algorithm selection affects both .cube files and LAB measurement data
- Uniform sampling: Preserves start/end points, reduces intermediate points with even spacing
- Smoothing Splines: Mathematical algorithm with automatic parameter selection for optimal smoothing
- Coordinate system handling: Maintains dual transformation for LAB data, preserves .cube coordinate relationships
- Processing pipeline: originalDataPoints → method selection → smoothing → sparse control points → interpolation → 256-point curve
- Data object integrity: LAB data objects with getSmoothingControlPoints() method now properly preserved through processing chain
- Path detection: apply1DLUT() correctly identifies LAB objects vs arrays to enable proper smoothing method application
- Control point generation: LAB data creates inverse mapping with dual transformation applied to control points
- File type support: LAB data (.txt) files, manual L* entry, 1DLUT (.cube) files, built-in sample data
- Algorithm switching: Real-time method selection with immediate preview update
- Sample data integration: LAB measurement measurement sample (21 points) and Gamma 2.2 curve sample (11 points)
- Coordinate preservation: Algorithms maintain proper spacing for .cube data to prevent interpolation artifacts
- Notification system: Non-intrusive overlay notification at top of graph when smoothing is active

CHANNEL STATE ARCHITECTURE:
- Channel properties: Percentage value, end value, enable/disable state
- Value synchronization: Percentage-end value computational relationship maintained
- Disabled channel handling: Checkbox unchecked, values = 0, previous state stored
- Memory management: channelPreviousValues object maintains restoration data

UI STATE CONTROL:
- Interpolation control state: Determined by hasAnyLinearization() function
- File information display: Activated for loaded .quad file datasets
- User feedback system: Status message communication protocol
- Interface documentation: Tooltip-based control functionality explanation
- Layout organization: Two-column interpolation panel (method selection left, smoothing controls right)
- Dropdown standardization: Unified .standard-dropdown CSS class for consistent styling
- Notification overlay: Fixed-position smoothing notification prevents layout shifts

FILENAME GENERATION ALGORITHM:
- Automatic generation: PrinterModel_Ch1Value_Ch2Value... pattern
- User override capability: Manual editing with userEdited flag
- Loaded file handling: originalname_copy default naming convention
- Filesystem compatibility: Character sanitization processing

================================================================================
TESTING NOTES
================================================================================

KEY TEST SCENARIOS:
1. Load .quad file → verify curve preservation and limit scaling
2. Load .quad + add linearization → verify layered processing
3. Enable/disable channels → verify apply-to-all skips disabled
4. Switch printers → verify channel count and layout changes
5. File validation → verify error handling for corrupted/invalid files
6. LAB data smoothing → verify no curve flipping, all interpolation methods functional
7. .cube file smoothing → verify coordinate system preservation and algorithm accuracy
8. Smoothing + interpolation → verify Linear/Cubic/Catmull-Rom/PCHIP compatibility
9. UI layout responsiveness → verify two-column interpolation panel and overlay notifications
10. Sample data integration → verify LAB measurement and Gamma 2.2 curve samples load correctly

EDGE CASES:
- Empty .quad files or corrupted data
- Linearization files with invalid ranges
- Channel limit changes on loaded curves
- Printer switching with loaded data
- File size limits and validation

================================================================================
LINEARIZATION CORRECTION PROCESSING
================================================================================

COORDINATE SYSTEM ANALYSIS: Correction curve implementation requires coordinate transformation distinct from mathematical intuition.

COLOR MUSE DATA PROCESSING:
- Input format: GRAY% (0-100) → LAB_L* (measured lightness values)
- Mathematical interpretation: GRAY% input produces LAB_L* output
- Industry standard implementation: Coordinate transformation required

ALGORITHM IMPLEMENTATION BY FILE TYPE:

COLOR MUSE (.txt) & MANUAL L* ENTRY PROCESSING:
1. Density value conversion: L* inversion (high L* = light = low density)
2. Density mapping generation: targetDensity (GRAY%) → actualDensity (L*)
3. Correction curve computation: Input determination for target density
4. Dual transformation application:
   - Horizontal flip: flippedInputPos = 1.0 - inputPos (coordinate mirror)
   - Vertical flip: verticallyFlipped = 1.0 - originalSample (value inversion)

CUBE FILE (.cube) PROCESSING:
1. 1D LUT sample extraction from file structure
2. Dual transformation application for coordinate system alignment:
   - Horizontal flip: Coordinate position reversal (ink-RGB relationship)
   - Vertical flip: Value inversion (printing intensity compatibility)
3. Transformation requirement: Industry standard application compatibility

DUAL TRANSFORMATION NECESSITY:
- Implementation consistency: All linearization methods employ identical transformation
- .cube files: RGB→printing ink coordinate space conversion required
- LAB measurement data: Raw measurement coordinate system interpretation
- Manual L* data: Laboratory measurement coordinate interpretation identical
- Industry compatibility: Standard coordinate system differs from mathematical intuition
- Transformation absence: Incorrect curve topology and crossing point behavior
- Transformation presence: Industry-standard curve behavior achieved

CUBE FILE COORDINATE SYSTEM SPECIFICATION:
- .cube RGB system: index 0 = white (RGB 255), index end = black (RGB 0)
- Printing ink system: 0% ink = white paper, 100% ink = black
- Horizontal transformation: .cube end → 0% ink, .cube start → 100% ink
- Vertical transformation: .cube value inversion for ink limit implementation
- Implementation example: test-half.cube RGB 50% → 0% ink 50% limit, 100% ink 100% limit

VALIDATION METHODOLOGY:
- test-linear.cube: Straight diagonal output (null effect confirmation)
- test-half.cube: 0% ink 50% limit → 100% ink 100% limit progression
- test-gamma.cube: Characteristic gamma curve topology (60% crossing point)
- Industry validation: Photoshop RGB 255 → RGB 127 behavior replication

TECHNICAL FINDINGS:
1. Coordinate interpretation significance exceeds mathematical complexity
2. Industry standards override intuitive coordinate systems
3. Empirical validation against established tools required
4. Coordinate transformation priority over algorithm selection
5. Historical workflow conventions influence digital implementation

================================================================================
USER WORKFLOW PROCEDURES
================================================================================

OPERATIONAL SEQUENCE:
1. .quad file creation: Specify target ink configuration and initial ink limit values
2. Test target printing: Execute print using specified .quad file with initial ink limits
3. Measurement data acquisition: LAB measurement device measurement OR 1DLUT (.cube) file generation via EDN system (http://www.easydigitalnegatives.com/)
4. Data importation: LAB data (.txt) file, manual L* entry, or 1DLUT (.cube) application to initial ink configuration
5. Result verification: Curve graph preview and tonal shape validation
6. Optional adjustment: Channel limit modification (enable/disable inks, uniform percentage application)
7. File export: Corrected .quad file generation and QuadToneRIP integration
8. Validation procedure: Reprint execution with corrected .quad file, tonal reproduction target matching verification

WORKFLOW INTEGRATION:
- QuadToneRIP ecosystem compatibility maintained throughout process
- Iterative refinement capability through measurement-correction cycles
- Alternative measurement methodologies supported (LAB measurement, EDN system)
- Advanced user flexibility via optional adjustment procedures

================================================================================
FUTURE CONSIDERATIONS
================================================================================

POTENTIAL ENHANCEMENTS:
- Additional printer model support
- Batch processing capabilities  
- Curve comparison tools
- Export format options
- Advanced curve editing features

ARCHITECTURAL NOTES:
- Single HTML file approach for simplicity and portability
- Client-side processing (no server dependencies)
- Tailwind CSS for styling consistency
- Vanilla JavaScript for maximum compatibility

================================================================================
-->

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title id="pageTitle">quadGEN</title>
  <meta name="description" content="quadGEN - Generate Epson P700-P900/P600-P800 QuadToneRIP .quad files with 256-step ramps per channel." />
  <!-- Version History notes guidance: keep entries concise, direct, factual, and short. See AGENTS.md and CLAUDE.md. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Theme tokens: light defaults */
    :root {
      color-scheme: light;            /* ensure light scrollbars/forms by default */
      --bg: #f9fafb;                 /* page background */
      --bg-elevated: #ffffff;        /* cards, panels */
      --text: #111827;               /* primary text */
      --muted: #374151;              /* secondary text */
      --border: #e5e7eb;             /* borders, dividers */
      --link: #374151;               /* link color (monochrome) */
      --link-hover: #111827;         /* link hover (monochrome) */
      --code-bg: #f3f4f6;            /* code/bg chips */
      --code-text: #111827;
      --accent: #374151;             /* primary accent (monochrome) */
      --accent-contrast: #ffffff;
      --tooltip-bg: #111111;         /* neutral tooltip background */
      --tooltip-text: #ffffff;       /* tooltip text */
      --scrollbar-track: var(--bg-elevated);
      --scrollbar-thumb-border: var(--bg-elevated);
      /* Console tokens */
      --console-bg: #0a0a0a;         /* neutral console body */
      --console-text: #f5f5f5;       /* console text */
      --console-border: #262626;     /* neutral divider */
      --console-resizer: rgba(115,115,115,0.35);     /* neutral-500 @35% */
      --console-resizer-hover: rgba(163,163,163,0.55);/* neutral-400 @55% */
      --console-grip: rgba(163,163,163,0.8);
      --console-input-bg: #0a0a0a;
      --console-input-border: #404040;
      /* Chart tokens */
      --chart-grid: #e5e7eb;
      --chart-axis: #374151;
      --chart-text: #000000;
      --chart-helper-border: #9ca3af;
      --chart-bg: transparent;
    }

    

    /* Dark theme overrides */
    [data-theme="dark"] {
      color-scheme: dark;             /* enable dark-native scrollbars/forms */
      --bg: #0a0a0a;                 /* neutral-950 (darkest shell) */
      --bg-subtle: #111111;          /* intermediate surface level */
      --bg-elevated: #171717;        /* neutral-900 (lighter panels) */
      --bg-elevated-hover: #1f1f1f;  /* hover states for elevated surfaces */
      --text: #e5e5e5;               /* neutral-200 */
      --muted: #9ca3af;              /* gray-400 - better for secondary text */
      --muted-subtle: #6b7280;       /* gray-500 - for very subtle text */
      --border: #262626;             /* neutral-800 - standard borders */
      --border-subtle: #1f1f1f;      /* barely visible borders */
      --border-emphasis: #374151;    /* prominent borders */
      --link: #60a5fa;               /* blue-400 - more visible links */
      --link-hover: #93c5fd;         /* blue-300 - hover state */
      --link-visited: #a78bfa;       /* violet-400 - visited links */
      --code-bg: #0b1220;            /* near-bg, subtle */
      --code-text: #e5e7eb;
      --accent: #60a5fa;             /* blue-400 - more engaging */
      --accent-contrast: #1e293b;    /* slate-800 - better contrast */
      --accent-secondary: #8b5cf6;   /* violet-400 - secondary accent */
      --interactive-hover: #1f2937;  /* gray-800 - subtle hover backgrounds */
      --interactive-pressed: #111827; /* gray-900 - pressed state */
      --focus-ring: #60a5fa;         /* blue-400 - focus indicators */
      --success: #10b981;            /* emerald-500 */
      --warning: #f59e0b;            /* amber-500 */
      --error: #ef4444;              /* red-500 */
      --tooltip-bg: #111111;
      --tooltip-text: #ffffff;
      --scrollbar-track: var(--bg-elevated);
      --scrollbar-thumb-border: var(--bg-elevated);
      --console-bg: #111111;        /* lighten console surfaces slightly */
      --console-text: #e5e5e5;
      --console-border: #262626;
      --console-resizer: rgba(115,115,115,0.35);
      --console-resizer-hover: rgba(163,163,163,0.55);
      --console-grip: rgba(163,163,163,0.8);
      --console-input-bg: #0a0a0a;
      --console-input-border: #404040;
      /* Dark-friendly chart with slightly lighter background */
      --chart-grid: #404040;         /* neutral grid */
      --chart-axis: #e5e5e5;         /* light axis lines */
      --chart-text: #e5e5e5;         /* light labels */
      --chart-helper-border: #525252;/* neutral helper borders */
      --chart-bg: rgba(255,255,255,0.10); /* modest lightening */
    }

    /* Emphasize the Download .quad button in light mode */
    #downloadBtn {
      background: linear-gradient(135deg, #2563eb, #8b5cf6);
      color: #ffffff;
      border: 1px solid rgba(17,24,39,0.08);
      box-shadow: 0 0 0 2px rgba(37,99,235,0.15), 0 8px 14px rgba(0,0,0,0.12);
      text-shadow: 0 1px 0 rgba(0,0,0,0.15);
    }
    #downloadBtn:hover {
      filter: brightness(1.05);
      box-shadow: 0 0 0 3px rgba(37,99,235,0.25), 0 10px 16px rgba(0,0,0,0.16);
    }
    #downloadBtn:active {
      transform: translateY(0.5px);
      filter: brightness(0.98);
    }
    #downloadBtn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px rgba(37,99,235,0.35), 0 10px 18px rgba(0,0,0,0.18);
    }

    /* Emphasize the Download .quad button in dark mode */
    [data-theme="dark"] #downloadBtn {
      background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
      color: #ffffff;
      border: 1px solid var(--border-emphasis);
      box-shadow: 0 0 0 2px rgba(96,165,250,0.35), 0 8px 16px rgba(0,0,0,0.45);
      text-shadow: 0 1px 0 rgba(0,0,0,0.25);
    }
    [data-theme="dark"] #downloadBtn:hover {
      filter: brightness(1.06);
      box-shadow: 0 0 0 3px rgba(96,165,250,0.45), 0 10px 18px rgba(0,0,0,0.55);
    }
    [data-theme="dark"] #downloadBtn:active {
      transform: translateY(0.5px);
      filter: brightness(0.98);
    }
    [data-theme="dark"] #downloadBtn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 4px rgba(96,165,250,0.55), 0 10px 18px rgba(0,0,0,0.55);
    }

    /* Dark mode: match Help and Load .quad buttons to Undo styling */
    [data-theme="dark"] #helpBtn,
    [data-theme="dark"] #loadQuadBtn {
      background-color: #475569 !important; /* slate-600 */
      color: #ffffff !important;
      border: 1px solid transparent !important;
    }
    [data-theme="dark"] #helpBtn:hover,
    [data-theme="dark"] #loadQuadBtn:hover { background-color: #374151 !important; /* gray-700 */ }

    /* Light-mode surfaces for Lab Tech, Preview, and Notes (not pure white) */
    :root:not([data-theme="dark"]) #labTechConsole,
    :root:not([data-theme="dark"]) #previewConsole {
      background-color: #f7f7f9; /* default-light theme feel */
      color: var(--text) !important;
      border-color: #e5e7eb !important;
    }
    :root:not([data-theme="dark"]) #chatHistory {
      color: var(--muted) !important;
    }
    :root:not([data-theme="dark"]) #aiInputCompact,
    :root:not([data-theme="dark"]) #userNotes,
    :root:not([data-theme="dark"]) #previewFull {
      background-color: #fbfbfc;
      color: var(--text) !important;
      border-color: #d1d5db !important; /* gray-300 */
    }
    :root:not([data-theme="dark"]) #aiInputCompact:focus,
    :root:not([data-theme="dark"]) #userNotes:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37,99,235,0.25);
      border-color: #93c5fd !important; /* blue-300 */
    }
    :root:not([data-theme="dark"]) #aiInputCompact::placeholder,
    :root:not([data-theme="dark"]) #userNotes::placeholder {
      color: color-mix(in srgb, var(--muted) 60%, var(--bg-elevated));
    }
    :root:not([data-theme="dark"]) #labTechResizer {
      background-color: #e5e7eb !important; /* gray-200 */
    }
    :root:not([data-theme="dark"]) #labTechResizer:hover {
      background-color: #d1d5db !important; /* gray-300 */
    }

    /* Console section headers in light mode: soft gradient and bottom border */
    :root:not([data-theme="dark"]) .console-header {
      background: linear-gradient(to bottom, #fafafa, #f3f4f6);
      color: #374151 !important; /* gray-700 */
      border-bottom: 1px solid #e5e7eb;
    }

    .chart-zoom-controls {
      position: absolute;
      bottom: -9px;
      left: -9px;
      display: inline-flex;
      align-items: center;
      border-radius: 0.75rem;
      border: 1px solid rgba(17,24,39,0.12);
      background: rgba(255,255,255,0.92);
      z-index: 12;
      padding: 0 2px;
    }
    .chart-zoom-btn {
      appearance: none;
      border: none;
      background: transparent;
      color: var(--text);
      font-size: 1rem;
      font-weight: 600;
      line-height: 1;
      padding: 0.35rem 0.55rem;
      cursor: pointer;
      border-radius: 0.6rem;
      transition: background-color 0.15s ease, color 0.15s ease;
    }
    .chart-zoom-btn:hover:not(:disabled) {
      background: rgba(37,99,235,0.08);
    }
    .chart-zoom-btn:active:not(:disabled) {
      background: rgba(37,99,235,0.14);
    }
    .chart-zoom-btn:focus-visible {
      outline: 2px solid var(--focus-ring, #2563eb);
      outline-offset: 2px;
    }
    .chart-zoom-btn:disabled {
      cursor: not-allowed;
      opacity: 0.45;
    }
    .chart-zoom-divider {
      width: 1px;
      height: 22px;
      background: rgba(17,24,39,0.12);
    }
    [data-theme="dark"] .chart-zoom-controls {
      background: rgba(17,24,39,0.78);
      border-color: rgba(148,163,184,0.28);
      box-shadow: 0 8px 16px rgba(0,0,0,0.45);
    }
    [data-theme="dark"] .chart-zoom-btn {
      color: var(--text);
    }
    [data-theme="dark"] .chart-zoom-btn:hover:not(:disabled) {
      background: rgba(148,163,184,0.16);
    }
    [data-theme="dark"] .chart-zoom-divider {
      background: rgba(229,231,235,0.22);
    }

    /* Dark-mode wrappers for consoles to keep parity */
    [data-theme="dark"] #labTechConsole, [data-theme="dark"] #previewConsole {
      background-color: var(--console-bg) !important;
      color: var(--console-text) !important;
      border-color: var(--console-border) !important;
    }
    [data-theme="dark"] #aiInputCompact:focus,
    [data-theme="dark"] #userNotes:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(96,165,250,0.35);
      border-color: var(--console-input-border) !important;
    }

    /* ===== .quad preview: lightweight syntax highlighting ===== */
    /* Base tokens */
    .quad-meta   { color: var(--link); font-weight: 600; }
    .quad-comment{ color: #047857; }  /* emerald-800 for light */
    [data-theme="dark"] .quad-comment { color: #34d399; } /* emerald-400 for dark */
    .quad-number { color: var(--text); }
    .quad-error  { color: #dc2626; font-weight: 700; }
    .quad-emph   { font-weight: 700; }

    /* Channel color in gutter provided via CSS variables set per line (--ln-bg, --ln-fg) */

    /* Line numbers (visible, not copied) */
    #previewFull { position: relative; counter-reset: quadline; --lnw: 3.2em; --lngap: 0.6em; }
    #previewFull .quad-line { display: block; position: relative; padding-left: calc(var(--lnw) + var(--lngap)); }
    #previewFull .quad-line::before {
      counter-increment: quadline;
      content: counter(quadline) " │ ";
      position: absolute; left: 0; top: 0; bottom: 0;
      width: var(--lnw); text-align: right;
      color: var(--ln-fg, color-mix(in srgb, var(--muted) 35%, var(--bg)));
      background: var(--ln-bg, transparent);
      user-select: none; -webkit-user-select: none; pointer-events: none;
      opacity: 0.55;
      font-weight: 400;
    }
    #previewFull .quad-line[data-ch]::before { opacity: 1; }
    [data-theme="dark"] #previewFull .quad-line::before {
      color: var(--ln-fg, color-mix(in srgb, var(--muted) 45%, var(--bg)));
      opacity: 0.5;
    }
    /* Ensure colored gutter stays fully opaque in dark mode */
    [data-theme="dark"] #previewFull .quad-line[data-ch]::before { opacity: 1 !important; }

    /* Lab Tech sample hint box: theme-aware, high-contrast */
    :root:not([data-theme="dark"]) .labtech-sample {
      background-color: #f3f4f6;         /* gray-100 */
      border: 1px solid #e5e7eb;         /* gray-200 */
      color: #374151 !important;         /* gray-700 */
    }
    :root:not([data-theme="dark"]) .labtech-sample strong { color: #111827; } /* gray-900 */
    [data-theme="dark"] .labtech-sample {
      background-color: #171717;         /* near console bg, slightly lifted */
      border: 1px solid #262626;         /* neutral-800 */
      color: #e5e5e5 !important;         /* light text */
    }
    [data-theme="dark"] .labtech-sample strong { color: #ffffff; }

    /* Explicit light-mode scrollbar colors (WebKit) */
    :root:not([data-theme="dark"]) #previewFull::-webkit-scrollbar-track,
    :root:not([data-theme="dark"]) #chatHistory::-webkit-scrollbar-track,
    :root:not([data-theme="dark"]) #helpContent::-webkit-scrollbar-track {
      background: #f7f7f7;
    }
    :root:not([data-theme="dark"]) #previewFull::-webkit-scrollbar-thumb,
    :root:not([data-theme="dark"]) #chatHistory::-webkit-scrollbar-thumb,
    :root:not([data-theme="dark"]) #helpContent::-webkit-scrollbar-thumb {
      background: #c7c7c7;
      border-color: #ffffff;
    }
    /* Firefox scrollbar colors */
    :root:not([data-theme="dark"]) #previewFull,
    :root:not([data-theme="dark"]) #chatHistory,
    :root:not([data-theme="dark"]) #helpContent { scrollbar-color: #c7c7c7 #f7f7f7; scrollbar-width: auto; }
    [data-theme="dark"] #previewFull,
    [data-theme="dark"] #chatHistory,
    [data-theme="dark"] #helpContent { scrollbar-color: #4b5563 #111111; scrollbar-width: auto; }

    /* Global color application (minimal override of Tailwind utility surfaces) */
    body { background-color: var(--bg); color: var(--text); }
    .bg-white { background-color: var(--bg-elevated) !important; }
    .bg-gray-50 { background-color: var(--bg) !important; }
    .bg-gray-100 { background-color: color-mix(in srgb, var(--bg-elevated) 92%, var(--text)) !important; }
    
    /* Override jarring light backgrounds in console headers for dark mode */
    [data-theme="dark"] .bg-gray-100 { 
      background-color: var(--console-border) !important; 
      color: var(--console-text) !important; 
    }
    
    /* Fix jarring console container backgrounds in dark mode */
    [data-theme="dark"] .border.border-gray-200.rounded-xl { 
      background-color: var(--console-bg) !important; 
      border-color: var(--console-border) !important; 
    }
    .border-gray-200 { border-color: var(--border) !important; }
    .border-gray-300 { border-color: var(--border) !important; }
    .text-gray-700 { color: var(--muted) !important; }
    .text-gray-600 { color: var(--muted) !important; }
    .text-gray-500 { color: color-mix(in srgb, var(--muted) 80%, var(--bg)) !important; }
    .text-gray-400 { color: color-mix(in srgb, var(--muted) 65%, var(--bg)) !important; }

    /* Buttons using blue accents keep contrast in dark */
    .bg-blue-600 { background-color: var(--accent) !important; color: var(--accent-contrast) !important; }
    .hover\:bg-blue-700:hover { background-color: color-mix(in srgb, var(--accent) 85%, black) !important; }

    /* Shell container: keep app frame darkest */
    .app-shell { background-color: var(--bg) !important; border: 1px solid var(--border); }

    /* Help/Markdown colors use theme tokens */
    #helpContent h2 { font-size: 1.125rem; line-height: 1.5rem; font-weight: 600; margin-top: 0.75rem; margin-bottom: 0.5rem; color: var(--text); }
    #helpContent h3 { font-size: 1rem; line-height: 1.5rem; font-weight: 600; margin-top: 0.5rem; margin-bottom: 0.25rem; color: var(--text); }
    #helpContent p  { margin: 0.25rem 0 0.5rem 0; color: var(--muted); }
    #helpContent hr { border: 0; border-top: 1px solid var(--border); margin: 0.75rem 0; }
    #helpContent ul, #helpContent ol { margin: 0.25rem 0 0.5rem 1.25rem; color: var(--muted); }
    #helpContent ul { list-style: disc; list-style-position: inside; }
    #helpContent ol { list-style: decimal; list-style-position: inside; }
    #helpContent li { margin: 0.125rem 0; }
    #helpContent dl { margin: 0.25rem 0 0.75rem 0; }
    #helpContent dt { font-weight: 700; margin-top: 0.75rem; color: var(--text); }
    #helpContent dd { margin: 0.15rem 0 0.5rem 0.75rem; color: var(--muted); }
    #helpContent code { background: var(--code-bg); color: var(--code-text); padding: 0 0.25rem; border-radius: 0.25rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #helpContent a { color: var(--link); text-decoration: underline; }
    #helpContent a:hover { color: var(--link-hover); }

    /* Help tabs: improve dark-mode selected contrast */
    [data-theme="dark"] #helpTabs button { color: var(--muted) !important; border-bottom-color: transparent !important; }
    [data-theme="dark"] #helpTabs button.text-gray-800 { color: #e5e7eb !important; }
    [data-theme="dark"] #helpTabs button.border-slate-700 { border-bottom-color: #e5e7eb !important; }

    /* Help popup: use same scrollbar style as chat/preview */
    #helpContent::-webkit-scrollbar { width: 24px; }
    #helpContent::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 10px; }
    #helpContent::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 10px; border: 3px solid var(--scrollbar-thumb-border); min-height: 60px; }
    #helpContent::-webkit-scrollbar-thumb:hover { background: #b3b3b3; }
    #helpContent::-webkit-scrollbar-thumb:active { background: #9a9a9a; }
    [data-theme="dark"] #helpContent::-webkit-scrollbar-thumb { background: #4b5563; border-color: var(--console-bg); }
    [data-theme="dark"] #helpContent::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    [data-theme="dark"] #helpContent::-webkit-scrollbar-track { background: var(--console-bg); }

    /* Help popup container contrast in dark mode */
    [data-theme="dark"] #helpPopup > div {
      background-color: var(--bg-elevated) !important;
      border: 1px solid var(--border-emphasis) !important;
      box-shadow: 0 16px 48px rgba(0,0,0,0.6);
    }

    /* Help overlay: ensure translucent backdrop in dark mode */
    [data-theme="dark"] #helpPopup { background-color: rgba(0,0,0,0.5) !important; }
    [data-theme="dark"] #globalCorrectionHelpPopup { background-color: rgba(0,0,0,0.5) !important; }
    [data-theme="dark"] #intentHelpPopup { background-color: rgba(0,0,0,0.5) !important; }

    /* Help logo: apply dark-mode stroke/fill overrides like main logo */
    [data-theme="dark"] #helpPopup svg [stroke="#1A1A1A"] { stroke: #e5e7eb !important; }
    [data-theme="dark"] #helpPopup svg [fill="#1A1A1A"] { fill: #e5e5e5 !important; }
    [data-theme="dark"] #intentHelpPopup > div {
      background-color: var(--bg-elevated) !important;
      border: 1px solid var(--border-emphasis) !important;
      box-shadow: 0 16px 48px rgba(0,0,0,0.6);
    }

    /* Reusable help callouts/badges */
    .help-callout { background-color: #f9fafb; border: 1px solid #e5e7eb; border-radius: 0.75rem; padding: 0.75rem; }
    [data-theme="dark"] .help-callout { background-color: #1f2937; border-color: #374151; color: #e5e7eb; }
    .help-badge { display: inline-block; padding: 2px 8px; border-radius: 9999px; font-size: 0.75rem; border: 1px solid #e5e7eb; background: #f3f4f6; color: #374151; }
    [data-theme="dark"] .help-badge { border-color: #374151; background: #111827; color: #e5e7eb; }

    /* Intent modal: match Help popup styling in dark mode */
    [data-theme="dark"] #intentModal > div {
      background-color: var(--bg-elevated) !important;
      border: 1px solid var(--border-emphasis) !important;
      box-shadow: 0 16px 48px rgba(0,0,0,0.6);
    }
    [data-theme="dark"] #intentModal { background-color: rgba(0,0,0,0.5) !important; }

    /* Intent content: use the same scrollbar styling as Help */
    #intentContent::-webkit-scrollbar { width: 24px; }
    #intentContent::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 10px; }
    #intentContent::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 10px; border: 3px solid var(--scrollbar-thumb-border); min-height: 60px; }
    #intentContent::-webkit-scrollbar-thumb:hover { background: #b3b3b3; }
    #intentContent::-webkit-scrollbar-thumb:active { background: #9a9a9a; }
    [data-theme="dark"] #intentContent::-webkit-scrollbar-thumb { background: #4b5563; border-color: var(--console-bg); }
    [data-theme="dark"] #intentContent::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    [data-theme="dark"] #intentContent::-webkit-scrollbar-track { background: var(--console-bg); }

    /* Paste tab note: light by default, darker in dark mode */
    [data-theme="dark"] #intentPasteNote {
      background-color: #1f2937 !important; /* gray-800 */
      color: #e5e7eb !important;            /* gray-200 */
      border-color: #374151 !important;     /* gray-700 */
    }

    /* Dark mode: make the paste-parse success message a brighter green */
    [data-theme="dark"] #intentPasteValidation.text-green-700 {
      color: #34d399 !important; /* Tailwind green-400 */
    }

    /* Dark-mode UI polish for Lab Tech + Notes */
    [data-theme="dark"] .border-gray-800 { border-color: var(--border-subtle) !important; }
    /* Match Clear button to Undo button styling in dark mode */
    [data-theme="dark"] #clearChatBtn { 
      background-color: #475569 !important; /* slate-600 */
      color: #ffffff !important; 
      border: 1px solid transparent !important; 
    }
    [data-theme="dark"] #clearChatBtn:hover { background-color: #374151 !important; /* gray-700 */ }
    /* Lighten generic bg-black containers in dark mode (console areas) */
    [data-theme="dark"] .bg-black { background-color: var(--bg-elevated) !important; color: var(--text) !important; }

    /* Improve logo contrast in dark: override black strokes/fills */
    [data-theme="dark"] #quadgenLogo [stroke="#1A1A1A"] { stroke: #e5e7eb !important; }
    [data-theme="dark"] #quadgenLogo [fill="#1A1A1A"] { fill: #e5e7eb !important; }

    /* Always show number input arrows */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: inner-spin-button !important;
      opacity: 1 !important;
    }
    
    input[type="number"] {
      -moz-appearance: textfield;
    }
    
    input[type="number"]::-moz-number-spin-box {
      -moz-appearance: spin-textfield !important;
    }

    /* Slider toggle styles */
    .slider-toggle {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }

    .slider-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #10b981;
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #10b981;
    }

    input:checked + .slider:before {
      transform: translateX(20px);
    }

    input:disabled + .slider {
      background-color: #e5e5e5;
      cursor: not-allowed;
    }

    input:disabled + .slider:before {
      background-color: #f5f5f5;
    }

    /* Dark mode overrides for toggle slider */
    [data-theme="dark"] .slider {
      background-color: var(--border) !important;         /* darker track when OFF */
    }
    [data-theme="dark"] input:checked + .slider {
      background-color: var(--accent) !important;         /* muted accent when ON */
    }
    [data-theme="dark"] input:focus + .slider {
      box-shadow: 0 0 0 2px #525252 !important;           /* soft gray focus ring */
    }
    [data-theme="dark"] .slider:before {
      background-color: #e5e5e5 !important;               /* lighter knob for contrast */
    }
    [data-theme="dark"] input:disabled + .slider {
      background-color: #1f1f1f !important;               /* dim disabled track */
    }
    [data-theme="dark"] input:disabled + .slider:before {
      background-color: #3a3a3a !important;               /* dim disabled knob */
    }


    /* Custom scrollbar styling for file preview */
    #previewFull::-webkit-scrollbar { width: 24px; }
    #previewFull::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 10px; }
    #previewFull::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 10px; border: 3px solid var(--scrollbar-thumb-border); min-height: 60px; }
    #previewFull::-webkit-scrollbar-thumb:hover { background: #b3b3b3; }
    #previewFull::-webkit-scrollbar-thumb:active { background: #9a9a9a; }

    /* Match Lab Tech console scrollbar to .quad File Preview */
    #chatHistory::-webkit-scrollbar { width: 24px; }
    #chatHistory::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 10px; }
    #chatHistory::-webkit-scrollbar-thumb { background: #c7c7c7; border-radius: 10px; border: 3px solid var(--scrollbar-thumb-border); min-height: 60px; }
    #chatHistory::-webkit-scrollbar-thumb:hover { background: #b3b3b3; }
    #chatHistory::-webkit-scrollbar-thumb:active { background: #9a9a9a; }

    /* Dark mode scrollbar tweaks: darker, less contrasty */
    [data-theme="dark"] #previewFull::-webkit-scrollbar-thumb,
    [data-theme="dark"] #chatHistory::-webkit-scrollbar-thumb { background: #4b5563; border-color: var(--console-bg); }
    [data-theme="dark"] #previewFull::-webkit-scrollbar-thumb:hover,
    [data-theme="dark"] #chatHistory::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    [data-theme="dark"] #previewFull::-webkit-scrollbar-track,
    [data-theme="dark"] #chatHistory::-webkit-scrollbar-track { background: var(--console-bg); }

    /* Instant tooltip for linearization buttons */
    .per-channel-btn, #globalLinearizationBtn {
      position: relative;
    }

    .per-channel-btn:hover::after, #globalLinearizationBtn:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--tooltip-bg);
      color: var(--tooltip-text);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 1000;
      margin-bottom: 4px;
      pointer-events: none;
    }

    .per-channel-btn:hover::before, #globalLinearizationBtn:hover::before {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid var(--tooltip-bg);
      z-index: 1000;
      pointer-events: none;
    }

    /* Hide number input spinners */
    .lstar-input::-webkit-outer-spin-button,
    .lstar-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    .lstar-input[type=number] {
      -moz-appearance: textfield;
    }
    /* Hide number input spinners for target inputs as well */
    /* (Removed) .lstar-target-* styles – Manual L* no longer uses Target inputs */
    
    /* Standard dropdown styling — compact across the app */
    .standard-dropdown {
      width: 100%;
      padding: 0.125rem 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.8125rem; /* ~13px */
      line-height: 1.25;
      height: 28px;
      box-sizing: border-box;
      background-color: white;
      color: #374151;
    }

    /* Edit panel global disable (except main toggle button) */
    #editPanelBody.edit-panel-disabled {
      opacity: 0.6;
      pointer-events: none;
      filter: grayscale(10%);
    }
    
    .standard-dropdown:disabled {
      background-color: #f9fafb;
      color: #9ca3af;
      cursor: not-allowed;
    }
    
    .standard-dropdown option {
      font-size: 0.8125rem;
      line-height: 1.25;
      color: #374151;
    }

    /* All dropdowns use the same compact size via .standard-dropdown */

    /* Custom Intent tab: make range sliders more prominent */
    #intentTab-custom input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 9999px;
      /* Light mode: uniform track (no filled portion) */
      background: #e5e7eb; /* gray-200 */
      outline: none;
      transition: filter 120ms ease;
    }
    /* Dark mode: uniform darker track (no filled portion) */
    [data-theme="dark"] #intentTab-custom input[type="range"] {
      background: var(--console-input-bg);
    }
    #intentTab-custom input[type="range"]:hover { filter: brightness(1.02); }
    #intentTab-custom input[type="range"]:focus { box-shadow: 0 0 0 3px rgba(59,130,246,0.25); }
    /* WebKit thumb */
    #intentTab-custom input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px; height: 16px;
      background: #ffffff;
      border: 1px solid #cbd5e1; /* slate-300 */
      border-radius: 9999px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.12);
      margin-top: -4px; /* center on 8px track */
    }
    /* Firefox track + progress */
    #intentTab-custom input[type="range"]::-moz-range-track {
      height: 8px; border-radius: 9999px; background: #e5e7eb; /* gray-200 */
    }
    #intentTab-custom input[type="range"]::-moz-range-progress {
      height: 8px; border-radius: 9999px; background: transparent; /* no filled portion */
    }
    #intentTab-custom input[type="range"]::-moz-range-thumb {
      width: 16px; height: 16px; background: #ffffff; border: 1px solid #cbd5e1; border-radius: 9999px; box-shadow: 0 1px 2px rgba(0,0,0,0.12);
    }

    /* Use default system checkbox styling */
    input[type="checkbox"] { accent-color: #ffffff; }

    /* Nudge buttons styling */
    .nudge-btn {
      background-color: #475569; /* slate-600 */
      color: #ffffff;
      transition: transform 0.05s ease, background-color 0.1s ease;
      user-select: none;
    }
    /* Unified disabled look in Edit panel: match Redo disabled */
    #editPanelBody button:disabled,
    #editPanelBody .nudge-btn:disabled {
      background-color: #475569; /* slate-600 */
      color: #ffffff;
      opacity: 0.5;
      cursor: not-allowed;
    }
    #editPanelBody #editPointIndex.is-disabled {
      background-color: #475569; /* slate-600 */
      color: #ffffff;
      opacity: 0.5;
    }
    .nudge-btn:hover { background-color: #374151; /* gray-700 (darker gray) */ }
    .nudge-btn:active {
      background-color: #000000; /* black */
      transform: translateY(2px);
    }

    /* Global press effect for all buttons */
    button {
      transition: transform 0.05s ease;
    }
    button:active {
      transform: translateY(2px);
    }

    /* Ultra-Compact Channel Styles */
    .channel-row {
      transition: all 0.2s ease-in-out;
    }
    
    /* Hide disabled channels from table flow */
    .channel-row[data-compact="true"] {
      display: none;
    }

    /* Disabled state styling for Generate button */
    #generateFromLstar:disabled {
      background-color: #9ca3af; /* gray-400 */
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    /* Compact chip container */
    .disabled-channels-compact {
      background-color: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 12px;
      margin: 8px 0;
      display: none; /* Hidden by default */
    }
    
    .disabled-channels-compact.show {
      display: block;
    }
    
    .disabled-channels-compact .compact-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 6px;
      display: block;
    }
    
    .disabled-channels-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    
    /* Individual disabled channel chips */
    .disabled-channel-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background-color: var(--bg-elevated);
      border-radius: 6px;
      padding: 3px 8px;
      font-size: 12px;
      color: var(--muted);
      cursor: pointer;
      transition: all 0.15s ease-in-out;
      user-select: none;
    }
    
    .disabled-channel-chip:hover {
      background-color: color-mix(in srgb, var(--bg-elevated) 85%, var(--text));
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .disabled-channel-chip.active {
      background-color: color-mix(in srgb, var(--accent) 15%, var(--bg-elevated));
      color: var(--accent);
    }
    
    .disabled-channel-chip .channel-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid color-mix(in srgb, var(--border) 80%, var(--text));
      flex-shrink: 0;
      display: inline-block;
    }
    
    .disabled-channel-chip .channel-checkbox {
      width: 12px;
      height: 12px;
      margin: 0;
      cursor: pointer;
      accent-color: #ffffff;
    }
    
    .disabled-channel-chip .channel-name {
      font-weight: 600;
      min-width: 20px;
      color: var(--muted);
      font-size: 12px;
    }

    /* Compact label styling */
    .disabled-channels-compact .compact-label::after {
      content: ':';
      margin-left: 2px;
    }

    /* Smooth transitions for showing/hiding */
    .disabled-channels-compact {
      transition: all 0.3s ease-in-out;
      transform-origin: top;
    }

    .disabled-channels-compact:not(.show) {
      max-height: 0;
      opacity: 0;
      margin: 0;
      padding: 0;
      border: none;
      overflow: hidden;
    }

    /* Terminal-style chat lines */
    #chatHistory .chat-line { display: block; margin: 0 0 2px 0; white-space: pre-wrap; }
    :root:not([data-theme="dark"]) #chatHistory .chat-line.assistant { color: #111827; }
    :root:not([data-theme="dark"]) #chatHistory .chat-line.user { color: #065f46; font-weight: 600; }
    :root:not([data-theme="dark"]) #chatHistory .chat-line.system { color: #6b7280; font-style: italic; }
    [data-theme="dark"] #chatHistory .chat-line.assistant { color: #e5e5e5; }
    [data-theme="dark"] #chatHistory .chat-line.user { color: #34d399; font-weight: 600; }
    [data-theme="dark"] #chatHistory .chat-line.system { color: #9ca3af; font-style: italic; }
    
    #chatHistory a { color: var(--link); text-decoration: underline; font-weight: 600; }
    #chatHistory a:hover { color: var(--link-hover); text-decoration: underline; }
    #chatHistory a[target="_blank"]::after { content: ' ↗'; font-weight: 600; color: var(--muted); }
    :root:not([data-theme="dark"]) #chatHistory .chat-line.user a { color: #15803d; }
    :root:not([data-theme="dark"]) #chatHistory .chat-line.user a:hover { color: #16a34a; }

    /* One Light-inspired theme for Lab Tech console (light mode) */
    :root:not([data-theme="dark"]) #labTechConsole {
      --onl-bg: #fafafa;        /* editor background */
      --onl-fg: #383a42;        /* editor foreground */
      --onl-muted: #a0a1a7;     /* comments/muted */
      --onl-blue: #4078f2;      /* link/primary */
      --onl-cyan: #0184bc;      /* info */
      --onl-green: #50a14f;     /* success/user */
      --onl-orange: #c18401;    /* warn */
      --onl-pink: #a626a4;      /* accent */
      --onl-red: #e45649;       /* error */
      --onl-yellow: #986801;    /* emphasis */
      background-color: var(--onl-bg) !important;
      color: var(--onl-fg) !important;
      border-color: #e6e6e6 !important;
    }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory .chat-line { color: var(--onl-fg); }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory .chat-line.user { color: var(--onl-green); font-weight: 600; }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory .chat-line.assistant { color: var(--onl-fg); }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory .chat-line.system { color: var(--onl-muted); font-style: italic; }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory .chat-line.system.error { color: var(--onl-red); font-style: normal; }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory .chat-line.system.info { color: var(--onl-cyan); font-style: normal; }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory a { color: var(--onl-blue); text-decoration: underline; font-weight: 600; }
    :root:not([data-theme="dark"]) #labTechConsole #chatHistory a:hover { color: #6ea1ff; }

    /* Input matches One Light */
    :root:not([data-theme="dark"]) #labTechConsole #aiInputCompact {
      background: var(--onl-bg) !important;
      color: var(--onl-fg) !important;
      border-color: #d0d0d0 !important;
    }
    :root:not([data-theme="dark"]) #labTechConsole #aiInputCompact::placeholder { color: var(--onl-muted); }
    :root:not([data-theme="dark"]) #labTechConsole #aiInputCompact:focus {
      outline: none !important;
      box-shadow: 0 0 0 2px rgba(64,120,242,0.25) !important;
      border-color: #4078f2 !important;
    }
    :root:not([data-theme="dark"]) #labTechConsole #clearChatBtn {
      background: #efefef !important;
      color: var(--onl-fg) !important;
      border: 1px solid #e2e2e2 !important;
    }
    :root:not([data-theme="dark"]) #labTechConsole #clearChatBtn:hover { background: #e7e7e7 !important; }

    /* Neutralize Lab Tech and .quad preview console hues in dark mode */
    [data-theme="dark"] #chatHistory,
    [data-theme="dark"] #previewFull,
    [data-theme="dark"] #userNotes,
    [data-theme="dark"] #aiInputCompact {
      background-color: var(--console-bg) !important;
      color: var(--console-text) !important;
      border-color: var(--console-input-border) !important;
    }
    /* Slightly lighten preview background in dark mode for better K gutter contrast */
    [data-theme="dark"] #previewFull {
      background-color: var(--bg-elevated-hover) !important; /* slightly lighter for gutter contrast */
    }
    [data-theme="dark"] #labTechResizer {
      background-color: var(--console-resizer) !important;
    }
    [data-theme="dark"] #labTechResizer:hover {
      background-color: var(--console-resizer-hover) !important;
    }
    [data-theme="dark"] #labTechResizer span,
    [data-theme="dark"] #previewResizer span {
      background-color: var(--console-grip) !important;
    }
    [data-theme="dark"] #previewResizer {
      background-color: var(--console-resizer) !important;
    }
    [data-theme="dark"] #previewResizer:hover {
      background-color: var(--console-resizer-hover) !important;
    }
    [data-theme="dark"] #userNotes::placeholder,
    [data-theme="dark"] #aiInputCompact::placeholder {
      color: #9a9a9a;
    }
    [data-theme="dark"] #userNotes {
      border-color: var(--console-input-border) !important;
    }

    /* Dark-mode readability for channel inputs (percent and end) */
    [data-theme="dark"] .percent-input,
    [data-theme="dark"] .end-input {
      background-color: var(--console-input-bg) !important; /* darker field */
      color: var(--text) !important;                         /* light text */
      border-color: var(--console-input-border) !important;  /* neutral border */
    }
    [data-theme="dark"] .percent-input::placeholder,
    [data-theme="dark"] .end-input::placeholder {
      color: #9a9a9a;                                       /* subtle placeholder */
    }
    [data-theme="dark"] .percent-input:focus,
    [data-theme="dark"] .end-input:focus {
      outline: 2px solid #737373;                           /* soft gray focus */
      outline-offset: 0;
      box-shadow: none !important;
      border-color: #737373 !important;
    }

    /* Extend dark-mode readability to other text inputs/selects */
    [data-theme="dark"] #filenameInput,
    [data-theme="dark"] .standard-dropdown,
    [data-theme="dark"] .lstar-input,
    [data-theme="dark"] #editXYInput,
    [data-theme="dark"] #aiInput,
    [data-theme="dark"] #editMaxError,
    [data-theme="dark"] #editMaxPoints,
    [data-theme="dark"] #perChannelDeltaSelect {
      background-color: var(--console-input-bg) !important;
      color: var(--text) !important;
      border-color: var(--console-input-border) !important;
    }
    [data-theme="dark"] #filenameInput::placeholder,
    [data-theme="dark"] .lstar-input::placeholder,
    [data-theme="dark"] #editXYInput::placeholder,
    [data-theme="dark"] #aiInput::placeholder {
      color: #9a9a9a;
    }
    [data-theme="dark"] #filenameInput:focus,
    [data-theme="dark"] .standard-dropdown:focus,
    [data-theme="dark"] .lstar-input:focus,
    [data-theme="dark"] #editXYInput:focus,
    [data-theme="dark"] #aiInput:focus,
    [data-theme="dark"] #editMaxError:focus,
    [data-theme="dark"] #editMaxPoints:focus,
    [data-theme="dark"] #perChannelDeltaSelect:focus {
      outline: 2px solid #737373;
      outline-offset: 0;
      box-shadow: none !important;
      border-color: #737373 !important;
    }

    /* (moved above) Help content readability via theme tokens */
  </style>
</head>
<body class="min-h-screen bg-gray-50 px-2 md:px-4 py-3">
  <main class="mx-auto max-w-6xl">
    <section class="app-shell bg-white rounded-2xl shadow-lg px-4 md:px-6 py-5 md:py-6">
      <header class="mb-6">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 items-center mb-2">
          <div class="flex items-center gap-4 lg:col-span-3">
            <svg id="quadgenLogo" xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 160 160" role="img" aria-labelledby="quadgenTitle quadgenDesc">
              <title id="quadgenTitle">quadGEN icon (CMYK)</title>
              <desc id="quadgenDesc">Four CMYK bars with a rising Bezier-style curve and nodes, flat design.</desc>
              <!-- baseline -->
              <path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round"/>
              <!-- CMYK bars -->
              <rect id="cyanBar" x="20" y="90" width="20" height="40" rx="6" ry="6" fill="#00B5E2"/>
              <rect id="magentaBar" x="52" y="70" width="20" height="60" rx="6" ry="6" fill="#FF2A8A"/>
              <rect id="yellowBar" x="84" y="50" width="20" height="80" rx="6" ry="6" fill="#FFD400"/>
              <rect id="blackBar" x="116" y="22" width="20" height="110" rx="6" ry="6" fill="#1A1A1A"/>
              <!-- Bezier-like curve -->
              <path id="logoPath" d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18"
                    fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
              <!-- curve nodes -->
              <circle id="node1" cx="30" cy="88" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node2" cx="62" cy="68" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node3" cx="94" cy="48" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node4" cx="126" cy="18" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
            </svg>
            <div>
              <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">
                quadGEN
                <span id="appVersion" class="text-gray-400 text-lg"></span>
              </h1>
              <p class="text-gray-400 text-sm -mt-1">by <a href="https://www.davidmarshprints.com/" target="_blank" rel="noopener noreferrer" class="hover:text-gray-600 underline">David Marsh</a></p>
            </div>
            
            <!-- Compact printer selector -->
            <div class="flex items-center gap-2 bg-gray-50 rounded-lg border border-gray-200 px-3 py-2 flex-1 ml-4">
              <label for="printerSelect" class="text-sm font-medium text-gray-700">Printer:</label>
              <select id="printerSelect" class="standard-dropdown" style="width: 120px;">
                <option value="P700P900" selected>P700-P900</option>
                <option value="P5-7-9000">P5-7-9000</option>
                <option value="P800">P600-P800</option>
                <option value="P400">P400</option>
                <option value="x900">x900</option>
                <option value="3880-7880">3880-7880</option>
                <option value="x800-x890">x800-x890</option>
                <option value="P4-6-8000">P4-6-8000</option>
              </select>
              <p id="channelInfo" class="flex-1 text-xs text-gray-600 ml-1"></p>
              <button id="helpBtn" class="text-sm bg-blue-600 hover:bg-blue-700 text-white rounded px-3 py-1 transition-colors ml-auto font-bold" title="Help and quick start">
                📖 Help
              </button>
              <button id="themeToggle" class="ml-2 text-sm rounded px-2 py-1 font-bold border border-gray-300 bg-white hover:bg-gray-50 transition-colors" title="Toggle dark mode" aria-pressed="false">🌙</button>
              
            </div>
          </div>
          
        </div>
        <p id="printerDescription" class="text-gray-600 mt-1"></p>
      </header>

      <!-- Main Actions -->
      <div class="mb-4">
              <div class="flex items-center gap-2 bg-white border border-gray-200 rounded-xl p-4">
          <input type="file" id="quadFile" accept=".quad" class="hidden">
          <button id="undoBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-700 rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed" disabled title="No changes to undo">
            ↺ Undo
          </button>
          <button id="redoBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-700 rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed" disabled title="No changes to redo">
            ↻ Redo
          </button>
          <button id="loadQuadBtn" class="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors font-bold">
            → Load .quad
          </button>
          <button id="downloadBtn" class="px-4 py-2 text-sm bg-black text-white hover:bg-black/90 rounded transition-colors font-bold">
            ↓ Download .quad
          </button>
          <input id="filenameInput" type="text" placeholder="P900_K33_C33_M33..." class="flex-1 ml-3 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
          <span class="text-sm text-gray-500">.quad</span>
        </div>
      </div>

      <!-- Ink Limits Graph and Linearization -->
      <div class="mb-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
        <!-- Graph Section -->
        <div class="lg:col-span-2 space-y-4">
          <div class="bg-white border border-gray-200 rounded-xl p-2 relative">
            <div class="bg-gray-50 rounded-lg p-2 relative">
              <canvas id="inkChart" width="950" height="700" class="w-full h-auto max-h-none"></canvas>

              <div class="chart-zoom-controls" aria-label="Adjust chart zoom">
                <button id="chartZoomOutBtn" type="button" class="chart-zoom-btn" title="Zoom out (show more ink range)">−</button>
                <div class="chart-zoom-divider" aria-hidden="true"></div>
                <button id="chartZoomInBtn" type="button" class="chart-zoom-btn" title="Zoom in (magnify ink range)">+</button>
              </div>

              <!-- (Removed) Smoothing Note -->
            </div>
            <!-- Cursor tooltip for X,Y coordinates over the graph -->
            <div id="chartCursorTooltip" class="hidden absolute z-20 px-1.5 py-0.5 text-xs rounded bg-black text-white pointer-events-none shadow-md"></div>
            
            <!-- Status Display -->
            <div class="absolute top-6 left-4 right-4 z-10">
              <div class="bg-gray-50 rounded-lg px-3 py-2 text-center flex items-center justify-center">
                <span id="status" class="text-xs text-gray-600 font-medium transition-opacity duration-500 ease-in-out">&nbsp;</span>
              </div>
            </div>
            <div class="absolute top-1 left-4 z-10">
              <span id="sessionStatus" class="text-xs text-gray-500">&nbsp;</span>
            </div>
            
            <!-- Interpolation Controls (moved inside graph container) -->
            <div class="mt-0">
              <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                <!-- Left Column: Interpolation Method -->
                <div class="space-y-2">
                  <div style="display: none;">
                    <h3 class="text-xs font-medium text-gray-700 mb-1">Interpolation Method</h3>
                    <select id="curveSmoothingMethod" class="standard-dropdown" disabled>
                      <option value="pchip" selected>PCHIP (monotonic)</option>
                      <option value="linear">Linear (none)</option>
                    </select>
                    <p id="interpolationDescription" class="text-xs text-gray-500 mt-2">Monotonic interpolation preserves data trends</p>
                  </div>
                  
                  <!-- Catmull-Rom Tension Control -->
                  <div id="catmullTensionContainer" style="display: none;">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Curve Tension</label>
                    <div class="flex items-center gap-2">
                      <span class="text-xs text-gray-500">Tight</span>
                      <input type="range" id="catmullTension" min="0" max="100" value="50" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" disabled>
                      <span class="text-xs text-gray-500">Loose</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Adjust how curvy the interpolation becomes</p>
                  </div>

                  
                </div>
                
                <!-- Right Column (reserved) -->
                <div class="space-y-2"></div>
              </div>
            </div>

            <!-- Debug Intent Tuning Panel (hidden unless DEBUG_INTENT_TUNING true) -->
            <div id="intentTuningPanel" class="mt-4 border border-amber-400 bg-amber-50 rounded-lg p-3 space-y-3 hidden">
              <div class="flex items-center justify-between">
                <span class="text-xs font-semibold text-amber-700">Intent Tuning (debug)</span>
                <span class="text-[10px] text-amber-600">Restore via button below</span>
              </div>
              <div class="grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
                <div class="space-y-2">
                  <label class="block font-semibold text-amber-700">Interpolation</label>
                  <select id="tuningInterpolationSelect" class="standard-dropdown text-xs">
                    <option value="pchip">PCHIP (monotonic)</option>
                    <option value="cubic">Cubic spline</option>
                    <option value="linear">Linear</option>
                  </select>
                  <div class="pt-2">
                    <label class="block font-semibold text-amber-700">Primary smoothing</label>
                    <div class="flex items-center gap-2">
                      <input type="range" id="tuningSmoothingPercent" min="0" max="30" step="1" value="30" class="flex-1">
                      <span id="tuningSmoothingLabel" class="w-8 text-right">30%</span>
                    </div>
                    <select id="tuningSmoothingAlgorithm" class="standard-dropdown text-xs mt-1">
                      <option value="smoothing-splines">Smoothing splines</option>
                      <option value="uniform">Uniform sampling</option>
                    </select>
                  </div>
                </div>
                <div class="space-y-2">
                  <label class="block font-semibold text-amber-700">Post smoothing</label>
                  <div class="flex items-center gap-2">
                    <select id="tuningPostPasses" class="standard-dropdown text-xs w-20">
                      <option value="0">0 passes</option>
                      <option value="1" selected>1 pass</option>
                    </select>
                    <div class="flex-1 flex items-center gap-2">
                      <input type="range" id="tuningPostPercent" min="0" max="30" step="1" value="30" class="flex-1">
                      <span id="tuningPostLabel" class="w-8 text-right">30%</span>
                    </div>
                  </div>
                  <select id="tuningPostAlgorithm" class="standard-dropdown text-xs">
                    <option value="smoothing-splines">Smoothing splines</option>
                    <option value="uniform">Uniform sampling</option>
                  </select>
                  <p class="text-[11px] text-amber-700">Post smoothing only applies when pass count &gt; 0.</p>
                </div>
                <div class="space-y-2">
                  <label class="block font-semibold text-amber-700">LAB bandwidth overrides</label>
                  <div class="grid grid-cols-2 gap-2">
                    <label class="block">K neighbors
                      <input type="number" id="tuningNeighbors" class="standard-input text-xs" value="2" min="1" max="12">
                    </label>
                    <label class="block">σ floor
                      <input type="number" id="tuningSigmaFloor" class="standard-input text-xs" value="0.036" step="0.005" min="0.001" max="0.5">
                    </label>
                    <label class="block">σ ceil
                      <input type="number" id="tuningSigmaCeil" class="standard-input text-xs" value="0.15" step="0.01" min="0.05" max="0.5">
                    </label>
                    <label class="block">σ alpha
                      <input type="number" id="tuningSigmaAlpha" class="standard-input text-xs" value="2.0" step="0.1" min="0.5" max="6">
                    </label>
                  </div>
                  <p class="text-[11px] text-amber-700">Leave defaults to use current LAB smoothing.</p>
                </div>
              </div>
              <div class="flex items-center gap-2 text-xs">
                <button id="tuningApplyBtn" class="px-3 py-2 rounded bg-amber-600 hover:bg-amber-700 text-white font-semibold">Apply Candidate</button>
                <button id="tuningRestoreBtn" class="px-3 py-2 rounded border border-amber-400 text-amber-700 hover:bg-amber-100" disabled>Restore Original</button>
                <span id="tuningStatus" class="text-[11px] text-amber-700"></span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Linearization Section -->
        <div class="lg:col-span-1 space-y-4">
          <!-- Global Linearization -->
          <div class="bg-white border border-gray-200 rounded-xl p-2 md:p-3">
            <div class="flex items-center justify-between mb-2">
              <div class="flex items-center gap-2">
                <h3 class="text-sm font-bold">🌐 Global Correction</h3>
                <label class="slider-toggle" title="Enable/disable global correction">
                  <input type="checkbox" id="globalLinearizationToggle" disabled>
                  <span class="slider"></span>
                </label>
              </div>
              <button id="intentHelpBtn" class="text-xs text-gray-400 hover:text-gray-600 bg-gray-100 hover:bg-gray-200 rounded px-2 py-1 transition-colors font-bold" title="Correction vs. Intent" aria-label="Correction vs. Intent">?</button>
            </div>
            <div class="flex items-center gap-2 mb-1">
              <button id="globalLinearizationBtn" class="px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold whitespace-nowrap shrink-0 inline-flex items-center" data-tooltip="Load LUT.cube, LABdata.txt, or .acv curve files">Load Data File</button>
              <input type="file" id="linearizationFile" accept=".cube,.txt,.acv" class="hidden">
              <button id="manualLstarBtn" class="px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold whitespace-nowrap shrink-0 inline-flex items-center">
                Enter L* Values
              </button>
              <button id="revertGlobalToMeasurementBtn" class="px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold whitespace-nowrap shrink-0 inline-flex items-center disabled:opacity-50 disabled:cursor-not-allowed" title="Revert to measurement source (global)" disabled>↺ Revert</button>
            </div>
            <p id="globalLinearizationHint" class="text-xs text-gray-500 mb-1">LUT (.cube), LAB data (.txt), or curves (.acv)</p>
            <div id="globalLinearizationInfo" class="text-xs text-gray-600 mb-2 hidden">
              <span id="globalLinearizationFilename" class="font-medium"></span>
              <span id="globalLinearizationDetails" class="text-gray-500"></span>
              <span id="deltaSummary" class="ml-2 inline-block align-middle hidden"></span>
              <span class="ml-3 inline-flex items-center gap-1 align-middle hidden">
                <label for="perChannelDeltaSelect" class="text-gray-600">Channel change:</label>
                <select id="perChannelDeltaSelect" class="text-xs border border-gray-300 rounded px-1 py-0.5"></select>
                <span id="perChannelDeltaSummary" class="ml-1"></span>
              </span>
            </div>
            <!-- Auto endpoint rolloff controls -->
            <div class="mt-2 flex items-center gap-3 text-xs text-gray-600">
              <span class="font-bold" title="Detect early plateau at the ends and apply a soft shoulder/toe so the curve reaches the ink limit exactly at 100% without flattening.">Auto limits</span>
              <label for="autoWhiteLimitToggle" class="inline-flex items-center gap-1" title="Enable automatic white-shoulder rolloff near paper white.">
                <input type="checkbox" id="autoWhiteLimitToggle" class="h-3 w-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                <span>White</span>
              </label>
              <label for="autoBlackLimitToggle" class="inline-flex items-center gap-1" title="Enable automatic black-toe rolloff near maximum ink.">
                <input type="checkbox" id="autoBlackLimitToggle" class="h-3 w-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                <span>Black</span>
              </label>
            </div>
            <div class="mt-2">
              <label for="contrastIntentSelect" class="text-xs text-gray-600 font-bold block mb-1">Intent</label>
              <div class="flex items-center gap-2">
                <select id="contrastIntentSelect" class="standard-dropdown text-xs" style="width: 200px;">
                  <!-- Preset options will be populated dynamically from CONTRAST_INTENT_PRESETS -->
                  <option value="custom">Custom (saved)</option>
                  <option value="enter_custom">Enter Custom…</option>
                </select>
                <button id="applyIntentToQuadBtn" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded transition-colors font-bold disabled:bg-gray-200 disabled:text-gray-400 disabled:opacity-60 disabled:cursor-not-allowed dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-100 dark:disabled:bg-slate-600 dark:disabled:text-slate-400 dark:disabled:opacity-60" disabled title="Load a .quad (no LAB data) to enable intent remap">Apply Intent</button>
              </div>
            </div>
            
            <!-- Linearization Controls -->
          <div class="space-y-3">
              <!-- File Upload -->
              <div>
                <!-- Buttons moved above; keep info here only -->
              </div>
            </div>
            
            

            <!-- Sample Data moved to About window -->
          </div>

          <!-- Edit Curves Panel -->
          <div class="bg-white border border-gray-200 rounded-xl p-3">
            <div class="flex items-center justify-between mb-4">
              <button id="editModeToggleBtn" type="button" class="inline-flex text-xs font-bold px-2.5 py-1.5 rounded cursor-pointer relative z-10 text-white bg-slate-600 hover:bg-slate-700 border-0" aria-pressed="false" role="switch" aria-checked="false" title="Toggle edit mode">
                <span id="editModeLabel">⟐ Edit Mode: OFF</span>
              </button>
              <button id="editModeHelpBtn" class="text-xs text-gray-400 hover:text-gray-600 bg-gray-100 hover:bg-gray-200 rounded px-2 py-1 transition-colors font-bold" title="Edit Mode Help" aria-label="Edit Mode Help">?</button>
            </div>
            <div id="editPanelBody">

            <!-- (Removed) Edit-panel smoothing: moved to Global Correction panel -->

            <!-- Calculate points -->
            <div class="border border-gray-200 rounded-lg p-3 mb-3 relative">
              <span class="absolute top-0 left-2 -translate-y-1/2 bg-white px-2 text-xs text-gray-700 z-10">Calculate points</span>
              <div class="flex items-end gap-4">
                <label class="text-xs text-gray-700 flex flex-col items-center">
                  <span class="mb-1">Max error %</span>
                  <input type="number" id="editMaxError" class="w-20 px-2 py-1 text-xs border border-gray-300 rounded" min="0.05" max="5" step="0.05" value="0.25">
                </label>
                <label class="text-xs text-gray-700 flex flex-col items-center">
                  <span class="mb-1">Max points</span>
                  <input type="number" id="editMaxPoints" class="w-16 px-2 py-1 text-xs border border-gray-300 rounded" min="2" max="21" step="1" value="21">
                </label>
                <button id="editRecomputeBtn" class="px-3 py-1.5 text-xs bg-green-600 hover:bg-green-700 text-white rounded transition-colors font-bold">↻ Recompute</button>
              </div>
            </div>

            <!-- Channel selection -->
            <div class="border border-gray-200 rounded-lg p-3 mb-3 relative">
              <span class="absolute top-0 left-2 -translate-y-1/2 bg-white px-2 text-xs text-gray-700 z-10">Channel</span>
              <div class="grid grid-cols-3 items-center">
                <label for="editChannelSelect" class="text-sm text-gray-700 justify-self-start invisible">Channel:</label>
                <div class="justify-self-center flex items-center gap-2">
                  <button id="editChannelPrev" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Previous channel" aria-label="Previous channel">◀</button>
                  <select id="editChannelSelect" class="standard-dropdown text-center" style="width:56px; padding-left:0.25rem; padding-right:0.25rem;"></select>
                  <button id="editChannelNext" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Next channel" aria-label="Next channel">▶</button>
                </div>
                <div></div>
              </div>
              <div class="mt-1 text-center"><span id="editChannelState" class="text-xs text-gray-500"></span></div>
            </div>

          <!-- Selected point tools -->
          <div class="border border-gray-200 rounded-lg p-3 relative">
              <span class="absolute top-0 left-2 -translate-y-1/2 bg-white px-2 text-xs text-gray-700 z-10">Point</span>
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <div class="inline-flex items-center gap-2">
                    <button id="editPointLeft" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Previous point">◀</button>
                    <span id="editPointIndex" class="text-sm font-bold text-white bg-black min-w-[1.5rem] text-center px-2 py-0.5 rounded is-disabled">–</span>
                    <button id="editPointRight" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Next point">▶</button>
                  </div>
                </div>
                <button id="editDeleteBtn" class="px-2 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded font-bold" title="Delete selected point">✖︎ Delete</button>
              </div>
              <div class="flex items-center justify-center gap-2">
                <button id="editNudgeYUp" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge Y up">△</button>
              </div>
              <div class="flex items-center justify-center gap-2 mt-1">
                <button id="editNudgeXNeg" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge X left">◁</button>
                <input id="editXYInput" class="w-24 text-center px-2 py-1 text-xs border border-gray-300 rounded" placeholder="X,Y" title="Edit point as 'X,Y' percent">
                <button id="editNudgeXPos" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge X right">▷</button>
              </div>
              <div class="flex items-center justify-center gap-2 mt-1">
                <button id="editNudgeYDown" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge Y down">▽</button>
              </div>
            <div id="editDisabledHint" class="text-xs text-gray-500 text-center mt-2 hidden">Channel is disabled (End=0). Enable in Channels to edit.</div>
          </div>
          <!-- Inline help moved to Edit Mode Help popup -->
            </div>
          </div>
      </div>
      </div>


      <!-- Quick Enable Chips -->
      <div id="disabledChannelsCompact" class="disabled-channels-compact mb-3">
        <div id="disabledChannelsRow" class="disabled-channels-row">
          <!-- Channel chips will be inserted here -->
        </div>
      </div>

      <!-- Channel table -->
      <div class="overflow-auto">
        <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden border-collapse">
          <thead>
            <tr class="bg-gray-50 text-gray-700 text-xs">
              <th class="text-center p-0" style="width:0;"></th>
              <th class="text-left px-1 py-2" style="width: 100px;">Channel</th>
              <th class="text-center px-1 py-2" style="width: 250px;">Correction</th>
              <th class="text-left px-1 py-2">Status</th>
              <th class="text-right pr-0 py-2" style="width:120px;">
                Percent <span class="font-normal text-gray-500">(0–100)</span>
              </th>
              <th class="text-right pl-0 py-2" style="width:120px;">
                End <span class="font-normal text-gray-500">(0–65,535)</span>
              </th>
            </tr>
          </thead>
          <tbody id="rows">
          </tbody>
        </table>
      </div>

      <!-- Lab Tech (console-style, matches .quad File Preview framing) -->
      <div class="mt-3">
          <div class="border border-gray-200 rounded-xl overflow-hidden">
          <div class="console-header bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700 flex items-center justify-between">
            <span><span id="labTechIcon" class="mr-1">💬</span>Lab Tech</span>
            <div class="flex items-center gap-3">
              <label class="flex items-center gap-1 text-xs text-gray-700 hidden" title="Show assistant status messages in chat">
                <input type="checkbox" id="aiShowStatusToggle" class="rounded border-gray-300" checked>
                <span>Show assistant status</span>
              </label>
              <button id="clearChatBtn" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 rounded px-2 py-0.5 font-bold focus:outline-none focus:ring-0">Clear</button>
            </div>
          </div>
          <div id="labTechConsole" class="font-mono p-2">
            <!-- Chat History -->
            <div id="chatHistory" class="overflow-y-auto text-xs leading-4 mb-2" style="height:224px;">
              <div class="labtech-sample px-2 py-1 rounded mb-2">
                <strong>Try this:</strong> "Reduce all ink limits by 20%"<br>
                <strong>or:</strong> "generate a curve with points 0,0 25,20 75,85 100,100"<br>
                <strong>or:</strong> "apply a midtone lift"<br>
                <strong>or:</strong> "delete the point near 25%"<br>
                <strong>or:</strong> "delete point 2"
              </div>
            </div>
            <!-- Resizer for Lab Tech console -->
            <div id="labTechResizer" class="h-4 bg-gray-800/40 hover:bg-gray-700/60 cursor-row-resize mb-2 rounded relative" role="separator" aria-orientation="horizontal" title="Drag to resize">
              <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <span class="inline-block w-10 h-[2px] bg-gray-400/80 rounded"></span>
                <span class="inline-block w-10 h-[2px] bg-gray-400/80 rounded ml-1"></span>
              </div>
            </div>
            <!-- Bottom input area -->
            <div class="flex items-center gap-2">
              <input type="text" id="aiInputCompact" placeholder="Ask Lab Tech… (Enter to send)" 
                     class="flex-1 min-w-0 rounded border px-3 py-1 text-xs focus:outline-none focus:ring-2 placeholder-gray-400">
              <button id="sendMessageBtnCompact" class="px-2 py-1 text-xs bg-green-600 hover:bg-green-700 text-white rounded font-bold focus:outline-none focus:ring-0" disabled>Send</button>
            </div>
          </div>
        </div>
      </div>

      

      <!-- Full Preview -->
      <div class="mt-5">
          <div class="border border-gray-200 rounded-xl overflow-hidden">
          <div class="console-header bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700">📝 .quad File Preview</div>
          <!-- Attached notes input styled like preview -->
          <div id="previewConsole" class="font-mono p-2 border-t">
            <textarea id="userNotes" placeholder="Notes (saved as # comments in the .quad file)" rows="3"
                      class="w-full font-mono text-xs p-2 outline-none resize-y border rounded-sm placeholder-gray-400"></textarea>
          </div>
          <pre id="previewFull" class="p-2 text-xs leading-4 overflow-auto font-mono" style="max-height:224px;">–</pre>
          <div id="previewResizer" class="h-4 bg-gray-200 hover:bg-gray-300 cursor-row-resize relative" role="separator" aria-orientation="horizontal" title="Drag to resize">
            <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
              <span class="inline-block w-10 h-[2px] bg-gray-400 rounded"></span>
              <span class="inline-block w-10 h-[2px] bg-gray-400 rounded ml-1"></span>
            </div>
          </div>
        </div>
      </div>
    </section>
    
  
  </main>

  <!-- Contrast Intent Modal -->
  <div id="intentModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
    <div class="bg-white rounded-lg max-w-2xl w-full mx-4 max-h-[90vh] flex flex-col">
      <div class="p-5 pb-3 flex-shrink-0 flex items-center justify-between">
        <h3 class="text-lg font-semibold">Contrast Intent</h3>
        <button id="closeIntentModal" class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
      </div>
      <div class="px-5 flex gap-2 text-sm border-b border-gray-200">
        <button class="px-3 py-2 rounded-t text-gray-700 bg-gray-100 font-medium" data-intent-tab="presets">Presets</button>
        <button class="px-3 py-2 rounded-t text-gray-600 hover:text-gray-800" data-intent-tab="custom">Custom</button>
        <button class="px-3 py-2 rounded-t text-gray-600 hover:text-gray-800" data-intent-tab="paste">Paste CSV/JSON</button>
        <button class="px-3 py-2 rounded-t text-gray-600 hover:text-gray-800" data-intent-tab="import">Import ACV/LUT</button>
      </div>
      <div id="intentContent" class="overflow-y-auto p-5 space-y-5 h-[512px]">
        <div id="intentTab-presets" class="space-y-4">
          <div class="text-sm text-gray-700">Choose a preset tonal intent for your linearization data.</div>
          <div class="flex items-center gap-3">
            <label class="text-sm text-gray-700">Preset:</label>
            <select id="intentPresetSelect" class="standard-dropdown text-sm" style="width: 220px;">
              <!-- Options will be populated dynamically from CONTRAST_INTENT_PRESETS -->
            </select>
          </div>
          <div id="presetDescription" class="border border-gray-200 rounded-lg p-4 bg-gray-50">
            <div id="presetDescriptionContent">
              <h4 class="font-medium text-gray-900 mb-2">Linear</h4>
              <p class="text-sm text-gray-600">No curve adjustment. 1:1 input-to-output mapping for neutral, unmodified tonal reproduction.</p>
            </div>
          </div>
        </div>
        <div id="intentTab-import" class="hidden space-y-4">
          <div class="text-sm text-gray-700">
            <div class="p-3 rounded border bg-gray-50">
              <div class="font-medium">Import Target (ACV/LUT)</div>
              <div class="text-xs text-gray-600 mt-1">Import an ACV/LUT as a target tonal intent (the curve you want to aim for if not the default Linear). This does not apply a correction. To apply ACV/LUT as a correction, use Global Corrections → Load Data File.</div>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <input id="intentImportFile" type="file" accept=".acv,.cube" class="hidden">
            <button id="intentImportBtn" class="px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded font-bold" title="Treats the file as a target curve (intent). No correction is applied.">Load ACV/LUT as Target</button>
          </div>
          <div id="intentImportInfo" class="text-xs text-gray-600"></div>
          
        </div>
        <div id="intentTab-custom" class="hidden space-y-4">
          <div class="text-sm text-gray-700">Define a simple custom shape.</div>
          <div class="flex items-center gap-3">
            <label class="text-sm text-gray-700" for="customGamma">Gamma:</label>
            <input id="customGamma" type="range" min="0.6" max="1.6" step="0.01" value="1.00" class="flex-1">
            <span id="customGammaVal" class="text-xs text-gray-600 w-12 text-right">1.00</span>
          </div>
          <div class="grid grid-cols-2 gap-3">
            <div class="flex items-center gap-2">
              <label class="text-sm text-gray-700" for="customGain">Midtone gain:</label>
              <input id="customGain" type="range" min="0.30" max="0.70" step="0.01" value="0.55" class="flex-1">
              <span id="customGainVal" class="text-xs text-gray-600 w-10 text-right">0.55</span>
            </div>
            <div class="flex items-center gap-2">
              <label class="text-sm text-gray-700" for="customShoulder">Shoulder:</label>
              <input id="customShoulder" type="range" min="0.00" max="0.60" step="0.01" value="0.35" class="flex-1">
              <span id="customShoulderVal" class="text-xs text-gray-600 w-10 text-right">0.35</span>
            </div>
          </div>
        </div>
        <div id="intentTab-paste" class="hidden space-y-3">
          <div class="text-sm text-gray-700">
            Supported formats:
            <ul class="list-disc list-inside text-xs text-gray-600 mt-1 space-y-0.5">
              <li>CSV with headers: <code>percent_input</code> + <code>density_rel</code> | <code>density_abs</code> | <code>Lstar</code></li>
              <li>Label-first CSV: <code>Matte Inkjet,20,20,12</code></li>
              <li>Pipe k/v: <code>Matte Inkjet | Input=20 Linear=20 Intent=12</code></li>
              <li>CGATS-like: <code>BEGIN_DATA_FORMAT ... BEGIN_DATA ... END_DATA</code> (uses <code>INPUT</code>/<code>INTENT</code>)</li>
              <li>JSON: <code>points[]</code>, <code>generator</code> (gamma/filmic), or <code>{ Media, Curve:[{Input, Intent}] }</code></li>
              <li>Whitespace table: rows like <code>0 0 0</code>, <code>20 20 12</code></li>
              <li>1D list (even spacing): one value per line, optional label as first line</li>
            </ul>
          </div>
          <div id="intentPasteNote" class="text-sm bg-gray-50 text-gray-700 border border-gray-200 rounded p-2">
            Note: pasted intent data is applied over a fixed 0–100% input scale. Black and white points (0% and 100%) do not move. To change endpoints, adjust ink limits/end values rather than the contrast intent.
          </div>
          <textarea id="intentPasteArea" class="w-full h-40 border border-gray-300 rounded p-2 text-sm" placeholder="Enter or paste data..."></textarea>
          <div class="flex items-center gap-3">
            <div id="intentPasteValidation" class="text-sm hidden flex-1"></div>
            <button id="intentParseBtn" class="px-3 py-2 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold whitespace-nowrap">Parse</button>
          </div>
        </div>
      </div>
      <div class="p-5 pt-3 flex-shrink-0 border-t border-gray-200">
        <div class="flex justify-end gap-3">
          <button id="resetIntentBtn" class="px-4 py-2 text-gray-600 hover:text-gray-800 bg-gray-100 hover:bg-gray-200 rounded font-bold">Reset to Linear</button>
          <button id="cancelIntentBtn" class="px-4 py-2 text-gray-600 hover:text-gray-800 bg-gray-100 hover:bg-gray-200 rounded font-bold">Cancel</button>
          <button id="applyIntentBtn" class="px-4 py-2 bg-slate-600 hover:bg-slate-700 text-white rounded">Apply Intent</button>
        </div>
      </div>
    </div>
  </div>
  <!-- Manual L* Entry Modal -->
  <div id="lstarModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
    <div class="bg-white rounded-lg max-w-3xl w-full mx-4 max-h-[90vh] flex flex-col">
      <!-- Fixed Header -->
      <div class="p-6 pb-4 flex-shrink-0">
        <div class="flex justify-between items-center mb-2">
          <h3 class="text-lg font-semibold">Manual Luminosity (L*) Entry</h3>
          <button id="closeLstarModal" class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
        </div>
        <div class="hidden text-xs italic text-gray-700 mb-3 p-2 px-3 bg-gray-50 border border-gray-200 rounded">The L* component of the Lab color system represents perceived lightness, ranging from 0 (black) to 100 (white). Equal steps in L* correspond approximately to equal perceptual differences in light–dark appearance.</div>
        
        <div class="hidden mb-4 text-sm text-gray-600">
          <ul class="list-disc list-inside space-y-1">
            <li>Measure and enter L* values for each patch (e.g., using a device like the Color Muse 2).</li>
            <li>If your chart uses even steps (0, 5, 10 … 100%), leave <span class="font-medium">Patch %</span> as‑is.</li>
            <li>Edit <span class="font-medium">Patch %</span> for irregular spacing (more steps in the highlights / shadows).</li>
            <li>Target result is linear (L* 100 → 0) and linked to Patch %.</li>
            <li>Inspired by & compatible with data from the <a href="https://clayharmonblog.com/wedgie.html" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">Wedgie tool</a> by Clay Harmon.</li>
            <li>A good resource for target images is <a href="https://clayharmonblog.com/downloads" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">clayharmonblog.com/downloads</a>.</li>
          </ul>
          
        </div>

        <div class="hidden flex items-center justify-center gap-6 mb-4 p-3 bg-gray-50 rounded border">
          <div class="flex gap-2">
            <button id="addLstarInputHeader" class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded font-bold">+ Add</button>
            <button id="removeLstarInputHeader" class="px-3 py-1 text-sm bg-red-100 hover:bg-red-200 text-red-700 rounded font-bold">- Remove</button>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600">Patches:</label>
            <input type="number" id="lstarCountInputHeader" min="5" max="50" value="5" class="w-16 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500">
          </div>
        </div>
      </div>

      <!-- Scrollable Content -->
      <div class="flex-1 overflow-y-auto overflow-x-auto px-6">
        <div class="text-xs italic text-gray-700 mb-3 p-2 px-3 bg-gray-50 border border-gray-200 rounded">The L* component of the Lab color system represents perceived lightness, ranging from 0 (black) to 100 (white). Equal steps in L* correspond approximately to equal perceptual differences in light–dark appearance.</div>

        <div class="mb-4 text-sm text-gray-600">
          <ul class="list-disc list-inside space-y-1">
            <li>Measure and enter L* values for each patch (e.g., using a device like the Color Muse 2).</li>
            <li>If your chart uses even steps (0, 5, 10 … 100%), leave <span class=\"font-medium\">Patch %</span> as‑is.</li>
            <li>Edit <span class=\"font-medium\">Patch %</span> for irregular spacing (more steps in the highlights / shadows).</li>
            <li>Target result is linear (L* 100 → 0) and linked to Patch %.</li>
            <li>Inspired by & compatible with data from the <a href=\"https://clayharmonblog.com/wedgie.html\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"text-green-700 underline\">Wedgie tool</a> by Clay Harmon.</li>
            <li>A good resource for target images is <a href=\"https://clayharmonblog.com/downloads\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"text-green-700 underline\">clayharmonblog.com/downloads</a>.</li>
          </ul>
        </div>

        <div class="flex items-center justify-center gap-6 mb-4 p-3 bg-gray-50 rounded border">
          <div class="flex gap-2">
            <button id="addLstarInput" class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded font-bold">+ Add</button>
            <button id="removeLstarInput" class="px-3 py-1 text-sm bg-red-100 hover:bg-red-200 text-red-700 rounded font-bold">- Remove</button>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600">Patches:</label>
            <input type="number" id="lstarCountInput" min="5" max="50" value="5" class="w-16 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500">
          </div>
        </div>
        <table class="w-auto mx-auto text-sm border border-gray-200 rounded overflow-hidden">
          <thead class="bg-gray-50 sticky top-0 z-10">
            <tr>
              <th class="px-2 py-2 w-8 text-center">#</th>
              <th class="px-2 py-2 w-24 text-center">Patch %</th>
              <th class="px-2 py-2 w-24 text-center">Target / Measured</th>
              <th class="px-2 py-2 w-24 text-center">L* (0–100)</th>
            </tr>
          </thead>
          <tbody id="lstarInputs" class="align-middle">
            <!-- Dynamic rows will be added here -->
          </tbody>
        </table>
        <div id="lstarValidation" class="text-sm text-red-600 mt-3 hidden"></div>
      </div>

      <!-- Fixed Footer -->
      <div class="p-6 pt-4 flex-shrink-0 border-t border-gray-200">
        <div class="flex justify-end gap-3">
          <button id="saveLstarTxt" class="px-4 py-2 bg-slate-600 hover:bg-slate-700 text-white rounded" title="Download entered Patch % and L* as a .txt file">Save as .txt</button>
          <button id="cancelLstar" class="px-4 py-2 text-gray-600 hover:text-gray-800 bg-gray-100 hover:bg-gray-200 rounded font-bold">Cancel</button>
          <button id="generateFromLstar" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded">Generate Correction</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Popup -->
  <div id="helpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
      <button id="closeHelpBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" aria-label="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
      <div class="flex items-center gap-3 mb-2">
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 160 160" role="img">
          <path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round"/>
          <rect x="20" y="90" width="20" height="40" rx="6" ry="6" fill="#00B5E2"/>
          <rect x="52" y="70" width="20" height="60" rx="6" ry="6" fill="#FF2A8A"/>
          <rect x="84" y="50" width="20" height="80" rx="6" ry="6" fill="#FFD400"/>
          <rect x="116" y="22" width="20" height="110" rx="6" ry="6" fill="#1A1A1A"/>
          <path d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18" fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="30" cy="88" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
          <circle cx="62" cy="68" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
          <circle cx="94" cy="48" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
          <circle cx="126" cy="18" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
        </svg>
        <h2 class="text-xl font-bold">quadGEN <span id="helpAppVersion" class="text-gray-400 text-base"></span></h2>
      </div>
      <div id="helpTabs" class="mb-2 border-b border-gray-200 flex items-center gap-2">
        <button id="helpTabReadme" class="px-3 py-1 text-sm font-bold text-gray-800 border-b-2 border-slate-700">ReadMe</button>
        <button id="helpTabGlossary" class="px-3 py-1 text-sm font-bold text-gray-500 hover:text-gray-700 border-b-2 border-transparent">Glossary</button>
        <button id="helpTabWorkflow" class="px-3 py-1 text-sm font-bold text-gray-500 hover:text-gray-700 border-b-2 border-transparent">Detailed Workflow</button>
        <button id="helpTabHistory" class="px-3 py-1 text-sm font-bold text-gray-500 hover:text-gray-700 border-b-2 border-transparent ml-auto">Version History</button>
      </div>
      <div id="helpContent" class="text-sm text-gray-700 space-y-4 max-h-[70vh] overflow-y-auto"></div>
    </div>
  </div>

  <!-- Global Correction Help Popup -->
  <div id="globalCorrectionHelpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
      <button id="closeGlobalCorrectionHelpBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" aria-label="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
      <h2 class="text-xl font-bold mb-4">Global Correction Help</h2>
      <div class="text-sm text-gray-700 space-y-6 max-h-[70vh] overflow-y-auto">
        <div>
          <p class="font-medium text-lg mb-2">Overview</p>
          <p class="text-sm text-gray-600">Global corrections can be applied in two ways: directly via a curve/LUT file, or by computing a linearization from L* measurements. Both approaches update all channels uniformly.</p>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Working Assumptions</p>
          <ul class="list-disc list-inside text-sm text-gray-600">
            <li>Positive space: X=0% is white → X=100% is black; Y=0% = no ink (white), Y=100% = max ink (black).</li>
            <li>Endpoints anchored: Keep 0→0 and 100→100 fixed unless you have a specific reason to change them.</li>
            <li>Monotonic, smooth curves: Avoid kinks or flat spots, especially near endpoints.</li>
            <li>Digital negatives: Work in positive space; invert your image in the editor when making a digital negative.</li>
          </ul>
        </div>
        <div>
          <p class="text-xs text-gray-700 font-semibold">Applies Directly →</p>
          <ul class="list-disc list-inside text-xs text-gray-600 mb-1">
            <li>Photoshop Curves (.acv): Curve presets.</li>
            <li>LUT (.cube): 1D or 3D LUT.</li>
          </ul>
        </div>
        <div>
          <p class="text-xs text-gray-700 font-semibold">Calculates Linearization ↕</p>
          <ul class="list-disc list-inside text-xs text-gray-600 mb-1">
            <li>LAB Data (.txt): L* measurements.</li>
            <li>Manual L* Entry: L* measurements.</li>
          </ul>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Tonal Zones</p>
          <ul class="list-disc list-inside text-sm text-gray-600">
            <li><span class="font-medium">Highlights</span>: 0–25% (X)</li>
            <li><span class="font-medium">Midtones</span>: 25–75% (X)</li>
            <li><span class="font-medium">Shadows</span>: 75–100% (X)</li>
          </ul>
          <div class="text-xs text-gray-600 mt-2">Examples: Lighten shadows → reduce output in 75–95% and taper to 0 change by 100%. Lighten highlights → reduce output in 5–25% and taper to 0 by 0%.</div>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Workflow Summary</p>
          <ol class="list-decimal list-inside space-y-1 ml-2 text-sm">
            <li>Choose your printer and set ink limits for each channel.</li>
            <li>Export a test .quad and print a 0–100% step wedge.</li>
            <li>Measure the positive result (inkjet print or alt‑process print).</li>
            <li>Load data into quadGEN: LAB (.txt), EDN LUT (.cube/.acv), or Manual L*.</li>
            <li>Review the graph and adjust channel limits if needed.</li>
            <li>Export the corrected .quad and reprint to verify.</li>
          </ol>
          <div class="text-xs text-gray-600 ml-2 mt-2">Tip for digital negatives: work in positive space, then invert your image in your editor before printing the negative.</div>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Auto endpoint rolloff</p>
          <p class="text-sm text-gray-600 mb-1">When a non-linear intent + correction pushes the curve against the ink limit early, the last steps can “flat-top” (no separation). Use the Auto limits checkboxes to apply a smooth shoulder (black) or toe (white) so the curve reaches the limit exactly at the endpoint with slope 0.</p>
          <ul class="list-disc list-inside text-sm text-gray-600">
            <li><span class="font-medium">Black limit (right)</span>: adds a soft shoulder when the curve plateaus near the max ink (End); preserves separation from ~knee→100%.</li>
            <li><span class="font-medium">White limit (left)</span>: adds a soft toe if the curve bunches near 0; preserves separation from 0→~knee.</li>
            <li><span class="font-medium">Scope</span>: local only — midtones are unchanged; applied after intent + corrections.</li>
            <li><span class="font-medium">Defaults</span>: Black limit ON, white limit OFF; 3% proximity threshold, C1-continuous, monotone knees that re-detect automatically on file/intent/limit changes.</li>
            <li><span class="font-medium">Edit Mode</span>: Recompute bakes any visible knees into Smart points (undoable). Disable a checkbox to export without that rolloff.</li>
          </ul>
          <div class="text-xs text-gray-600 mt-2">Debug notes: With <code>DEBUG_LOGS = true</code>, the console prints detected knee indices and before/after samples; dashed blue (black) / red (white) markers show knee positions on the chart while the respective Auto limit is on.</div>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Sample Data</p>
          <div class="flex gap-2">
            <div class="flex-1">
              <button id="helpLoadSampleLab" class="w-full px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded transition-colors font-bold">Load LAB-Data-sample.txt</button>
              <a id="helpDownloadSampleLab" href="#" class="block text-center text-xs text-blue-600 hover:text-blue-800 mt-1">↓ Download LAB-Data-sample.txt</a>
            </div>
            <div class="flex-1">
              <button id="helpLoadSampleCube" class="w-full px-2 py-1 text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 rounded transition-colors font-bold">Load Sample LUT.cube</button>
              <a id="helpDownloadSampleCube" href="#" class="block text-center text-xs text-purple-600 hover:text-purple-800 mt-1">↓ Download LUT_sample.cube</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Intent Help Popup (Correction vs Intent) -->
  <div id="intentHelpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
      <button id="closeIntentHelpBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" aria-label="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
      <h2 class="text-xl font-bold mb-4">Global Correction & Intent</h2>
      <div id="intentHelpContent" class="text-sm text-gray-700 space-y-6 max-h-[70vh] overflow-y-auto"></div>
    </div>
  </div>

  <!-- Edit Mode Help Popup -->
  <div id="editModeHelpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
      <button id="closeEditModeHelpBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" aria-label="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
      <h2 class="text-xl font-bold mb-4">Edit Mode Help</h2>
      <div class="text-sm text-gray-700 space-y-4 max-h-[70vh] overflow-y-auto">
        <div>
          <p class="font-medium">Overview</p>
          <p class="text-sm text-gray-600">Edit Mode enables point-by-point curve editing on the selected channel. Your data is converted into Smart curves to allow edits. Other enabled channels dim for focus. Turn Edit Mode off to prevent accidental edits.</p>
          <p class="text-sm text-gray-600 mt-2">If at any time you want to revert to the original data instead of the generated Smart curves, you can use the "Revert" buttons.</p>
        </div>
        <div>
          <p class="font-medium">Calculate points</p>
          <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
            <li><strong>Max error %</strong>: Controls how closely the curve fits when generating points (lower = more points, tighter fit).</li>
            <li><strong>Max points</strong>: Limits the maximum number of points generated (2-21).</li>
            <li><strong>Recompute</strong>: Regenerates Smart curve points from the current curve using the Max error % and Max points settings.</li>
          </ul>
        </div>
        <div>
          <p class="font-medium">Point editing</p>
          <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
            <li>Selected channel draws on top; others dim to 50%.</li>
            <li>Only the selected channel shows key‑point markers and numbered labels.</li>
            <li>Click the chart to insert a point at the curve under the cursor X.</li>
            <li>Type "X,Y" in the field and press Enter to move the selected point (0–100).</li>
            <li>Use ◀ ▶ to change the selected point; use △ ▽ ◁ ▷ or nudgers to adjust position.</li>
            <li>Undo/Redo supports all edit actions.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Embedded README fallback for Help popup (used if fetch fails) -->
  <script type="text/markdown" id="embeddedReadme">
## 1. Overview  
quadGEN is a free, browser‑based tool for generating and refining `.quad` files used with QuadToneRIP. It supports Smart Curves (formerly “AI curves”), LAB/LUT/ACV inputs, and an Edit Mode for precise, point‑based curve edits. Core features work fully offline; the optional AI assistant requires network access.  

quadGEN is designed for photographers, printmakers, and alt‑process practitioners who create digital negatives or monochrome prints and need reliable tonal calibration.  

### What is QuadToneRIP?  
QuadToneRIP (QTR) is a specialized RIP/driver for Epson printers focused on high‑quality monochrome printing using multi‑shade ink sets. QTR uses `.quad` files to determine how much ink each printer channel lays down at every input level. A `.quad` file contains 256‑sample curves (0–100% input) for each channel supported by the printer (e.g., K, C, M, Y, LC, LM, LK, LLK, OR, GR, etc.). When you select a `.quad` in your QTR workflow (often via Print‑Tool on macOS), QTR reads these curves and applies the specified per‑channel ink outputs to render your print. quadGEN’s role is to help you build and refine those `.quad` curves so QTR can produce linear, predictable output.

—

## 2. Installation and Access  
- Online: open `quadgen.html` in a modern browser (Chrome, Firefox, Safari).  
- Offline: download `quadgen.html` and open it locally (no install required).  
- Platforms: macOS, Windows, Linux (desktop recommended).  
- Network note: the AI assistant features require internet; all manual editing and exports do not.  

—

## 3. Quick Start (Beta 2.3)  
1) Choose your printer and set ink limits (per channel).
2) Start with Linear Ramp, or  
3) Load data: `.quad` (inspect/correct), LAB `.txt`, LUT `.cube` (1D/3D), Photoshop `.acv`, or enter Manual L*.  
4) Export the corrected `.quad`, print a step wedge target.
5) Measure print and load data, repeat if necessary.  

—

## 4. Features (highlights)  
- Supports most Epson printers.
- Quickly export linear ramps with any single ink channel or combination of channels
- Inputs: `.quad`, LAB `.txt`, LUT `.cube` (1D/3D), `.acv`, and manually entered L* values.
- Support for evenly spaced or irregularly spaced targets.
- Edit Mode: edit the graph data anytime. 
- Undo/Redo: full history for insert/adjust/delete/recompute and Edit Mode toggles.   
- Recompute key points: simplify/extract Smart key points from a loaded `.quad` with tolerance and max‑point controls.  
- Lab Tech: AI-linked assistant that can answer questions or perform actions.

—

## 5. Usage Examples  
- Digital negatives: calibrate for cyanotype, Pt/Pd, kallitype, polymer photogravure.  
- Inkjet linearization: refine monochrome response for QTR printing.  
- Curve editing: Enter Edit Mode, nudge the selected ordinal, and export.  
- Conversion: load LAB/LUT/ACV, export .quad to integrate corrections.  

—

## 6. Best Practices  
- If your process requires a negative, invert it in Photoshop or similar too before printing with your .quad
- Measure the final positive print (not the negative).  
- Keep endpoints anchored and curves monotonic for stable results.  
- Use the ink limit to set where you get your best black (or white) 
- Make incremental edits; use Undo/Redo to explore safely.  

—

## 7. Troubleshooting & FAQ  
- Offline use: the Lab Tech assistant is unavailable offline; manual edits and exports still work.  
- Looks different than Photoshop or other curve tools: quadGEN plots printer‑space input % (X) vs ink output % (Y) with 0% = white (no ink) at the origin. Many curve tools plot image tone with 0,0 = black, so the visual orientation differs. Compare shapes rather than absolute orientation when cross‑checking.  
- Graph response expectations: with X = input level % and Y = ink output %, upward corrections add ink (darker output) and downward corrections reduce ink (lighter output). Example: If midtones are too light, expect the correction to rise in the mid‑range; if shadows are too dark, expect a downward adjustment in the shadow region.  

—

## 8. Contributing / Feedback  
- For feedback or questions contact David Marsh - marshmonkey@gmail.com  

—

## 9. External References  

- Easy Digital Negatives (EDN): framework for building correction LUTs used with digital negatives.
  - How to use with quadGEN: export your EDN correction as a `.cube` LUT and load it via “Load LUT (.cube)” (global or per‑channel). quadGEN applies the LUT in positive space and plots the result. If further refinement is needed, convert to editable Smart key points, make changes in Edit Mode, then export a corrected `.quad`.
  - Link: http://www.easydigitalnegatives.com/

- QuadToneRIP (QTR): RIP used for monochrome inkjet printing and applying `.quad` curves.
  - How to use with quadGEN: after exporting a `.quad` from quadGEN, install it in QTR’s quad folder for your printer, then select it when printing. Use QTR to print step wedges/targets that you later measure and feed back into quadGEN for iteration.
  - Link: https://www.quadtonerip.com/

- Print‑Tool (on the QuadToneRIP site): utility for printing images/targets through QTR on macOS with proper color‑management handling.
  - How to use with quadGEN: print your step wedge/target through Print‑Tool with the chosen `.quad` to generate measurement prints for calibration. Ensure color management is off and that you select the intended `.quad`.
  - Link: https://www.quadtonerip.com/html/QTRprinttool.html

- Color Muse 2: handheld colorimeter used to capture LAB measurements from printed wedges/targets.
  - How to use with quadGEN: measure your printed wedge and export LAB data as `.txt`. In quadGEN, choose “Load LAB (.txt)” to import. The expected format is a GRAY column (0–100) and LAB L*,A*,B* columns. Tip: quadGEN can generate a `LAB-Data.txt` template with the correct header for Color Muse workflows. Most accurate consumer-level way to measure for calibration.
  - Link: https://amzn.to/45R8rof (affiliate link)

- Clay Harmon’s target file: 21-step target for calibration.
  - How to use with quadGEN: print the target via with Print‑Tool using your current `.quad`. Measure the print (e.g., with Color Muse 2) and import the LAB `.txt` into quadGEN. Export the corrected `.quad`, then reprint and iterate until linear.
  - Link: https://clayharmonblog.com/downloads/25-step-ColorMuse-target.zip
  </script>

  <script>
    // Application version - update in one place
    const APP_VERSION = 'Beta 2.5.1';
    // Dark mode feature flag
    const ENABLE_DARK_MODE = true;
    // Global debug logging toggle for non-AI logs
    var DEBUG_LOGS = false;
    // AI provider selection (code-level switch, no UI): 'anthropic' or 'openai'
    const AI_PROVIDER = 'anthropic';
    const WORKER_URL = 'https://sparkling-shape-8b5a.marshmonkey.workers.dev';
    const ANTHROPIC_MODEL = 'claude-sonnet-4-0';
    // Set OPENAI_MODEL to 'gpt-5' if you have access; 'gpt-4o' is a safe default
    const OPENAI_MODEL = 'gpt-5-mini';
    // Debug flag for AI logs
    const DEBUG_AI = false;
    // Temporary alias during terminology transition (AI → Smart)
    const DEBUG_SMART = DEBUG_AI;

    const INTENT_TUNING_STORAGE_KEY = 'quadgen.debugIntentTuning';
    function storeIntentTuningFlag(flag) {
      try {
        if (flag) localStorage.setItem(INTENT_TUNING_STORAGE_KEY, '1');
        else localStorage.removeItem(INTENT_TUNING_STORAGE_KEY);
      } catch {}
    }
    function loadIntentTuningFlag() {
      try { return localStorage.getItem(INTENT_TUNING_STORAGE_KEY) === '1'; }
      catch { return false; }
    }
    const DEBUG_INTENT_TUNING = (() => {
      if (typeof window !== 'undefined' && typeof window.DEBUG_INTENT_TUNING === 'boolean') {
        storeIntentTuningFlag(window.DEBUG_INTENT_TUNING);
        return window.DEBUG_INTENT_TUNING;
      }
      return loadIntentTuningFlag();
    })();
    if (typeof window !== 'undefined') {
      window.DEBUG_INTENT_TUNING = DEBUG_INTENT_TUNING;
      window.setIntentTuningDebug = function(flag) {
        storeIntentTuningFlag(!!flag);
        window.DEBUG_INTENT_TUNING = !!flag;
        window.location.reload();
      };
    }

    const LAB_TUNING = {
      overrides: null,
      setOverrides(overrides) {
        if (overrides && typeof overrides === 'object') {
          const sanitized = {};
          const neighbor = Number(overrides.K_NEIGHBORS);
          if (Number.isFinite(neighbor) && neighbor > 0) sanitized.K_NEIGHBORS = Math.max(1, Math.round(neighbor));
          const sigmaFloor = Number(overrides.SIGMA_FLOOR);
          if (Number.isFinite(sigmaFloor) && sigmaFloor > 0) sanitized.SIGMA_FLOOR = sigmaFloor;
          const sigmaCeil = Number(overrides.SIGMA_CEIL);
          if (Number.isFinite(sigmaCeil) && sigmaCeil > 0) sanitized.SIGMA_CEIL = sigmaCeil;
          const sigmaAlpha = Number(overrides.SIGMA_ALPHA);
          if (Number.isFinite(sigmaAlpha) && sigmaAlpha > 0) sanitized.SIGMA_ALPHA = sigmaAlpha;
          this.overrides = Object.keys(sanitized).length ? sanitized : null;
        } else {
          this.overrides = null;
        }
      },
      get(key, fallback) {
        const value = this.overrides && this.overrides[key];
        if (Number.isFinite(value)) return value;
        return fallback;
      },
      exportOverrides() {
        return this.overrides ? { ...this.overrides } : null;
      }
    };
    LAB_TUNING.setOverrides({ K_NEIGHBORS: 2, SIGMA_FLOOR: 0.036, SIGMA_CEIL: 0.15, SIGMA_ALPHA: 2.0 });



    let tuningRestoreState = null;
    // One-time guard to prevent logo animation on every chart redraw
    let LOGO_ANIMATED_ONCE = false;
    
    // Centralized version history - update in one place
    const VERSION_HISTORY = {
      'Unreleased': {
        date: '—',
        title: 'In progress',
        sections: {
          ADDED: [],
          CHANGED: [],
          FIXED: [],
          REMOVED: [],
          DOCS: []
        },
        aboutDialog: []
      },
      'v2.5.1': {
        date: '2025-09-18',
        title: 'Zoom presets + curve stability',
        sections: {
          ADDED: [
            'Chart zoom controls (+/−) rescale the ink plot, persist per browser, and expose Lab Tech commands (`set_chart_zoom`, `nudge_chart_zoom`).',
            'Tests/chart_zoom.spec.js exercises the zoom helpers (percent↔Y mapping, persistence, button guards).',
            'Lab Tech understands simple “zoom in” / “zoom out” phrasing and routes it to the controls.'
          ],
          CHANGED: [
            'Zoom now steps through clean 10% increments and clamps to the highest active ink limit so 100% curves stay visible.',
            'Graph grids, axes, overlays, and tooltips all derive from the active zoom so the Y-axis always matches what you see.'
          ],
          FIXED: [
            'Undo/redo of Smart key-point edits keeps the rest of the curve stable; only the edited point moves when you step backward or forward.',
            '“+” now magnifies (lower max) and “−” zooms out, matching expectations.'
          ],
          REMOVED: [],
          DOCS: [
            'Help → ReadMe & Detailed Workflow, QUADGEN_README.md, and AGENTS.md document the zoom workflow and automation hooks.'
          ]
        },
        aboutDialog: [
          { label: 'Zoom Presets', desc: 'Use the +/− control (or Lab Tech commands) to step through 10% zoom levels without ever cropping active ink limits.' },
          { label: 'Stable Undo', desc: 'Smart key-point undo/redo keeps the rest of your curve anchored so only the edited point moves.' }
        ]
      },
      'v2.5.0': {
        date: '2025-09-17',
        title: 'Intent remap automation + button polish',
        sections: {
          ADDED: [
            'Apply Intent now bakes the selected preset into the loaded .quad even when no LAB/manual data is active—ideal for branching variants from a master linear profile.',
            'Lab Tech assistant can call apply_intent_to_loaded_quad() to bake the current preset without manual clicks.'
          ],
          CHANGED: [],
          FIXED: [],
          REMOVED: [],
          DOCS: []
        },
        aboutDialog: [
          { label: 'Added', desc: 'Apply Intent to bake contrast intents into your loaded .quad—even without LAB data.' },
          { label: 'Lab Tech Automation', desc: 'Lab Tech can invoke apply_intent_to_loaded_quad() to bake the current preset on command.' }
        ]
      },
      'v2.4.0': {
        date: '2025-09-16',
        title: 'Centralized printer-space pipeline + POPS smoothing defaults',
        sections: {
          ADDED: [
            'Printer-space sanity fixtures with FEATURE_EXPECTATIONS guide so you can spot curve regressions quickly.',
            'Node scripts cover DataSpace conversions, make256 helpers, and automated intent sweeps; history flow spec stubbed for headless undo/redo.',
            'Debug-only Intent Tuning panel (enable DEBUG_INTENT_TUNING) to audition smoothing and LAB overrides inside quadGEN.',
            '“Apply to Loaded Curve” button lets you bake the active intent into a loaded .quad without re-running LAB corrections.'
          ],
          CHANGED: [
            'Measurement rebuild now defaults to POPS-style smoothing (PCHIP with 30% primary + 1×30% post) and LAB bandwidth overrides (K=2, σ_floor=0.036, σ_ceil=0.15, σ_alpha=2.0).',
            'DataSpace now owns every image→printer conversion; loaders tag missing sourceSpace metadata and make256 helpers were split out for clarity.',
            'Undo/redo shares a single timeline so intent swaps, channel edits, and history snapshots stay in sync.',
            'Debug tuning panel drops the experimental intent blend slider to focus on smoothing/LAB controls, and automated intent tolerance is now 8% to match the new defaults.',
            'Cached per-channel row lookups trim DOM thrash during LAB updates and history playback.',
            'Intent dropdown previews the selected curve on the chart before you bake it into a .quad.'
          ],
          FIXED: [
            'Undo now clears per-channel measurement switches alongside loaded data.',
            'Legacy printer-space datasets without explicit sourceSpace metadata no longer get flipped on reload.',
            'Undo/redo preserves the LAB / Manual L* smoothing hook so scripted smoothing continues to work.',
            'Contrast intent status banner reports the active preset instead of always showing Linear.',
            'Intent remap honours existing ink limits, reverting to Linear restores the original .quad curve, and undo/redo preserves that exact shape.'
          ],
          REMOVED: [],
          DOCS: [
            'Updated QUADGEN_DATA_TYPES.md, QUADGEN_DEVELOPMENT.md, QUADGEN_AI_INTEGRATION.md, and AGENTS.md with sourceSpace guidance and regression workflows.'
          ]
        },
        aboutDialog: [
          { label: 'Printer-space Pipeline', desc: 'DataSpace now owns every conversion and the new fixtures/tests catch double-flip regressions early.' },
          { label: 'POPS Smoothing Defaults', desc: '30% primary + 30% post smoothing with LAB bandwidth overrides keep LAB rebuilds print-ready out of the box.' },
          { label: 'Intent Remap', desc: 'Use Apply to Loaded Curve to bake the selected intent into a linearized .quad—no external LUT required. Intent previews now render as soon as you pick a preset.' }
        ]
      },
      'v2.3.0': {
        date: '2025-09-16',
        title: 'Auto endpoint rolloff (white/black) + UX',
        sections: {
          ADDED: [
            'Auto endpoint rolloff now has independent white/black limit toggles so you can knee only the side that needs protection.',
            'Glossary: added Auto white limit, Auto black limit, and Endpoint rolloff entries.',
            'Chart markers: dashed red/blue lines indicate detected knee start/end while the respective Auto limit is on.',
            'Lab Tech assistant: new set_auto_white_limit / set_auto_black_limit commands to toggle Auto endpoint rolloff from chat.'
          ],
          CHANGED: [
            'Threshold: proximity epsilon increased to 3% of End for clearer shoulders on long plateaus.',
            'Auto endpoint rolloff now exposes independent white/black limit checkboxes (defaults: white OFF, black ON) with persisted preferences and per-side baking guards.',
            '.quad generation and channel controls now use the full 0–65,535 16-bit scale instead of 0–64,000; UI ranges and validation updated accordingly so ink limits align with QuadToneRIP conventions.',
            'Chart background: Enhanced visual structure with subtle accent lines - darker 50% crossover grid lines and boundary lines from 100,0→100,100 and 0,100→100,100 to improve coordinate reference.'
          ]
        },
        aboutDialog: [
          { label: 'Auto Rolloff Controls', desc: 'Independent white/black knees with 3% proximity threshold keep endpoints smooth without flattening the curve.' },
          { label: 'Lab Tech Integration', desc: 'New chat commands toggle Auto white/black limits directly from the assistant.' },
          { label: 'Ink Limit Alignment', desc: 'Full 0–65,535 scaling and dashed knee markers keep the UI aligned with QuadToneRIP expectations.' }
        ]
      },
      'v2.2.3': {
        date: '2025-09-15',
        title: 'Intent system fixes + Documentation improvements',
        sections: {
          ADDED: [
            'Help glossary entries for "Image space" and "Printer space": Added comprehensive definitions explaining the coordinate system differences that are central to quadGEN\'s data transformation pipeline. Image space (0=black pixel, 100=white pixel) vs printer space (0=white/no ink, 100=black/maximum ink) with explicit (0,0) and (100,100) coordinate meanings for both systems.',
            'PoPS (Prints on Paper Studio) glossary entry: Added definition with link to their website and note about contrast intent presets included in quadGEN.',
            'MIT License: Added complete license text to Help ReadMe section with proper attribution and scope clarification.',
            'Prints on Paper Studio attribution: Added formal attribution in Help ReadMe Credits section for contrast intent definitions used with permission under GNU Public License.'
          ],
          CHANGED: [
            'Contrast intent system architecture: Centralized all preset definitions (Linear, Soft, Hard, Filmic) into single source object. Removed sliders from Preset tab in favor of descriptive text. Preset dropdowns now populate dynamically from central definitions, making preset management more maintainable.'
          ],
          FIXED: [
            'Intent system image-to-printer space conversion: Fixed critical issue where custom pasted intent data wasn\'t being transformed consistently with preset intents. All intent types now use the same image-to-printer space transformation pipeline (horizontal flip + vertical inversion) as ACV/LUT files, ensuring consistent behavior across preset and custom intents.',
            'Custom intent data parsing for 0-255 range: Fixed parsing failure when pasting intent data with 0-255 range values (common in image editing workflows). Parser now auto-detects range (0-100 vs 0-255) and normalizes appropriately, preventing data truncation and visualization artifacts.',
            'LAB linearization with custom intents: Resolved issue where LAB linearization would revert to linear when custom intent data was applied, caused by NaN values in the correction algorithm due to improper intent data transformation.',
            'Auto-detection for mixed-range data: Added consistent range detection logic to parseIntentPaste(), parseLabData(), parseManualLstarData(), and buildManualLinearizationFromOriginal() functions. Input values auto-detect 0-100 vs 0-255 ranges while maintaining CIE LAB standard (L* values always 0-100).'
          ]
        },
        aboutDialog: [
          { label: 'Intent System Overhaul', desc: 'Fixed critical image-to-printer space conversion issues, 0-255 range parsing, and LAB linearization compatibility with custom intents.' },
          { label: 'Enhanced Documentation', desc: 'Added comprehensive glossary entries for coordinate systems, PoPS attribution, and complete MIT license in Help section.' },
          { label: 'Data Range Auto-Detection', desc: 'Improved parsing across multiple functions to handle both 0-100 and 0-255 input ranges automatically.' },
          { label: 'Architecture Improvements', desc: 'Centralized intent preset definitions and improved preset management workflow.' }
        ]
      },
      'v2.2.2': {
        date: '2025-09-15',
        title: 'UI refinements + Intent behavior improvements',
        sections: {
          CHANGED: [
            'Edit Mode panel layout: Consolidated Calculate points controls onto single row with centered field labels and aligned Recompute button. Improved Point section spacing and reduced graph container margins for tighter UI layout.',
            'Edit Mode help modal: Clarified data conversion to Smart curves, added Calculate points section explaining Max error %/Max points/Recompute functionality, and improved terminology throughout.',
            'Global Correction & Intent help modal: Added correction process overview, warning section explaining when Intent takes effect, and link to Detailed Workflow. Modal title changed from "Correction vs. Intent" to "Global Correction & Intent". Reorganized content with card-based layout for improved readability and visual hierarchy.',
            'Intent dropdown behavior: Now automatically disables when no linearization data is loaded (visual feedback with grayed appearance). Eliminates confusion about why Intent appears inactive with .quad files only.'
          ],
          FIXED: [
            'Edit Mode revert button: Fixed issue where the revert button would appear to work but continue showing "Smart Curve" status when used in Edit Mode. The button now properly clears Smart curve data and displays the original loaded .quad status without automatic restoration interference.'
          ]
        },
        aboutDialog: [
          { label: 'UI Layout Refinements', desc: 'Improved Edit Mode panel layout, Point section spacing, and graph container margins for better space utilization.' },
          { label: 'Enhanced Help Modals', desc: 'Clarified Edit Mode help with Smart curve explanation and reorganized Global Correction help with card-based layout.' },
          { label: 'Intent Dropdown Feedback', desc: 'Intent dropdown now disables and grays out when no linearization data is loaded, eliminating user confusion.' },
          { label: 'Edit Mode Revert Fix', desc: 'Fixed revert button issue that continued showing "Smart Curve" status after reverting in Edit Mode.' }
        ]
      },
      'v2.2.1': {
        date: '2025-09-14',
        title: 'ACV/LUT orientation parity + Undo pairing fixes',
        sections: {
          ADDED: [
            'Custom Intent: new Import Target (ACV/LUT) tab — load .acv/.cube as a target intent (not a correction), with endpoint anchoring, monotonic enforcement, and optional blend with current target.'
          ],
          FIXED: [
            'ACV/LUT orientation centralized in parsers (flip + invert once); removed duplicate reverse+invert in loaders — Photoshop “lighten” now shows less ink (down hump).',
            'Undo pairing for load actions now uses the most recent matching “Before:” state — undoing multiple global loads steps back to the immediately previous correction.'
          ],
          CHANGED: []
        },
        aboutDialog: [
          { label: 'Import Target (ACV/LUT)', desc: 'New Custom Intent tab to load .acv/.cube as a target intent; includes anchor/monotonic options and blend with current.' },
          { label: 'Orientation Parity', desc: 'ACV and LUT imports apply flip+invert once in the parser; loaders no longer reapply.' },
          { label: 'Undo Pairing', desc: 'Undo of consecutive loads returns to the previous correction, not an empty state.' }
        ]
      },
      'v2.2.0': {
        date: '2025-09-13',
        title: 'Local-σ LAB reconstruction, Manual L* parity, console clarity',
        sections: {
          FIXED: [
            'Manual L* and LAB status lines clarified: Δ vs linear now labels positions as % input; removed duplicate method note',
            'Preview update ReferenceError fixed in LAB smoothing provider (removed stale radius reference)'
          ],
          CHANGED: [
            'LAB/Manual L* mapping now uses CIE luminance → density (−log10(Y)) with Dmax normalization (replaces min/max L* normalization); improves shadow convergence; existing .quad files unaffected',
            'LAB reconstruction now uses Gaussian-weighted regression with a local adaptive bandwidth based on median neighbor spacing (robust to uneven spacing and dense datasets)',
            'Manual L* now uses the same CIE density + local-σ Gaussian reconstruction as LAB (full parity)'
          ],
          ADDED: []
        },
        aboutDialog: [
          { label: 'CIE Density Mapping', desc: 'LAB/Manual L* now use CIE luminance → density (−log10(Y)) for corrections; better shadow handling, stable highlights.' },
          { label: 'Local-σ Reconstruction', desc: 'Gaussian weights now adapt to local patch spacing for smoother, robust LAB curves.' },
          { label: 'Manual L* Parity', desc: 'Manual L* uses the same reconstruction as LAB for consistent results.' },
          { label: 'Console Clarity', desc: 'Δ vs linear shows “% input”; method note appears once on load/apply.' }
        ]
      },
      'v2.1.0': {
        date: '2025-09-13',
        title: 'Edit Mode reliability, Revert fixes, channel-colored labels',
        sections: {
          FIXED: [
            'Double-scaling eliminated when toggling Edit Mode OFF→ON on Smart-sourced channels',
            'Ordinal labels no longer collapse to the X-axis when switching to a newly enabled channel',
            'Revert to measurement clears lingering Smart source tags (no linear ramp fallback)',
            'Revert preserves the selected channel in Edit Mode and redraws overlays/labels correctly'
          ],
          ADDED: [
            '.quad Preview: lightweight syntax highlighting and non-copying line numbers',
            '.quad Preview: per-line channel gutter tint with auto-contrast line numbers',
            'Revert UI: added global and per-channel Revert buttons with integrated Undo/Redo',
            'Help: new Detailed Workflow tab plus Version History moved into Help window',
            'Lab Tech console (light mode): One Light–inspired text theme with terminal-style lines',
            'Dark mode toggle: header button (🌙/☀️) to switch themes; remembers your choice and syncs with system preference'
          ],
          CHANGED: [
            'Ordinal label chips now match the exact channel ink color with automatic black/white text for contrast',
            'Edit channel selection instantly redraws overlays to reflect the selected channel',
            'Dark mode polish: improved input/scrollbar contrast, help tab selection contrast, and preview readability'
          ]
        },
        aboutDialog: [
          { label: 'Edit Reliability', desc: 'No more double-apply on Smart curves when toggling Edit Mode.' },
          { label: 'Revert UX', desc: 'Revert keeps your selected channel and restores measurement plotting.' },
          { label: 'Channel-Colored Labels', desc: 'Ordinal labels use the exact plot color for the selected channel.' },
          { label: '.quad Preview', desc: 'Syntax highlighting, line numbers, and channel-colored gutter.' },
          { label: 'Lab Tech Theme', desc: 'Polished console theme (light mode) for readability.' },
          { label: 'Dark Mode Toggle', desc: 'Added header toggle (🌙/☀️); remembers your choice and follows system preference.' }
        ]
      },
      'v2.0.5': {
        date: '2025-09-13',
        title: 'Edit toggle double-scaling fix + stability',
        sections: {
          FIXED: [
            'Edit toggle OFF→ON no longer double-applies global on Smart-sourced channels',
            'Entering Edit Mode after load no longer reverts plotted curve to a linear ramp while key points stay at prior shape',
            'Undo/Redo restore bakedGlobal meta with interpolation to keep plots/overlays aligned',
            'Revert preserves selected channel in Edit Mode and clears Smart source tags so plots/labels reflect the measurement again'
          ]
        },
        aboutDialog: [
          { label: 'Edit Toggle', desc: 'No more double application when toggling Edit Mode; Smart-sourced channels are treated as baked.' },
          { label: 'Plot Alignment', desc: 'Plot stays aligned to key points when entering Edit Mode after loading data.' },
          { label: 'Revert UX', desc: 'Revert keeps your selected channel and restores measurement plotting (no MK fallback labels).' }
        ]
      },
      'v2.0.4': {
        date: '2025-09-11',
        title: 'Edit Mode × Linearization Fixes + Dark Mode Polish',
        sections: {
          FIXED: [
            'Global linearization applies even when Smart points exist (Edit Mode ON)',
            'Recompute samples the current plotted curve (respects global/per-channel corrections and End)',
            'Double-apply guard: recomputed Smart curves “bake” global correction once (no extra global on top)'
          ],
          CHANGED: [
            'Near-linear detection tightened (0.5%→0.2%, 5→11 samples) to avoid collapsing lightly corrected curves',
            'Dark mode: input fields (percent/end, filename, L*, edits) use darker backgrounds and clearer focus',
            'Dark mode: toggle sliders use darker tracks and high-contrast knobs; key-point ordinal labels use theme text color'
          ]
        },
        aboutDialog: [
          { label: 'Global + Smart', desc: 'Global corrections now work with Edit Mode ON; recompute bakes global once to avoid double application.' },
          { label: 'Recompute Source', desc: 'Recompute uses the currently plotted curve so points match what you see.' },
          { label: 'Dark Mode', desc: 'Improved readability for inputs, toggles, and labels.' }
        ]
      },
      'v2.0.3': {
        date: '2025-09-10',
        title: 'Detailed Workflow Guide in Help',
        aboutDialog: [
          { label: 'Detailed Workflow', desc: 'Added a new Help tab with a step-by-step calibration guide (LAB and EDN workflows), including ink-limit verification and target printing.' },
          { label: 'ReadMe/Help Polish', desc: 'Improved Installation links, Glossary entries, and formatting; Help button updated with icon.' }
        ]
      },
      'v2.0.2': {
        date: '2025-09-10',
        title: 'Tabbed Help + About Removed',
        aboutDialog: [
          { label: 'Help Tabs', desc: 'Help window now has ReadMe, Glossary, and Version History tabs.' },
          { label: 'Version History', desc: 'Moved from the separate About dialog into Help → Version History.' },
          { label: 'About Removed', desc: 'Removed the About button and popup; all info is available in Help.' }
        ]
      },
      'v2.0.1': {
        date: '2025-09-09',
        title: 'Embedded Help Window',
        aboutDialog: [
          { label: 'Help Content', desc: 'Help window now displays embedded documentation (Overview, Quick Start, Features, Troubleshooting, External References). No separate inline help to maintain.' },
          { label: 'Header', desc: 'Help header matches the main app (logo + version).' },
          { label: 'Formatting', desc: 'Help content is styled for readability; headings, lists, links, and code are preserved.' }
        ]
      },
      'v2.0': {
        date: '2025-09-09',
        title: 'Edit Mode, Smart Curves, Robust History',
        sections: {
          ADDED: [
            'Edit Mode: gates all key‑point edits and overlay visibility; APIs respect mode state',
            'Undo/Redo: full history for insert/adjust/delete/recompute and Edit Mode toggles',
            'Smart Curve: renamed from “AI curve”; writes source tag “smart”, reads legacy “ai”; legacy AI function names remain as aliases',
            'Absolute coordinates: XY input and Up/Down nudges use absolute Y (post‑End); Left/Right adjust X (pre‑scale)',
            'Redo parity: redo restores Smart key points + interpolation and recomputes curves to match overlays',
            'Ink‑limit guard: blocks edits that would exceed End when End cannot be raised, with a clear status message'
          ]
        },
        aboutDialog: [
          { label: 'Edit Mode', desc: 'All key‑point edits require Edit Mode; overlays show only when ON' },
          { label: 'History', desc: 'Undo/Redo covers edits and Edit Mode toggles' },
          { label: 'Smart Curves', desc: '“AI curve” → “Smart Curve”; reads ai/smart, writes smart; APIs keep AI aliases' },
          { label: 'Absolute Y', desc: 'XY input and Up/Down use absolute Y; Left/Right nudges X' },
          { label: 'Redo Parity', desc: 'Redo restores key points + interpolation, then recomputes curves' },
          { label: 'Ink Guard', desc: 'Blocks edits that exceed End when End is effectively locked' }
        ]
      },
      'v1.9.0': {
        date: '2025-09-06',
        title: 'Gaussian LAB, Overlay Alignment, Preserved Smart Shape',
        sections: {
          CHANGED: [
            'LAB processing now uses Gaussian Weighted Correction (density‑independent); smoothing slider widens Gaussian influence radius',
            'LAB → Smart conversion preserves plotted shape using adaptive key‑point fit (defaults: 0.25% max error, 21 max points)',
            'Key‑point overlay and adapter overlays now align exactly with End‑scaled curves (absolute plotting)'
          ],
          FIXED: [
            'Removed localized “bubble” artifacts when applying LAB to dense .quad curves',
            'Pre‑conversion overlay markers now use interpolated Y (no nearest‑index drift)'
          ],
          DOCS: [
            'Added debug helper compareKeyPointsToPlot and updated CLAUDE.md with Gaussian LAB and conversion details'
          ]
        },
        aboutDialog: [
          { label: 'Gaussian LAB', desc: 'Density‑independent LAB correction; smoother results on dense .quad curves' },
          { label: 'Preserved Shape', desc: 'LAB → AI conversion fits points to the plotted curve' },
          { label: 'Overlay Accuracy', desc: 'Markers and labels align with End‑scaled curves' },
          { label: 'Simplifier Defaults', desc: 'Tighter default fit (0.25% / 21 points)' }
        ]
      },
      'v1.8.6': {
        date: '2025-09-05',
        title: 'LAB Wedgie Parity & Manual L* Simplification',
        sections: {
          ADDED: [
            'LAB .txt import now uses wedgie-style inversion to a linear target (parity with Manual L*)',
            'Documentation updated to reflect wedgie inversion for measurement data'
          ],
          CHANGED: [
            'Manual L* modal simplified: removed Target X%/L* and link; Measured-only table',
            'Unified processing: Target X% = Measured X%; Target L* = 100→0'
          ],
          FIXED: [
            'Original measured points overlay and format labels consistent across LAB and Manual L*',
            'Measurement intent marker applies to LAB formats regardless of suffix',
            'ACV overlay: “Show key points” displays original ACV anchor points (global and per‑channel); no 32‑point fallback. ACV/LUT/LAB overlays take precedence over Smart key points.',
            'ACV → Smart editing: When first editing key points with a global ACV loaded, editable Smart points are seeded from the ACV anchors (not a simplified set) to avoid unexpected point shifts.',
            'Overlay preference: When Smart key points exist for a channel, the overlay shows those Smart points; ACV/LUT/LAB overlays appear only when no Smart points are present.',
            'No double processing: Global linearization is not applied to channels that have Smart Curves, preventing unintended changes when editing Smart points.',
            'Exact Smart plotting: “Show key points” draws Smart points directly from stored values (pre‑scale) for precise alignment.'
          ],
          REMOVED: [
            'Gaussian LAB documentation references',
            'Manual L* Target L* inputs and link toggle'
          ]
        },
        aboutDialog: [
          { label: 'Wedgie Parity', desc: 'LAB .txt and Manual L* use the same inversion to a linear target' },
          { label: 'Simplified Manual L*', desc: 'Measured-only entry; target is implicit (linear 100→0)' },
          { label: 'Docs Updated', desc: 'Removed Gaussian references; clarified wedgie mapping' }
        ]
      },
      'v1.8.5': {
        date: '2025-09-04',
        title: 'Smart Key‑Point Deletion',
        sections: {
          ADDED: [
            'Smart key‑point deletion: delete by index or nearest to input % (endpoints blocked by default)'
          ]
        },
        aboutDialog: [
          { label: 'Point Deletion', desc: 'Delete key points by index or nearest input % (safe by default: endpoints blocked)' }
        ]
      },
      'v1.8.4': {
        date: '2025-09-04',
        title: 'Smart Key‑Point Labels and UI Polish',
        sections: {
          ADDED: [
            'Numbered labels above Smart key points with ink‑colored backgrounds and auto black/white text for readability',
            'Lab Tech sample: added “apply a midtone lift” example',
            'Smart key‑point deletion: delete by index or nearest to input % (endpoints blocked by default)'
          ],
          CHANGED: [
            'Graph axis titles now use %: “Input Level %” (X), “Output Ink Level %” (Y)',
            'Key‑point label positioning refined: shifts slightly right near 0% and left near 100% to reduce overlap',
            'Lab Tech sample updated to “generate a curve with points 0,0 25,20 75,85 100,100”'
          ],
          DOCS: [
            'Updated CLAUDE.md and AGENTS.md to reflect numeric key‑point workflow and insert/adjust commands'
          ]
        },
        aboutDialog: [
          { label: 'Key‑Point Labels', desc: 'Smart key points now show numbered labels with ink‑colored backgrounds and readable text' },
          { label: 'Axis Titles', desc: 'Graph uses “Input Level %” (X) and “Output Ink Level %” (Y)' },
          { label: 'Lab Tech Samples', desc: 'Focused natural language controls on curve generation' }
        ]
      },
      'v1.8.3': {
        date: '2025-09-03',
        title: 'Expanded Printer Support, OR/GR Inks, Ordered by Release',
        sections: {
          ADDED: [
            'New printers: P400 (K,C,M,Y,LC,LM), x800-x890 (K,C,M,Y,LC,LM,LK,LLK), x900 (K,C,M,Y,LC,LM,LK,LLK,OR,GR), P4-6-8000 (K,C,M,Y,LC,LM,LK,LLK), P5-7-9000 (K,C,M,Y,LC,LM,LK,LLK,OR,GR)',
            'Ink colors: OR (#FF7F00, Orange) and GR (#00A651, Green) supported in charts and swatches',
            'Smart key‑point overlays: squares + ordinal labels for Smart Curves (<21 points)',
            'Smart key‑point insert commands: insert point at X or between ordinals',
            'Undo/redo now restores Smart key points and interpolation meta along with curves'
          ],
          CHANGED: [
            'Printer dropdown, Lab Tech enums, and validation lists reordered newest→oldest based on Epson release eras',
            'Supported printers list in .quad import error updated to include new models',
            'Smart workflow: natural‑language preset curves deprecated; tool now computes numeric key points and applies them directly',
            'Graph axis titles: display shows “Input Level %” (X) and “Output Ink Level %” (Y)'
          ],
          FIXED: [
            'AI-generated curves now respect ink limit percentage; plots update on relative adjustments (e.g., “reduce by 20%”).'
          ],
          REMOVED: [
            'Legacy 860-1160-VM model removed from UI and internal registry'
          ]
        },
        aboutDialog: [
          { label: 'More Printers', desc: 'Added P400, x800-x890, x900, P4-6-8000, P5-7-9000' },
          { label: 'OR/GR Inks', desc: 'Added support for Orange and Green ink channels' },
          { label: 'Smart Curve Scaling', desc: 'Smart Curves now scale with ink limit changes (e.g., reduce by 20%).' },
          { label: 'Defaults', desc: 'Channels now default to 100%' }
        ]
      },
      'v1.8.2': {
        date: '2025-09-03',
        title: 'Unified Workflow Summary & Positive-only Cleanup',
        sections: {
          CHANGED: [
            'About: Consolidated Recommended + Quick Workflow into a single beginner-friendly Workflow Summary',
            'About: Removed the “(Positive‑Only)” label and the PCHIP requirement bullet to simplify guidance'
          ],
          DOCS: [
            'Clarified Positive-only operation in UI text and helper messages; EDN LUT/.acv use Positive mapping (reverse + invert) by default',
            'Removed user-facing references to toggling intent or mismatch warnings; older release notes retained for history'
          ]
        },
        aboutDialog: [
          { label: 'Workflow Summary', desc: 'Step-by-step beginner overview replaces separate Recommended/Quick sections' },
          { label: 'Simplified Wording', desc: 'Cleaned up language and removed extra qualifiers for clarity' },
          { label: 'Positive-only Operation', desc: 'Tool operates in printer-space with Positive mapping; invert images in your editor for digital negatives' }
        ]
      },
      'v1.8.1': {
        date: '2025-09-03',
        title: 'MIT License + Chart Orientation Aids',
        sections: {
          ADDED: [
            'MIT License for quadgen.html only: header comment added; About dialog blurb notes scope and holder',
            'Chart orientation aids: White→black gradient bars added under X-axis (left→right) and beside Y-axis (bottom→top)'
          ],
          CHANGED: [
            'Axis titles: X now “Input Level Percent”, Y now “Output Ink Level Percent”',
            'Axis label contrast: Force solid black text and adjust spacing to avoid overlap with gradients',
            'EDN mapping fixed to Positive semantics (reverse + invert) with no intent toggle'
          ],
          REMOVED: [
            'Negative Print Intent UI and intent mismatch warning banner; tool now operates in Positive intent only'
          ]
        },
        aboutDialog: [
          { label: 'MIT License (HTML only)', desc: 'Added MIT header in quadgen.html and brief notice in About; scope limited to this HTML file' },
          { label: 'Axis Gradients', desc: 'Added white→black bars under X and along Y for clear white/black orientation' },
          { label: 'Readable Labels', desc: 'Labels forced to black with spacing tweaks for clarity' },
          { label: 'Axis Titles', desc: 'Renamed to “Input Level Percent” (X) and “Output Ink Level Percent” (Y)' },
          { label: 'Positive-only Intent', desc: 'Removed Negative intent; EDN mapping uses Positive semantics by default' }
        ]
      },
      'v1.8': {
        date: '2025-09-02',
        title: 'Print Intent Mapping, ACV/LUT Parity, LAB Traceability',
        sections: {
          ADDED: [
            'Print Intent selector (Positive/Negative) applied to EDN-style corrections; live recompute on toggle',
            'LAB measurement intent traceability: UI shows “measured: Positive/Negative” and .quad comments include it',
            'LAB intent mismatch warning banner when current intent differs from recorded LAB measurement intent'
          ],
          FIXED: [
            'ACV/LUT parity: ACV path now uses same orientation as LUT (horizontal flip + vertical inversion for positive-domain EDN)',
            'Immediate graph update when toggling Print Intent with EDN corrections loaded',
            'LAB endpoints anchored to 0 and 1 to preserve full dynamic range',
            'Natural-language curve parser: Tonal regions flipped to match 0% = white, 100% = black ("shadows" now 75–100%)'
          ],
          REMOVED: [
            'Built-in process presets (cyanotype, palladium, etc.) and process triggers from AI routing',
            'Bookmarks/auto-citation experiment; the assistant no longer auto-injects sources'
          ]
        },
        aboutDialog: [
          { label: 'Print Intent Mapping', desc: 'EDN (.cube/.acv) mapped by intent (Positive: flip+invert; Negative: flip only) with live recompute' },
          { label: 'ACV/LUT Parity', desc: 'ACV orientation normalized to match LUT; midtones now align closely' },
          { label: 'LAB Traceability', desc: 'Recorded “measured: Positive/Negative” and added mismatch warning banner' },
          { label: 'LAB Endpoints Anchored', desc: 'Measurement curves now start at 0% and end at 100% to preserve range' },
          { label: 'Tonal Region Mapping', desc: 'Parser regions flipped; 0% is white and 100% is black. "Lift shadows" now affects 75–100% correctly.' },
          { label: 'Simplified AI Scope', desc: 'Removed process presets; assistant provides guidance to load EDN/LAB instead' }
        ]
      },
      'v1.7': {
        date: '2025-09-02',
        title: 'Wedgie Inversion & LAB Data Artifacts Fix',
        sections: {
          FIXED: [
            'LAB data curve artifacts: Replaced complex coordinate transformation with wedgie-style inversion to a linear target',
            'Dense-on-dense data processing: Eliminated curve spikes when applying LAB corrections to loaded .quad files and AI-generated curves',
            'Undo system gaps: Added proper state capture for all LAB data loading methods (sample data, file upload, pasted data)',
            'Algorithm mismatch: Sparse measurement data (21 points) now properly applied to dense curve data (256 points)'
          ],
          ENHANCED: [
            'LAB processing algorithm: Wedgie-style inversion to linear target; optional smoothing available separately',
            'Processing reliability: Eliminated need for ad-hoc smoothing by fixing the mapping at the source',
            'Mathematical accuracy: Replaced experimental coordinate transformation with direct inversion to target'
          ],
          REMOVED: [
            'RBF experimental method: Removed Radial Basis Functions option after confirming no advantage over the simplified inversion',
            'UI switching controls: Cleaned up method selection dropdown and event listeners for simplified interface'
          ]
        },
        aboutDialog: [
          { label: 'LAB Data Artifact Fix', desc: 'Eliminated curve spikes when applying measurement data to loaded .quad files using wedgie-style inversion' },
          { label: 'Unified Inversion', desc: 'Manual L* and LAB .txt now use the same inversion to a linear target' },
          { label: 'Dense Data Processing', desc: 'Proper handling of sparse corrections (21 points) applied to dense curves (256 points)' },
          { label: 'Undo System Completion', desc: 'Added state capture for all LAB data loading methods ensuring proper undo functionality' },
          { label: 'Algorithm Simplification', desc: 'Removed RBF experimental option after simplification to wedgie-style inversion' }
        ]
      },
      'v1.6': {
        date: '2025-08-31',
        title: 'Lab Tech Assistant & Processing Visibility',
        sections: {
          ADDED: [
            'Lab Tech AI assistant with 25 specialized functions for natural language control',
            'Processing detail panels showing Base Curves → Per-Channel → Global pipeline per channel',
            'Professional communication style with markdown formatting support',
            'Quick reference documentation with function locations'
          ],
          ENHANCED: [
            'Smart Curve generation with natural language descriptions ("palladium curve", "S-curve")',
            'Undo system integration for AI-generated curves',
            'Visual state restoration for disabled channels'
          ],
          FIXED: [
            'Disabled channel transparency when Lab Tech adds curves',
            'Processing panel updates now immediate (no manual refresh needed)',
            'Channel iteration bug causing incorrect references',
            'Smart Curve undo functionality integration'
          ]
        },
        aboutDialog: [
          { label: 'Lab Tech Assistant', desc: 'AI assistant with 25 specialized functions for natural language control of QuadGEN' },
          { label: 'Processing Visibility', desc: 'Expandable panels show Base Curves → Per-Channel → Global pipeline for each channel' },
          { label: 'Professional Communication', desc: 'Concise responses with markdown formatting and structured information' },
          { label: 'AI Curve Integration', desc: 'Natural language curve generation with full undo system integration' },
          { label: 'Visual Improvements', desc: 'Enhanced state restoration and immediate processing panel updates' }
        ]
      },
      'v1.5': {
        date: '2025-08-29',
        title: 'Adobe Photoshop .acv Curve File Support',
        sections: {
          ADDED: [
            'Adobe Photoshop .acv file format support: Complete binary format parser for curve presets',
            'Cubic spline interpolation: Smooth curve generation matching Photoshop\'s behavior between control points',
            'ACV format detection: Automatic binary vs text file handling in parseLinearizationFile()',
            'RGB composite curve extraction: Uses first curve from multi-curve .acv files for linearization',
            'Binary data parsing: DataView-based parser supporting Adobe\'s int16 big-endian format specification',
            'File input support: .acv files accepted in both global and per-channel linearization inputs',
            'UI integration: Updated tooltips and file format descriptions to include .acv curve file support'
          ],
          IMPROVED: [
            'File format documentation: Comprehensive .acv technical specifications in internal documentation',
            'Linearization workflow: Seamless integration with existing .cube and .txt file processing pipeline'
          ]
        },
        aboutDialog: [
          { label: 'ACV File Format', desc: 'Complete binary format parser for Adobe Photoshop curve presets' },
          { label: 'Cubic Spline Interpolation', desc: 'Smooth curve generation matching Photoshop\'s behavior between control points' },
          { label: 'RGB Composite Curves', desc: 'Automatic extraction of first curve from multi-curve .acv files' },
          { label: 'Binary Data Handling', desc: 'DataView-based parser supporting Adobe\'s int16 big-endian format specification' },
          { label: 'Seamless Integration', desc: '.acv files work in both global and per-channel linearization workflows' },
          { label: 'UI Updates', desc: 'Updated tooltips and file format descriptions for .acv curve file support' }
        ]
      },
      'v1.4.1': {
        date: '2025-08-29',
        title: 'Smoothing Algorithm Refinements & .quad File Improvements',
        sections: {
          ADDED: [
            'Smoothing Splines algorithm: Mathematical curve smoothing with automatic lambda parameter selection',
            'Visual curve comparison: Original curve overlay (gray dashed line) shows smoothing effects on all channels',
            'Simplified curve algorithms: Focused on Uniform Sampling and Smoothing Splines',
            'Accurate .quad file maximum detection: Uses actual curve maximum instead of endpoint value'
          ],
          REFINED: [
            'Streamlined algorithm selection: Focused on reliable smoothing methods',
            'Simplified interpolation options: Hidden Cubic Spline and Catmull-Rom from UI to reduce complexity',
            'Default algorithm changed: Uniform Sampling now default with Smoothing Splines as advanced option',
            'UI cleanup: Removed monotonicity preservation option (PCHIP handles this appropriately)'
          ],
          IMPROVED: [
            'Curve visualization: Original vs smoothed comparison works with multiple channels simultaneously',
            'Algorithm focus: Concentrated on reliable, predictable smoothing methods for production use',
            '.quad file scaling: Proper scaling based on actual maximum value for non-monotonic curves'
          ]
        },
        aboutDialog: [
          { label: 'Smoothing Splines', desc: 'Added mathematical smoothing algorithm with automatic parameter selection' },
          { label: 'Visual Curve Comparison', desc: 'Original curve overlay shows before/after smoothing effects on all channels' },
          { label: 'Accurate .quad File Handling', desc: 'Proper detection and scaling of ink limits based on actual curve maximum' },
          { label: 'Non-Monotonic Curve Support', desc: 'Correctly handles curves where peak ink density occurs before 100% input' },
          { label: 'Streamlined Algorithm Selection', desc: 'Focused on Uniform Sampling and Smoothing Splines for reliable results' },
          { label: 'Improved Interpolation Defaults', desc: 'PCHIP monotonic interpolation as primary method with Linear fallback' }
        ]
      }
    };

    // Centralized contrast intent preset definitions
    const CONTRAST_INTENT_PRESETS = {
      'linear': {
        id: 'linear',
        label: 'Linear',
        description: 'Neutral contrast. No curve adjustment with 1:1 input-to-output mapping for unmodified tonal reproduction.',
        params: {},
        curveFunction: (t) => clamp01(t),
        displayOrder: 1
      },
      'soft': {
        id: 'soft',
        label: 'Gamma 0.85',
        description: 'Lowers contrast. Gentle highlight compression that brightens shadows while preserving detail in bright areas. Ideal for maintaining shadow detail in high-contrast images.',
        params: { gamma: 0.85 },
        curveFunction: (t) => gammaMap(t, 0.85),
        displayOrder: 2
      },
      'hard': {
        id: 'hard',
        label: 'Gamma 1.2',
        description: 'Increases contrast. Mild shadow compression that darkens shadows while maintaining highlight detail. Useful for adding contrast to flat images.',
        params: { gamma: 1.20 },
        curveFunction: (t) => gammaMap(t, 1.20),
        displayOrder: 3
      },
      'gamma16': {
        id: 'gamma16',
        label: 'Gamma 1.6',
        description: 'Increases contrast. Moderate shadow compression providing balanced contrast enhancement between mild and strong gamma curves. Good for print workflows requiring moderate contrast.',
        params: { gamma: 1.6 },
        curveFunction: (t) => gammaMap(t, 1.6),
        displayOrder: 4
      },
      'gamma18': {
        id: 'gamma18',
        label: 'Gamma 1.8',
        description: 'Increases contrast. Strong shadow compression that darkens shadows significantly while preserving highlight detail. Useful for dramatic tonal effects.',
        params: { gamma: 1.8 },
        curveFunction: (t) => gammaMap(t, 1.8),
        displayOrder: 5
      },
      'gamma20': {
        id: 'gamma20',
        label: 'Gamma 2.0',
        description: 'Increases contrast. High contrast with pronounced shadow compression providing substantial tonal separation. Good for high-impact printing applications.',
        params: { gamma: 2.0 },
        curveFunction: (t) => gammaMap(t, 2.0),
        displayOrder: 6
      },
      'gamma22': {
        id: 'gamma22',
        label: 'Gamma 2.2',
        description: 'Increases contrast. Standard sRGB gamma correction providing traditional monitor-like contrast curve with substantial shadow compression. Common for display calibration.',
        params: { gamma: 2.2 },
        curveFunction: (t) => gammaMap(t, 2.2),
        displayOrder: 7
      },
      'filmic': {
        id: 'filmic',
        label: 'Filmic (soft shoulder)',
        description: 'Preserves contrast. Soft shoulder roll-off protects highlights from clipping while maintaining midtone contrast. Mimics film-like highlight handling for smooth tonal transitions.',
        params: { filmicGain: 0.55, shoulder: 0.35 },
        curveFunction: (t) => filmicSoftShoulder(t, 0.55, 0.35),
        displayOrder: 8
      },
      'popsgloss': {
        id: 'popsgloss',
        label: 'PoPS Gloss Curve',
        description: 'Increases contrast. Prints on Paper Studios system gloss curve with gentle shadow compression and smooth highlight preservation. Optimized for photographic paper simulation.',
        params: {
          keyPoints: [
            {x: 0, y: 0},
            {x: 10/255, y: 4/255},
            {x: 40/255, y: 30/255},
            {x: 125/255, y: 123/255},
            {x: 192/255, y: 193/255},
            {x: 223/255, y: 223/255},
            {x: 1, y: 1}
          ]
        },
        curveFunction: (t) => {
          // PoPS Gloss Curve PCHIP interpolation
          const points = [
            {x: 0, y: 0},
            {x: 10/255, y: 4/255},
            {x: 40/255, y: 30/255},
            {x: 125/255, y: 123/255},
            {x: 192/255, y: 193/255},
            {x: 223/255, y: 223/255},
            {x: 1, y: 1}
          ];

          // PCHIP interpolation for smooth curves
          if (t <= 0) return 0;
          if (t >= 1) return 1;

          const xs = points.map(p => p.x);
          const ys = points.map(p => p.y);

          try {
            const pchip = createPCHIPSpline(xs, ys);
            return clamp01(pchip(t));
          } catch (e) {
            // Fallback to linear if PCHIP fails
            for (let i = 0; i < points.length - 1; i++) {
              if (t >= points[i].x && t <= points[i + 1].x) {
                const ratio = (t - points[i].x) / (points[i + 1].x - points[i].x);
                return points[i].y + ratio * (points[i + 1].y - points[i].y);
              }
            }
            return t;
          }
        },
        displayOrder: 9
      },
      'popsmatte': {
        id: 'popsmatte',
        label: 'PoPS Matte Curve',
        description: 'Increases contrast. Prints on Paper Studios system matte curve with more aggressive shadow compression than gloss variant. Designed for matte paper characteristics.',
        params: {
          keyPoints: [
            {x: 0, y: 0},
            {x: 10/255, y: 3/255},
            {x: 28/255, y: 14/255},
            {x: 55/255, y: 37/255},
            {x: 90/255, y: 79/255},
            {x: 170/255, y: 174/255},
            {x: 1, y: 1}
          ]
        },
        curveFunction: (t) => {
          // PoPS Matte Curve PCHIP interpolation
          const points = [
            {x: 0, y: 0},
            {x: 10/255, y: 3/255},
            {x: 28/255, y: 14/255},
            {x: 55/255, y: 37/255},
            {x: 90/255, y: 79/255},
            {x: 170/255, y: 174/255},
            {x: 1, y: 1}
          ];

          // PCHIP interpolation for smooth curves
          if (t <= 0) return 0;
          if (t >= 1) return 1;

          const xs = points.map(p => p.x);
          const ys = points.map(p => p.y);

          try {
            const pchip = createPCHIPSpline(xs, ys);
            return clamp01(pchip(t));
          } catch (e) {
            // Fallback to linear if PCHIP fails
            for (let i = 0; i < points.length - 1; i++) {
              if (t >= points[i].x && t <= points[i + 1].x) {
                const ratio = (t - points[i].x) / (points[i + 1].x - points[i].x);
                return points[i].y + ratio * (points[i + 1].y - points[i].y);
              }
            }
            return t;
          }
        },
        displayOrder: 10
      },
      'popsuncoated': {
        id: 'popsuncoated',
        label: 'PoPS Uncoated / Alt Process',
        description: 'Increases contrast. Prints on Paper Studios system curve optimized for uncoated papers and alternative photographic processes. Features strong shadow compression with smooth highlight transitions.',
        params: {
          keyPoints: [
            {x: 0, y: 0},
            {x: 28/255, y: 9/255},
            {x: 66/255, y: 44/255},
            {x: 112/255, y: 100/255},
            {x: 164/255, y: 168/255},
            {x: 221/255, y: 223/255},
            {x: 1, y: 1}
          ]
        },
        curveFunction: (t) => {
          // PoPS Uncoated / Alt Process Curve PCHIP interpolation
          const points = [
            {x: 0, y: 0},
            {x: 28/255, y: 9/255},
            {x: 66/255, y: 44/255},
            {x: 112/255, y: 100/255},
            {x: 164/255, y: 168/255},
            {x: 221/255, y: 223/255},
            {x: 1, y: 1}
          ];

          // PCHIP interpolation for smooth curves
          if (t <= 0) return 0;
          if (t >= 1) return 1;

          const xs = points.map(p => p.x);
          const ys = points.map(p => p.y);

          try {
            const pchip = createPCHIPSpline(xs, ys);
            return clamp01(pchip(t));
          } catch (e) {
            // Fallback to linear if PCHIP fails
            for (let i = 0; i < points.length - 1; i++) {
              if (t >= points[i].x && t <= points[i + 1].x) {
                const ratio = (t - points[i].x) / (points[i + 1].x - points[i].x);
                return points[i].y + ratio * (points[i + 1].y - points[i].y);
              }
            }
            return t;
          }
        },
        displayOrder: 11
      },
      'popsuncoatedsofter': {
        id: 'popsuncoatedsofter',
        label: 'PoPS Uncoated / Alt Process (softer)',
        description: 'Increases contrast. Prints on Paper Studios system softer variant for uncoated papers and alternative processes. Less aggressive shadow compression than the standard uncoated curve.',
        params: {
          keyPoints: [
            {x: 0, y: 0},
            {x: 28/255, y: 12/255},
            {x: 66/255, y: 47/255},
            {x: 112/255, y: 100/255},
            {x: 164/255, y: 168/255},
            {x: 221/255, y: 223/255},
            {x: 1, y: 1}
          ]
        },
        curveFunction: (t) => {
          // PoPS Uncoated / Alt Process (softer) Curve PCHIP interpolation
          const points = [
            {x: 0, y: 0},
            {x: 28/255, y: 12/255},
            {x: 66/255, y: 47/255},
            {x: 112/255, y: 100/255},
            {x: 164/255, y: 168/255},
            {x: 221/255, y: 223/255},
            {x: 1, y: 1}
          ];

          // PCHIP interpolation for smooth curves
          if (t <= 0) return 0;
          if (t >= 1) return 1;

          const xs = points.map(p => p.x);
          const ys = points.map(p => p.y);

          try {
            const pchip = createPCHIPSpline(xs, ys);
            return clamp01(pchip(t));
          } catch (e) {
            // Fallback to linear if PCHIP fails
            for (let i = 0; i < points.length - 1; i++) {
              if (t >= points[i].x && t <= points[i + 1].x) {
                const ratio = (t - points[i].x) / (points[i + 1].x - points[i].x);
                return points[i].y + ratio * (points[i + 1].y - points[i].y);
              }
            }
            return t;
          }
        },
        displayOrder: 12
      }
    };

    // Utility functions for preset management
    function getPreset(presetId) {
      return CONTRAST_INTENT_PRESETS[presetId] || null;
    }

    function getAllPresets() {
      return Object.values(CONTRAST_INTENT_PRESETS)
        .sort((a, b) => a.displayOrder - b.displayOrder);
    }

    function getPresetDefaults(presetId, param) {
      const preset = CONTRAST_INTENT_PRESETS[presetId];
      if (!preset || !preset.params) return null;
      return preset.params[param];
    }

    function generatePresetDropdownHTML() {
      const presets = getAllPresets();
      return presets.map(preset =>
        `<option value="${preset.id}">${preset.label}</option>`
      ).join('\n');
    }

    // Functions to generate version history content
    // Removed unused generateInternalVersionHistory()
    
    function generateAboutDialogVersionHistory() {
      let content = '';
      for (const [version, data] of Object.entries(VERSION_HISTORY)) {
        if (version === 'Unreleased') continue;
        const displayVersion = `Beta ${version}`;
        content += `
          <div class="mb-3">
            <p class="font-bold">${displayVersion}</p>
            <ul class="list-none ml-2 mt-1 text-sm leading-tight">`;
        
        for (const item of data.aboutDialog) {
          content += `
              <li>- ${item.desc}</li>`;
        }
        
        content += `
            </ul>
          </div>`;
      }
      return content;
    }
    
    const TOTAL = 65535;
    const N = 256;
    const DENOM = N - 1;

    /**
     * QuadGenActions - Centralized system for programmatic control of quadGEN
     * Provides methods for Lab Tech assistant to execute user actions
     */
    class QuadGenActions {
      constructor() {
        this.lastAction = null;
        this.lastActionTime = null;
      }

      /**
       * Resolve channel: if not provided, choose the first enabled channel
       * Enabled = percentage > 0 OR endValue > 0 OR enabled = true
       */
      _resolveChannel(preferredChannel = null) {
        const currentPrinter = getCurrentPrinter();
        if (preferredChannel && currentPrinter.channels.includes(preferredChannel)) {
          return preferredChannel;
        }
        const state = this.getCurrentState();
        if (!state.success) return currentPrinter.channels[0];
        const entries = Object.entries(state.data.channels || {});
        const firstEnabled = entries.find(([name, ch]) => ch && (ch.enabled || (ch.percentage || 0) > 0 || (ch.endValue || 0) > 0));
        if (firstEnabled) return firstEnabled[0];
        // Fallback: first printer channel
        return currentPrinter.channels[0];
      }

      /**
       * Set individual channel ink limit value
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {number} percentage - Ink limit percentage (0-100)
       * @returns {Object} Result with success status and message
       */
      setChannelValue(channelName, percentage) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (DEBUG_LOGS) console.log('🖨️ Current printer:', currentPrinter.name);
          if (DEBUG_LOGS) console.log('🎯 Requested channel:', channelName);
          
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Validate percentage
          const validatedPercentage = InputValidator.clampPercent(percentage);
          if (validatedPercentage !== percentage) {
            return {
              success: false,
              message: `Invalid percentage '${percentage}'. Must be between 0 and 100.`
            };
          }

          // Update the channel value
          const channelRow = getChannelRow(channelName);
          if (!channelRow) {
            // List all channel rows for debugging
            const allRows = Array.from(document.querySelectorAll('tr[data-channel]'));
            
            return {
              success: false,
              message: `Channel row for '${channelName}' not found. Available channels: ${allRows.map(row => row.dataset.channel).join(', ')}`
            };
          }

          const channelElement = channelRow.querySelector('.percent-input');
          if (!channelElement) {
            return {
              success: false,
              message: `Percent input element not found for channel '${channelName}'`
            };
          }

          // Record the action before changing the value
          const oldValue = channelElement.value;
          CurveHistory.recordChannelAction(channelName, 'percentage', oldValue, validatedPercentage.toString());
          
          channelElement.value = validatedPercentage;
          
          // Trigger the input event to update the UI and recalculate
          channelElement.dispatchEvent(new Event('input', { bubbles: true }));

          this._recordAction('setChannelValue', { channelName, percentage: validatedPercentage });

          return {
            success: true,
            message: `Set ${channelName} channel to ${validatedPercentage}%`,
            details: { channel: channelName, value: validatedPercentage }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting channel value: ${error.message}`
          };
        }
      }

      /**
       * Revert all channels to the loaded global measurement (AI assistant callable)
       */
      revertGlobalToMeasurement() {
        try {
          const btn = document.getElementById('revertGlobalToMeasurementBtn');
          if (!linearizationData) {
            return { success: false, message: 'No global measurement loaded to revert to.' };
          }
          if (!btn) {
            // Fallback: inline perform same logic as click handler
            try { CurveHistory.captureState('Before: Revert Global to Measurement'); } catch {}
            const savedSel = (isEditModeEnabled() && typeof EDIT !== 'undefined' && EDIT && EDIT.selectedChannel) ? EDIT.selectedChannel : null;
            const chs = (getCurrentPrinter()?.channels || []).slice();
            chs.forEach((ch) => {
              try {
                if (window.loadedQuadData?.curves?.[ch]) delete window.loadedQuadData.curves[ch];
                if (window.loadedQuadData?.keyPoints?.[ch]) delete window.loadedQuadData.keyPoints[ch];
                if (window.loadedQuadData?.keyPointsMeta?.[ch]) delete window.loadedQuadData.keyPointsMeta[ch];
                if (window.loadedQuadData?.sources?.[ch]) delete window.loadedQuadData.sources[ch];
              } catch {}
            });
            if (elements.globalLinearizationToggle) {
              elements.globalLinearizationToggle.disabled = false;
              elements.globalLinearizationToggle.checked = true;
            }
            try { linearizationData.edited = false; } catch {}
            refreshGlobalLinearizationDisplay();
            updateInterpolationControls();
            updatePreview();
            try { const chans = getCurrentPrinter().channels; chans.forEach((name)=> updateProcessingDetail(name)); } catch {}
            showStatus('Reverted to measurement (global)');
            updateRevertButtonsState();
            try {
              if (savedSel && isEditModeEnabled()) {
                const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === savedSel);
                const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                if (endVal > 0) {
                  if (elements.editChannelSelect) elements.editChannelSelect.value = savedSel;
                  EDIT.selectedChannel = savedSel;
                  edit_refreshState();
                  updateInkChart();
                }
              }
            } catch {}
            return { success: true, message: 'Reverted to measurement (global)' };
          }
          btn.click();
          return { success: true, message: 'Revert (global) triggered' };
        } catch (e) {
          return { success: false, message: `Global revert failed: ${e.message}` };
        }
      }

      /**
       * Revert a specific channel to its loaded per‑channel measurement (AI assistant callable)
       */
      revertChannelToMeasurement(channelName) {
        try {
          const tr = getChannelRow(channelName);
          if (!tr) return { success: false, message: `Channel row not found for ${channelName}` };
          const btn = tr.querySelector('.per-channel-revert');
          if (!perChannelLinearization[channelName]) {
            return { success: false, message: `No per‑channel measurement loaded for ${channelName}` };
          }
          if (btn) { btn.click(); return { success: true, message: `Reverted ${channelName} to measurement` }; }
          // Fallback: inline logic
          try { CurveHistory.captureState(`Before: Revert ${channelName} to Measurement`); } catch {}
          try {
            if (window.loadedQuadData?.curves?.[channelName]) delete window.loadedQuadData.curves[channelName];
            if (window.loadedQuadData?.keyPoints?.[channelName]) delete window.loadedQuadData.keyPoints[channelName];
            if (window.loadedQuadData?.keyPointsMeta?.[channelName]) delete window.loadedQuadData.keyPointsMeta[channelName];
            if (window.loadedQuadData?.sources?.[channelName]) delete window.loadedQuadData.sources[channelName];
          } catch {}
          perChannelEnabled[channelName] = true;
          const perToggle = tr.querySelector('.per-channel-toggle');
          if (perToggle) { perToggle.disabled = false; perToggle.checked = true; }
          try { perChannelLinearization[channelName].edited = false; } catch {}
          refreshPerChannelLinearizationDisplay(channelName);
          updateInterpolationControls();
          updateProcessingDetail(channelName);
          debouncedPreviewUpdate();
          showStatus(`Reverted ${channelName} to measurement`);
          return { success: true, message: `Reverted ${channelName} to measurement` };
        } catch (e) {
          return { success: false, message: `Channel revert failed: ${e.message}` };
        }
      }

      /**
       * Set ink limit end value for a specific channel
       * @param {string} channelName - The channel name (K, C, M, Y, etc.)
       * @param {number} endValue - Ink limit end value (0-65535)
       * @returns {Object} Result with success status and message
       */
      setChannelEndValue(channelName, endValue) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Validate end value
          const validatedEndValue = InputValidator.clampEnd(endValue);
          if (validatedEndValue !== endValue) {
            return {
              success: false,
              message: `Invalid end value '${endValue}'. Must be between 0 and 65535.`
            };
          }

          // Find the channel row
          const channelRow = getChannelRow(channelName);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          const endElement = channelRow.querySelector('.end-input');
          if (!endElement) {
            return {
              success: false,
              message: `End value input element not found for channel '${channelName}'`
            };
          }

          // Record the action before changing the value
          const oldValue = endElement.value;
          CurveHistory.recordChannelAction(channelName, 'end', oldValue, validatedEndValue.toString());
          
          endElement.value = validatedEndValue;
          
          // Trigger the input event to update the UI and recalculate percentage
          endElement.dispatchEvent(new Event('input', { bubbles: true }));

          this._recordAction('setChannelEndValue', { channelName, endValue: validatedEndValue });

          return {
            success: true,
            message: `Set ${channelName} channel end value to ${validatedEndValue}`,
            details: { channel: channelName, endValue: validatedEndValue }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting channel end value: ${error.message}`
          };
        }
      }

      /**
       * Apply same percentage to all enabled channels
       * @param {number} percentage - Ink limit percentage (0-100)
       * @returns {Object} Result with success status and message
       */
      applyToAllChannels(percentage) {
        try {
          const validatedPercentage = InputValidator.clampPercent(percentage);
          if (validatedPercentage !== percentage) {
            return {
              success: false,
              message: `Invalid percentage '${percentage}'. Must be between 0 and 100.`
            };
          }

          const currentPrinter = getCurrentPrinter();
          const results = [];
          const channelActions = [];
          let appliedCount = 0;

          // First pass: collect current values and prepare batch action
          for (const channelName of currentPrinter.channels) {
            // Check if channel is enabled
            const channelRow = getChannelRow(channelName);
            if (channelRow) {
              const checkbox = channelRow._virtualCheckbox;
              if (checkbox && checkbox.checked) {
                const channelElement = channelRow.querySelector('.percent-input');
                if (channelElement) {
                  const oldValue = channelElement.value;
                  
                  // Record this individual channel change for the batch
                  channelActions.push({
                    channelName: channelName,
                    type: 'percentage',
                    oldValue: oldValue,
                    newValue: validatedPercentage.toString()
                  });
                  
                  results.push(channelName);
                  appliedCount++;
                }
              }
            }
          }

          // Second pass: apply all changes and record as batch
          if (channelActions.length > 0) {
            // Set flag to prevent individual action recording during batch operation
            CurveHistory.isBatchOperation = true;
            
            for (const channelAction of channelActions) {
              const channelRow = getChannelRow(channelAction.channelName);
              if (channelRow) {
                const channelElement = channelRow.querySelector('.percent-input');
                if (channelElement) {
                  
                  // Set value and manually trigger UI updates without dispatching input event
                  channelElement.value = validatedPercentage;
                  
                  // Manually perform the same UI updates as the input handler, but without recording actions
                  const p = InputValidator.validateInput(channelElement, InputValidator.clampPercent);
                  const endVal = InputValidator.computeEndFromPercent(p);
                  const endInput = channelRow.querySelector('.end-input');
                  if (endInput) endInput.value = String(endVal);
                  
                  // Update UI display
                  if (channelRow.refreshDisplayFn) channelRow.refreshDisplayFn();
                }
              }
            }
            
            // Update compact channels list and graphs after all changes
            setTimeout(() => updateCompactChannelsList(), 50);
            debouncedPreviewUpdate();
            
            // Clear flag and record the batch action
            CurveHistory.isBatchOperation = false;
            CurveHistory.recordBatchAction(
              `Apply ${validatedPercentage}% to ${appliedCount} channels`,
              channelActions
            );
          }

          this._recordAction('applyToAllChannels', { percentage: validatedPercentage, appliedChannels: results });

          return {
            success: true,
            message: `Applied ${validatedPercentage}% to ${appliedCount} enabled channels: ${results.join(', ')}`,
            details: { percentage: validatedPercentage, channels: results }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error applying to all channels: ${error.message}`
          };
        }
      }

      /**
       * Apply same end value to all enabled channels
       * @param {number} endValue - Ink limit end value (0-65535)
       * @returns {Object} Result with success status and message
       */
      applyEndToAllChannels(endValue) {
        try {
          const validatedEndValue = InputValidator.clampEnd(endValue);
          if (validatedEndValue !== endValue) {
            return {
              success: false,
              message: `Invalid end value '${endValue}'. Must be between 0 and 65535.`
            };
          }

          const currentPrinter = getCurrentPrinter();
          const results = [];
          const channelActions = [];
          let appliedCount = 0;

          // First pass: collect current values and prepare batch action
          for (const channelName of currentPrinter.channels) {
            // Check if channel is enabled
            const channelRow = getChannelRow(channelName);
            if (channelRow) {
              const checkbox = channelRow._virtualCheckbox;
              if (checkbox && checkbox.checked) {
                const channelElement = channelRow.querySelector('.end-input');
                if (channelElement) {
                  const oldValue = channelElement.value;
                  
                  // Record this individual channel change for the batch
                  channelActions.push({
                    channelName: channelName,
                    type: 'end',
                    oldValue: oldValue,
                    newValue: validatedEndValue.toString()
                  });
                  
                  results.push(channelName);
                  appliedCount++;
                }
              }
            }
          }

          // Second pass: apply all changes and record as batch
          if (channelActions.length > 0) {
            // Set flag to prevent individual action recording during batch operation
            CurveHistory.isBatchOperation = true;
            
            for (const channelAction of channelActions) {
              const channelRow = getChannelRow(channelAction.channelName);
              if (channelRow) {
                const channelElement = channelRow.querySelector('.end-input');
                if (channelElement) {
                  
                  // Set value and manually trigger UI updates without dispatching input event
                  channelElement.value = validatedEndValue;
                  
                  // Manually perform the same UI updates as the input handler, but without recording actions
                  const e = InputValidator.validateInput(channelElement, InputValidator.clampEnd);
                  const p = InputValidator.computePercentFromEnd(e);
                  const percentInput = channelRow.querySelector('.percent-input');
                  if (percentInput) percentInput.value = p.toFixed(1);
                  
                  // Update UI display
                  if (channelRow.refreshDisplayFn) channelRow.refreshDisplayFn();
                }
              }
            }
            
            // Update compact channels list and graphs after all changes
            setTimeout(() => updateCompactChannelsList(), 50);
            debouncedPreviewUpdate();
            
            // Clear flag and record the batch action
            CurveHistory.isBatchOperation = false;
            CurveHistory.recordBatchAction(
              `Apply end value ${validatedEndValue} to ${appliedCount} channels`,
              channelActions
            );
          }

          this._recordAction('applyEndToAllChannels', { endValue: validatedEndValue, appliedChannels: results });

          return {
            success: true,
            message: `Applied end value ${validatedEndValue} to ${appliedCount} enabled channels: ${results.join(', ')}`,
            details: { endValue: validatedEndValue, channels: results }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error applying end value to all channels: ${error.message}`
          };
        }
      }

      /**
       * Enable or disable a specific channel
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {boolean} enabled - Whether to enable (true) or disable (false)
       * @returns {Object} Result with success status and message
       */
      enableDisableChannel(channelName, enabled) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Find and update the channel checkbox
          const channelRow = getChannelRow(channelName);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          const checkbox = channelRow._virtualCheckbox;
          if (!checkbox) {
            return {
              success: false,
              message: `Channel checkbox for '${channelName}' not found`
            };
          }

          // Only trigger change event if the state is actually changing
          if (checkbox.checked !== enabled) {
            checkbox.checked = enabled;
            // Trigger the change event to update the UI
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }

          this._recordAction('enableDisableChannel', { channelName, enabled });

          const action = enabled ? 'enabled' : 'disabled';
          return {
            success: true,
            message: `${channelName} channel ${action}`,
            details: { channel: channelName, enabled }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error ${enabled ? 'enabling' : 'disabling'} channel: ${error.message}`
          };
        }
      }

      /**
       * Apply the currently selected intent to the loaded .quad (no LAB data)
       */
      applyIntentToLoadedQuad() {
        try {
          if (!canApplyIntentRemap()) {
            return {
              success: false,
              message: 'Load a .quad (and ensure no LAB/manual data is active) before applying an intent.'
            };
          }

          const intentName = contrastIntent?.name || 'Linear';
          applyIntentToLoadedCurve();
          this._recordAction('applyIntentToLoadedQuad', { intent: intentName });

          return {
            success: true,
            message: `Applied ${intentName} intent to the loaded .quad.`,
            details: { intent: intentName }
          };
        } catch (error) {
          return {
            success: false,
            message: `Error applying intent to loaded .quad: ${error.message}`
          };
        }
      }

      /**
       * Get current state of all channels
       * @returns {Object} Current app state with channel values and settings
       */
      getCurrentState() {
        try {
          const currentPrinter = getCurrentPrinter();
          const channels = {};

          for (const channelName of currentPrinter.channels) {
            const channelRow = getChannelRow(channelName);
            
            if (channelRow) {
              const percentElement = channelRow.querySelector('.percent-input');
              const enabledElement = channelRow._virtualCheckbox;
              const endElement = channelRow.querySelector('.end-input');

              channels[channelName] = {
                percentage: percentElement ? parseFloat(percentElement.value) : 0,
                enabled: enabledElement ? enabledElement.checked : false,
                endValue: endElement ? parseInt(endElement.value) : 0
              };
            } else {
              // Channel row not found, set defaults
              channels[channelName] = {
                percentage: 0,
                enabled: false,
                endValue: 0
              };
            }
          }

          const state = {
            printer: currentPrinter.name,
            channels: channels,
            filename: elements.filenameInput ? elements.filenameInput.value : '',
            printIntent: elements.printIntent ? elements.printIntent.value : 'positive',
            chart: {
              zoomMaxPercent: getChartZoomPercent()
            },
            version: APP_VERSION
          };

          return {
            success: true,
            message: 'Current state retrieved successfully',
            data: state
          };

        } catch (error) {
          return {
            success: false,
            message: `Error getting current state: ${error.message}`
          };
        }
      }

      /**
       * Open file picker for global linearization
       * @returns {Object} Result with success status and message
       */
      openGlobalLinearizationFilePicker() {
        try {
          const fileInput = document.getElementById('linearizationFile');
          if (!fileInput) {
            return {
              success: false,
              message: 'Global linearization file input not found'
            };
          }

          // Trigger the file picker
          fileInput.click();

          return {
            success: true,
            message: 'File picker opened for global linearization. Please select a .cube, .txt, or .acv file.',
            details: { action: 'file_picker_opened', type: 'global' }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error opening global linearization file picker: ${error.message}`
          };
        }
      }

      /**
       * Open file picker for per-channel linearization
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @returns {Object} Result with success status and message
       */
      openPerChannelLinearizationFilePicker(channelName) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          const fileInput = document.getElementById(`perChannel_${channelName}`);
          if (!fileInput) {
            return {
              success: false,
              message: `Per-channel file input for '${channelName}' not found`
            };
          }

          // Trigger the file picker
          fileInput.click();

          return {
            success: true,
            message: `File picker opened for ${channelName} channel linearization. Please select a .cube, .txt, or .acv file.`,
            details: { action: 'file_picker_opened', type: 'per_channel', channel: channelName }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error opening per-channel linearization file picker: ${error.message}`
          };
        }
      }

      /**
       * Set contrast intent to a preset or explicit gamma/filmic parameters
       * @param {string} preset - 'linear' | 'soft' | 'hard' | 'filmic' | 'gamma'
       * @param {object} params - optional params: { gamma?:number, filmicGain?:number, shoulder?:number }
       */
      setContrastIntentPreset(preset, params = {}) {
        try {
          const p = String(preset || 'linear').toLowerCase();

          // Check for preset definitions first
          const presetDef = getPreset(p);
          if (presetDef) {
            setContrastIntent(presetDef.id, presetDef.params, 'preset');
            return { success: true, message: `Intent set to ${presetDef.label}` };
          }

          // Handle filmic with custom parameters
          if (p === 'filmic') {
            const gain = isFinite(params.filmicGain) ? Number(params.filmicGain) : 0.55;
            const shoulder = isFinite(params.shoulder) ? Number(params.shoulder) : 0.35;
            setContrastIntent('filmic', { filmicGain: gain, shoulder }, 'preset');
            try { saveCustomPrefs({ gain, shoulder }); } catch {}
            return { success: true, message: `Intent set to Filmic (gain=${gain.toFixed(2)}, shoulder=${shoulder.toFixed(2)})` };
          }
          if (p === 'gamma') {
            const g = isFinite(params.gamma) ? Number(params.gamma) : 1.00;
            // Explicit gamma mapped to custom_gamma so the exact value is used
            setContrastIntent('custom_gamma', { gamma: g }, 'custom');
            try { saveCustomPrefs({ gamma: g }); } catch {}
            return { success: true, message: `Custom Gamma intent applied (γ=${g.toFixed(2)})` };
          }
          return { success: false, message: `Unknown preset '${preset}'. Use linear | soft | hard | filmic | gamma.` };
        } catch (e) {
          return { success: false, message: `Error setting contrast intent: ${e.message}` };
        }
      }

      /** Apply custom intent using sliders (gamma or filmic-like) */
      applyCustomIntentSliders(params = {}) {
        try {
          const g = isFinite(params.gamma) ? Number(params.gamma) : 1.00;
          const gain = isFinite(params.gain) ? Number(params.gain) : 0.55;
          const shoulder = isFinite(params.shoulder) ? Number(params.shoulder) : 0.35;
          // Follow UI rule: if gain/shoulder deviate from defaults, treat as filmic; otherwise gamma
          if (Math.abs(gain - 0.55) > 1e-3 || Math.abs(shoulder - 0.35) > 1e-3) {
            try { saveCustomPrefs({ gain, shoulder }); } catch {}
            setContrastIntent('custom_filmic', { gain, shoulder }, 'custom');
            return { success: true, message: `Applied Custom Filmic intent (gain=${gain.toFixed(2)}, shoulder=${shoulder.toFixed(2)})` };
          } else {
            try { saveCustomPrefs({ gamma: g }); } catch {}
            setContrastIntent('custom_gamma', { gamma: g }, 'custom');
            return { success: true, message: `Applied Custom Gamma intent (γ=${g.toFixed(2)})` };
          }
        } catch (e) {
          return { success: false, message: `Error applying custom sliders: ${e.message}` };
        }
      }

      /** Parse and apply pasted CSV/JSON intent data */
      applyCustomIntentPaste(text) {
        try {
          const t = String(text || '').trim();
          if (!t) return { success: false, message: 'No data provided' };
          if (typeof parseIntentPaste !== 'function') return { success: false, message: 'Parser unavailable in this build' };
          const parsed = parseIntentPaste(t);
          if (parsed && parsed.ok && typeof parsed.targetFn === 'function') {
            const name = parsed.name || 'Custom (pasted)';
            try { saveCustomPrefs({ pasteText: t }); } catch {}
            setContrastIntent('custom_points', { name, targetFn: parsed.targetFn }, 'paste');
            return { success: true, message: `Applied Custom (pasted) intent${name ? `: ${name}` : ''}` };
          }
          return { success: false, message: parsed?.error || 'Could not parse pasted data' };
        } catch (e) {
          return { success: false, message: `Error applying pasted intent: ${e.message}` };
        }
      }

      /** Get current contrast intent info */
      getContrastIntent() {
        try {
          const info = { id: contrastIntent?.id || 'linear', name: contrastIntent?.name || 'Linear', params: contrastIntent?.params || {} };
          let hasSaved = false;
          try { hasSaved = hasSavedCustomIntent(); } catch {}
          return { success: true, message: 'OK', data: { ...info, hasSavedCustom: !!hasSaved } };
        } catch (e) {
          return { success: false, message: `Error reading contrast intent: ${e.message}` };
        }
      }

      /**
       * Load sample LAB data file
       * @returns {Object} Result with success status and message
       */
      loadSampleLabFile() {
        try {
          const downloadLink = document.getElementById('downloadSampleLabData');
          if (!downloadLink) {
            return {
              success: false,
              message: 'Sample LAB data download link not found'
            };
          }

          // Trigger the download/load of sample file
          downloadLink.click();

          return {
            success: true,
            message: 'Loading sample LAB measurement data file...',
            details: { action: 'sample_file_loaded', type: 'lab_data' }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error loading sample LAB data file: ${error.message}`
          };
        }
      }

      /**
       * Load LAB data from pasted text content
       * @param {string} labData - LAB measurement data (standard format)
       * @param {boolean} isGlobal - Whether to apply globally (true) or to specific channel (false)
       * @param {string} channelName - Channel name if isGlobal is false
       * @returns {Object} Result with success status and message
       */
      loadLabData(labData, isGlobal = true, channelName = null) {
        try {
          // Capture state before loading LAB data for proper undo functionality
          CurveHistory.captureState('Before loading pasted LAB data');
          
          // Validate channel if per-channel loading
          if (!isGlobal) {
            const currentPrinter = getCurrentPrinter();
            if (!channelName || !currentPrinter.channels.includes(channelName)) {
              return {
                success: false,
                message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
              };
            }
          }

          // Parse the LAB data using the existing parser
          let parseResult;
          try {
            parseResult = parseLabData(labData, isGlobal ? 'pasted_global_lab_data.txt' : `pasted_${channelName}_lab_data.txt`);
          } catch (error) {
            return {
              success: false,
              message: `Failed to parse LAB data: ${error.message || error}`
            };
          }

          if (!parseResult || !parseResult.samples || parseResult.samples.length === 0) {
            return {
              success: false,
              message: 'No valid LAB data points found. Expected format: GRAY_PERCENT LAB_L [LAB_A LAB_B]'
            };
          }

          // Apply the linearization data
          if (isGlobal) {
            // Set global linearization data (use the same variables as file loading)
            linearizationData = normalizeLinearizationEntry(parseResult);
            linearizationApplied = true;
            
            // Update UI
            const globalToggle = document.getElementById('globalLinearizationToggle');
            if (globalToggle) {
              globalToggle.disabled = false;
              globalToggle.checked = true;
              globalToggle.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Note: No auto-smoothing; wedgie inversion produces the base curve. Smoothing is optional via slider.

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            return {
              success: true,
              message: `Loaded global LAB data with ${parseResult.samples.length} measurement points. Global linearization enabled.`,
              details: { 
                type: 'global_lab_data', 
                points: parseResult.samples.length,
                range: `${parseResult.domainMin * 100}% to ${parseResult.domainMax * 100}%`
              }
            };

          } else {
            // Set per-channel linearization data (use the same variables as file loading)
            perChannelLinearization[channelName] = normalizeLinearizationEntry(parseResult);
            perChannelEnabled[channelName] = true;
            try { updateRevertButtonsState(); } catch {}

            // Update UI toggle for this channel
            const channelRow = getChannelRow(channelName);
            if (channelRow) {
              const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
                perChannelToggle.checked = true;
                perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }

            // Note: No auto-smoothing; wedgie inversion produces the base curve. Smoothing is optional via slider.

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            return {
              success: true,
              message: `Loaded LAB data for ${channelName} channel with ${parseResult.samples.length} measurement points. Channel linearization enabled.`,
              details: { 
                type: 'per_channel_lab_data',
                channel: channelName, 
                points: parseResult.samples.length,
                range: `${parseResult.domainMin * 100}% to ${parseResult.domainMax * 100}%`
              }
            };
          }

        } catch (error) {
          return {
            success: false,
            message: `Error loading LAB data: ${error.message}`
          };
        }
      }

      /**
       * Load sample LUT cube file
       * @returns {Object} Result with success status and message
       */
      loadSampleCubeFile() {
        try {
          const downloadLink = document.getElementById('downloadSampleCube');
          if (!downloadLink) {
            return {
              success: false,
              message: 'Sample cube download link not found'
            };
          }

          // Trigger the download/load of sample file
          downloadLink.click();

          return {
            success: true,
            message: 'Loading sample LUT cube file...',
            details: { action: 'sample_file_loaded', type: 'cube' }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error loading sample cube file: ${error.message}`
          };
        }
      }

      /**
       * Load cube data from pasted text content
       * @param {string} cubeData - Cube file data (1D or 3D LUT format)
       * @param {boolean} isGlobal - Whether to apply globally (true) or to specific channel (false)
       * @param {string} channelName - Channel name if isGlobal is false
       * @returns {Object} Result with success status and message
       */
      loadCubeData(cubeData, isGlobal = true, channelName = null) {
        try {
          // Validate channel if per-channel loading
          if (!isGlobal) {
            const currentPrinter = getCurrentPrinter();
            if (!channelName || !currentPrinter.channels.includes(channelName)) {
              return {
                success: false,
                message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
              };
            }
          }

          // Parse the cube data using the existing parser
          let parseResult;
          try {
            parseResult = parseCube1D(cubeData); // This will route to parseCube3D if needed
          } catch (error) {
            return {
              success: false,
              message: `Failed to parse cube data: ${error.message || error}`
            };
          }

          if (!parseResult || !parseResult.samples || parseResult.samples.length === 0) {
            return {
              success: false,
              message: 'No valid cube data found. Expected .cube format with DOMAIN_MIN/MAX and LUT data.'
            };
          }

          // Apply the linearization data
          if (isGlobal) {
            // Set global linearization data (use the same variables as file loading)
            linearizationData = normalizeLinearizationEntry(parseResult);
            linearizationApplied = true;
            
            // Update UI
            const globalToggle = document.getElementById('globalLinearizationToggle');
            if (globalToggle) {
              globalToggle.disabled = false;
              globalToggle.checked = true;
              globalToggle.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            const cubeType = parseResult.format || 'cube';
            return {
              success: true,
              message: `Loaded global cube data (${cubeType}) with ${parseResult.samples.length} points. Global linearization enabled.`,
              details: { 
                type: 'global_cube_data', 
                format: cubeType,
                points: parseResult.samples.length,
                range: `${parseResult.domainMin} to ${parseResult.domainMax}`
              }
            };

          } else {
            // Set per-channel linearization data (use the same variables as file loading)
            perChannelLinearization[channelName] = normalizeLinearizationEntry(parseResult);
            perChannelEnabled[channelName] = true;
            try { updateRevertButtonsState(); } catch {}

            // Update UI toggle for this channel
            const channelRow = getChannelRow(channelName);
            if (channelRow) {
              const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
                perChannelToggle.checked = true;
                perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            const cubeType = parseResult.format || 'cube';
            return {
              success: true,
              message: `Loaded cube data (${cubeType}) for ${channelName} channel with ${parseResult.samples.length} points. Channel linearization enabled.`,
              details: { 
                type: 'per_channel_cube_data',
                channel: channelName,
                format: cubeType,
                points: parseResult.samples.length,
                range: `${parseResult.domainMin} to ${parseResult.domainMax}`
              }
            };
          }

        } catch (error) {
          return {
            success: false,
            message: `Error loading cube data: ${error.message}`
          };
        }
      }

      /**
       * Copy curve from one channel to another
       * @param {string} sourceChannel - Channel to copy from
       * @param {string} targetChannel - Channel to copy to
       * @returns {Object} Result with success status and message
       */
      copyCurveToChannel(sourceChannel, targetChannel) {
        try {
          // Validate channels
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(sourceChannel)) {
            return {
              success: false,
              message: `Source channel '${sourceChannel}' not found. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }
          if (!currentPrinter.channels.includes(targetChannel)) {
            return {
              success: false,
              message: `Target channel '${targetChannel}' not found. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Check if source channel has a custom curve
          if (!loadedQuadData?.curves?.[sourceChannel]) {
            return {
              success: false,
              message: `No custom curve found for ${sourceChannel} channel. Generate or load a curve first.`
            };
          }

          // Copy the curve
          const sourceCurve = [...loadedQuadData.curves[sourceChannel]];
          
          // Apply the copied curve to target channel
          const result = this._applyCurveToChannel(targetChannel, sourceCurve);
          
          if (!result.success) {
            return result;
          }

          // Record action
          this._recordAction('copyCurveToChannel', { sourceChannel, targetChannel });
          updatePreview();
          // Refresh Edit Curves channel dropdown now that printer/channels are set
          try { if (typeof edit_populateChannelSelect === 'function') edit_populateChannelSelect(); } catch {}

          return {
            success: true,
            message: `Successfully copied curve from ${sourceChannel} to ${targetChannel} channel`,
            details: {
              source: sourceChannel,
              target: targetChannel,
              curveMaxValue: Math.max(...sourceCurve)
            }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error copying curve: ${error.message}`
          };
        }
      }

      /**
       * Generate and download the .quad file
       * @returns {Object} Result with success status and message
       */
      generateAndDownloadQuadFile() {
        try {
          // Generate the .quad file content using the existing buildFile function
          const quadContent = buildFile();
          
          if (!quadContent || quadContent.length === 0) {
            return {
              success: false,
              message: 'Failed to generate .quad file content. Check that channels are properly configured.'
            };
          }

          // Get the filename
          const filenameInput = document.getElementById('filenameInput');
          let filename;
          const customName = filenameInput ? filenameInput.value.trim() : '';
          
          if (customName) {
            // Remove .quad extension if user added it, then sanitize
            const cleanName = customName.replace(/\.quad$/, '');
            filename = `${sanitizeFilename(cleanName)}.quad`;
          } else {
            // Use auto-generated filename
            filename = `${generateFilename()}.quad`;
          }

          // Create download link and trigger download
          const blob = new Blob([quadContent], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.style.display = 'none';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          return {
            success: true,
            message: `Generated and downloaded '${filename}' successfully`,
            details: { 
              filename: filename,
              size: quadContent.length,
              channels: Object.keys(getCurrentPrinter().channels).length
            }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error generating .quad file: ${error.message}`
          };
        }
      }

      /**
       * Set the filename for the .quad file
       * @param {string} filename - Desired filename (without extension)
       * @returns {Object} Result with success status and message
       */
      setFilename(filename) {
        try {
          const filenameInput = document.getElementById('filenameInput');
          if (!filenameInput) {
            return {
              success: false,
              message: 'Filename input not found'
            };
          }

          // Sanitize filename - remove invalid characters
          const sanitized = filename
            .replace(/[<>:"/\\|?*]/g, '')  // Remove invalid file system characters
            .replace(/\s+/g, '_')          // Replace spaces with underscores
            .trim();

          if (!sanitized) {
            return {
              success: false,
              message: 'Filename cannot be empty after sanitization'
            };
          }

          // Set the filename
          filenameInput.value = sanitized;
          filenameInput.dataset.userEdited = 'true'; // Mark as user-edited to prevent auto-generation
          filenameInput.dispatchEvent(new Event('input', { bubbles: true }));

          return {
            success: true,
            message: `Filename set to '${sanitized}.quad'`,
            details: { filename: sanitized }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting filename: ${error.message}`
          };
        }
      }

      /**
       * Toggle global linearization
       * @param {boolean} enabled - Whether to enable global linearization
       * @returns {Object} Result with success status and message
       */
      setGlobalLinearization(enabled) {
        try {
          const globalToggle = document.getElementById('globalLinearizationToggle');
          if (!globalToggle) {
            return {
              success: false,
              message: 'Global linearization toggle not found'
            };
          }

          // Check if linearization file is loaded
          if (enabled && globalToggle.disabled) {
            return {
              success: false,
              message: 'Cannot enable global linearization - no linearization file loaded. Load a .cube, .txt, or .acv file first.'
            };
          }

          globalToggle.checked = enabled;
          globalToggle.dispatchEvent(new Event('change', { bubbles: true }));

          return {
            success: true,
            message: `Global linearization ${enabled ? 'enabled' : 'disabled'}`,
            details: { globalLinearization: enabled }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting global linearization: ${error.message}`
          };
        }
      }

      /** Toggle the Auto white limit rolloff checkbox */
      setAutoWhiteLimit(enabled) {
        try {
          const toggle = elements.autoWhiteLimitToggle;
          if (!toggle) {
            return { success: false, message: 'Auto white limit toggle not available in this build' };
          }
          const desired = !!enabled;
          toggle.checked = desired;
          toggle.dispatchEvent(new Event('change', { bubbles: true }));
          return { success: true, message: `Auto white limit ${desired ? 'enabled' : 'disabled'}` };
        } catch (error) {
          return { success: false, message: `Error setting auto white limit: ${error.message}` };
        }
      }

      /** Toggle the Auto black limit rolloff checkbox */
      setAutoBlackLimit(enabled) {
        try {
          const toggle = elements.autoBlackLimitToggle;
          if (!toggle) {
            return { success: false, message: 'Auto black limit toggle not available in this build' };
          }
          const desired = !!enabled;
          toggle.checked = desired;
          toggle.dispatchEvent(new Event('change', { bubbles: true }));
          return { success: true, message: `Auto black limit ${desired ? 'enabled' : 'disabled'}` };
        } catch (error) {
          return { success: false, message: `Error setting auto black limit: ${error.message}` };
        }
      }

      /**
       * Toggle per-channel linearization
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {boolean} enabled - Whether to enable linearization for this channel
       * @returns {Object} Result with success status and message
       */
      setPerChannelLinearization(channelName, enabled) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Find the channel row and toggle
          const channelRow = getChannelRow(channelName);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
          if (!perChannelToggle) {
            return {
              success: false,
              message: `Per-channel linearization toggle for '${channelName}' not found`
            };
          }

          // Check if linearization file is loaded for this channel
          if (enabled && perChannelToggle.disabled) {
            return {
              success: false,
              message: `Cannot enable linearization for ${channelName} - no linearization file loaded for this channel. Load a .cube, .txt, or .acv file first.`
            };
          }

          perChannelToggle.checked = enabled;
          perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));

          return {
            success: true,
            message: `${channelName} channel linearization ${enabled ? 'enabled' : 'disabled'}`,
            details: { channel: channelName, linearization: enabled }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting per-channel linearization: ${error.message}`
          };
        }
      }

      /**
       * Set interpolation method
       * @param {string} method - Interpolation method (pchip or linear)
       * @returns {Object} Result with success status and message
       */
      setInterpolationMethod(method) {
        try {
          const interpolationSelect = document.getElementById('curveSmoothingMethod');
          if (!interpolationSelect) {
            return {
              success: false,
              message: 'Interpolation selector not found'
            };
          }

          // Validate method
          const validMethods = ['pchip', 'linear'];
          if (!validMethods.includes(method)) {
            return {
              success: false,
              message: `Invalid interpolation method '${method}'. Available methods: PCHIP (monotonic), Linear (none)`
            };
          }

          // Set the interpolation method
          interpolationSelect.value = method;
          interpolationSelect.dispatchEvent(new Event('change', { bubbles: true }));

          const methodName = method === 'pchip' ? 'PCHIP (monotonic)' : 'Linear (none)';
          return {
            success: true,
            message: `Set interpolation method to ${methodName}`,
            details: { method: methodName }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting interpolation method: ${error.message}`
          };
        }
      }

      /**
       * Set data point smoothing percentage
       * @param {number} percentage - Smoothing percentage (0-90)
       * @returns {Object} Result with success status and message
       */
      setSmoothingPercentage(percentage) {
        try {
          const smoothingSlider = document.getElementById('smoothingSlider');
          const smoothingValue = document.getElementById('smoothingValue');
          
          if (!smoothingSlider) {
            return {
              success: false,
              message: 'Smoothing slider not found'
            };
          }

          // Validate percentage
          const clampedValue = Math.max(0, Math.min(90, percentage));
          if (clampedValue !== percentage) {
            return {
              success: false,
              message: `Invalid smoothing percentage '${percentage}'. Must be between 0 and 90.`
            };
          }

          // Set the smoothing value
          smoothingSlider.value = clampedValue;
          if (smoothingValue) {
            smoothingValue.textContent = `${clampedValue}%`;
          }
          smoothingSlider.dispatchEvent(new Event('input', { bubbles: true }));

          return {
            success: true,
            message: `Set data point smoothing to ${clampedValue}%`,
            details: { smoothing: clampedValue }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting smoothing percentage: ${error.message}`
          };
        }
      }

      /**
       * Set the chart zoom to a specific percentage max
       * @param {number} percent - Desired maximum percent (e.g., 60, 80, 100)
       */
      setChartZoom(percent) {
        try {
          const before = getChartZoomPercent();
          const after = setChartZoomPercent(percent, { persist: true, refresh: true });
          const changed = after !== before;
          return {
            success: true,
            message: changed ? `Chart zoom set to ${after}% max` : `Chart zoom already at ${after}% max`,
            details: { percent: after, changed }
          };
        } catch (error) {
          return {
            success: false,
            message: `Error setting chart zoom: ${error.message}`
          };
        }
      }

      /**
       * Step the chart zoom in or out by one preset level
       * @param {number} direction - Positive to zoom in, negative to zoom out
       */
      nudgeChartZoom(direction = 1) {
        try {
          const before = getChartZoomPercent();
          const after = stepChartZoom(direction, { persist: true, refresh: true });
          const changed = after !== before;
          const message = changed
            ? `Zoomed ${direction >= 0 ? 'in' : 'out'} to ${after}% max`
            : `Chart zoom already at limit (${after}% max)`;
          return {
            success: true,
            message,
            details: { percent: after, changed }
          };
        } catch (error) {
          return {
            success: false,
            message: `Error adjusting chart zoom: ${error.message}`
          };
        }
      }

      /**
       * Change the active printer
       * @param {string} printerName - Printer name (P600-P800 or P700P900)
       * @returns {Object} Result with success status and message
       */
      changePrinter(printerName) {
        try {
          const printerSelect = document.getElementById('printerSelect');
          if (!printerSelect) {
            return {
              success: false,
              message: 'Printer selector not found'
            };
          }

          // Validate printer name
          const validPrinters = ['P700P900', 'P5-7-9000', 'P800', 'P400', 'x900', '3880-7880', 'x800-x890', 'P4-6-8000'];
          if (!validPrinters.includes(printerName)) {
            return {
              success: false,
              message: `Invalid printer '${printerName}'. Available printers: ${validPrinters.join(', ')}`
            };
          }

          // Change the printer
          printerSelect.value = printerName;
          
          // Trigger the change event to update the UI
          printerSelect.dispatchEvent(new Event('change', { bubbles: true }));

          return {
            success: true,
            message: `Switched to ${printerName} printer`,
            details: { printer: printerName }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error changing printer: ${error.message}`
          };
        }
      }

      /**
       * Perform multiple channel enable/disable operations
       * @param {Array} operations - Array of {channelName, enabled} objects
       * @returns {Object} Result with success status and message
       */
      batchChannelOperations(operations) {
        try {
          const results = [];
          const errors = [];
          const channelActions = [];

          // Set flag to prevent individual action recording during batch operation
          CurveHistory.isBatchOperation = true;
          
          // First pass: collect current values and prepare batch action
          for (const operation of operations) {
            const channelRow = getChannelRow(operation.channelName);
            if (channelRow) {
              const checkbox = channelRow._virtualCheckbox;
              if (checkbox) {
                const oldValue = checkbox.checked;
                
                // Only record if there's an actual change
                if (oldValue !== operation.enabled) {
                  channelActions.push({
                    channelName: operation.channelName,
                    type: 'enable',
                    oldValue: oldValue,
                    newValue: operation.enabled
                  });
                }
              }
            }
          }

          // Second pass: apply all changes
          for (const operation of operations) {
            const result = this.enableDisableChannel(operation.channelName, operation.enabled);
            if (result.success) {
              results.push(result.message);
            } else {
              errors.push(result.message);
            }
          }
          
          // Clear flag and record the batch action
          CurveHistory.isBatchOperation = false;
          
          if (channelActions.length > 0) {
            const enabledCount = channelActions.filter(a => a.newValue).length;
            const disabledCount = channelActions.filter(a => !a.newValue).length;
            let description = '';
            if (enabledCount > 0 && disabledCount > 0) {
              description = `Batch enable ${enabledCount} and disable ${disabledCount} channels`;
            } else if (enabledCount > 0) {
              description = `Batch enable ${enabledCount} channels`;
            } else {
              description = `Batch disable ${disabledCount} channels`;
            }
            
            CurveHistory.recordBatchAction(description, channelActions);
          }

          if (errors.length > 0) {
            return {
              success: false,
              message: `Some operations failed: ${errors.join(', ')}. Successful: ${results.join(', ')}`
            };
          }

          return {
            success: true,
            message: `All operations completed: ${results.join(', ')}`,
            details: { operationCount: operations.length, results }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error performing batch operations: ${error.message}`
          };
        }
      }

      /**
       * Record the last action for potential undo functionality
       * @private
       */
      _recordAction(actionType, params) {
        this.lastAction = {
          type: actionType,
          params: params,
          timestamp: Date.now()
        };
        this.lastActionTime = new Date().toLocaleTimeString();
      }

      /**
       * Get information about the last action performed
       * @returns {Object|null} Last action details or null if no actions
       */
      getLastAction() {
        return this.lastAction;
      }

      /**
       * Generate a custom curve from natural language description
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {string} description - Natural language curve description
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @returns {Object} Result with success status and message
       */
      generateCurveFromDescription(channelName, description, interpolationType = 'smooth') {
        return {
          success: false,
          message: 'DEPRECATED: Natural-language curve generation is disabled. Compute numeric key points and call setAIKeyPoints.'
        };
      }

      /**
       * Generate a custom curve from key points for a specific channel
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {Array} keyPoints - Array of {input: number, output: number} objects (0-100 range)
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @returns {Object} Result with success status and message
       */
      generateCustomCurve(channelName, keyPoints, interpolationType = 'smooth') {
        try {
          // Validate channel
          const currentPrinter = getCurrentPrinter();
          if (!channelName || !currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Validate key points
          if (!Array.isArray(keyPoints) || keyPoints.length < 2) {
            return {
              success: false,
              message: 'At least 2 key points required for curve generation'
            };
          }

          // Validate and normalize key points
          const normalizedPoints = keyPoints.map((point, index) => {
            if (!point || typeof point.input !== 'number' || typeof point.output !== 'number') {
              throw new Error(`Invalid key point at index ${index}: must have 'input' and 'output' properties`);
            }
            return {
              input: Math.max(0, Math.min(100, point.input)),
              output: Math.max(0, Math.min(100, point.output))
            };
          });

          // Sort by input value
          normalizedPoints.sort((a, b) => a.input - b.input);

          // Ensure we have start and end points
          if (normalizedPoints[0].input !== 0) {
            normalizedPoints.unshift({ input: 0, output: 0 });
          }
          if (normalizedPoints[normalizedPoints.length - 1].input !== 100) {
            normalizedPoints.push({ input: 100, output: normalizedPoints[normalizedPoints.length - 1].output });
          }

          // Generate 256-point curve
          if (DEBUG_LOGS) console.log('Generating curve with key points:', normalizedPoints, 'interpolation:', interpolationType);
          const curve = this._interpolateCurve(normalizedPoints, interpolationType);

          // Apply curve to channel with key-point history extras
          const oldKP = window.loadedQuadData?.keyPoints?.[channelName] ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null;
          const oldMeta = window.loadedQuadData?.keyPointsMeta?.[channelName] || {};
          const oldInterp = oldMeta.interpolationType || 'smooth';
          const oldBaked = !!oldMeta.bakedGlobal;
          const newInterp = (interpolationType === 'linear' ? 'linear' : 'smooth');
          const extras = {
            oldKeyPoints: oldKP,
            newKeyPoints: normalizedPoints.map(p => ({ input: p.input, output: p.output })),
            oldInterpolation: oldInterp,
            newInterpolation: newInterp,
            oldBakedGlobal: oldBaked,
            newBakedGlobal: !!(window.loadedQuadData?.keyPointsMeta?.[channelName]?.bakedGlobal)
          };
          CurveHistory.recordKeyPointsChange(channelName, extras.oldKeyPoints, extras.newKeyPoints, extras.oldInterpolation, extras.newInterpolation);
          const result = this._applyCurveToChannel(channelName, curve, extras);
          
          if (!result.success) {
            return result;
          }
          // Persist Smart key points for overlay display (store normalized 0-100 inputs/outputs)
          try {
            ControlPoints.persist(channelName, normalizedPoints, interpolationType);
          } catch (e) {
          if (DEBUG_LOGS) console.warn('Could not persist Smart key points for overlay:', e);
          }

          // Record action and trigger update
          this._recordAction('generateCustomCurve', { channelName, keyPoints: normalizedPoints, interpolationType });
          updatePreview();

          return {
            success: true,
            message: `Generated custom ${interpolationType} curve for ${channelName} channel with ${keyPoints.length} key points`,
            details: {
              channelName,
              interpolationType,
              keyPointsCount: normalizedPoints.length,
              keyPoints: normalizedPoints.slice(0, 5) // summarize first up to 5 points
            }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error generating custom curve: ${error.message}`
          };
        }
      }

      /**
       * Generate curves from natural language description for multiple channels
       * @param {string} description - Natural language curve description
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @param {string|Array} channelFilter - 'all', 'enabled', or array of channel names
       * @returns {Object} Result with success status and message
       */
      generateGlobalCurveFromDescription(description, interpolationType = 'smooth', channelFilter = 'enabled') {
        return {
          success: false,
          message: 'DEPRECATED: Natural-language curve generation is disabled. Compute numeric key points and call generateGlobalCustomCurve or setAIKeyPoints.'
        };
      }

      /**
       * Generate custom curves from key points for multiple channels
       * @param {Array} keyPoints - Array of {input: number, output: number} objects (0-100 range)
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @param {string|Array} channelFilter - 'all', 'enabled', or array of channel names
       * @returns {Object} Result with success status and message
       */
      generateGlobalCustomCurve(keyPoints, interpolationType = 'smooth', channelFilter = 'enabled') {
        try {
          // Validate key points
          if (!Array.isArray(keyPoints) || keyPoints.length < 2) {
            return {
              success: false,
              message: 'At least 2 key points required for curve generation'
            };
          }

          // Determine target channels based on filter
          const currentPrinter = getCurrentPrinter();
          let targetChannels = [];
          
          if (channelFilter === 'all') {
            targetChannels = [...currentPrinter.channels];
          } else if (channelFilter === 'enabled') {
            // Find enabled channels
            targetChannels = currentPrinter.channels.filter(channelName => {
              const channelRow = getChannelRow(channelName);
              if (!channelRow) return false;
              const checkbox = channelRow._virtualCheckbox;
              return checkbox && checkbox.checked;
            });
          } else if (Array.isArray(channelFilter)) {
            // Validate specified channels exist
            targetChannels = channelFilter.filter(channelName => 
              currentPrinter.channels.includes(channelName)
            );
          } else {
            return {
              success: false,
              message: `Invalid channel filter '${channelFilter}'. Use 'all', 'enabled', or channel array.`
            };
          }

          if (targetChannels.length === 0) {
            return {
              success: false,
              message: channelFilter === 'enabled' ? 
                'No enabled channels found. Enable at least one channel first.' :
                'No valid channels found for the specified filter.'
            };
          }

          // Validate and normalize key points
          const normalizedPoints = keyPoints.map((point, index) => {
            if (!point || typeof point.input !== 'number' || typeof point.output !== 'number') {
              throw new Error(`Invalid key point at index ${index}: must have 'input' and 'output' properties`);
            }
            return {
              input: Math.max(0, Math.min(100, point.input)),
              output: Math.max(0, Math.min(100, point.output))
            };
          });

          // Sort by input value
          normalizedPoints.sort((a, b) => a.input - b.input);

          // Ensure we have start and end points
          if (normalizedPoints[0].input !== 0) {
            normalizedPoints.unshift({ input: 0, output: 0 });
          }
          if (normalizedPoints[normalizedPoints.length - 1].input !== 100) {
            normalizedPoints.push({ input: 100, output: normalizedPoints[normalizedPoints.length - 1].output });
          }

          // Generate 256-point curve
          if (DEBUG_LOGS) console.log('Generating global curve with key points:', normalizedPoints, 'interpolation:', interpolationType, 'channels:', targetChannels);
          const curve = this._interpolateCurve(normalizedPoints, interpolationType);

          // Set flag to prevent individual action recording during batch operation
          CurveHistory.isBatchOperation = true;
          const channelActions = [];
          const results = [];
          const errors = [];

          // Apply curve to each target channel
          for (const channelName of targetChannels) {
            try {
              // Capture old state before changing anything
              const channelRow = getChannelRow(channelName);
              if (!channelRow) {
                errors.push(`${channelName}: channel row not found`);
                continue;
              }
              
              const percentInput = channelRow.querySelector('.percent-input');
              const checkbox = channelRow._virtualCheckbox;
              
              const oldCurveData = window.loadedQuadData?.curves?.[channelName] ? 
                [...window.loadedQuadData.curves[channelName]] : null;
              const oldPercentage = percentInput ? percentInput.value : '0';
              const oldEnabled = checkbox ? checkbox.checked : false;
              const oldSource = window.loadedQuadData?.sources?.[channelName] || null;
              
              // Apply curve to channel
              const result = this._applyCurveToChannel(channelName, curve);
              
              if (result.success) {
                // Persist the same AI key points for each affected channel
                try {
                  ControlPoints.persist(channelName, normalizedPoints, interpolationType);
                } catch (e) {
                  if (DEBUG_LOGS) console.warn('Could not persist Smart key points for overlay (global):', channelName, e);
                }
                // Mark contributing linearization as edited for display
                markLinearizationEdited(channelName);
                // For global curve generation, we only need to record the curve changes
                // The curve undo will automatically restore the channel to its previous state
                channelActions.push({
                  channelName: channelName,
                  type: 'curve',
                  oldValue: oldCurveData,
                  newValue: [...curve],
                  oldKeyPoints: (window.loadedQuadData?.keyPoints?.[channelName]) ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null,
                  newKeyPoints: normalizedPoints.map(p => ({ input: p.input, output: p.output })),
                  oldInterpolation: window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth',
                  newInterpolation: interpolationType,
                  oldSource: oldSource,
                  newSource: 'smart'
                });
                
                results.push(`${channelName}: curve applied`);
              } else {
                errors.push(`${channelName}: ${result.message}`);
              }
            } catch (error) {
              errors.push(`${channelName}: ${error.message}`);
            }
          }

          // Record the batch action first, then clear flag after debounced handlers have time to execute
          if (DEBUG_LOGS) console.log('🔄 Recording batch action and scheduling flag clear');
          
          if (channelActions.length > 0) {
            const curveType = normalizedPoints.length <= 3 ? 'simple' : 'complex';
            const batchDescription = `Generate global ${interpolationType} ${curveType} curve for ${channelActions.length} channels`;
            CurveHistory.recordBatchAction(batchDescription, channelActions);
            if (DEBUG_LOGS) console.log('✅ Batch action recorded successfully');
            
            // Clear batch flag after debounced handlers have time to execute (1.5 seconds)
            setTimeout(() => {
              if (DEBUG_LOGS) console.log('🔄 Clearing batch operation flag after timeout');
              CurveHistory.isBatchOperation = false;
            }, 1500);
          } else {
            if (DEBUG_LOGS) console.log('⚠️ No channel actions to record');
            // Clear flag immediately if no actions
            CurveHistory.isBatchOperation = false;
          }

          // Record action for internal tracking
          this._recordAction('generateGlobalCustomCurve', { 
            keyPoints: normalizedPoints, 
            interpolationType, 
            channelFilter,
            affectedChannels: targetChannels 
          });

          // CRITICAL: Trigger graph redraw for all affected channels
          updatePreview();
          
          // Additional deferred update to ensure all DOM changes are processed
          setTimeout(() => {
              
            // Force refresh each affected channel's display
            for (const channelName of targetChannels) {
              const channelRow = getChannelRow(channelName);
              if (channelRow && channelRow.refreshDisplayFn) {
                channelRow.refreshDisplayFn();
              }
            }
            
            updatePreview();
          }, 100);

          // Return results
          if (errors.length > 0 && results.length === 0) {
            return {
              success: false,
              message: `All curve generations failed: ${errors.join(', ')}`
            };
          } else if (errors.length > 0) {
            return {
              success: true,
              message: `Partial success: ${results.length} curves generated, ${errors.length} failed. Successful: ${results.join(', ')}. Failed: ${errors.join(', ')}`,
              details: { 
                successCount: results.length, 
                errorCount: errors.length,
                affectedChannels: channelActions.map(a => a.channelName)
              }
            };
          } else {
            return {
              success: true,
              message: `Generated global ${interpolationType} curve for ${channelActions.length} channels: ${channelActions.map(a => a.channelName).join(', ')}`,
              details: { 
                affectedChannels: channelActions.map(a => a.channelName),
                keyPoints: keyPoints.length,
                interpolationType
              }
            };
          }

        } catch (error) {
          // Clear flag in case of error
          setTimeout(() => {
            CurveHistory.isBatchOperation = false;
          }, 1500);
          return {
            success: false,
            message: `Error generating global custom curve: ${error.message}`
          };
        }
      }

      /**
       * Generate global linearization curve from natural language description
       * @param {string} description - Natural language curve description
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @param {number} pointCount - Number of curve points to generate (default 256)
       * @returns {Object} Result with success status and message
       */
      generateGlobalLinearizationFromDescription(description, interpolationType = 'smooth', pointCount = 256) {
        return { success: false, message: 'DEPRECATED: Natural-language global linearization is disabled. Compute numeric key points and use generate_global_custom_curve or setAIKeyPoints per channel.' };
      }

      /**
       * Interpolate curve from key points to 256 data points
       * @param {Array} keyPoints - Sorted array of {input, output} points (0-100 range)
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @returns {Array} 256-point curve array scaled to TOTAL
       * @private
       */
      _interpolateCurve(keyPoints, interpolationType) {
        const curve = new Array(N);
        
        for (let i = 0; i < N; i++) {
          const inputPercent = (i / DENOM) * 100; // Convert index to 0-100 range
          let outputPercent;

          // Find surrounding key points
          let leftPoint = null;
          let rightPoint = null;

          for (let j = 0; j < keyPoints.length - 1; j++) {
            if (inputPercent >= keyPoints[j].input && inputPercent <= keyPoints[j + 1].input) {
              leftPoint = keyPoints[j];
              rightPoint = keyPoints[j + 1];
              break;
            }
          }

          if (!leftPoint || !rightPoint) {
            // Fallback: clamp to nearest point
            if (inputPercent <= keyPoints[0].input) {
              outputPercent = keyPoints[0].output;
            } else {
              outputPercent = keyPoints[keyPoints.length - 1].output;
            }
          } else if (interpolationType === 'linear' || leftPoint.input === rightPoint.input) {
            // Linear interpolation
            const t = leftPoint.input === rightPoint.input ? 0 : 
                     (inputPercent - leftPoint.input) / (rightPoint.input - leftPoint.input);
            outputPercent = leftPoint.output + t * (rightPoint.output - leftPoint.output);
          } else {
            // Use PCHIP interpolation for smooth, monotonic curves (from working v1.5)
            const x = keyPoints.map(p => p.input);
            const y = keyPoints.map(p => p.output);
            outputPercent = this._pchipInterpolate(x, y, inputPercent);
          }

          // Convert to TOTAL scale and clamp
          if (isNaN(outputPercent)) {
            console.error('❌ NaN outputPercent at index', i, 'inputPercent:', inputPercent, 'interpolationType:', interpolationType);
            console.error('❌ Left/Right points:', { leftPoint, rightPoint });
          }
          curve[i] = Math.round(Math.max(0, Math.min(TOTAL, (outputPercent / 100) * TOTAL)));
          if (isNaN(curve[i])) {
            console.error('❌ NaN in final curve at index', i, 'outputPercent:', outputPercent, 'TOTAL:', TOTAL);
          }
        }

        return curve;
      }


      /**
       * Parse photography curve description into key points
       * @param {string} description - Natural language curve description
       * @returns {Object} Result with success status and keyPoints array
       * @private
       */
      /**
       * ⚠️  CRITICAL: DO NOT REPLACE THIS INTERPOLATION METHOD ⚠️
       * PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) interpolation
       * 
       * THIS IS THE ONLY APPROVED METHOD FOR SMOOTH INTERPOLATION
       * - VERIFIED WORKING in v1.5 for natural language curve generation
       * - Avoids horizontal flattening (smoothstep problem)
       * - Avoids sharp corners (linear problem)  
       * - Avoids overshooting (spline problem)
       * - DO NOT replace with Catmull-Rom, smoothstep, cosine, or other methods
       * 
       * @param {number[]} x - Input values (sorted ascending)
       * @param {number[]} y - Output values corresponding to x
       * @param {number} xi - Input value to interpolate at
       * @returns {number} Interpolated output value
       */
      _pchipInterpolate(x, y, xi) {
        // Development reminder about this critical method
        if (this._pchipWarningShown !== true) {
          console.warn('🚨 PCHIP INTERPOLATION IN USE: This is the ONLY approved smooth interpolation method. DO NOT replace with other methods.');
          this._pchipWarningShown = true;
        }
        
        const n = x.length;
        
        // Handle edge cases
        if (n < 2) return y[0] || 0;
        if (xi <= x[0]) return y[0];
        if (xi >= x[n - 1]) return y[n - 1];
        
        // Find the interval containing xi
        let i = 0;
        for (i = 0; i < n - 1; i++) {
          if (xi >= x[i] && xi <= x[i + 1]) break;
        }
        
        // Calculate slopes (derivatives) at each point
        const slopes = new Array(n);
        const h = new Array(n - 1);
        const delta = new Array(n - 1);
        
        // Calculate intervals and finite differences
        for (let j = 0; j < n - 1; j++) {
          h[j] = x[j + 1] - x[j];
          delta[j] = (y[j + 1] - y[j]) / h[j];
        }
        
        // Calculate slopes using PCHIP method
        slopes[0] = delta[0]; // First point - use forward difference
        slopes[n - 1] = delta[n - 2]; // Last point - use backward difference
        
        for (let j = 1; j < n - 1; j++) {
          // Interior points - use monotonic slope calculation
          if (delta[j - 1] * delta[j] <= 0) {
            slopes[j] = 0; // Local extremum
          } else {
            // Weighted average of neighboring slopes
            const w1 = 2 * h[j] + h[j - 1];
            const w2 = h[j] + 2 * h[j - 1];
            slopes[j] = (w1 + w2) / (w1 / delta[j - 1] + w2 / delta[j]);
          }
        }
        
        // Perform cubic Hermite interpolation
        const x0 = x[i];
        const x1 = x[i + 1];
        const y0 = y[i];
        const y1 = y[i + 1];
        const m0 = slopes[i];
        const m1 = slopes[i + 1];
        
        const t = (xi - x0) / (x1 - x0);
        const t2 = t * t;
        const t3 = t2 * t;
        
        const h00 = 2 * t3 - 3 * t2 + 1;
        const h10 = t3 - 2 * t2 + t;
        const h01 = -2 * t3 + 3 * t2;
        const h11 = t3 - t2;
        
        return h00 * y0 + h10 * (x1 - x0) * m0 + h01 * y1 + h11 * (x1 - x0) * m1;
      }

      _parsePhotographyCurveDescription(description) {
        return { success: false, message: 'DEPRECATED: Natural-language curve parsing is disabled. Compute numeric key points and use setAIKeyPoints.' };
      }

      /**
       * Apply a curve to a specific channel by setting it as loaded curve data
       * @param {string} channelName - Channel name
       * @param {Array} curve - 256-point curve array
       * @returns {Object} Result object
       * @private
       */
      _applyCurveToChannel(channelName, curve, historyExtras = null) {
        try {
          // Find the channel row
          const channelRow = getChannelRow(channelName);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          // Initialize loadedQuadData if it doesn't exist (ensure global scope)
          if (!window.loadedQuadData) {
            window.loadedQuadData = { curves: {}, sources: {} };
          }
          if (!window.loadedQuadData.curves) {
            window.loadedQuadData.curves = {};
          }
          if (!window.loadedQuadData.sources) {
            window.loadedQuadData.sources = {};
          }

          // Capture old curve data before changing it
          const oldCurveData = window.loadedQuadData.curves[channelName] ? 
            [...window.loadedQuadData.curves[channelName]] : null;
          
          // Record the curve change action (only if not during batch operation or restore)
          if (!CurveHistory.isBatchOperation && !CurveHistory.isRestoring) {
            // Prefer explicit extras; otherwise consume pending key-point change recorded earlier
            let extras = historyExtras;
            if (!extras) {
              const pending = CurveHistory._pendingKeyPoints?.[channelName];
              if (pending) {
                extras = { ...pending };
                delete CurveHistory._pendingKeyPoints[channelName];
              } else {
                const existingKP = window.loadedQuadData?.keyPoints?.[channelName];
                if (existingKP) {
                  const meta = window.loadedQuadData?.keyPointsMeta?.[channelName] || {};
                  extras = { oldKeyPoints: existingKP.map(p => ({ input: p.input, output: p.output })), oldInterpolation: meta.interpolationType, oldBakedGlobal: !!meta.bakedGlobal };
                }
              }
            }
            // Ensure bakedGlobal meta is captured for undo path
            try {
              const _existingMeta = window.loadedQuadData?.keyPointsMeta?.[channelName] || {};
              if (extras && typeof extras === 'object' && typeof extras.oldBakedGlobal === 'undefined') {
                extras.oldBakedGlobal = !!_existingMeta.bakedGlobal;
              }
            } catch {}

            // Attach source transition metadata for accurate undo/redo labeling
            if (!extras || typeof extras !== 'object') extras = {};
            const oldSource = window.loadedQuadData?.sources?.[channelName] || null;
            extras.oldSource = oldSource;
            extras.newSource = 'smart';
            CurveHistory.recordChannelAction(channelName, 'curve', oldCurveData, [...curve], extras);
          } else {
          if (DEBUG_LOGS) console.log(`⏭️ Skipping individual curve action for ${channelName} (in batch mode)`);
          }

          // Store the curve in the global loadedQuadData and mark as Smart source
          window.loadedQuadData.curves[channelName] = [...curve];
          window.loadedQuadData.sources[channelName] = 'smart';
          
          // Keep any existing per-channel linearization metadata so the UI can still display the source filename.
          // Just ensure it is disabled to avoid double-processing while a Smart Curve is active.
          if (perChannelLinearization[channelName]) {
            perChannelEnabled[channelName] = false;
          }
          
          // Update UI for Smart Curve (different from file-loaded linearization)
          const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
          const perChannelBtn = channelRow.querySelector('.per-channel-btn');
          
          // For Smart Curves, disable the per-channel linearization toggle since the curve is applied directly
          if (perChannelToggle) {
            perChannelToggle.disabled = true;
            perChannelToggle.checked = false;
            perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));
          }
          
          if (perChannelBtn) {
            const base = perChannelFilenames[channelName] || 'unknown file';
            const edited = !!(perChannelLinearization[channelName] && perChannelLinearization[channelName].edited);
            const disp = getEditedDisplayName(base, edited);
            const tip = perChannelLinearization[channelName]
              ? `Loaded: ${disp} (disabled; Smart Curve applied)`
              : `Smart Curve: ${curve.length} point curve (applied directly)`;
            perChannelBtn.setAttribute('data-tooltip', tip);
          }
          
          // Update interpolation controls since we now have linearization data
          if (typeof updateInterpolationControls === 'function') {
            updateInterpolationControls();
          }
          

          // Preserve existing scaling: only adjust percentage automatically if channel is currently disabled
          const currentEndValue = parseInt(channelRow.querySelector('.end-input').value) || 0;
          const percentInput = channelRow.querySelector('.percent-input');
          const endInput = channelRow.querySelector('.end-input');
          const checkbox = channelRow._virtualCheckbox;
          
          if (!CurveHistory.isRestoring && percentInput && endInput && currentEndValue === 0) {
            // Channel is disabled: set a reasonable starting percentage based on curve amplitude
            const maxCurveValue = Math.max(...curve);
            const suggestedPercent = Math.max(20, Math.min(100, Math.round((maxCurveValue / TOTAL) * 100)));
            
            percentInput.value = suggestedPercent;
            percentInput.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Enable the channel checkbox if it was disabled
            if (checkbox && !checkbox.checked) {
              checkbox.checked = true;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
            
            // Force visual state refresh to ensure disabled channel transparency is removed
            const refreshDisplayFn = channelRow.refreshDisplayFn;
            if (refreshDisplayFn) {
              setTimeout(() => { refreshDisplayFn(); }, 10);
            }
          }

          // Force preview update after all DOM changes are complete
          if (typeof updatePreview === 'function') {
            updatePreview();
          }
          
          // Update processing detail for this channel
          if (typeof updateProcessingDetail === 'function') {
            updateProcessingDetail(channelName);
          }
          
          return {
            success: true,
            message: `Applied custom curve to ${channelName} channel`
          };

        } catch (error) {
          return {
            success: false,
            message: `Error applying curve to channel: ${error.message}`
          };
        }
      }

      /**
       * Get stored Smart key points for a channel (deep copy)
       */
      getAIKeyPoints(channelName) {
        try {
          channelName = this._resolveChannel(channelName);
          const { points: kp, interpolation: interp } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const suggestion = `No Smart key points yet for ${channelName}. They will be created automatically on first edit. Example: adjust_smart_key_point_by_index(ordinal=2, outputPercent=90) or insert_smart_key_point_at(inputPercent=50, outputPercent=50).`;
            return {
              success: true,
              channelName,
              keyPoints: [],
              interpolationType: (interp || 'smooth'),
              created: false,
              canAutoCreateOnEdit: true,
              message: suggestion,
              nextActions: [
                { name: 'adjust_smart_key_point_by_index', params: { ordinal: 2, outputPercent: 90 } },
                { name: 'insert_smart_key_point_at', params: { inputPercent: 50, outputPercent: 50 } }
              ]
            };
          }
          const list = kp.map(p => `${Math.round(p.input)},${Math.round(p.output)}`).join(' ');
          const msg = `Key points (${channelName}): ${list}`;
          return { success: true, channelName, keyPoints: kp.map(p => ({ input: p.input, output: p.output })), interpolationType: interp, message: msg };
        } catch (e) {
          return { success: false, message: `Error getting Smart key points: ${e.message}` };
        }
      }

      /**
       * Set Smart key points for a channel and apply the resulting curve
       */
      setAIKeyPoints(channelName, points, interpolationType = 'smooth') {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          if (!Array.isArray(points) || points.length < 2) {
            return { success: false, message: 'At least 2 key points are required' };
          }
          // Normalize and clamp via ControlPoints
          const norm = ControlPoints.normalize(points);
          // Interpolate to 256-point curve
          const curve = this._interpolateCurve(norm, interpolationType === 'linear' ? 'linear' : 'smooth');
          // Record key-point change for history linkage and apply curve
          const oldKP = window.loadedQuadData?.keyPoints?.[channelName] ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null;
          const oldInterp = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth';
          const extras = {
            oldKeyPoints: oldKP,
            newKeyPoints: norm.map(p => ({ input: p.input, output: p.output })),
            oldInterpolation: oldInterp,
            newInterpolation: (interpolationType === 'linear' ? 'linear' : 'smooth')
          };
          CurveHistory.recordKeyPointsChange(channelName, extras.oldKeyPoints, extras.newKeyPoints, extras.oldInterpolation, extras.newInterpolation);
          // Persist Smart key points BEFORE applying curve so downstream UI reflects latest counts
          ControlPoints.persist(channelName, norm, interpolationType);
          try {
            if (!window.loadedQuadData) window.loadedQuadData = {};
            if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
            window.loadedQuadData.keyPointsMeta[channelName] = {
              ...(window.loadedQuadData.keyPointsMeta[channelName] || {}),
              interpolationType: (interpolationType === 'linear' ? 'linear' : 'smooth')
            };
          } catch {}
          const applied = this._applyCurveToChannel(channelName, curve, extras);
          if (!applied.success) return applied;
          // Mark any contributing linearization as edited for display
          markLinearizationEdited(channelName);
          updatePreview();
          // Ensure processing panel reflects latest key-point count (in case panel was already open)
          if (typeof updateProcessingDetail === 'function') {
            updateProcessingDetail(channelName);
          }
          this._recordAction('setAIKeyPoints', { channelName, points: norm, interpolationType });
          return { success: true, message: `Updated Smart key points for ${channelName} (${norm.length} points)`, details: { keyPoints: norm } };
        } catch (e) {
          return { success: false, message: `Error setting Smart key points: ${e.message}` };
        }
      }

      /**
       * Extract adaptive Smart key points from the current curve (prefers loaded .quad curve if available)
       * and apply them to a channel. Useful for turning dense .quad data into an editable sparse set.
       */
      simplifyAIKeyPointsFromCurve(channelName, options = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          const row = getChannelRow(channelName);
          const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input').value) : TOTAL;
          // Always use the currently plotted curve so recompute respects global/per-channel corrections and End
          const values = make256(endVal, channelName, true);
          const maxErrorPercent = Math.max(0.05, Math.min(5, options.maxErrorPercent || KP_SIMPLIFY.maxErrorPercent || 1.0));
      const maxPoints = Math.max(2, Math.min(21, options.maxPoints || KP_SIMPLIFY.maxPoints || 21));
          const keyPoints = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent, maxPoints });
          const res = this.setAIKeyPoints(channelName, keyPoints, 'smooth');
          // Mark Smart points as baked-from-global if a global correction is active at recompute time
          try {
            if (res && res.success && linearizationApplied && linearizationData) {
              if (!window.loadedQuadData) window.loadedQuadData = {};
              if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
              const autoWhiteOn = !!(elements?.autoWhiteLimitToggle?.checked);
              const autoBlackOn = !!(elements?.autoBlackLimitToggle?.checked);
              window.loadedQuadData.keyPointsMeta[channelName] = {
                ...(window.loadedQuadData.keyPointsMeta[channelName] || {}),
                bakedGlobal: true,
                bakedAutoLimit: autoWhiteOn || autoBlackOn,
                bakedAutoWhite: autoWhiteOn,
                bakedAutoBlack: autoBlackOn
              };
              // Also tag the most recent curve action for this channel so redo restores bakedGlobal
              try {
                for (let i = CurveHistory.history.length - 1; i >= 0; i--) {
                  const entry = CurveHistory.history[i];
                  if (entry && entry.kind === 'channel') {
                    const a = entry.action;
                    if (a && a.type === 'curve' && a.channelName === channelName) {
                      a.newBakedGlobal = true;
                      break;
                    }
                  }
                }
              } catch {}
            }
          } catch {}
          return res;
        } catch (e) {
          return { success: false, message: `Error simplifying Smart key points: ${e.message}` };
        }
      }

      /**
       * Set AI key points for multiple channels as a single batch action
       * entries: [{ channelName, keyPoints, interpolationType }]
       */
      setAIKeyPointsBatch(entries = []) {
        try {
          if (!Array.isArray(entries) || entries.length === 0) {
            return { success: false, message: 'entries must be a non-empty array' };
          }

          // Begin batch
          CurveHistory.isBatchOperation = true;
          const channelActions = [];
          const results = [];
          const errors = [];

          for (const entry of entries) {
            try {
              let { channelName, keyPoints, interpolationType } = entry || {};
              channelName = this._resolveChannel(channelName);
              if (!Array.isArray(keyPoints) || keyPoints.length < 2) {
                errors.push(`${channelName}: at least 2 key points required`);
                continue;
              }
              const norm = ControlPoints.normalize(keyPoints);
              const interp = (interpolationType === 'linear' ? 'linear' : 'smooth');

              // Capture old state
              const oldCurveData = window.loadedQuadData?.curves?.[channelName] ?
                [...window.loadedQuadData.curves[channelName]] : null;
              const oldKP = window.loadedQuadData?.keyPoints?.[channelName] ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null;
              const oldInterp = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth';
              const oldSource = window.loadedQuadData?.sources?.[channelName] || null;

              // Generate curve and persist key points before applying (so UI counts are up to date)
              const curve = this._interpolateCurve(norm, interp);
              try { ControlPoints.persist(channelName, norm, interp); } catch (e) { console.warn('Persist KP (batch) failed:', channelName, e); }
              try {
                if (!window.loadedQuadData) window.loadedQuadData = {};
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                window.loadedQuadData.keyPointsMeta[channelName] = {
                  ...(window.loadedQuadData.keyPointsMeta[channelName] || {}),
                  interpolationType: (interp === 'linear' ? 'linear' : 'smooth')
                };
              } catch {}

              const extras = { oldKeyPoints: oldKP, newKeyPoints: norm.map(p => ({ input: p.input, output: p.output })), oldInterpolation: oldInterp, newInterpolation: interp };
              const applied = this._applyCurveToChannel(channelName, curve, extras);
              if (!applied.success) { errors.push(`${channelName}: ${applied.message}`); continue; }

              markLinearizationEdited(channelName);

              channelActions.push({
                channelName,
                type: 'curve',
                oldValue: oldCurveData,
                newValue: [...curve],
                oldKeyPoints: oldKP,
                newKeyPoints: norm.map(p => ({ input: p.input, output: p.output })),
                oldInterpolation: oldInterp,
                newInterpolation: interp,
                oldSource: oldSource,
                newSource: 'smart'
              });
              results.push(`${channelName}: ${norm.length} key points`);

            } catch (err) {
              errors.push(`${entry?.channelName || 'unknown'}: ${err.message}`);
            }
          }

          // Record batch action and clear flag after debounce window
          if (channelActions.length > 0) {
            const batchDescription = `Batch set Smart key points for ${channelActions.length} channel(s)`;
            CurveHistory.recordBatchAction(batchDescription, channelActions);
            setTimeout(() => { CurveHistory.isBatchOperation = false; }, 1500);
          } else {
            CurveHistory.isBatchOperation = false;
          }

          // Refresh UI
          updatePreview();
          try {
            const current = getCurrentPrinter();
            current.channels.forEach((name) => { if (typeof updateProcessingDetail === 'function') updateProcessingDetail(name); });
          } catch {}

          if (errors.length > 0 && results.length === 0) {
            return { success: false, message: `All operations failed: ${errors.join('; ')}` };
          }
          if (errors.length > 0) {
            return { success: true, message: `Partial success. ${results.length} updated, ${errors.length} failed. ${errors.join('; ')}`, details: { updated: results, errors } };
          }
          return { success: true, message: `Updated Smart key points for ${results.length} channel(s).`, details: { updated: results } };

        } catch (e) {
          CurveHistory.isBatchOperation = false;
          return { success: false, message: `Batch set Smart key points failed: ${e.message}` };
        }
      }

      /**
       * Adjust a single Smart key point by ordinal (1-based, endpoints included)
       * Supports absolute or delta changes to input (X) and output (Y)
       */
      adjustAIKeyPointByIndex(channelName, ordinal, params = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          if (typeof ordinal !== 'number' || ordinal < 1 || ordinal > kp.length) {
            return { success: false, message: `Invalid ordinal ${ordinal}. Valid range: 1..${kp.length}` };
          }
          const gap = ControlPolicy.minGap;
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          const idx = ordinal - 1;
          let target = points[idx];
          // Compute new values
          let newInput = target.input;
          let newOutput = target.output;
          if (typeof params.inputPercent === 'number') newInput = params.inputPercent;
          if (typeof params.deltaInput === 'number') newInput = newInput + params.deltaInput;
          if (typeof params.deltaOutput === 'number') newOutput = newOutput + params.deltaOutput;
          // If an absolute output is provided, convert to pre-scale; may require End increase
          if (typeof params.outputPercent === 'number') {
            try {
              const row = getChannelRow(channelName);
              const endEl = row?.querySelector('.end-input');
              const pctEl = row?.querySelector('.percent-input');
              let endVal = InputValidator.clampEnd(endEl?.value || 0);
              const endLocked = !!(row?.hasAttribute('data-user-disabled') || endEl?.disabled || pctEl?.disabled);
              const oldScale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              const desiredAbs = Math.max(0, Math.min(100, params.outputPercent));
              let scale = (InputValidator.computePercentFromEnd(endVal)) / 100; // fraction of TOTAL
              if (scale <= 0 && desiredAbs > 0) {
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                // Channel effectively at 0%; raise End to minimally satisfy desiredAbs at pre-scale 100
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                }
                endVal = neededEnd;
                scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              }
              const pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
              if (pre > 100 + 1e-6) {
                // Need to increase End so pre-scale stays within [0,100]
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                if (neededEnd > endVal && endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  // Recompute scale
                  scale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                }
              }
              // Final pre-scale target under current/new scale
              newOutput = Math.max(0, Math.min(100, (scale > 0) ? (desiredAbs / scale) : desiredAbs));
              // If End increased (scale > oldScale), scale all other points down to keep their absolute outputs constant
              if (scale > oldScale + 1e-6) {
                const factor = oldScale / scale;
                for (let j = 0; j < points.length; j++) {
                  if (j === idx) continue;
                  points[j].output = ControlPolicy.clampY(points[j].output * factor);
                }
              }
            } catch (e) {
              console.warn('Absolute-to-prescale conversion failed:', e);
              newOutput = Math.max(0, Math.min(100, params.outputPercent));
            }
          }
          // Clamp output after conversions
          newOutput = Math.max(0, Math.min(100, newOutput));
          // Bounds for input to maintain order
          const prevX = idx > 0 ? points[idx - 1].input : 0;
          const nextX = idx < points.length - 1 ? points[idx + 1].input : 100;
          const minX = idx === 0 ? 0 : prevX + gap;
          const maxX = idx === points.length - 1 ? 100 : nextX - gap;
          newInput = Math.max(minX, Math.min(maxX, newInput));

          // Endpoint edits: interpret requested output as absolute axis % (0-100) and
          // convert to pre-scale percent so final (after End scaling) hits the requested value.
          if (idx === points.length - 1 && typeof params.outputPercent === 'number') {
            try {
              const row = getChannelRow(channelName);
              const endInput = row?.querySelector('.end-input');
              if (endInput) {
                const endVal = InputValidator.clampEnd(endInput.value);
                const endPercentOfTotal = InputValidator.computePercentFromEnd(endVal); // 0..100 of TOTAL
                const scale = Math.max(0, endPercentOfTotal) / 100; // fraction of TOTAL
                if (scale > 0) {
                  // We need pre-scale output so that (pre * scale) = requestedAbsolute
                  const desiredAbs = Math.max(0, Math.min(100, params.outputPercent));
                  newOutput = Math.max(0, Math.min(100, desiredAbs / scale));
                } else {
                  // End=0, keep as-is but clamp
                  newOutput = Math.max(0, Math.min(100, params.outputPercent));
                }
              }
            } catch (e) {
              console.warn('Endpoint absolute conversion failed:', e);
              newOutput = Math.max(0, Math.min(100, params.outputPercent));
            }
          }
          // Apply and re-set
          const preScaleEndpointPercent = (idx === points.length - 1 && typeof params.outputPercent === 'number')
            ? (function(){
                try {
                  const row = getChannelRow(channelName);
                  const endVal = InputValidator.clampEnd(row?.querySelector('.end-input')?.value || 0);
                  const endPct = InputValidator.computePercentFromEnd(endVal);
                  const scale = Math.max(0, endPct) / 100;
                  const desiredAbs = Math.max(0, Math.min(100, params.outputPercent));
                  if (scale > 0) return Math.max(0, Math.min(100, desiredAbs / scale));
                  return desiredAbs; // End=0 edge case
                } catch { return newOutput; }
              })()
            : null;

          points[idx] = { input: newInput, output: newOutput };
          const res = this.setAIKeyPoints(channelName, points, interpType);
          try {
            if (res && res.success && preScaleEndpointPercent !== null && window.loadedQuadData?.curves?.[channelName]) {
              const enforced = Math.round((Math.max(0, Math.min(100, preScaleEndpointPercent)) / 100) * TOTAL);
              const arr = window.loadedQuadData.curves[channelName];
              if (Array.isArray(arr) && arr.length === 256) {
                arr[arr.length - 1] = enforced;
              }
              if (typeof updatePreview === 'function') updatePreview();
              if (typeof updateProcessingDetail === 'function') updateProcessingDetail(channelName);
            }
          } catch (e) { console.warn('Endpoint enforcement failed:', e); }
          return res;
        } catch (e) {
          return { success: false, message: `Error adjusting Smart key point: ${e.message}` };
        }
      }

      /**
       * Insert a new AI key point at a specific input (X). If output (Y) omitted, sample current Smart Curve at X.
       */
      insertAIKeyPointAt(channelName, inputPercent, outputPercent = null) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          let x = typeof inputPercent === 'number' ? inputPercent : null;
          if (x === null || isNaN(x)) {
            return { success: false, message: 'inputPercent is required and must be a number (0-100).' };
          }
          x = Math.max(0, Math.min(100, x));
          // Prevent inserting directly on top of an existing X (within duplicateTolerance)
          const dupIdx0 = ControlPoints.nearestIndex(kp, x, ControlPolicy.duplicateTolerance);
          if (dupIdx0 !== null) {
            const existing = kp[dupIdx0];
            return { success: false, message: `A key point already exists at ${existing.input.toFixed(3)}%.` };
          }
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          // Ensure sorted by input
          points.sort((a, b) => a.input - b.input);
          const gap = ControlPolicy.minGap;
          // Find neighbors
          let insertIndex = 0;
          while (insertIndex < points.length && points[insertIndex].input < x) insertIndex++;
          const left = insertIndex > 0 ? points[insertIndex - 1] : null;
          const right = insertIndex < points.length ? points[insertIndex] : null;
          // Enforce spacing
          const leftBound = left ? left.input + gap : 0;
          const rightBound = right ? right.input - gap : 100;
          if (left && right && (right.input - left.input) <= 2 * gap) {
            return { success: false, message: `Not enough space to insert between ${left.input}% and ${right.input}%.` };
          }
          x = Math.max(leftBound, Math.min(rightBound, x));
          // Determine Y (treat provided outputPercent as ABSOLUTE; convert to pre-scale and raise End if needed)
          let y;
          if (typeof outputPercent === 'number') {
            try {
              const row = getChannelRow(channelName);
              const endEl = row?.querySelector('.end-input');
              const pctEl = row?.querySelector('.percent-input');
              let endVal = InputValidator.clampEnd(endEl?.value || 0);
              const oldScale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              const desiredAbs = Math.max(0, Math.min(100, outputPercent));
              let scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              if (scale <= 0 && desiredAbs > 0) {
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                }
                endVal = neededEnd;
                scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              }
              const pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
              if (pre > 100 + 1e-6) {
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (neededEnd > endVal && endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  // Recompute scale
                  const newScale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                  // Scale existing points down so their absolute outputs remain unchanged
                  const factor = (oldScale > 0) ? (oldScale / newScale) : 0;
                  for (let j = 0; j < points.length; j++) {
                    points[j].output = ControlPolicy.clampY(points[j].output * factor);
                  }
                  scale = newScale;
                  endVal = neededEnd;
                }
              }
              y = Math.max(0, Math.min(100, (scale > 0) ? (desiredAbs / scale) : desiredAbs));
            } catch (e) {
              console.warn('Insert absolute-to-prescale conversion failed:', e);
              y = ControlPolicy.clampY(outputPercent);
            }
          } else {
            y = ControlPoints.sampleY(points, interpType, x);
          }
          // Insert and persist
          points.splice(insertIndex, 0, { input: x, output: y });
          return this.setAIKeyPoints(channelName, points, interpType);
        } catch (e) {
          return { success: false, message: `Error inserting Smart key point: ${e.message}` };
        }
      }

      /**
       * Insert a new AI key point between two adjacent ordinals. If output omitted, sample current Smart Curve at midpoint.
       */
      insertAIKeyPointBetween(channelName, leftOrdinal, rightOrdinal, outputPercent = null) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          const n = kp.length;
          if (typeof leftOrdinal !== 'number' || typeof rightOrdinal !== 'number') {
            return { success: false, message: 'leftOrdinal and rightOrdinal must be numbers.' };
          }
          if (leftOrdinal < 1 || rightOrdinal < 1 || leftOrdinal > n || rightOrdinal > n) {
            return { success: false, message: `Ordinals must be within 1..${n}.` };
          }
          if (rightOrdinal !== leftOrdinal + 1) {
            return { success: false, message: 'Ordinals must be adjacent (rightOrdinal = leftOrdinal + 1).' };
          }
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          // Ensure sorted by input
          points.sort((a, b) => a.input - b.input);
          const left = points[leftOrdinal - 1];
          const right = points[rightOrdinal - 1];
          const gap = ControlPolicy.minGap;
          if ((right.input - left.input) <= 2 * gap) {
            return { success: false, message: `Not enough space to insert between ${left.input}% and ${right.input}%.` };
          }
          // Midpoint X by default
          let x = (left.input + right.input) / 2;
          // Prevent inserting on top of an existing X within tolerance
          const dupIdx1 = ControlPoints.nearestIndex(kp, x, ControlPolicy.duplicateTolerance);
          if (dupIdx1 !== null) {
            const existing = kp[dupIdx1];
            return { success: false, message: `A key point already exists at ${existing.input.toFixed(3)}%.` };
          }
          x = Math.max(left.input + gap, Math.min(right.input - gap, x));
          // Determine Y (treat provided outputPercent as ABSOLUTE; convert to pre-scale and raise End if needed)
          let y;
          if (typeof outputPercent === 'number') {
            try {
              const row = getChannelRow(channelName);
              const endEl = row?.querySelector('.end-input');
              const pctEl = row?.querySelector('.percent-input');
              let endVal = InputValidator.clampEnd(endEl?.value || 0);
              const endLocked = !!(row?.hasAttribute('data-user-disabled') || endEl?.disabled || pctEl?.disabled);
              const oldScale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              const desiredAbs = Math.max(0, Math.min(100, outputPercent));
              let scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              if (scale <= 0 && desiredAbs > 0) {
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                }
                endVal = neededEnd;
                scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              }
              const pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
              if (pre > 100 + 1e-6) {
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                if (neededEnd > endVal && endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  const newScale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                  const factor = (oldScale > 0) ? (oldScale / newScale) : 0;
                  for (let j = 0; j < points.length; j++) {
                    points[j].output = ControlPolicy.clampY(points[j].output * factor);
                  }
                  scale = newScale;
                  endVal = neededEnd;
                }
              }
              y = Math.max(0, Math.min(100, (scale > 0) ? (desiredAbs / scale) : desiredAbs));
            } catch (e) {
              console.warn('Insert-between absolute-to-prescale conversion failed:', e);
              y = ControlPolicy.clampY(outputPercent);
            }
          } else {
            y = ControlPoints.sampleY(points, interpType, x);
          }
          // Insert and persist
          points.splice(leftOrdinal, 0, { input: x, output: y });
          return this.setAIKeyPoints(channelName, points, interpType);
        } catch (e) {
          return { success: false, message: `Error inserting Smart key point: ${e.message}` };
        }
      }

      /**
       * Delete an AI key point by ordinal (1-based). Endpoints blocked by default.
       */
      deleteAIKeyPointByIndex(channelName, ordinal, options = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interp } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interp } = ControlPoints.get(channelName));
          }
          if (typeof ordinal !== 'number' || ordinal < 1 || ordinal > kp.length) {
            return { success: false, message: `Invalid ordinal ${ordinal}. Valid range: 1..${kp.length}` };
          }
          const allowEndpoint = options.allowEndpoint === true;
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          const idx = ordinal - 1;
          const isEndpoint = (idx === 0 || idx === points.length - 1);
          if (isEndpoint && !allowEndpoint) {
            return { success: false, message: 'Endpoint deletion is blocked by default. Set allowEndpoint=true to remove endpoints.' };
          }
          if (points.length - 1 < 2) {
            return { success: false, message: 'Cannot delete: at least 2 key points are required.' };
          }
          points.splice(idx, 1);
          return this.setAIKeyPoints(channelName, points, interp);
        } catch (e) {
          return { success: false, message: `Error deleting Smart key point: ${e.message}` };
        }
      }

      /**
       * Delete the Smart key point nearest to a given input percentage within a tolerance. Endpoints blocked by default.
       */
      deleteAIKeyPointNearInput(channelName, inputPercent, options = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interp } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interp } = ControlPoints.get(channelName));
          }
          if (typeof inputPercent !== 'number' || isNaN(inputPercent)) {
            return { success: false, message: 'inputPercent must be a number (0-100).' };
          }
          const x = ControlPolicy.clampX(inputPercent);
          const tolerance = typeof options.tolerance === 'number' ? Math.max(0, options.tolerance) : ControlPolicy.defaultTolerance;
          const allowEndpoint = options.allowEndpoint === true;
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          const nearest = ControlPoints.nearestIndex(points, x, tolerance);
          if (nearest === null) {
            return { success: false, message: `No key point found within ±${tolerance}% of ${x}%.` };
          }
          const isEndpoint = (nearest === 0 || nearest === points.length - 1);
          if (isEndpoint && !allowEndpoint) {
            return { success: false, message: 'Nearest point is an endpoint; endpoint deletion is blocked by default.' };
          }
          if (points.length - 1 < 2) {
            return { success: false, message: 'Cannot delete: at least 2 key points are required.' };
          }
          // Create reduced set excluding selected index
          const reduced = kp.filter((_, i) => i !== nearest).map(p => ({ input: p.input, output: p.output }));
          return this.setAIKeyPoints(channelName, reduced, interp);
        } catch (e) {
          return { success: false, message: `Error deleting Smart key point: ${e.message}` };
        }
      }

      /**
       * Insert multiple Smart key points in a single batch action for one channel
       * inserts: [{ inputPercent, outputPercent? }]
       */
      insertAIKeyPointsBatch(channelName, inserts = []) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          if (!Array.isArray(inserts) || inserts.length === 0) {
            return { success: false, message: 'inserts must be a non-empty array' };
          }
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          let points = kp.map(p => ({ input: p.input, output: p.output }));
          const gap = ControlPolicy.minGap;
          // Cache channel End UI refs for efficient updates
          const row = getChannelRow(channelName);
          const endEl = row?.querySelector('.end-input');
          const pctEl = row?.querySelector('.percent-input');
          let endVal = InputValidator.clampEnd(endEl?.value || 0);
          let scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
          // Sort inserts by input to produce deterministic results
          const sorted = inserts.map(p => ({
            input: ControlPolicy.clampX(Number(p.inputPercent)),
            output: typeof p.outputPercent === 'number' ? ControlPolicy.clampY(Number(p.outputPercent)) : null
          })).sort((a, b) => a.input - b.input);
          for (const ins of sorted) {
            // Skip if attempting to insert on top of an existing X within tolerance
            const dupIdx = ControlPoints.nearestIndex(points, ins.input, ControlPolicy.duplicateTolerance);
            if (dupIdx !== null) {
              continue; // silently skip duplicates in batch
            }
            // Sample output if not provided
            let y = ins.output;
            if (y === null || typeof y !== 'number' || isNaN(y)) {
              // Ensure points are sorted for sampling
              points.sort((a, b) => a.input - b.input);
              y = ControlPoints.sampleY(points, interpType, ins.input);
            } else {
              // Treat provided output as ABSOLUTE; convert to pre-scale and raise End if needed
              try {
                const desiredAbs = Math.max(0, Math.min(100, y));
                const oldScale = scale;
                if (scale <= 0 && desiredAbs > 0) {
                  const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                  if (endEl && pctEl) {
                    endEl.value = String(neededEnd);
                    pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                    endEl.dispatchEvent(new Event('input', { bubbles: true }));
                    pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                    if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                    showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  }
                  endVal = neededEnd;
                  scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
                }
                let pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
                if (pre > 100 + 1e-6) {
                  const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                  if (neededEnd > endVal && endEl && pctEl) {
                    endEl.value = String(neededEnd);
                    pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                    endEl.dispatchEvent(new Event('input', { bubbles: true }));
                    pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                    if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                    showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                    const newScale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                    const factor = (oldScale > 0) ? (oldScale / newScale) : 0;
                    for (let j = 0; j < points.length; j++) {
                      points[j].output = ControlPolicy.clampY(points[j].output * factor);
                    }
                    scale = newScale;
                    endVal = neededEnd;
                  }
                  // recompute pre with latest scale
                  pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
                }
                y = Math.max(0, Math.min(100, pre));
              } catch (e) {
                console.warn('Batch insert absolute-to-prescale conversion failed:', e);
                y = ControlPolicy.clampY(y);
              }
            }
            // Constrain X within neighbor gap
            points.sort((a, b) => a.input - b.input);
            let x = ins.input;
            for (let i = 0; i < points.length - 1; i++) {
              if (x >= points[i].input && x <= points[i + 1].input) {
                x = Math.max(points[i].input + gap, Math.min(points[i + 1].input - gap, x));
                break;
              }
            }
            points.push({ input: x, output: y });
            points = ControlPoints.normalize(points);
          }
          // Apply once to create a single undoable action
          return this.setAIKeyPoints(channelName, points, interpType);
        } catch (e) {
          return { success: false, message: `Error in batch insert: ${e.message}` };
        }
      }

      // === Smart Curve aliases (non-breaking rename: AI → Smart) ===
      getSmartKeyPoints(channelName) { return this.getAIKeyPoints(channelName); }
      setSmartKeyPoints(channelName, keyPoints, interpolationType = 'smooth') { return this.setAIKeyPoints(channelName, keyPoints, interpolationType); }
      setSmartKeyPointsBatch(entries = []) { return this.setAIKeyPointsBatch(entries); }
      simplifySmartKeyPointsFromCurve(channelName, options = {}) { return this.simplifyAIKeyPointsFromCurve(channelName, options); }
      adjustSmartKeyPointByIndex(channelName, ordinal, params = {}) { return this.adjustAIKeyPointByIndex(channelName, ordinal, params); }
      insertSmartKeyPointAt(channelName, inputPercent, outputPercent = null) { return this.insertAIKeyPointAt(channelName, inputPercent, outputPercent); }
      insertSmartKeyPointBetween(channelName, leftOrdinal, rightOrdinal, outputPercent = null) { return this.insertAIKeyPointBetween(channelName, leftOrdinal, rightOrdinal, outputPercent); }
      insertSmartKeyPointsBatch(channelName, inserts = []) { return this.insertAIKeyPointsBatch(channelName, inserts); }
      deleteSmartKeyPointByIndex(channelName, ordinal, options = {}) { return this.deleteAIKeyPointByIndex(channelName, ordinal, options); }
      deleteSmartKeyPointNearInput(channelName, inputPercent, options = {}) { return this.deleteAIKeyPointNearInput(channelName, inputPercent, options); }
    }

    /**
     * Get current printer configuration
     * @returns {Object} Current printer object with name and channels
     */
    function getCurrentPrinter() {
      const printerSelect = document.getElementById('printerSelect');
      if (!printerSelect) {
        return PRINTERS.P700P900; // Default fallback
      }
      return PRINTERS[printerSelect.value] || PRINTERS.P700P900;
    }

    // Create singleton instance
    const quadGenActions = new QuadGenActions();

    // Debug utilities for validating overlay vs. plotted curve
    const DebugUtils = {
      /**
       * Compare Smart key points (as drawn) against the plotted curve values used in the chart.
       * Logs a table with expected (from make256) vs actual (pre‑scale × End%) and delta in %.
       * @param {string} channelName - channel to inspect (default resolves to first enabled if omitted)
       * @param {object} options - { thresholdPercent?: number }
       * @returns {Array} rows with idx, X%, expected%, actual%, delta%
       */
      compareKeyPointsToPlot(channelName = null, options = {}) {
        try {
          // Resolve channel
          const currentPrinter = getCurrentPrinter();
          let ch = channelName;
          if (!ch || !currentPrinter.channels.includes(ch)) {
            // choose first enabled channel
            const rows = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
            const enabled = rows.find(tr => InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0) > 0);
            ch = enabled ? enabled.getAttribute('data-channel') : (currentPrinter.channels[0] || 'K');
          }

          const row = getChannelRow(ch);
          if (!row) throw new Error(`Channel row not found for ${ch}`);
          const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
          if (endVal <= 0) throw new Error(`${ch} channel is disabled (End=0)`);

          // Gather Smart key points
          const kp = ControlPoints.get(ch).points;
          if (!Array.isArray(kp) || kp.length < 2) throw new Error(`No Smart key points for ${ch}`);

          // Build plotted values (same path as chart)
          const values = make256(endVal, ch, true); // 256 integers 0..endVal (after processing)
          const endPct = InputValidator.computePercentFromEnd(endVal);
          const endScale = Math.max(0, endPct) / 100; // fraction of TOTAL for overlay mapping

          function expectedAt(xp) {
            const N = values.length;
            const t = Math.max(0, Math.min(1, xp / 100)) * (N - 1);
            const i0 = Math.floor(t);
            const i1 = Math.min(N - 1, Math.ceil(t));
            const a = t - i0;
            const v = (1 - a) * values[i0] + a * values[i1]; // absolute (0..End)
            return endVal > 0 ? (v / endVal) * 100 : 0; // percent of End (chart percent)
          }

          // Compute rows
          const rows = kp.map((p, i) => {
            const xp = Math.max(0, Math.min(100, Number(p.input || 0)));
            const pre = Math.max(0, Math.min(100, Number(p.output || 0)));
            const actual = Math.max(0, Math.min(100, pre * endScale)); // overlay absolute percent
            const expected = expectedAt(xp);
            const delta = actual - expected;
            return {
              idx: i + 1,
              X_percent: +xp.toFixed(3),
              expected_percent: +expected.toFixed(3),
              actual_percent: +actual.toFixed(3),
              delta_percent: +delta.toFixed(3)
            };
          });

          const threshold = typeof options.thresholdPercent === 'number' ? Math.max(0, options.thresholdPercent) : 0.25;
          const maxAbsDelta = rows.reduce((m, r) => Math.max(m, Math.abs(r.delta_percent)), 0);
          console.table(rows);
          if (maxAbsDelta > threshold) {
            console.warn(`[DEBUG] Max delta ${maxAbsDelta.toFixed(3)}% exceeds threshold ${threshold}% on ${ch}.`);
          } else {
            console.log(`[DEBUG] All deltas within ±${threshold}% on ${ch}. Max |delta|=${maxAbsDelta.toFixed(3)}%`);
          }
          return rows;
        } catch (e) {
          console.warn('compareKeyPointsToPlot error:', e.message || e);
          return [];
        }
      }
    };

    // Expose debug helpers
    window.quadGenDebug = DebugUtils;

    /**
     * Claude Sonnet 4 API function definitions for quadGEN operations
     */
    const CLAUDE_FUNCTIONS = [
      {
        name: "set_contrast_intent",
        description: "Set the contrast intent preset (linear, soft, hard, filmic) or explicit gamma.",
        parameters: {
          type: "object",
          properties: {
            preset: {
              type: "string",
              description: "Preset name: linear | soft | hard | filmic | gamma",
              enum: ["linear", "soft", "hard", "filmic", "gamma"]
            },
            params: {
              type: "object",
              description: "Optional parameters for filmic or gamma presets",
              properties: {
                gamma: { type: "number", description: "Gamma value when preset='gamma' (e.g., 0.85, 1.20)" },
                filmicGain: { type: "number", description: "Filmic midtone gain (default 0.55)" },
                shoulder: { type: "number", description: "Filmic shoulder strength (default 0.35)" }
              }
            }
          },
          required: ["preset"]
        }
      },
      {
        name: "apply_custom_intent_sliders",
        description: "Apply a custom intent using slider parameters (gamma or filmic-like).",
        parameters: {
          type: "object",
          properties: {
            gamma: { type: "number", description: "Custom gamma (used if gain/shoulder are at defaults)" },
            gain: { type: "number", description: "Filmic midtone gain (triggers filmic when not 0.55)" },
            shoulder: { type: "number", description: "Filmic shoulder (triggers filmic when not 0.35)" }
          },
          required: []
        }
      },
      {
        name: "apply_custom_intent_paste",
        description: "Parse and apply a custom intent from pasted CSV/JSON data.",
        parameters: {
          type: "object",
          properties: {
            text: { type: "string", description: "Pasted CSV/JSON describing a 0–100% input to relative density target" }
          },
          required: ["text"]
        }
      },
      {
        name: "get_contrast_intent",
        description: "Return the current contrast intent id/name/params and whether a saved custom exists.",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "set_edit_mode",
        description: "Enable or disable Edit Mode for key‑point editing and overlays.",
        parameters: {
          type: "object",
          properties: {
            enabled: { type: "boolean", description: "true to enable Edit Mode; false to disable" }
          },
          required: ["enabled"]
        }
      },
      {
        name: "explain_lab_linearization",
        description: "Return a concise explanation of quadGEN's LAB linearization and plotting semantics for user-facing help.",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "set_channel_value",
        description: "Set the ink limit percentage for a specific channel",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            percentage: {
              type: "number",
              description: "Ink limit percentage (0-100)",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["channelName", "percentage"]
        }
      },
      {
        name: "set_channel_end_value",
        description: "Set the ink limit end value for a specific channel (0-65535 range)",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            endValue: {
              type: "number",
              description: "Ink limit end value (0-65535). Common values: 21627 (~33%), 32768 (50%), 65535 (100%)",
              minimum: 0,
              maximum: 65535
            }
          },
          required: ["channelName", "endValue"]
        }
      },
      {
        name: "apply_to_all_channels",
        description: "Apply the same ink limit percentage to all enabled channels",
        parameters: {
          type: "object",
          properties: {
            percentage: {
              type: "number",
              description: "Ink limit percentage to apply to all enabled channels (0-100)",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["percentage"]
        }
      },
      {
        name: "apply_end_to_all_channels",
        description: "Apply the same ink limit end value to all enabled channels",
        parameters: {
          type: "object",
          properties: {
            endValue: {
              type: "number",
              description: "Ink limit end value to apply to all enabled channels (0-65535)",
              minimum: 0,
              maximum: 65535
            }
          },
          required: ["endValue"]
        }
      },
      {
        name: "enable_disable_channel",
        description: "Enable or disable a specific ink channel",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            enabled: {
              type: "boolean",
              description: "Whether to enable (true) or disable (false) the channel"
            }
          },
          required: ["channelName", "enabled"]
        }
      },
      {
        name: "batch_channel_operations",
        description: "Perform multiple channel enable/disable operations in a single call",
        parameters: {
          type: "object",
          properties: {
            operations: {
              type: "array",
              description: "Array of channel operations to perform",
              items: {
                type: "object",
                properties: {
                  channelName: {
                    type: "string",
                    description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  enabled: {
                    type: "boolean",
                    description: "Whether to enable (true) or disable (false) the channel"
                  }
                },
                required: ["channelName", "enabled"]
              }
            }
          },
          required: ["operations"]
        }
      },
      {
        name: "open_global_linearization_file_picker",
        description: "Open file picker dialog to load global linearization file (.cube, .txt, or .acv)",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "open_per_channel_linearization_file_picker",
        description: "Open file picker dialog to load linearization file for a specific channel",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name to load linearization for",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["channelName"]
        }
      },
      {
        name: "load_sample_lab_file",
        description: "Load the sample LAB measurement data file for testing",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "load_sample_cube_file",
        description: "Load the sample LUT cube file for testing",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "load_lab_data_global",
        description: "Load LAB measurement data from pasted text for global linearization",
        parameters: {
          type: "object",
          properties: {
            labData: {
              type: "string",
              description: "LAB measurement data in standard format (GRAY_PERCENT LAB_L [LAB_A LAB_B])"
            }
          },
          required: ["labData"]
        }
      },
      {
        name: "load_lab_data_per_channel",
        description: "Load LAB measurement data from pasted text for specific channel linearization",
        parameters: {
          type: "object",
          properties: {
            labData: {
              type: "string",
              description: "LAB measurement data in standard format (GRAY_PERCENT LAB_L [LAB_A LAB_B])"
            },
            channelName: {
              type: "string",
              description: "Channel name to apply the LAB data to",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["labData", "channelName"]
        }
      },
      {
        name: "load_cube_data_global",
        description: "Load .cube (LUT) file data from pasted text for global linearization",
        parameters: {
          type: "object",
          properties: {
            cubeData: {
              type: "string",
              description: ".cube file data in standard LUT format (supports 1D and 3D LUTs)"
            }
          },
          required: ["cubeData"]
        }
      },
      {
        name: "load_cube_data_per_channel",
        description: "Load .cube (LUT) file data from pasted text for specific channel linearization",
        parameters: {
          type: "object",
          properties: {
            cubeData: {
              type: "string",
              description: ".cube file data in standard LUT format (supports 1D and 3D LUTs)"
            },
            channelName: {
              type: "string",
              description: "Channel name to apply the cube data to",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["cubeData", "channelName"]
        }
      },
      {
        name: "generate_and_download_quad_file",
        description: "Generate, save, export, or download the .quad file with current settings",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "set_filename",
        description: "Set the filename for the .quad file (without extension)",
        parameters: {
          type: "object",
          properties: {
            filename: {
              type: "string",
              description: "Desired filename without extension (will be sanitized automatically)"
            }
          },
          required: ["filename"]
        }
      },
      {
        name: "set_global_linearization",
        description: "Enable or disable global linearization (requires linearization file to be loaded)",
        parameters: {
          type: "object",
          properties: {
            enabled: {
              type: "boolean",
              description: "Whether to enable (true) or disable (false) global linearization"
            }
          },
          required: ["enabled"]
        }
      },
      {
        name: "set_auto_white_limit",
        description: "Enable or disable the Auto white limit rolloff (toe near paper white).",
        parameters: {
          type: "object",
          properties: {
            enabled: {
              type: "boolean",
              description: "true to enable the Auto white limit rolloff; false to disable"
            }
          },
          required: ["enabled"]
        }
      },
      {
        name: "set_auto_black_limit",
        description: "Enable or disable the Auto black limit rolloff (shoulder near max ink).",
        parameters: {
          type: "object",
          properties: {
            enabled: {
              type: "boolean",
              description: "true to enable the Auto black limit rolloff; false to disable"
            }
          },
          required: ["enabled"]
        }
      },
      {
        name: "revert_global_to_measurement",
        description: "Revert all channels to the loaded global measurement source (clears Smart curves/points; undoable). Enabled only when a global measurement is loaded.",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "revert_channel_to_measurement",
        description: "Revert a specific channel to its loaded per‑channel measurement source (clears Smart curves/points; undoable). Enabled only when that channel has measurement loaded.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name to revert",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["channelName"]
        }
      },
      {
        name: "set_per_channel_linearization",
        description: "Enable or disable linearization for a specific channel (requires linearization file to be loaded for that channel)",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            enabled: {
              type: "boolean",
              description: "Whether to enable (true) or disable (false) linearization for this channel"
            }
          },
          required: ["channelName", "enabled"]
        }
      },
      {
        name: "set_interpolation_method",
        description: "Set the interpolation method for curve generation",
        parameters: {
          type: "object",
          properties: {
            method: {
              type: "string",
              description: "Interpolation method to use",
              enum: ["pchip", "linear"]
            }
          },
          required: ["method"]
        }
      },
      {
        name: "set_smoothing_percentage",
        description: "Set the data point smoothing percentage (0-90%)",
        parameters: {
          type: "object",
          properties: {
            percentage: {
              type: "number",
              description: "Smoothing percentage (0=none, 90=maximum)",
              minimum: 0,
              maximum: 90
            }
          },
          required: ["percentage"]
        }
      },
      {
        name: "change_printer",
        description: "Switch between supported printer models",
        parameters: {
          type: "object",
          properties: {
            printerName: {
              type: "string",
              description: "Printer model to switch to",
              enum: ["P700P900", "P5-7-9000", "P800", "P400", "x900", "3880-7880", "x800-x890", "P4-6-8000"]
            }
          },
          required: ["printerName"]
        }
      },
      {
        name: "generate_custom_curve", 
        description: "Generate a curve from explicit numerical key points (single channel). Prefer set_ai_key_points for AI-driven curves.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name to generate curve for",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            keyPoints: {
              type: "array",
              description: "Array of curve control points with input/output values (0-100 range)",
              items: {
                type: "object",
                properties: {
                  input: {
                    type: "number",
                    description: "Input position (0-100%)",
                    minimum: 0,
                    maximum: 100
                  },
                  output: {
                    type: "number", 
                    description: "Output value (0-100%)",
                    minimum: 0,
                    maximum: 100
                  }
                },
                required: ["input", "output"]
              },
              minItems: 2
            },
            interpolationType: {
              type: "string",
              description: "Interpolation method between points",
              enum: ["linear", "smooth"],
              default: "smooth"
            }
          },
          required: ["channelName", "keyPoints"]
        }
      },
      {
        name: "get_ai_key_points",
        description: "Get stored AI key points (endpoints included). If channelName is omitted, uses the first enabled channel. If none exist yet, returns an empty list with suggestions; edit calls will auto‑create.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: []
        }
      },
      {
        name: "get_smart_key_points",
        description: "Get stored Smart key points (endpoints included). If channelName is omitted, uses the first enabled channel. If none exist yet, returns an empty list with suggestions; edit calls will auto‑create.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: []
        }
      },
      {
        name: "set_ai_key_points",
        description: "Replace AI key points and reapply the curve. If channelName is omitted, uses the first enabled channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            keyPoints: {
              type: "array",
              description: "Array of {input, output} in 0-100%",
              items: {
                type: "object",
                properties: {
                  input: { type: "number", minimum: 0, maximum: 100 },
                  output: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["input", "output"]
              },
              minItems: 2
            },
            interpolationType: {
              type: "string",
              enum: ["linear", "smooth"],
              default: "smooth"
            }
          },
          required: ["keyPoints"]
        }
      },
      {
        name: "set_smart_key_points",
        description: "Replace Smart key points and reapply the curve. If channelName is omitted, uses the first enabled channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            keyPoints: {
              type: "array",
              description: "Array of {input, output} in 0-100%",
              items: {
                type: "object",
                properties: {
                  input: { type: "number", minimum: 0, maximum: 100 },
                  output: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["input", "output"]
              },
              minItems: 2
            },
            interpolationType: {
              type: "string",
              enum: ["linear", "smooth"],
              default: "smooth"
            }
          },
          required: ["keyPoints"]
        }
      },
      {
        name: "set_ai_key_points_batch",
        description: "Replace AI key points for multiple channels and reapply curves as a single batch action.",
        parameters: {
          type: "object",
          properties: {
            entries: {
              type: "array",
              description: "List of per-channel key points updates",
              items: {
                type: "object",
                properties: {
                  channelName: {
                    type: "string",
                    description: "Channel to update",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  keyPoints: {
                    type: "array",
                    description: "Array of {input, output} in 0-100%",
                    items: {
                      type: "object",
                      properties: {
                        input: { type: "number", minimum: 0, maximum: 100 },
                        output: { type: "number", minimum: 0, maximum: 100 }
                      },
                      required: ["input", "output"]
                    },
                    minItems: 2
                  },
                  interpolationType: {
                    type: "string",
                    enum: ["linear", "smooth"],
                    default: "smooth"
                  }
                },
                required: ["channelName", "keyPoints"]
              },
              minItems: 1
            }
          },
          required: ["entries"]
        }
      },
      {
        name: "set_smart_key_points_batch",
        description: "Replace Smart key points for multiple channels and reapply curves as a single batch action.",
        parameters: {
          type: "object",
          properties: {
            entries: {
              type: "array",
              description: "List of per-channel key points updates",
              items: {
                type: "object",
                properties: {
                  channelName: {
                    type: "string",
                    description: "Channel to update",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  keyPoints: {
                    type: "array",
                    description: "Array of {input, output} in 0-100%",
                    items: {
                      type: "object",
                      properties: {
                        input: { type: "number", minimum: 0, maximum: 100 },
                        output: { type: "number", minimum: 0, maximum: 100 }
                      },
                      required: ["input", "output"]
                    },
                    minItems: 2
                  },
                  interpolationType: {
                    type: "string",
                    enum: ["linear", "smooth"],
                    default: "smooth"
                  }
                },
                required: ["channelName", "keyPoints"]
              },
              minItems: 1
            }
          },
          required: ["entries"]
        }
      },
      {
        name: "simplify_ai_key_points_from_curve",
        description: "Extract adaptive key points from the current curve (prefers loaded .quad) and apply them to a channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to simplify",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            maxErrorPercent: {
              type: "number",
              description: "Max allowed deviation in % (0.05–5). Default 1.0",
              minimum: 0.05,
              maximum: 5
            },
            maxPoints: {
              type: "integer",
              description: "Upper bound on points (2–20). Default 16",
              minimum: 2,
              maximum: 20
            }
          },
          required: ["channelName"]
        }
      },
      {
        name: "simplify_smart_key_points_from_curve",
        description: "Extract adaptive Smart key points from the current curve (prefers loaded .quad) and apply them to a channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to simplify",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            maxErrorPercent: {
              type: "number",
              description: "Max allowed deviation in % (0.05–5). Default 1.0",
              minimum: 0.05,
              maximum: 5
            },
            maxPoints: {
              type: "integer",
              description: "Upper bound on points (2–20). Default 16",
              minimum: 2,
              maximum: 20
            }
          },
          required: ["channelName"]
        }
      },
      {
        name: "adjust_ai_key_point_by_index",
        description: "Adjust a single AI key point by ordinal (1‑based, endpoints included). If channelName is omitted, uses the first enabled channel. If no AI key points exist yet, quadGEN will silently create them from the current curve/data and then apply the edit.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point (including endpoints)",
              minimum: 1
            },
            inputPercent: {
              type: "number",
              description: "Absolute new input (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Absolute new output (Y) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            deltaInput: {
              type: "number",
              description: "Delta to add to input (X) in percentage points"
            },
            deltaOutput: {
              type: "number",
              description: "Delta to add to output (Y) in percentage points"
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "adjust_smart_key_point_by_index",
        description: "Adjust a single Smart key point by ordinal (1‑based, endpoints included). If channelName is omitted, uses the first enabled channel. If no Smart key points exist yet, quadGEN will create them from the current curve/data and then apply the edit.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point (including endpoints)",
              minimum: 1
            },
            inputPercent: {
              type: "number",
              description: "Absolute new input (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Absolute new output (Y) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            deltaInput: {
              type: "number",
              description: "Delta to add to input (X) in percentage points"
            },
            deltaOutput: {
              type: "number",
              description: "Delta to add to output (Y) in percentage points"
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "insert_ai_key_point_at",
        description: "Insert a new AI key point at a given input (X). If output is omitted, sample current Smart Curve at X. If no AI key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current Smart Curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "insert_smart_key_point_at",
        description: "Insert a new Smart key point at a given input (X). If output is omitted, sample current Smart curve at X. If no Smart key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current Smart curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "insert_ai_key_point_between",
        description: "Insert a new AI key point between two adjacent ordinals. If output is omitted, sample at the midpoint. If no AI key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            leftOrdinal: {
              type: "integer",
              description: "Left ordinal (1-based)",
              minimum: 1
            },
            rightOrdinal: {
              type: "integer",
              description: "Right ordinal (must be leftOrdinal+1)",
              minimum: 2
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current Smart Curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["leftOrdinal", "rightOrdinal"]
        }
      },
      {
        name: "insert_smart_key_point_between",
        description: "Insert a new Smart key point between two adjacent ordinals. If output is omitted, sample at the midpoint. If no Smart key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            leftOrdinal: {
              type: "integer",
              description: "Left ordinal (1-based)",
              minimum: 1
            },
            rightOrdinal: {
              type: "integer",
              description: "Right ordinal (must be leftOrdinal+1)",
              minimum: 2
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current Smart curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["leftOrdinal", "rightOrdinal"]
        }
      },
      {
        name: "insert_ai_key_points_batch",
        description: "Insert multiple AI key points for a single channel in one batch (single undoable action).",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to update",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inserts: {
              type: "array",
              description: "List of points to insert",
              items: {
                type: "object",
                properties: {
                  inputPercent: { type: "number", minimum: 0, maximum: 100 },
                  outputPercent: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["inputPercent"]
              },
              minItems: 1
            }
          },
          required: ["channelName", "inserts"]
        }
      },
      {
        name: "insert_smart_key_points_batch",
        description: "Insert multiple Smart key points for a single channel in one batch (single undoable action).",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to update",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inserts: {
              type: "array",
              description: "List of points to insert",
              items: {
                type: "object",
                properties: {
                  inputPercent: { type: "number", minimum: 0, maximum: 100 },
                  outputPercent: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["inputPercent"]
              },
              minItems: 1
            }
          },
          required: ["channelName", "inserts"]
        }
      },
      {
        name: "delete_ai_key_point_by_index",
        description: "Delete a single AI key point by ordinal (1‑based). Endpoints blocked by default. If no AI key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point to delete",
              minimum: 1
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "delete_smart_key_point_by_index",
        description: "Delete a single Smart key point by ordinal (1‑based). Endpoints blocked by default. If no Smart key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point to delete",
              minimum: 1
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "delete_ai_key_point_near_input",
        description: "Delete the AI key point nearest to a given input % within a tolerance. Endpoints blocked by default. If no AI key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Target input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            tolerance: {
              type: "number",
              description: "Maximum distance in % to consider a match (default 1.0)"
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "delete_smart_key_point_near_input",
        description: "Delete the Smart key point nearest to a given input % within a tolerance. Endpoints blocked by default. If no Smart key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Target input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            tolerance: {
              type: "number",
              description: "Maximum distance in % to consider a match (default 1.0)"
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "copy_curve_to_channel",
        description: "Copy a custom curve from one channel to another channel",
        parameters: {
          type: "object",
          properties: {
            sourceChannel: {
              type: "string",
              description: "Channel to copy the curve from",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            targetChannel: {
              type: "string",
              description: "Channel to copy the curve to",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["sourceChannel", "targetChannel"]
        }
      },
      
      {
        name: "generate_global_custom_curve",
        description: "Generate curves from explicit numerical key points for multiple channels simultaneously. Creates single batch undo action.",
        parameters: {
          type: "object",
          properties: {
            keyPoints: {
              type: "array",
              description: "Array of curve control points with input/output values (0-100 range)",
              items: {
                type: "object",
                properties: {
                  input: {
                    type: "number",
                    description: "Input value (0-100)"
                  },
                  output: {
                    type: "number", 
                    description: "Output value (0-100)"
                  }
                },
                required: ["input", "output"]
              }
            },
            interpolationType: {
              type: "string",
              description: "Interpolation method between points",
              enum: ["linear", "smooth"],
              default: "smooth"
            },
            channelFilter: {
              oneOf: [
                {
                  type: "string",
                  enum: ["all", "enabled"],
                  description: "Predefined channel filters"
                },
                {
                  type: "array",
                  items: {
                    type: "string",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  description: "Array of specific channel names"
                }
              ],
              description: "Which channels to apply to: 'all' (all printer channels), 'enabled' (only enabled channels), or array of specific channels like ['LK', 'MK']",
              default: "enabled"
            }
          },
          required: ["keyPoints"]
        }
      },
      
      {
        name: "get_current_state",
        description: "Get the current state of all channels and app settings",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "undo_last_change",
        description: "Revert to the previous state (undo the last change made to curves or channel settings)",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "get_history_summary",
        description: "Get a summary of recent changes and undo history for reference",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "get_quad_file_content",
        description: "Return the current generated .quad file content as text (based on current settings)",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      }
    ];

    /**
     * Lab Tech integration for quadGEN
     * Handles API communication and function execution
     */
    class LabTech {
      constructor() {
        this.conversationHistory = [];
        this.isProcessing = false;
        this.requestCount = 0;
        this.requestTimes = [];
        this.maxRequestsPerMinute = 10;
        this.maxRequestsPerHour = 100;
        // Recent system notices buffer (not sent until user chats)
        this.systemContextBuffer = [];
        this.systemContextMaxLines = 8;
        this.systemContextMaxChars = 800;
      }

      addSystemContext(message) {
        try {
          const line = String(message || '').trim();
          if (!line) return;
          this.systemContextBuffer.push(line);
          // Trim by lines
          if (this.systemContextBuffer.length > this.systemContextMaxLines) {
            this.systemContextBuffer = this.systemContextBuffer.slice(-this.systemContextMaxLines);
          }
          // Trim by chars
          let txt = this.systemContextBuffer.join('\n');
          if (txt.length > this.systemContextMaxChars) {
            txt = txt.slice(txt.length - this.systemContextMaxChars);
            this.systemContextBuffer = txt.split('\n').slice(-this.systemContextMaxLines);
          }
        } catch {}
      }

      getSystemContext() {
        try {
          if (!this.systemContextBuffer || this.systemContextBuffer.length === 0) return '';
          return this.systemContextBuffer.join('\n');
        } catch { return ''; }
      }

      // (Tool gating removed - always include tools for assistant)

      /**
       * Check if user is within rate limits
       * @returns {Object} Rate limit status
       */
      checkRateLimit() {
        const now = Date.now();
        const oneMinuteAgo = now - 60 * 1000;
        const oneHourAgo = now - 60 * 60 * 1000;
        
        // Clean old entries
        this.requestTimes = this.requestTimes.filter(time => time > oneHourAgo);
        
        const requestsLastMinute = this.requestTimes.filter(time => time > oneMinuteAgo).length;
        const requestsLastHour = this.requestTimes.length;
        
        if (requestsLastMinute >= this.maxRequestsPerMinute) {
          return {
            allowed: false,
            reason: `Rate limit: Max ${this.maxRequestsPerMinute} requests per minute. Please wait.`
          };
        }
        
        if (requestsLastHour >= this.maxRequestsPerHour) {
          return {
            allowed: false,
            reason: `Rate limit: Max ${this.maxRequestsPerHour} requests per hour. Please try later.`
          };
        }
        
        return { allowed: true };
      }

      /**
       * Record a new request
       */
      recordRequest() {
        this.requestTimes.push(Date.now());
        this.requestCount++;
      }

      /**
       * Get usage statistics
       * @returns {Object} Usage stats
       */
      getUsageStats() {
        const now = Date.now();
        const oneHourAgo = now - 60 * 60 * 1000;
        const requestsLastHour = this.requestTimes.filter(time => time > oneHourAgo).length;
        
        return {
          totalRequests: this.requestCount,
          requestsLastHour,
          remainingHourly: Math.max(0, this.maxRequestsPerHour - requestsLastHour)
        };
      }

      /**
       * Estimate token usage for a request (rough approximation)
       * @param {string} userMessage - User's message
       * @returns {number} Estimated token count
       */
      estimateTokens(userMessage) {
        // Rough token estimation: ~4 characters per token
        const systemMessageTokens = 400; // System message is ~400 tokens
        const functionDefinitionTokens = 800; // 17 functions * ~50 tokens each
        const appStateTokens = 200; // Current app state context
        const conversationHistoryTokens = 500; // 10 messages * ~50 tokens each
        const userMessageTokens = Math.ceil(userMessage.length / 4);
        
        return systemMessageTokens + functionDefinitionTokens + appStateTokens + conversationHistoryTokens + userMessageTokens;
      }

      /**
       * Check if token usage seems high and warn user
       * @param {string} userMessage - User's message
       * @returns {Object} Warning info
       */
      checkTokenUsage(userMessage) {
        const estimatedTokens = this.estimateTokens(userMessage);
        
        if (estimatedTokens > 2000) {
          return {
            shouldWarn: true,
            message: `This request will use approximately ${estimatedTokens} tokens. Consider shorter messages to reduce costs.`,
            estimatedTokens
          };
        }
        
        return { shouldWarn: false, estimatedTokens };
      }

      /**
       * Determine whether to apply curve as global linearization or per-channel curves
       * @param {string} userPrompt - The user's natural language request
       * @returns {string} 'global' for global linearization, 'per_channel' for individual channels
       */
      determineApplicationMethod(userPrompt) {
        // Feature flag for easy enable/disable
        const ENABLE_AI_GLOBAL_LINEARIZATION = true;
        
        
        if (!ENABLE_AI_GLOBAL_LINEARIZATION) {
          return 'per_channel';
        }

        // Global linearization indicators
        const globalIndicators = [
          // System-wide language
          /\b(entire system|whole print|overall|globally|system-wide)\b/i,
          // Direct global language
          /\b(global)\b.*\b(curve|correction|adjustment|linearization|compensation)\b/i,
          /\b(apply|add|create)\b.*\b(global)\b/i,
          // Process/paper simulation language
          // Process-specific triggers removed to avoid generating image-space style presets in printer-space
          // Paper/process characteristics
          /\b(paper|process|tonality|characteristics|simulation)\b.*\b(curve|adjustment|correction)\b/i,
          /\b(matte paper|glossy paper|textured paper)\b/i,
          // Global effect language
          /\b(simulate|create|add|apply)\b.*\b(paper|process|print|system)\b/i,
          /\b(compensat|correct|adjust)\b.*\b(paper|printer|system|print)\b/i,
          // Universal/system-wide effects
          /\b(universal|system-wide|across.all|for.everything)\b/i
        ];
        
        // Per-channel curve indicators  
        const perChannelIndicators = [
          // Channel-specific language
          /\b(all channels|each channel|every channel|individual channels?)\b/i,
          /\b(K.*C.*M|cyan.*magenta|ink.*channel|channel.*control)\b/i,
          // Selective control language
          /\b(selective|separate|independent|individual|per.channel)\b/i,
          /\b(color.*balanc|channel.*specific)\b/i
        ];

        // Check for explicit global indicators
        const matchedGlobalPattern = globalIndicators.find(pattern => pattern.test(userPrompt));
        if (matchedGlobalPattern) {
          if (DEBUG_AI || DEBUG_LOGS) console.log('🌐 AI Decision: Using GLOBAL LINEARIZATION based on pattern:', matchedGlobalPattern);
          if (DEBUG_AI || DEBUG_LOGS) console.log('🌐 Matched text in prompt:', userPrompt.match(matchedGlobalPattern));
          return 'global';
        }
        
        // Check for explicit per-channel indicators
        const matchedChannelPattern = perChannelIndicators.find(pattern => pattern.test(userPrompt));
        if (matchedChannelPattern) {
          return 'per_channel';
        }
        
        // Default to per-channel (existing behavior)
        return 'per_channel';
      }

      /**
       * Execute a function call returned by Claude
       * @param {Object} functionCall - Function call object from Claude
       * @returns {Object} Function execution result
       */
      executeFunctionCall(functionCall, userMessage = '') {
        const { name, parameters } = functionCall;

        switch (name) {
          case 'set_contrast_intent':
            return quadGenActions.setContrastIntentPreset(parameters.preset, parameters.params || {});
          case 'apply_custom_intent_sliders':
            return quadGenActions.applyCustomIntentSliders(parameters);
          case 'apply_custom_intent_paste':
            return quadGenActions.applyCustomIntentPaste(parameters.text);
          case 'get_contrast_intent':
            return quadGenActions.getContrastIntent();
          case 'set_edit_mode': {
            try {
              const on = parameters && parameters.enabled === true;
              setEditMode(on, { recordHistory: true });
              return { success: true, message: `Edit Mode ${on ? 'enabled' : 'disabled'}` };
            } catch (e) {
              return { success: false, message: `Error toggling Edit Mode: ${e.message}` };
            }
          }
          case 'explain_lab_linearization': {
            const blurb = [
              "quadGEN plots ink mapping: Y = output ink level vs X = input ink level; Y=X means no correction.",
              "Too dark at input X → reduce ink → curve dips below the diagonal; too light → add ink → curve rises above.",
              "Other tools may mirror X (curves view) or plot luminance instead of ink, so features can appear at 1−X or on the opposite side of the diagonal."
            ].join(' ');
            return { success: true, message: blurb };
          }
          case 'set_channel_value':
            return quadGenActions.setChannelValue(parameters.channelName, parameters.percentage);
          
          case 'set_channel_end_value':
            return quadGenActions.setChannelEndValue(parameters.channelName, parameters.endValue);
          
          case 'apply_to_all_channels':
            return quadGenActions.applyToAllChannels(parameters.percentage);
          
          case 'apply_end_to_all_channels':
            return quadGenActions.applyEndToAllChannels(parameters.endValue);
          
          case 'enable_disable_channel':
            return quadGenActions.enableDisableChannel(parameters.channelName, parameters.enabled);
          
          case 'batch_channel_operations':
            return quadGenActions.batchChannelOperations(parameters.operations);
          
          case 'open_global_linearization_file_picker':
            return quadGenActions.openGlobalLinearizationFilePicker();
          
          case 'open_per_channel_linearization_file_picker':
            return quadGenActions.openPerChannelLinearizationFilePicker(parameters.channelName);
          
          case 'load_sample_lab_file':
            return quadGenActions.loadSampleLabFile();
          
          case 'load_sample_cube_file':
            return quadGenActions.loadSampleCubeFile();
          
          case 'load_lab_data_global':
            return quadGenActions.loadLabData(parameters.labData, true);
          
          case 'load_lab_data_per_channel':
            return quadGenActions.loadLabData(parameters.labData, false, parameters.channelName);
          
          case 'load_cube_data_global':
            return quadGenActions.loadCubeData(parameters.cubeData, true);
          
          case 'load_cube_data_per_channel':
            return quadGenActions.loadCubeData(parameters.cubeData, false, parameters.channelName);
          
          case 'generate_and_download_quad_file':
            return quadGenActions.generateAndDownloadQuadFile();
          
          case 'set_filename':
            return quadGenActions.setFilename(parameters.filename);
          
          case 'set_global_linearization':
            return quadGenActions.setGlobalLinearization(parameters.enabled);
          case 'set_auto_white_limit':
            return quadGenActions.setAutoWhiteLimit(parameters.enabled);
          case 'set_auto_black_limit':
            return quadGenActions.setAutoBlackLimit(parameters.enabled);
          case 'apply_intent_to_loaded_quad':
            return quadGenActions.applyIntentToLoadedQuad();

          case 'set_per_channel_linearization':
            return quadGenActions.setPerChannelLinearization(parameters.channelName, parameters.enabled);
          case 'revert_global_to_measurement':
            return quadGenActions.revertGlobalToMeasurement();
          case 'revert_channel_to_measurement':
            return quadGenActions.revertChannelToMeasurement(parameters.channelName);
          
          case 'set_interpolation_method':
            return quadGenActions.setInterpolationMethod(parameters.method);
          
          case 'set_smoothing_percentage':
            return quadGenActions.setSmoothingPercentage(parameters.percentage);
          
          case 'set_chart_zoom':
            return quadGenActions.setChartZoom(parameters.percent);

          case 'nudge_chart_zoom':
            return quadGenActions.nudgeChartZoom(parameters.direction || 1);

          case 'change_printer':
            return quadGenActions.changePrinter(parameters.printerName);
          
          case 'generate_custom_curve':
            return quadGenActions.generateCustomCurve(
              parameters.channelName, 
              parameters.keyPoints, 
              parameters.interpolationType || 'smooth'
            );
          
          
          
          case 'generate_global_custom_curve':
            return quadGenActions.generateGlobalCustomCurve(
              parameters.keyPoints,
              parameters.interpolationType || 'smooth',
              parameters.channelFilter || 'enabled'
            );
          
          case 'get_current_state':
            return quadGenActions.getCurrentState();
          
          case 'undo_last_change':
            return CurveHistory.undo();
          
          case 'get_history_summary':
            return CurveHistory.getHistorySummary();
          
          case 'get_quad_file_content':
            try {
              const content = buildFile();
              return { success: true, message: 'Generated current .quad content', content };
            } catch (e) {
              return { success: false, message: `Error generating .quad content: ${e.message}` };
            }
          
          case 'copy_curve_to_channel':
            return quadGenActions.copyCurveToChannel(parameters.sourceChannel, parameters.targetChannel);
          case 'get_ai_key_points':
            return quadGenActions.getAIKeyPoints(parameters.channelName);
          case 'get_smart_key_points':
            return quadGenActions.getSmartKeyPoints(parameters.channelName);
          case 'set_ai_key_points':
            return quadGenActions.setAIKeyPoints(parameters.channelName, parameters.keyPoints, parameters.interpolationType);
          case 'set_smart_key_points':
            return quadGenActions.setSmartKeyPoints(parameters.channelName, parameters.keyPoints, parameters.interpolationType);
          case 'set_ai_key_points_batch':
            return quadGenActions.setAIKeyPointsBatch(parameters.entries);
          case 'set_smart_key_points_batch':
            return quadGenActions.setSmartKeyPointsBatch(parameters.entries);
          case 'simplify_ai_key_points_from_curve':
            return quadGenActions.simplifyAIKeyPointsFromCurve(parameters.channelName, { maxErrorPercent: parameters.maxErrorPercent, maxPoints: parameters.maxPoints });
          case 'simplify_smart_key_points_from_curve':
            return quadGenActions.simplifySmartKeyPointsFromCurve(parameters.channelName, { maxErrorPercent: parameters.maxErrorPercent, maxPoints: parameters.maxPoints });
          case 'adjust_ai_key_point_by_index':
            return quadGenActions.adjustAIKeyPointByIndex(parameters.channelName, parameters.ordinal, {
              inputPercent: parameters.inputPercent,
              outputPercent: parameters.outputPercent,
              deltaInput: parameters.deltaInput,
              deltaOutput: parameters.deltaOutput
            });
          case 'adjust_smart_key_point_by_index':
            return quadGenActions.adjustSmartKeyPointByIndex(parameters.channelName, parameters.ordinal, {
              inputPercent: parameters.inputPercent,
              outputPercent: parameters.outputPercent,
              deltaInput: parameters.deltaInput,
              deltaOutput: parameters.deltaOutput
            });
          case 'insert_ai_key_point_at':
            return quadGenActions.insertAIKeyPointAt(parameters.channelName, parameters.inputPercent, parameters.outputPercent);
          case 'insert_smart_key_point_at':
            return quadGenActions.insertSmartKeyPointAt(parameters.channelName, parameters.inputPercent, parameters.outputPercent);
          case 'insert_ai_key_point_between':
            return quadGenActions.insertAIKeyPointBetween(parameters.channelName, parameters.leftOrdinal, parameters.rightOrdinal, parameters.outputPercent);
          case 'insert_smart_key_point_between':
            return quadGenActions.insertSmartKeyPointBetween(parameters.channelName, parameters.leftOrdinal, parameters.rightOrdinal, parameters.outputPercent);
          case 'insert_ai_key_points_batch':
            return quadGenActions.insertAIKeyPointsBatch(parameters.channelName, parameters.inserts);
          case 'insert_smart_key_points_batch':
            return quadGenActions.insertSmartKeyPointsBatch(parameters.channelName, parameters.inserts);
          case 'delete_ai_key_point_by_index':
            return quadGenActions.deleteAIKeyPointByIndex(parameters.channelName, parameters.ordinal, { allowEndpoint: parameters.allowEndpoint });
          case 'delete_smart_key_point_by_index':
            return quadGenActions.deleteSmartKeyPointByIndex(parameters.channelName, parameters.ordinal, { allowEndpoint: parameters.allowEndpoint });
          case 'delete_ai_key_point_near_input':
            return quadGenActions.deleteAIKeyPointNearInput(parameters.channelName, parameters.inputPercent, { tolerance: parameters.tolerance, allowEndpoint: parameters.allowEndpoint });
          case 'delete_smart_key_point_near_input':
            return quadGenActions.deleteSmartKeyPointNearInput(parameters.channelName, parameters.inputPercent, { tolerance: parameters.tolerance, allowEndpoint: parameters.allowEndpoint });
          
          default:
            return {
              success: false,
              message: `Unknown function: ${name}`
            };
        }
      }

      /**
       * Send message to Claude and handle response
       * @param {string} userMessage - User's message
       * @returns {Promise<Object>} Response object with message and any actions performed
       */
      async sendMessage(userMessage) {
        // Check rate limits first
        const rateLimitCheck = this.checkRateLimit();
        if (!rateLimitCheck.allowed) {
          return {
            success: false,
            message: rateLimitCheck.reason,
            response: rateLimitCheck.reason
          };
        }

        const normalizedMessage = String(userMessage || '').trim().toLowerCase();

        const zoomInMaxPhrases = [
          'zoom in as far as possible',
          'zoom way in',
          'zoom all the way in',
          'zoom in all the way'
        ];
        const zoomOutMaxPhrases = [
          'zoom all the way out',
          'zoom way out',
          'zoom out as far as possible',
          'zoom out all the way'
        ];
        const includesPhrase = (phrase) => normalizedMessage.includes(phrase);

        if (zoomInMaxPhrases.some(includesPhrase)) {
          const result = quadGenActions.setChartZoom(0);
          const reply = result?.message || 'Zoomed in to the minimum allowed range.';
          return {
            success: result?.success !== false,
            message: reply,
            response: reply,
            actionsPerformed: true
          };
        }

        if (zoomOutMaxPhrases.some(includesPhrase)) {
          const result = quadGenActions.setChartZoom(100);
          const reply = result?.message || 'Zoomed out to show the full range.';
          return {
            success: result?.success !== false,
            message: reply,
            response: reply,
            actionsPerformed: true
          };
        }

        const zoomInRegex = /\bzoom(?:\s+\w+){0,3}\s+in\b/;
        const zoomOutRegex = /\bzoom(?:\s+\w+){0,3}\s+out\b/;
        const hasZoomIn = zoomInRegex.test(normalizedMessage);
        const hasZoomOut = zoomOutRegex.test(normalizedMessage);
        if ((hasZoomIn || hasZoomOut) && !(hasZoomIn && hasZoomOut)) {
          const direction = hasZoomIn ? 1 : -1;
          const result = quadGenActions.nudgeChartZoom(direction);
          const reply = result?.message || (direction > 0 ? 'Zoomed in.' : 'Zoomed out.');
          return {
            success: result?.success !== false,
            message: reply,
            response: reply,
            actionsPerformed: true
          };
        }

        if (this.isProcessing) {
          return {
            success: false,
            message: 'Already processing a request. Please wait.',
            response: 'I\'m still processing your previous request. Please wait a moment.'
          };
        }

        try {
          this.isProcessing = true;
          this.recordRequest();

          // Get current app state for context
          const currentState = quadGenActions.getCurrentState();
          const contextMessage = currentState.success 
            ? `Current QuadGEN state: ${JSON.stringify(currentState.data, null, 2)}`
            : 'Unable to retrieve current state';

          // No bookmarks or reference injection

          // Prepare system message separately (append recent system notices if any)
          const baseSystemMessage = `You are Lab Tech, the specialized digital darkroom assistant for QuadGEN. You control QuadToneRIP .quad file generation for Epson printers. Always refer to yourself as "Lab Tech" when speaking to users. Adopt the persona of a knowledgeable lab technician who's expert in digital printmaking and alternative photographic processes.

COMMUNICATION STYLE: Be professional, concise, and direct in all responses. Provide clear, actionable guidance without unnecessary elaboration. Do NOT use greetings, pleasantries, self-descriptive language ("I'm here to help", "As Lab Tech", etc.), exclamation points, or conversational endings ("Let me know if you have questions", "Does this help", etc.). Simply provide the requested information and stop. Use formatting to improve readability:
- Use bullet points for lists (- item or * item)
- Use **bold** for emphasis on key terms
- Use line breaks to separate different topics or steps
- Use numbered lists (1. 2. 3.) for sequential instructions

🚨 CRITICAL CHANNEL SELECTION RULE 🚨
SIMPLE RULE: If user doesn't specify a channel, use the FIRST ENABLED channel from the provided state.
ENABLED = percentage > 0 OR endValue > 0 OR enabled = true (check ALL three fields)
- DO NOT analyze what channel would be "most appropriate" 
- DO NOT enable different channels
- DO NOT make assumptions based on curve names
- JUST use the first enabled channel you find in the current state JSON
- If NO channels are enabled, then ask which channel to use

Current state provided with each request. Make multiple function calls in one response for complex requests.

INK COLORS:
K=Black(Photo/Matte), C=Cyan, M=Magenta, Y=Yellow, LC=Light Cyan, LM=Light Magenta, LK=Gray/Light Black, LLK=Light Gray, V=Violet, MK=Matte Black

PRINTERS:
P600-P800 (8 channels, K switchable), P700-P900 (10 channels, MK+V dedicated)

.QUAD ESSENTIALS:
• 256-step linearization curves mapping input density to ink output
• Higher % = more ink = darker output | 0% = disabled channel
• Multiple active channels blend to create neutral or tinted prints
• Linearization files (.cube/.txt/.acv) compensate for paper/ink characteristics
• Users can PASTE LAB measurement data or .cube LUT file data directly into chat for instant linearization
• Positive-only workflow: quadGEN operates in printer-space. EDN LUT/.acv are mapped for Positive orientation (reverse + invert). Work in positive space; invert your image when printing a digital negative. Measurement linearization unchanged.
• Auto endpoint rolloff: set_auto_black_limit/set_auto_white_limit toggle localized knees (black shoulder default ON, white toe default OFF). Recompute with a side enabled bakes bakedAutoBlack/bakedAutoWhite meta so plotting skips double application.
• Curve creation: Compute explicit numeric key points yourself based on the user’s intent (e.g., gentle S-curve, lift shadows) and apply them with set_ai_key_points. Do NOT rely on built-in presets or pre-defined curves.
• You may interpret photography terms (lift/drop shadows/midtones/highlights, crush/blow, peak/bump, gentle arc, roll off, S-curve), but YOU must choose the actual numerical key points.
• Alt-process terms: palladium/pt-pd curve, cyanotype density, salt print range, gum curve, zone system, block shadows, boost shadows, preserve highlights, contact printing density, UV blocking, exposure scale (ES)
• Global curve generation: Apply same numeric key points to multiple channels with a single undo action
  - Prefer generate_global_custom_curve when the user mentions multiple channels (e.g., 'LK and MK', or 'C, M, Y').
  - Single batch undo reverts all affected channels simultaneously
  - Do NOT use generate_curve_from_description or generate_global_curve_from_description (deprecated)
• To save/download: "download the quad file", "generate quad file", "export quad"
• Generated files work with QuadToneRIP print driver for precise ink control

TONAL MODEL (POSITIVE SPACE):
• Assume a positive working space. X=0% is white, X=100% is black. Y=0% is no ink (white), Y=100% is max ink (black). More output (%) = darker print.
• Endpoints policy: Keep 0→0 and 100→100 anchored by default. Do not move endpoints unless the user explicitly asks. Maintain monotonicity and smoothness; avoid kinks near endpoints.
• Zones by input (X): Highlights 0–25%, Midtones 25–75%, Shadows 75–100%.
• Common requests (interpretation):
  - Lighten shadows: decrease output in 75–95% and taper to 0 change by 100%.
  - Darken shadows: increase output in 75–95% and taper to 0 change by 100%.
  - Lighten highlights: decrease output in 5–25% and taper to 0 change by 0%.
  - Darken highlights: increase output in 5–25% and taper to 0 change by 0%.
  - Increase midtone contrast: gentle S around 50% with endpoints unchanged.
• Guardrail: If the user mentions digital negatives/inversion, briefly confirm orientation or provide both interpretations without changing the positive-space assumption unless requested.

CONFIRMATION & EFFECT SUMMARY:
• After any successful curve/key‑point change (set/adjust/insert/delete/generate global), end with ONE concise effect line.
• Format: Effect: <zone/change> <±peak>% → <expected outcome>; <endpoints note>
  - Examples: Effect: Midtone lift −6% @ 50% → lighter midtones; 0/100 fixed.
             Effect: Shadow boost +5% (75–95%) → darker shadows; endpoints anchored.
• Keep ≤120 characters. Do NOT repeat the points preview or the “Action:” line shown by the app.

KEY‑POINT EDITING DEFAULTS:
• “point N” ALWAYS refers to the AI key‑point ordinal N (1‑based, endpoints included) on the selected channel
• If channel is not specified, apply the CRITICAL CHANNEL SELECTION RULE (first enabled channel). Only ask which channel if none are enabled
• Silent conversion: If no AI key points exist yet, call the edit/insert/delete function anyway — quadGEN will convert from any loaded ACV/LUT/LAB or from the currently displayed curve on the first edit. Do NOT ask the user to generate a curve first
• Disambiguation: If the user mentions “point N … %”, interpret as a key‑point change, not a channel ink limit. Example: “set point 5 to 90%” ⇒ adjust_ai_key_point_by_index(ordinal=5, outputPercent=90)
• Use insert_ai_key_point_at / insert_ai_key_point_between and delete_ai_key_point_* similarly; endpoints are included in indexing and deletions of endpoints are blocked unless allowEndpoint=true
• Edit Mode control: If making edits and Edit Mode is off, call set_edit_mode(enabled=true) before performing the edit. You may turn it off if the user asks (set_edit_mode(enabled=false)).

RULES:
• Only engage with requests about: app functionality, printing, photography, historical/alternative processes, digital negatives/positives
• Politely decline unrelated topics - stay focused on quadGEN and printing
• NEVER change settings when user asks general questions (what, why, how, which, etc.)
• ONLY make changes when user explicitly commands it (set, change, enable, disable, apply, etc.)
• For general questions, provide advice/information WITHOUT making changes
• If unclear whether user wants changes, ASK before acting
• Confirm all actions taken
• Standard: K/MK=100%, colors=30-45% | Light: LC/LM/LK/LLK=60-80% | Rich black: K/MK+LK+LLK
• batch_channel_operations for multiple enable/disable same action (creates single batch undo)
• apply_to_all_channels for same percentage across enabled channels (creates single batch undo)
• apply_end_to_all_channels for same end value across enabled channels (creates single batch undo)
• Multiple set_channel_value calls for different percentages (individual undos)
• Multiple set_channel_end_value calls for different end values (individual undos)
• Ask clarification if ambiguous
• Process curve requests (cyanotype, palladium, etc.): Do NOT generate a preset. Briefly explain image-space vs printer-space and ask the user to load EDN (.cube/.acv) or LAB (.txt).

VALUE INTERPRETATION:
• Percentages (0-100%) and end values (0-65535) are equivalent representations
• 0% = 0, 33% ~ 21627, 50% = 32768, 100% = 65535
• Use set_channel_value for percentage requests ("set to 50%")
• Use set_channel_end_value for end value requests ("set to 32000")

UNDO/REDO BEHAVIOR:
• Batch operations (batch_channel_operations, apply_to_all_channels, apply_end_to_all_channels) create single undoable actions
• Individual channel changes (set_channel_value, set_channel_end_value, enable_disable_channel) create individual undos
• Users can undo entire batch operations with one button press
• Only actual state changes are recorded (enabling already-enabled channels creates no undo action)

CHANNEL SELECTION RULES - KEEP IT SIMPLE:
• Step 1: Look at provided state JSON, find channels with percentage > 0 OR endValue > 0 OR enabled = true
• Step 2: If user didn't specify a channel, use the FIRST enabled channel - that's it!
• Step 3: If NO channels enabled, ask which channel to use
• DO NOT overthink, DO NOT analyze "appropriateness", DO NOT enable new channels
• Curve names describe TONAL CHARACTERISTICS, not which ink to use` + (this.getSystemContext() ? ("\n\nRecent system notices:\n" + this.getSystemContext()) : '');
          const systemMessage = baseSystemMessage;


          // Prepare the API request messages
          const messages = [
            {
              role: 'user',
              content: `${contextMessage}\n\nUser request: ${userMessage}`
            }
          ];

          // Add conversation history (last 10 messages to avoid token limits)
          const recentHistory = this.conversationHistory.slice(-10);
          messages.splice(-1, 0, ...recentHistory);

          // Provider request helper with parsing and error propagation
          const requestProvider = async (provider) => {
            // Build provider-specific payload
            let payload;
            if (provider === 'openai') {
              const openaiMessages = [
                { role: 'system', content: systemMessage },
                ...recentHistory,
                messages[messages.length - 1]
              ];
              const openaiTools = CLAUDE_FUNCTIONS.map(func => ({
                type: 'function',
                function: {
                  name: func.name,
                  description: func.description,
                  parameters: func.parameters
                }
              }));
              payload = {
                provider: 'openai',
                model: OPENAI_MODEL,
                messages: openaiMessages,
                tools: openaiTools
                // Note: some models only support default temperature; omit to use default
              };
            } else {
              payload = {
                provider: 'anthropic',
                model: ANTHROPIC_MODEL,
                max_tokens: 1000,
                system: systemMessage,
                messages: messages,
                tools: CLAUDE_FUNCTIONS.map(func => ({
                  name: func.name,
                  description: func.description,
                  input_schema: func.parameters
                }))
              };
            }

            // Retry wrapper for transient errors (429/5xx/529)
            const maxAttempts = 3;
            let response, respText, data;
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              response = await fetch(WORKER_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });

              respText = await response.text();
              try { data = JSON.parse(respText); } catch { data = {}; }

              if (response.ok) break;

              const status = response.status;
              const retryAfterHeader = response.headers.get('Retry-After');
              const retryAfter = retryAfterHeader ? parseInt(retryAfterHeader, 10) * 1000 : null;
              const isRetryable = status === 429 || status === 529 || (status >= 500 && status <= 504);
              if (attempt < maxAttempts && isRetryable) {
                const backoff = retryAfter ?? attempt * 600; // ms
                if (DEBUG_AI || DEBUG_LOGS) console.warn(`Transient AI error ${status}; retrying in ${backoff}ms (attempt ${attempt}/${maxAttempts - 1})`);
                await new Promise(r => setTimeout(r, backoff));
                continue;
              }

              const errMsg = data?.error?.message || data?.error || response.statusText || 'Unknown error';
              const error = new Error(`API Error: ${status} - ${errMsg}`);
              error.status = status;
              error.provider = provider;
              error.data = data;
              throw error;
            }

            // One-time model/provider debug line
            if (!this._modelLogged) {
              const servedModel = data.model || (provider === 'openai' ? OPENAI_MODEL : ANTHROPIC_MODEL);
              const servedProvider = response.headers.get('X-Model-Provider') || provider;
              const connectMsg = `AI connected → provider: ${servedProvider}, model: ${servedModel}`;
              if (DEBUG_AI || DEBUG_LOGS) console.log(connectMsg);
              try { if (shouldShowAssistantStatus() && typeof addChatMessage === 'function') addChatMessage('system', connectMsg); } catch {}
              this._modelLogged = true;
            }

            // Mark AI as connected (successful response)
            aiConnected = true;
            refreshLabTechIcon();

            // Extract rate limit headers
            const rateLimitHeaders = {};
            ['x-ratelimit-limit', 'x-ratelimit-remaining', 'x-ratelimit-reset'].forEach(header => {
              const value = response.headers.get(header);
              if (value) rateLimitHeaders[header] = value;
            });

            // Process function calls and text
            const functionResults = [];
            let assistantMessage = '';
            if (provider === 'openai') {
              const choice = data.choices?.[0] || {};
              const msg = choice.message || {};
              // Robust text extraction for OpenAI variants
              if (typeof msg.content === 'string') {
                assistantMessage = msg.content;
              } else if (Array.isArray(msg.content)) {
                assistantMessage = msg.content.map(c => (typeof c === 'string' ? c : (c?.text ?? ''))).join('');
              } else if (typeof choice.text === 'string') {
                assistantMessage = choice.text; // Some responses include .text
              } else if (Array.isArray(data.output_text)) {
                assistantMessage = data.output_text.join('\n'); // Responses API style
              } else if (typeof data.output_text === 'string') {
                assistantMessage = data.output_text;
              }
              const toolCalls = msg.tool_calls || choice.tool_calls || [];
            for (const call of toolCalls) {
              if (call.type === 'function' && call.function?.name) {
                let args = {};
                try { args = JSON.parse(call.function.arguments || '{}'); } catch {}
                  if (DEBUG_AI || DEBUG_LOGS) console.log('🔧 Function call (OpenAI):', call.function.name, args);
                  const result = this.executeFunctionCall({ name: call.function.name, parameters: args }, userMessage);
                  functionResults.push({ function: call.function.name, parameters: args, result });
              }
            }
            } else {
              for (const content of data.content || []) {
                if (content.type === 'text') {
                  assistantMessage += content.text;
                } else if (content.type === 'tool_use') {
                  if (DEBUG_AI || DEBUG_LOGS) console.log('🔧 Function call (Anthropic):', content.name, content.input);
                  const result = this.executeFunctionCall({ name: content.name, parameters: content.input }, userMessage);
                  functionResults.push({ function: content.name, parameters: content.input, result });
                }
              }
            }

            return { assistantMessage, functionResults, rateLimitHeaders, provider };
          };

          // No fallback: strictly use the configured provider
          let result = await requestProvider(AI_PROVIDER);

          const { assistantMessage, functionResults, rateLimitHeaders } = result;
          let finalMessage = assistantMessage || '';

          // If the model didn't produce a narrative, synthesize a concise action summary for AI key point updates
          try {
            const hasSetAI = (functionResults || []).some(fr => fr.function === 'set_ai_key_points');
            if ((!finalMessage || finalMessage.trim().length === 0) && hasSetAI) {
              const parts = [];
              // Helper to build a one-line effect summary from key points
              const buildEffectSummary = (keyPoints) => {
                try {
                  if (!Array.isArray(keyPoints) || keyPoints.length < 2) return '';
                  // Determine peak absolute delta and its zone
                  let peak = { x: 50, d: 0 };
                  for (const p of keyPoints) {
                    const x = typeof p.input === 'number' ? p.input : Number(p.input);
                    const y = typeof p.output === 'number' ? p.output : Number(p.output);
                    if (!isFinite(x) || !isFinite(y)) continue;
                    const d = y - x; // positive = more ink (darken), negative = less ink (lighten)
                    if (Math.abs(d) > Math.abs(peak.d)) peak = { x, d };
                  }
                  if (!isFinite(peak.d)) return '';
                  const zone = (peak.x < 25) ? 'Highlight' : (peak.x > 75 ? 'Shadow' : 'Midtone');
                  const action = peak.d < 0 ? (zone === 'Shadow' ? 'lift' : 'lift') : (zone === 'Shadow' ? 'boost' : 'boost');
                  const outcome = peak.d < 0 ? (zone === 'Shadow' ? 'lighter shadows' : zone === 'Highlight' ? 'lighter highlights' : 'lighter midtones')
                                             : (zone === 'Shadow' ? 'darker shadows' : zone === 'Highlight' ? 'darker highlights' : 'darker midtones');
                  // Endpoints note
                  const first = keyPoints[0];
                  const last = keyPoints[keyPoints.length - 1];
                  const endpointsFixed = first && last && Math.round(first.input) === 0 && Math.round(first.output) === 0 && Math.round(last.input) === 100 && Math.round(last.output) === 100;
                  const endpointsNote = endpointsFixed ? '0/100 fixed' : 'endpoints anchored';
                  const peakPct = Math.round(Math.abs(peak.d));
                  const at = Math.round(peak.x);
                  return `Effect: ${zone.toLowerCase()} ${action} ${peakPct}% @ ${at}% → ${outcome}; ${endpointsNote}.`;
                } catch { return ''; }
              };

              let lastKP = null;
              for (const fr of functionResults) {
                if (fr.function === 'set_ai_key_points') {
                  const res = fr.result || {};
                  const d = res.details;
                  const msg = res.message || '';
                  const safeMsg = msg || 'Applied AI key points.';
                  if (d && Array.isArray(d.keyPoints)) {
                    const kpPreview = d.keyPoints.map(p => `${Math.round(p.input)}→${Math.round(p.output)}`).join(', ');
                    parts.push(`Action: ${safeMsg}\n- Preview: ${kpPreview}`);
                    lastKP = d.keyPoints;
                  } else {
                    parts.push(`Action: ${safeMsg}`);
                  }
                }
              }
              if (parts.length > 0) {
                const effect = buildEffectSummary(lastKP);
                if (effect) parts.push(effect);
                finalMessage = parts.join('\n\n');
              }
            }

            // Always format get_ai_key_points results (either fill or append)
            const getAIResults = (functionResults || []).filter(fr => fr.function === 'get_ai_key_points');
            if (getAIResults.length > 0) {
              const lines = [];
              for (const fr of getAIResults) {
                const res = fr.result || {};
                if (res.success && Array.isArray(res.keyPoints)) {
                  const ch = res.channelName || fr.parameters?.channelName || 'channel';
                  const list = res.keyPoints.map(p => `${Math.round(p.input)},${Math.round(p.output)}`).join(' ');
                  lines.push(`Key points (${ch}): ${list}`);
                } else if (res.message) {
                  lines.push(res.message);
                }
              }
              if (lines.length > 0) {
                if (!finalMessage || finalMessage.trim().length === 0) {
                  finalMessage = lines.join('\n');
                } else {
                  finalMessage += `\n${lines.join('\n')}`;
                }
              }
            }
          } catch (e) {
            if (DEBUG_AI || DEBUG_LOGS) console.warn('Failed to synthesize action summary:', e.message);
          }

          // No auto-citations; references removed (trust the model)
          
          if (DEBUG_AI || DEBUG_LOGS) console.log('📝 Total function calls processed:', functionResults.length);

          // Update conversation history
          this.conversationHistory.push(
            { role: 'user', content: userMessage },
            { role: 'assistant', content: finalMessage || 'I performed the requested actions.' }
          );

          return {
            success: true,
            message: 'Request processed successfully',
            response: finalMessage || 'Actions completed successfully.',
            functionResults: functionResults,
            actionsPerformed: functionResults.length > 0,
            rateLimitHeaders: rateLimitHeaders
          };

        } catch (error) {
          console.error('AI API Error:', error);
          // Mark AI as disconnected on error
          aiConnected = false;
          refreshLabTechIcon();
          return {
            success: false,
            message: `Error communicating with AI provider: ${error.message}`,
            response: `Sorry, I encountered an error: ${error.message}`
          };
        } finally {
          this.isProcessing = false;
        }
      }

      /**
       * Clear conversation history
       */
      clearHistory() {
        this.conversationHistory = [];
      }

      /**
       * Get processing status
       * @returns {boolean} Whether the assistant is currently processing
       */
      isProcessingRequest() {
        return this.isProcessing;
      }

      /**
       * Test the proxy connection
       * @returns {Promise<Object>} Connection test result
       */
      async testConnection() {
        try {
          const response = await fetch('http://localhost:8080/v1/messages', {
            method: 'OPTIONS'
          });
          return {
            success: response.ok,
            message: response.ok ? 'Proxy server is running' : 'Proxy server error'
          };
        } catch (error) {
          return {
            success: false,
            message: 'Proxy server not accessible. Please run: node cors-proxy.js'
          };
        }
      }

      /**
       * Validate API key by making a test request
       * @param {string} testApiKey - API key to validate
       * @returns {Promise<Object>} Validation result
       */
      async validateApiKey(testApiKey) {
        // Basic validation - let the API validate the format
        if (!testApiKey || typeof testApiKey !== 'string' || testApiKey.trim().length === 0) {
          return {
            success: false,
            message: 'Please enter a valid API key'
          };
        }

        try {
          
          const response = await fetch('http://localhost:8080/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': testApiKey,
              'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
              model: 'claude-sonnet-4-0',
              max_tokens: 10,
              messages: [
                {
                  role: 'user',
                  content: 'Test'
                }
              ]
            })
          });

          if (DEBUG_AI || DEBUG_LOGS) console.log('📡 API Response:', {
            status: response.status,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers.entries())
          });

          if (response.ok) {
            if (DEBUG_AI || DEBUG_LOGS) console.log('✅ API key validation successful');
            return {
              success: true,
              message: 'API key is valid'
            };
          } else {
            const errorData = await response.json().catch(() => ({}));
            if (DEBUG_AI || DEBUG_LOGS) console.log('❌ API Error Response:', errorData);
            
            let errorMessage = 'Authentication failed';
            
            if (response.status === 401) {
              errorMessage = errorData.error?.message || 'Invalid API key. Please check your key from console.anthropic.com';
            } else if (response.status === 429) {
              // Server-side rate limit from Cloudflare Worker
              const retryAfter = errorData.retryAfter || response.headers.get('Retry-After');
              errorMessage = errorData.message || 'Rate limit exceeded. Please try again later.';
              if (retryAfter) {
                errorMessage += ` (Wait ${retryAfter} seconds)`;
              }
            } else if (response.status >= 500) {
              errorMessage = 'Claude Sonnet 4 API server error. Please try again later.';
            } else if (errorData.error?.message) {
              errorMessage = errorData.error.message;
            }
            
            return {
              success: false,
              message: `${errorMessage} (Status: ${response.status})`,
              statusCode: response.status,
              rawError: errorData
            };
          }
        } catch (error) {
          console.error('🚨 Validation network error:', error);
          return {
            success: false,
            message: `Validation error: ${error.message}`
          };
        }
      }
    }

    // Create singleton instance
    const claudeAssistant = new LabTech();

    const PRINTERS = {
      P400: { name: "Epson P400", channels: ["K","C","M","Y","LC","LM"] },
      P800: { name: "Epson P600-P800", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "3880-7880": { name: "Epson 3880-7880", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "x800-x890": { name: "Epson x800-x890", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "x900": { name: "Epson x900", channels: ["K","C","M","Y","LC","LM","LK","LLK","OR","GR"] },
      "P4-6-8000": { name: "Epson P4-6-8000", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "P5-7-9000": { name: "Epson P5-7-9000", channels: ["K","C","M","Y","LC","LM","LK","LLK","OR","GR"] },
      P700P900: { name: "Epson P700-P900", channels: ["K","C","M","Y","LC","LM","LK","LLK","V","MK"] },
      
    };

    const INK_COLORS = {
      K: "#111111",
      C: "#00AEEF",
      M: "#EC008C",
      Y: "#FFF200",
      LC: "#8FD3FF",
      LM: "#FF9AD5",
      LK: "#777777",
      LLK: "#BBBBBB",
      OR: "#FF7F00",
      GR: "#00A651",
      V: "#7F00FF",
      MK: "#000000"
    };


    // Cache DOM elements
  const elements = {
      rows: document.getElementById('rows'),
      printerSelect: document.getElementById('printerSelect'),
      channelInfo: document.getElementById('channelInfo'),
      printerDescription: document.getElementById('printerDescription'),
      downloadBtn: document.getElementById('downloadBtn'),
      previewFull: document.getElementById('previewFull'),
      status: document.getElementById('status'),
      inkChart: document.getElementById('inkChart'),
      chartCursorTooltip: document.getElementById('chartCursorTooltip'),
      chartZoomInBtn: document.getElementById('chartZoomInBtn'),
      chartZoomOutBtn: document.getElementById('chartZoomOutBtn'),
      filenameInput: document.getElementById('filenameInput'),
      linearizationFile: document.getElementById('linearizationFile'),
      globalLinearizationBtn: document.getElementById('globalLinearizationBtn'),
      globalLinearizationHint: document.getElementById('globalLinearizationHint'),
      globalLinearizationToggle: document.getElementById('globalLinearizationToggle'),
      autoWhiteLimitToggle: document.getElementById('autoWhiteLimitToggle'),
      autoBlackLimitToggle: document.getElementById('autoBlackLimitToggle'),
      curveSmoothingMethod: document.getElementById('curveSmoothingMethod'),
      catmullTension: document.getElementById('catmullTension'),
      catmullTensionContainer: document.getElementById('catmullTensionContainer'),
      smoothingSlider: document.getElementById('smoothingSlider'),
      smoothingValue: document.getElementById('smoothingValue'),
      smoothingWarning: document.getElementById('smoothingWarning'),
      // Simplifier controls removed; handled in Edit Curves panel
      kpSimplifierContainer: document.getElementById('kpSimplifierContainer'),
      intentTuningPanel: document.getElementById('intentTuningPanel'),
      tuningInterpolationSelect: document.getElementById('tuningInterpolationSelect'),
      tuningSmoothingPercent: document.getElementById('tuningSmoothingPercent'),
      tuningSmoothingLabel: document.getElementById('tuningSmoothingLabel'),
      tuningSmoothingAlgorithm: document.getElementById('tuningSmoothingAlgorithm'),
      tuningPostPasses: document.getElementById('tuningPostPasses'),
      tuningPostPercent: document.getElementById('tuningPostPercent'),
      tuningPostLabel: document.getElementById('tuningPostLabel'),
      tuningPostAlgorithm: document.getElementById('tuningPostAlgorithm'),
      tuningNeighbors: document.getElementById('tuningNeighbors'),
      tuningSigmaFloor: document.getElementById('tuningSigmaFloor'),
      tuningSigmaCeil: document.getElementById('tuningSigmaCeil'),
      tuningSigmaAlpha: document.getElementById('tuningSigmaAlpha'),
      tuningApplyBtn: document.getElementById('tuningApplyBtn'),
      tuningRestoreBtn: document.getElementById('tuningRestoreBtn'),
      tuningStatus: document.getElementById('tuningStatus'),
      userNotes: document.getElementById('userNotes'),
      notesToggle: document.getElementById('notesToggle'),
      quadFile: document.getElementById('quadFile'),
      loadQuadBtn: document.getElementById('loadQuadBtn'),
      manualLstarBtn: document.getElementById('manualLstarBtn'),
      lstarModal: document.getElementById('lstarModal'),
      closeLstarModal: document.getElementById('closeLstarModal'),
      lstarInputs: document.getElementById('lstarInputs'),
      addLstarInput: document.getElementById('addLstarInput'),
      removeLstarInput: document.getElementById('removeLstarInput'),
      lstarCountInput: document.getElementById('lstarCountInput'),
      lstarValidation: document.getElementById('lstarValidation'),
      cancelLstar: document.getElementById('cancelLstar'),
      saveLstarTxt: document.getElementById('saveLstarTxt'),
      generateFromLstar: document.getElementById('generateFromLstar'),
      notesContent: document.getElementById('notesContent'),
      notesChevron: document.getElementById('notesChevron'),
      helpBtn: document.getElementById('helpBtn'),
      deltaSummary: document.getElementById('deltaSummary'),
      perChannelDeltaSelect: document.getElementById('perChannelDeltaSelect'),
      perChannelDeltaSummary: document.getElementById('perChannelDeltaSummary'),
      helpPopup: document.getElementById('helpPopup'),
      themeToggle: document.getElementById('themeToggle'),
      closeHelpBtn: document.getElementById('closeHelpBtn'),
      helpContent: document.getElementById('helpContent'),
      helpTabReadme: document.getElementById('helpTabReadme'),
      helpTabGlossary: document.getElementById('helpTabGlossary'),
      helpTabWorkflow: document.getElementById('helpTabWorkflow'),
      helpTabHistory: document.getElementById('helpTabHistory'),
      sessionStatus: document.getElementById('sessionStatus'),
      globalCorrectionHelpBtn: document.getElementById('globalCorrectionHelpBtn'),
      globalCorrectionHelpPopup: document.getElementById('globalCorrectionHelpPopup'),
      closeGlobalCorrectionHelpBtn: document.getElementById('closeGlobalCorrectionHelpBtn'),
      editModeHelpBtn: document.getElementById('editModeHelpBtn'),
      editModeHelpPopup: document.getElementById('editModeHelpPopup'),
      closeEditModeHelpBtn: document.getElementById('closeEditModeHelpBtn'),
      interpolationDescription: document.getElementById('interpolationDescription'),
      globalLinearizationInfo: document.getElementById('globalLinearizationInfo'),
      aiLabelToggle: document.getElementById('aiLabelToggle'),
      globalLinearizationFilename: document.getElementById('globalLinearizationFilename'),
      globalLinearizationDetails: document.getElementById('globalLinearizationDetails'),
      applyIntentToQuadBtn: document.getElementById('applyIntentToQuadBtn'),
      // Contrast Intent UI
      contrastIntentSelect: document.getElementById('contrastIntentSelect'),
      intentHelpBtn: document.getElementById('intentHelpBtn'),
      intentHelpPopup: document.getElementById('intentHelpPopup'),
      closeIntentHelpBtn: document.getElementById('closeIntentHelpBtn'),
      intentModal: document.getElementById('intentModal'),
      intentContent: document.getElementById('intentContent'),
      closeIntentModal: document.getElementById('closeIntentModal'),
      cancelIntentBtn: document.getElementById('cancelIntentBtn'),
      applyIntentBtn: document.getElementById('applyIntentBtn'),
      resetIntentBtn: document.getElementById('resetIntentBtn'),
      intentTabPresets: document.getElementById('intentTab-presets'),
      intentTabCustom: document.getElementById('intentTab-custom'),
      intentTabPaste: document.getElementById('intentTab-paste'),
      intentTabImport: document.getElementById('intentTab-import'),
      intentTabs: document.querySelectorAll('[data-intent-tab]'),
      intentPresetSelect: document.getElementById('intentPresetSelect'),
      intentGamma: document.getElementById('intentGamma'),
      intentGammaVal: document.getElementById('intentGammaVal'),
      intentGammaRow: document.getElementById('intentGammaRow'),
      intentFilmicRow: document.getElementById('intentFilmicRow'),
      intentFilmicGain: document.getElementById('intentFilmicGain'),
      intentFilmicGainVal: document.getElementById('intentFilmicGainVal'),
      intentShoulder: document.getElementById('intentShoulder'),
      intentShoulderVal: document.getElementById('intentShoulderVal'),
      customGamma: document.getElementById('customGamma'),
      customGammaVal: document.getElementById('customGammaVal'),
      customGain: document.getElementById('customGain'),
      customGainVal: document.getElementById('customGainVal'),
      customShoulder: document.getElementById('customShoulder'),
      customShoulderVal: document.getElementById('customShoulderVal'),
      intentPasteArea: document.getElementById('intentPasteArea'),
      intentPasteValidation: document.getElementById('intentPasteValidation'),
      intentImportBtn: document.getElementById('intentImportBtn'),
      intentImportFile: document.getElementById('intentImportFile'),
      intentImportInfo: document.getElementById('intentImportInfo'),
      
      intentPresetSelect: document.getElementById('intentPresetSelect'),
      intentGamma: document.getElementById('intentGamma'),
      intentGammaVal: document.getElementById('intentGammaVal'),
      intentFilmicGain: document.getElementById('intentFilmicGain'),
      intentFilmicGainVal: document.getElementById('intentFilmicGainVal'),
      intentShoulder: document.getElementById('intentShoulder'),
      intentShoulderVal: document.getElementById('intentShoulderVal'),
      intentGammaRow: document.getElementById('intentGammaRow'),
      intentFilmicRow: document.getElementById('intentFilmicRow'),
      intentTabPresets: document.getElementById('intentTab-presets'),
      intentTabCustom: document.getElementById('intentTab-custom'),
      intentTabPaste: document.getElementById('intentTab-paste'),
      intentTabs: document.querySelectorAll('[data-intent-tab]'),
      customGamma: document.getElementById('customGamma'),
      customGammaVal: document.getElementById('customGammaVal'),
      customGain: document.getElementById('customGain'),
      customGainVal: document.getElementById('customGainVal'),
      customShoulder: document.getElementById('customShoulder'),
      customShoulderVal: document.getElementById('customShoulderVal'),
      intentPasteArea: document.getElementById('intentPasteArea'),
      intentParseBtn: document.getElementById('intentParseBtn'),
      intentPasteValidation: document.getElementById('intentPasteValidation'),
      
      loadSampleLabData: document.getElementById('loadSampleLabData'),
      loadSampleCube: document.getElementById('loadSampleCube'),
      pageTitle: document.getElementById('pageTitle'),
      appVersion: document.getElementById('appVersion'),
      // Edit Curves panel
      editSmoothingSlider: document.getElementById('editSmoothingSlider'),
      editSmoothingValue: document.getElementById('editSmoothingValue'),
      editChannelSelect: document.getElementById('editChannelSelect'),
      editChannelPrev: document.getElementById('editChannelPrev'),
      editChannelNext: document.getElementById('editChannelNext'),
      editChannelState: document.getElementById('editChannelState'),
      editMaxError: document.getElementById('editMaxError'),
      editMaxPoints: document.getElementById('editMaxPoints'),
      editRecomputeBtn: document.getElementById('editRecomputeBtn'),
      editPanelBody: document.getElementById('editPanelBody'),
      editPointLeft: document.getElementById('editPointLeft'),
      editPointRight: document.getElementById('editPointRight'),
      editPointIndex: document.getElementById('editPointIndex'),
      editNudgeXNeg: document.getElementById('editNudgeXNeg'),
      editNudgeXPos: document.getElementById('editNudgeXPos'),
      editNudgeYUp: document.getElementById('editNudgeYUp'),
      editNudgeYDown: document.getElementById('editNudgeYDown'),
      editXYInput: document.getElementById('editXYInput'),
      editDeleteBtn: document.getElementById('editDeleteBtn'),
      editDisabledHint: document.getElementById('editDisabledHint'),
      // Lab Tech elements
      aiToggle: document.getElementById('aiToggle'),
      aiChevron: document.getElementById('aiChevron'),
      aiContent: document.getElementById('aiContent'),
      aiCompactBar: document.getElementById('aiCompactBar'),
      aiStatus: document.getElementById('aiStatus'), // Will be null - kept for compatibility
      aiStatusIcon: document.getElementById('aiStatusIcon'), // Will be null - kept for compatibility
      // usageCounter: document.getElementById('usageCounter'), // Disabled
      chatHistory: document.getElementById('chatHistory'),
      aiInput: document.getElementById('aiInput'),
      aiInputCompact: document.getElementById('aiInputCompact'),
      sendMessageBtn: document.getElementById('sendMessageBtn'),
      sendMessageBtnCompact: document.getElementById('sendMessageBtnCompact'),
      clearChatBtn: document.getElementById('clearChatBtn'),
      labTechIcon: document.getElementById('labTechIcon'),
  };

  // Enable/disable Revert buttons depending on loaded measurement data
  function updateRevertButtonsState() {
    try {
      // Global revert: enable if any global measurement is loaded (robust check)
      const globalBtn = document.getElementById('revertGlobalToMeasurementBtn');
      if (globalBtn) {
        const fmt = String(linearizationData?.format || '').toUpperCase();
        const isMeasurement = !!linearizationData && (fmt.includes('LAB') || fmt.includes('MANUAL')) && Array.isArray(linearizationData.originalData) && linearizationApplied === true;
        if (isMeasurement) { globalBtn.disabled = false; globalBtn.removeAttribute('disabled'); }
        else { globalBtn.disabled = true; globalBtn.setAttribute('disabled','disabled'); }
      }
    } catch {}
    try {
      // Per-channel revert: enabled only if per-channel measurement is present
      const rows = Array.from(elements.rows?.children || []);
      rows.forEach(tr => {
        const ch = tr && tr.getAttribute && tr.getAttribute('data-channel');
        if (!ch) return;
        const btn = tr.querySelector('.per-channel-revert');
        if (!btn) return;
        const hasMeas = !!perChannelLinearization[ch];
        const hasSmart = (typeof isSmartCurve === 'function') ? isSmartCurve(ch) : false;
        btn.disabled = !(hasMeas || hasSmart);
        if (!btn.disabled) {
          btn.title = hasMeas ? `Revert ${ch} to measurement source` : `Clear Smart (restore loaded .quad)`;
        }
        // Reserve space: hide visually but keep layout when disabled
        btn.classList.toggle('invisible', btn.disabled);
      });
    } catch {}
  }

  // No display orientation or Y semantics toggles in stable layout

    // Global defaults for key‑point simplifier
    let KP_SIMPLIFY = { maxErrorPercent: 0.25, maxPoints: 21 };
    // Maximum count at which we directly seed source points into AI key points
    // (Above this, we recompute/simplify to an edit‑friendly subset.)
    const DIRECT_SEED_MAX_POINTS = 25;

    const CHART_ZOOM_LEVELS = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
    const CHART_ZOOM_STORAGE_KEY = 'chartZoomPercentV1';
    let chartZoomIndex = CHART_ZOOM_LEVELS.length - 1; // default to 100%

    (function restoreChartZoomPreference() {
      try {
        const raw = localStorage.getItem(CHART_ZOOM_STORAGE_KEY);
        if (!raw) return;
        const saved = parseInt(raw, 10);
        if (!Number.isFinite(saved)) return;
        let nearest = CHART_ZOOM_LEVELS[0];
        let bestDiff = Math.abs(saved - nearest);
        for (let i = 1; i < CHART_ZOOM_LEVELS.length; i++) {
          const level = CHART_ZOOM_LEVELS[i];
          const diff = Math.abs(level - saved);
          if (diff < bestDiff) {
            nearest = level;
            bestDiff = diff;
          }
        }
        const idx = CHART_ZOOM_LEVELS.indexOf(nearest);
        if (idx >= 0) chartZoomIndex = idx;
      } catch {}
    })();

    function getChartZoomPercent() {
      return CHART_ZOOM_LEVELS[chartZoomIndex] || 100;
    }

    function persistChartZoom() {
      try {
        localStorage.setItem(CHART_ZOOM_STORAGE_KEY, String(getChartZoomPercent()));
      } catch {}
    }

    function getHighestActivePercent() {
      let maxPercent = 0;
      try {
        const rowNodes = elements.rows?.children ? Array.from(elements.rows.children) : [];
        rowNodes.forEach((row) => {
          if (!row || row.id === 'noChannelsRow') return;
          const endInput = row.querySelector ? row.querySelector('.end-input') : null;
          const rawValue = endInput?.value ?? 0;
          const endVal = (typeof InputValidator?.clampEnd === 'function')
            ? InputValidator.clampEnd(rawValue)
            : Number(rawValue) || 0;
          if (endVal <= 0) return;
          const percent = (typeof InputValidator?.computePercentFromEnd === 'function')
            ? InputValidator.computePercentFromEnd(endVal)
            : (endVal / TOTAL) * 100;
          if (Number.isFinite(percent)) {
            maxPercent = Math.max(maxPercent, percent);
          }
        });
      } catch {}
      return Math.max(0, Math.min(100, maxPercent));
    }

    function getMinimumAllowedZoomIndex() {
      const highest = getHighestActivePercent();
      if (!Number.isFinite(highest) || highest <= 0) return 0;
      const target = Math.min(100, Math.max(0, Math.ceil(highest / 10) * 10));
      for (let i = 0; i < CHART_ZOOM_LEVELS.length; i++) {
        if (CHART_ZOOM_LEVELS[i] >= target) return i;
      }
      return CHART_ZOOM_LEVELS.length - 1;
    }

    function updateChartZoomButtons() {
      try {
        const current = getChartZoomPercent();
        const minIdx = getMinimumAllowedZoomIndex();
        if (elements.chartZoomInBtn) {
          const atZoomInLimit = chartZoomIndex <= minIdx;
          elements.chartZoomInBtn.disabled = atZoomInLimit;
          elements.chartZoomInBtn.setAttribute('aria-disabled', atZoomInLimit ? 'true' : 'false');
          elements.chartZoomInBtn.setAttribute('aria-label', `Zoom in (current max ${current}%)`);
        }
        if (elements.chartZoomOutBtn) {
          const atZoomOutLimit = chartZoomIndex >= CHART_ZOOM_LEVELS.length - 1;
          elements.chartZoomOutBtn.disabled = atZoomOutLimit;
          elements.chartZoomOutBtn.setAttribute('aria-disabled', atZoomOutLimit ? 'true' : 'false');
          elements.chartZoomOutBtn.setAttribute('aria-label', `Zoom out (current max ${current}%)`);
        }
      } catch {}
    }

    function setChartZoomIndex(idx, options = {}) {
      const { persist = true, refresh = true } = options;
      const minIdx = getMinimumAllowedZoomIndex();
      const clampedIdx = Math.max(minIdx, Math.min(CHART_ZOOM_LEVELS.length - 1, idx));
      const changed = clampedIdx !== chartZoomIndex;
      chartZoomIndex = clampedIdx;
      if (persist) persistChartZoom();
      updateChartZoomButtons();
      if (changed) {
        try { updateSessionStatus(); } catch {}
      }
      if (refresh && changed) {
        try { updateInkChart(); } catch {}
      }
      return getChartZoomPercent();
    }

    function setChartZoomPercent(percent, options = {}) {
      const target = Number(percent);
      if (!Number.isFinite(target)) return getChartZoomPercent();
      let nearest = CHART_ZOOM_LEVELS[0];
      let bestDiff = Math.abs(target - nearest);
      for (let i = 1; i < CHART_ZOOM_LEVELS.length; i++) {
        const level = CHART_ZOOM_LEVELS[i];
        const diff = Math.abs(level - target);
        if (diff < bestDiff) {
          nearest = level;
          bestDiff = diff;
        }
      }
      return setChartZoomIndex(CHART_ZOOM_LEVELS.indexOf(nearest), options);
    }

    function stepChartZoom(direction, options = {}) {
      const dir = direction >= 0 ? -1 : 1;
      const idx = chartZoomIndex + dir;
      return setChartZoomIndex(idx, options);
    }

    function normalizeDisplayMax(geom) {
      const raw = Number(geom?.displayMax);
      if (Number.isFinite(raw) && raw > 0) return raw;
      return 100;
    }

    function clampPercentForDisplay(percent, geom) {
      const max = normalizeDisplayMax(geom);
      if (!Number.isFinite(percent)) return 0;
      return Math.max(0, Math.min(max, percent));
    }

    function mapPercentToY(percent, geom) {
      const max = normalizeDisplayMax(geom);
      let chartHeight = Number(geom?.chartHeight);
      const padding = Number(geom?.padding) || 0;
      const height = Number(geom?.height) || 0;
      if (!Number.isFinite(chartHeight) || chartHeight <= 0) {
        chartHeight = Math.max(0, height - 2 * padding);
      }
      const clamped = clampPercentForDisplay(percent, geom);
      if (chartHeight <= 0) return height - padding;
      return height - padding - (chartHeight * (clamped / max));
    }

    function mapYToPercent(yPx, geom) {
      const max = normalizeDisplayMax(geom);
      let chartHeight = Number(geom?.chartHeight);
      const padding = Number(geom?.padding) || 0;
      const height = Number(geom?.height) || 0;
      if (!Number.isFinite(chartHeight) || chartHeight <= 0) {
        chartHeight = Math.max(0, height - 2 * padding);
      }
      if (chartHeight <= 0) return 0;
      const ratio = (height - padding - yPx) / chartHeight;
      const value = ratio * max;
      if (!Number.isFinite(value)) return 0;
      return Math.max(0, Math.min(max, value));
    }

    function rescaleSmartCurveForInkLimit(channelName, fromPercent, toPercent) {
      try {
        if (!channelName) return;
        const fromPct = Number(fromPercent);
        const toPct = Number(toPercent);
        if (!Number.isFinite(fromPct) || !Number.isFinite(toPct)) return;
        const fromScale = InputValidator.clampPercent(fromPct) / 100;
        const toScale = InputValidator.clampPercent(toPct) / 100;
        if (!Number.isFinite(fromScale) || !Number.isFinite(toScale) || fromScale <= 0 || toScale <= 0) return;
        if (Math.abs(fromScale - toScale) < 1e-6) return;
        const { points, interpolation } = ControlPoints.get(channelName);
        if (!points || points.length === 0) return;
        const factor = fromScale / toScale;
        if (!Number.isFinite(factor) || factor <= 0) return;
        const scaledPoints = points.map(p => ({ input: p.input, output: ControlPolicy.clampY(p.output * factor) }));
        ControlPoints.persist(channelName, scaledPoints, interpolation);
        try {
          const curve = quadGenActions._interpolateCurve(scaledPoints, interpolation === 'linear' ? 'linear' : 'smooth');
          quadGenActions._applyCurveToChannel(channelName, curve, { oldKeyPoints: null, newKeyPoints: scaledPoints.map(pt => ({ input: pt.input, output: pt.output })), oldInterpolation: interpolation, newInterpolation: interpolation });
        } catch (e) {
          if (DEBUG_LOGS) console.warn('rescaleSmartCurveForInkLimit apply failed:', e);
        }
      } catch (err) {
        if (DEBUG_LOGS) console.warn('rescaleSmartCurveForInkLimit failed:', err);
      }
    }

    // clampSimplifierSettings removed; simplifier is managed by Edit Curves panel

    // Internal state: track whether we auto-toggled overlays off due to multi-channel selection
    let overlayAutoToggledOff = false;
    // Lab Tech: command history for Up/Down navigation
    let aiCommandHistory = [];
    let aiHistoryIndex = 0; // points to next insertion (history.length). Up/Down move within [0..length]
    // Lab Tech: AI connection indicator
    let aiConnected = null; // null = unknown/pending (💬), true = connected (⚡), false = disconnected (🚫)

    function refreshLabTechIcon() {
      try {
        if (!elements.labTechIcon) return;
        elements.labTechIcon.textContent = (aiConnected === true) ? '⚡' : (aiConnected === false ? '🚫' : '💬');
      } catch {}
    }

    // Contrast Intent state and helpers
    const DEFAULT_INTENT = { id: 'linear', name: 'Linear', source: 'preset', params: getPreset('linear')?.params || {} };
    // Always default to Linear at startup; custom sliders/paste are persisted separately
    let contrastIntent = DEFAULT_INTENT;

    // clamp01 defined later globally; use it here at call time
    function schlickBias(t, b){ const k = (1/Math.max(1e-6,b) - 2); return t / (k * (1 - t) + 1); }
    function schlickGain(t, g){ if (t < 0.5) return 0.5 * schlickBias(t*2, 1-g); return 1 - 0.5 * schlickBias(2 - 2*t, 1-g); }
    function gammaMap(t, gamma){ const g = Math.max(0.01, Number(gamma)||1.0); return Math.pow(clamp01(t), g); }
    function filmicSoftShoulder(t, gain, shoulder){ const y = schlickGain(clamp01(t), clamp01(gain)); const y2 = 1 - Math.pow(1 - y, 1 + clamp01(shoulder)); return clamp01(y2); }
    function popsCompatStandard(t){ const y = schlickGain(clamp01(t), 0.55); const shoulder = 0.15; const y2 = 1 - Math.pow(1 - y, 1 + shoulder); return clamp01(y2); }

    // Compile a monotone intent function from anchor points [[t,d_rel]...]
    function compileIntentFromPoints(points){
      try {
        const pts = (points||[]).filter(p=>Array.isArray(p)&&p.length>=2).map(([t,y])=>[clamp01(+t), clamp01(+y)]);
        if (pts.length < 2) return (t)=>clamp01(t);
        if (pts[0][0] !== 0) pts.unshift([0,0]);
        if (pts[pts.length-1][0] !== 1) pts.push([1,1]);
        pts.sort((a,b)=>a[0]-b[0]);

        // Convert points to 256 uniform samples for consistent transformation pipeline
        const samples = new Array(256);
        const xs = pts.map(p=>p[0]);
        const ys = pts.map(p=>p[1]);

        for (let i=1;i<ys.length;i++){ if (ys[i] < ys[i-1]) ys[i] = ys[i-1]; }
        const tempInterp = createPCHIPSpline(xs, ys);

        for (let i = 0; i < 256; i++) {
          const inputValue = i / 255;
          samples[i] = clamp01(tempInterp(inputValue));
        }

        // Apply the same transformation as ACV files via DataSpace helper
        const transformedSamples = DataSpace.convertSamples(samples, {
          from: DataSpace.SPACE.IMAGE,
          to: DataSpace.SPACE.PRINTER
        });

        // Build final target function from transformed samples
        return buildTargetFnFromSamples(transformedSamples.values);
      } catch (e) {
        console.warn('compileIntentFromPoints failed:', e);
        return (t)=>clamp01(t);
      }
    }

    // Build a target intent function from uniformly spaced samples (0..1 domain)
    function buildTargetFnFromSamples(samples){
      try {
        const n = Array.isArray(samples) ? samples.length : 0;
        if (n < 2) return (t)=>clamp01(t);
        const xs = new Array(n);
        for (let i=0;i<n;i++) xs[i] = i/(n-1);
        const pchip = createPCHIPSpline(xs, samples.map(v=>clamp01(Number(v)||0)));
        return (t)=> clamp01(pchip(clamp01(t)));
      } catch { return (t)=>clamp01(t); }
    }

    // Cache for expensive intent transformations
    let _intentCache = { id: null, targetFn: null };

    function getTargetRelAt(t){
      const id = (contrastIntent && contrastIntent.id) || 'linear';

      // Linear stays linear in any space
      if (id === 'linear') return clamp01(t);

      // Check for preset definitions first - treat as image space and transform to printer space
      const preset = CONTRAST_INTENT_PRESETS[id];
      if (preset && preset.curveFunction) {
        // For gamma-based presets, use reciprocal gamma (image-space to printer-space conversion)
        if (preset.params && typeof preset.params.gamma === 'number') {
          const imageSpaceGamma = preset.params.gamma;
          const printerSpaceGamma = 1.0 / imageSpaceGamma;
          return Math.pow(clamp01(t), printerSpaceGamma);
        }
        // For non-gamma presets (PoPS, filmic), use cached transformation
        else {
          try {
            // Check cache first
            if (_intentCache.id !== id || !_intentCache.targetFn) {
              // Generate 256 samples from the image-space curve function
              const samples = new Array(256);
              for (let i = 0; i < 256; i++) {
                const inputValue = i / 255;
                samples[i] = preset.curveFunction(inputValue);
              }

              const transformedSamples = DataSpace.convertSamples(samples, {
                from: DataSpace.SPACE.IMAGE,
                to: DataSpace.SPACE.PRINTER
              });

              const targetFn = buildTargetFnFromSamples(transformedSamples.values);

              // Cache the result
              _intentCache = { id, targetFn };
            }

            return _intentCache.targetFn(t);
          } catch (e) {
            console.warn('Intent processing failed for', id, ':', e);
            return clamp01(t); // Fallback to linear
          }
        }
      }

      // Handle custom intents - treat as image space and transform to printer space
      if (id === 'pops_standard') {
        try {
          // Check cache first
          if (_intentCache.id !== id || !_intentCache.targetFn) {
            const samples = new Array(256);
            for (let i = 0; i < 256; i++) {
              const inputValue = i / 255;
              samples[i] = popsCompatStandard(inputValue);
            }
            const transformedSamples = DataSpace.convertSamples(samples, {
              from: DataSpace.SPACE.IMAGE,
              to: DataSpace.SPACE.PRINTER
            });
            const targetFn = buildTargetFnFromSamples(transformedSamples.values);
            _intentCache = { id, targetFn };
          }
          return _intentCache.targetFn(t);
        } catch (e) {
          console.warn('Intent processing failed for pops_standard:', e);
          return clamp01(t);
        }
      }

      if (id === 'custom_gamma') {
        try {
          const imageSpaceGamma = contrastIntent?.params?.gamma ?? 1.0;
          const printerSpaceGamma = 1.0 / imageSpaceGamma;
          return Math.pow(clamp01(t), printerSpaceGamma);
        } catch (e) {
          console.warn('Intent processing failed for custom_gamma:', e);
          return clamp01(t);
        }
      }

      if (id === 'custom_filmic') {
        try {
          // Create cache key with parameters
          const cacheKey = `${id}_${contrastIntent?.params?.gain ?? 0.55}_${contrastIntent?.params?.shoulder ?? 0.35}`;
          if (_intentCache.id !== cacheKey || !_intentCache.targetFn) {
            const samples = new Array(256);
            for (let i = 0; i < 256; i++) {
              const inputValue = i / 255;
              samples[i] = filmicSoftShoulder(inputValue, contrastIntent?.params?.gain ?? 0.55, contrastIntent?.params?.shoulder ?? 0.35);
            }
            const transformedSamples = DataSpace.convertSamples(samples, {
              from: DataSpace.SPACE.IMAGE,
              to: DataSpace.SPACE.PRINTER
            });
            const targetFn = buildTargetFnFromSamples(transformedSamples.values);
            _intentCache = { id: cacheKey, targetFn };
          }
          return _intentCache.targetFn(t);
        } catch (e) {
          console.warn('Intent processing failed for custom_filmic:', e);
          return clamp01(t);
        }
      }

      // Points-based intents (pasted/imported) - ALREADY transformed to printer space during parsing
      if (id === 'custom_points' && typeof contrastIntent.targetFn === 'function') {
        try {
          const result = contrastIntent.targetFn(t); // Already in printer space via DataSpace conversion
          if (t === 0 || t === 1) {
            console.log('DEBUG: custom_points intent at', (t*100).toFixed(0) + '%:', result.toFixed(3));
          }
          return result;
        } catch (e) {
          console.warn('Intent processing failed for custom_points:', e);
          return clamp01(t);
        }
      }

      // Default fallback
      return clamp01(t);
    }

    function persistContrastIntent(){ try { localStorage.setItem('contrastIntentV1', JSON.stringify({ id: contrastIntent.id, name: contrastIntent.name, source: contrastIntent.source||'preset', params: contrastIntent.params||{}, hasPoints: !!contrastIntent.targetFn })); } catch {} }
    function setContrastIntent(newId, params, source){
      const id = newId || 'linear';
      const preset = getPreset(id);
      const baseParams = preset && preset.params ? { ...preset.params } : {};
      const providedParams = params ? { ...params } : {};
      const p = Object.keys(baseParams).length ? { ...baseParams, ...providedParams } : providedParams;
      let name = 'Linear';
      let targetFn = null;

      if (id === 'custom_points') {
        name = (providedParams && providedParams.name) ? providedParams.name : 'Custom (points)';
        targetFn = providedParams?.targetFn || null;
      } else if (id === 'custom_gamma') {
        name = 'Custom Gamma';
      } else if (id === 'custom_filmic') {
        name = 'Custom Filmic';
      } else if (id === 'pops_standard') {
        name = 'POPS‑Compat (Standard)';
      } else if (preset) {
        name = preset.label || preset.name || preset.id || 'Linear';
      } else {
        name = id === 'linear' ? 'Linear' : id;
      }

      const prev = contrastIntent ? { id: contrastIntent.id, name: contrastIntent.name, source: contrastIntent.source, params: contrastIntent.params, targetFn: contrastIntent.targetFn } : null;
      contrastIntent = { id, name, source: source || (id.startsWith('custom')?'custom':'preset'), params: p, targetFn };

      // Clear intent cache when intent changes
      _intentCache = { id: null, targetFn: null };
      // Mark that a custom intent exists so the main dropdown can show "Custom"
      try { if (String(id).startsWith('custom')) localStorage.setItem('hasCustomIntentV1', '1'); } catch {}
      // Persist "last applied custom" kind so 'Custom (saved)' restores the most recent from any tab
      try {
        if (String(id).startsWith('custom')) {
          localStorage.setItem('lastCustomTimestampV1', String(Date.now()));
          if (id === 'custom_points') {
            // Distinguish paste vs import based on provided source hint
            const src = (source||'').toLowerCase();
            localStorage.setItem('lastCustomKindV1', 'points');
            localStorage.setItem('lastCustomPointsSourceV1', (src === 'import') ? 'import' : 'paste');
          } else if (id === 'custom_gamma') {
            localStorage.setItem('lastCustomKindV1', 'gamma');
          } else if (id === 'custom_filmic') {
            localStorage.setItem('lastCustomKindV1', 'filmic');
          }
        }
      } catch {}
      if (elements.contrastIntentSelect) {
        const idStr = String(id);
        const opts = Array.from(elements.contrastIntentSelect.options).map(o=>o.value);
        if (idStr.startsWith('custom') && opts.includes('custom')) elements.contrastIntentSelect.value = 'custom';
        else if (opts.includes(idStr)) elements.contrastIntentSelect.value = idStr;
      }
      persistContrastIntent();
      updateIntentDetailLabel();
      updateIntentDropdownState();
      try { updateSessionStatus(); } catch {}
      recomputeLinearizationForCurrentIntent();
      try { if (typeof updateCustomOptionVisibility === 'function') updateCustomOptionVisibility(); } catch {}
      try {
        CurveHistory.recordUIAction('intent', prev, { id, name, source: contrastIntent.source, params: p, targetFn }, `Change Contrast Intent → ${name}`);
      } catch {}
      try { updateInkChart(); } catch {}
    }
    function updateIntentDetailLabel(){
      try {
        // Keep the loaded correction filename/details clean; show intent as a tooltip on the dropdown instead
        const detailsEl = elements.globalLinearizationDetails;
        if (detailsEl) {
          const base = detailsEl.textContent || '';
          // Strip any previous appended intent text if present
          const cleaned = base.replace(/\s+—\s+Intent:.*$/, '');
          if (cleaned !== base) detailsEl.textContent = cleaned;
        }

        // Build concise tooltip for the intent dropdown
        const intentLabel = contrastIntent?.name || 'Linear';
        const params = contrastIntent?.params || {};
        let extra = '';
        if (contrastIntent.id === 'soft') extra = ` (γ≈0.85)`;
        else if (contrastIntent.id === 'hard') extra = ` (γ≈1.20)`;
        else if (contrastIntent.id === 'custom_gamma') extra = ` (γ=${(params.gamma??1).toFixed?params.gamma.toFixed(2):params.gamma})`;
        else if (contrastIntent.id === 'filmic' || contrastIntent.id === 'custom_filmic') {
          const gain = Number(params.filmicGain ?? params.gain ?? 0.55);
          const shoulder = Number(params.shoulder ?? 0.35);
          extra = ` (gain ${isFinite(gain)?gain.toFixed(2):'0.55'}, shoulder ${isFinite(shoulder)?shoulder.toFixed(2):'0.35'})`;
        }
        const tip = `Intent: ${intentLabel}${extra}`;
        if (elements.contrastIntentSelect) elements.contrastIntentSelect.setAttribute('title', tip);
      } catch {}
    }
    function canApplyIntentRemap() {
      try {
        const hasQuad = !!(window.loadedQuadData && window.loadedQuadData.curves && Object.keys(window.loadedQuadData.curves).length);
        const hasGlobalMeasurement = !!linearizationData;
        return hasQuad && !hasGlobalMeasurement;
      } catch { return false; }
    }
    function recomputeLinearizationForCurrentIntent(){
      try {
        if (!linearizationData || !linearizationApplied) return;
        console.log('DEBUG: Recomputing LAB for intent:', contrastIntent?.id, contrastIntent?.name);
        const fmt = String(linearizationData.format||'').toUpperCase();
        if (fmt.includes('LAB') && Array.isArray(linearizationData.originalData)) {
          console.log('DEBUG: Rebuilding LAB linearization with', linearizationData.originalData.length, 'data points');
          const rebuilt = buildLabLinearizationFromOriginal(linearizationData.originalData);
          console.log('DEBUG: LAB rebuild result:', rebuilt ? 'success' : 'failed', 'samples:', rebuilt?.samples?.length);
          rebuilt.filename = linearizationData.filename || 'LAB-Data';
          linearizationData = normalizeLinearizationEntry(rebuilt);
          elements.globalLinearizationInfo.classList.remove('hidden');
          updateInterpolationControls(); updatePreview(); try { postGlobalDeltaChatSummary(); } catch {}
        } else if (fmt.includes('MANUAL') && Array.isArray(linearizationData.originalData)) {
          const rebuilt = buildManualLinearizationFromOriginal(linearizationData.originalData);
          rebuilt.filename = linearizationData.filename || 'Manual L* Entry';
          linearizationData = normalizeLinearizationEntry(rebuilt);
          elements.globalLinearizationInfo.classList.remove('hidden');
          updateInterpolationControls(); updatePreview(); try { postGlobalDeltaChatSummary(); } catch {}
        }
      } catch (e) { console.warn('Recompute intent failed:', e); }
    }
    function buildLabLinearizationFromOriginal(originalDataPoints, targetOverrideFn, options = {}){
      const skipDefaultSmoothing = options && options.skipDefaultSmoothing;
      try {
        const dataPoints = Array.from(originalDataPoints||[]).map(p=>({ input: p.input, lab: p.lab }));
        if (!dataPoints.length) throw new Error('No LAB original data');
        dataPoints.sort((a,b)=>a.input-b.input);
        const labValues = dataPoints.map(p=>p.lab);
        const D_values = labValues.map(L => cieDensityFromLstar(L));
        const Dmax = Math.max(...D_values, 1e-6);
        console.log('DEBUG: Processing', dataPoints.length, 'LAB points, Dmax:', Dmax);
        const correctionPoints = dataPoints.map(point => {
          const pos = Math.max(0, Math.min(1, point.input / 100));
          const actualDensity = cieDensityFromLstar(point.lab) / Dmax;
          const expectedDensity = (typeof targetOverrideFn === 'function' ? targetOverrideFn(pos) : getTargetRelAt(pos));
          const correction = expectedDensity - actualDensity;
          if (point.input === 0 || point.input === 100) {
            console.log('DEBUG: Endpoint', point.input + '%: actual =', actualDensity.toFixed(3), 'expected =', expectedDensity.toFixed(3), 'correction =', correction.toFixed(3));
          }
          return { position: pos, correction, originalLab: point.lab, originalInput: point.input };
        });
        const positionsOnly = correctionPoints.map(p => p.position);
        const K_NEIGHBORS = LAB_TUNING.get('K_NEIGHBORS', 6);
        const SIGMA_FLOOR = LAB_TUNING.get('SIGMA_FLOOR', 0.02);
        const SIGMA_CEIL = LAB_TUNING.get('SIGMA_CEIL', 0.15);
        const SIGMA_ALPHA = LAB_TUNING.get('SIGMA_ALPHA', 3.0);
        function localSigmaAt(t) {
          const n = positionsOnly.length; if (n <= 1) return SIGMA_CEIL;
          let lo = 0, hi = n; while (lo < hi) { const mid = (lo + hi) >> 1; if (positionsOnly[mid] < t) lo = mid + 1; else hi = mid; }
          const dists = []; let L = lo - 1, R = lo; while ((L >= 0 || R < n) && dists.length < K_NEIGHBORS) { const dl = (L >= 0) ? Math.abs(t - positionsOnly[L]) : Infinity; const dr = (R < n) ? Math.abs(t - positionsOnly[R]) : Infinity; if (dl <= dr) { if (isFinite(dl)) dists.push(dl); L--; } else { if (isFinite(dr)) dists.push(dr); R++; } }
          if (!dists.length) return SIGMA_CEIL; dists.sort((a,b)=>a-b); const mid = dists.length >> 1; const med = (dists.length % 2 === 0) ? 0.5*(dists[mid-1]+dists[mid]) : dists[mid];
          return Math.min(SIGMA_CEIL, Math.max(SIGMA_FLOOR, SIGMA_ALPHA * med));
        }
        let samples = []; for (let i=0;i<256;i++){ const t = i/255; const sigma = localSigmaAt(t); const denom = 2*sigma*sigma; let num=0, den=0; for (let j=0;j<correctionPoints.length;j++){ const d = Math.abs(t - correctionPoints[j].position); const w = Math.exp(-(d*d)/Math.max(1e-9,denom)); num += correctionPoints[j].correction*w; den += w; } const corr = den>0 ? (num/den) : 0; samples.push(Math.max(0, Math.min(1, t + corr))); }
        samples[0]=0.0; samples[255]=1.0;
        if (!skipDefaultSmoothing) {
          samples = applySmoothingSequence(samples, 30, 'smoothing-splines');
          samples = applySmoothingSequence(samples, 30, 'smoothing-splines');
        }
        samples[0] = 0.0; samples[samples.length - 1] = 1.0;
        console.log('DEBUG: LAB samples at key points:', 'sample[64]:', samples[64].toFixed(3), 'sample[128]:', samples[128].toFixed(3), 'sample[192]:', samples[192].toFixed(3));
        console.log('DEBUG: Is linear?', samples.every((val, i) => Math.abs(val - i/255) < 0.001));
        return {
          domainMin:0.0,
          domainMax:1.0,
          samples,
          originalData: dataPoints,
          format:'LAB Data',
          sourceSpace: DataSpace.SPACE.PRINTER,
          getSmoothingControlPoints: function(sp){ const widen = 1 + (Math.max(0, Math.min(90, Number(sp) || 0))/100); const dyn = new Array(256); for (let i=0;i<256;i++){ const t=i/255; const sigma = Math.min(0.15, Math.max(0.02, localSigmaAt(t)*widen)); const denom=2*sigma*sigma; let num=0, den=0; for (let j=0;j<correctionPoints.length;j++){ const d = Math.abs(t - correctionPoints[j].position); const w = Math.exp(-(d*d)/Math.max(1e-9,denom)); num += correctionPoints[j].correction*w; den += w; } dyn[i]=Math.max(0, Math.min(1, t + (den>0?(num/den):0))); } dyn[0]=0.0; dyn[255]=1.0; const K = 21 - Math.floor(Math.max(0, Math.min(90, Number(sp) || 0))/10); const controlPointCount = Math.max(3, K); const cpY = []; const cpX = []; for (let i=0;i<controlPointCount;i++){ const x = i/(controlPointCount-1); const idx = Math.round(x*255); cpX.push(x); cpY.push(dyn[idx]); } return { samples: cpY, xCoords: cpX, needsDualTransformation: false }; }
        };
      } catch (e) { console.warn('buildLabLinearizationFromOriginal failed:', e); return linearizationData || { domainMin:0, domainMax:1, samples: Array.from({length:256},(_,i)=>i/255), format:'LAB Data', sourceSpace: DataSpace.SPACE.PRINTER }; }
    }
    function buildManualLinearizationFromOriginal(originalData, targetOverrideFn, options = {}){
      const skipDefaultSmoothing = options && options.skipDefaultSmoothing;
      try {
        const measuredXs = originalData.map(p=>p.input);
        const measuredL = originalData.map(p=>p.lab);
        const N = measuredL.length;

        // Auto-detect range for input values: if any input value > 100, assume 0-255 range; otherwise 0-100 range
        // L* values are always 0-100 by CIE LAB standard
        const maxInputValue = measuredXs.length > 0 ? Math.max(...measuredXs) : 0;
        const divisor = maxInputValue > 100 ? 255 : 100;
        const posNorm = measuredXs.map(v => Math.max(0, Math.min(divisor, v)) / divisor);

        const Dvals = measuredL.map(L => cieDensityFromLstar(L));
        const Dmax = Math.max(...Dvals, 1e-6);
        const actualDensity = Dvals.map(D => D / Dmax);
        const targetDensity = posNorm.map(t => (typeof targetOverrideFn === 'function' ? targetOverrideFn(t) : getTargetRelAt(t)));
        const cps = posNorm.map((pos,i)=>({ position: pos, correction: (targetDensity[i] - actualDensity[i]) }));
        const positionsOnly = cps.map(p=>p.position);
        const K = LAB_TUNING.get('K_NEIGHBORS', 6);
        const F = LAB_TUNING.get('SIGMA_FLOOR', 0.02);
        const C = LAB_TUNING.get('SIGMA_CEIL', 0.15);
        const A = LAB_TUNING.get('SIGMA_ALPHA', 3.0);

        function localSigmaAt(t){
          const n=positionsOnly.length;
          if (n<=1) return C;
          let lo=0,hi=n;
          while(lo<hi){
            const mid=(lo+hi)>>1;
            if(positionsOnly[mid]<t) lo=mid+1;
            else hi=mid;
          }
          const d=[]; let L=lo-1,R=lo;
          while((L>=0||R<n)&&d.length<K){
            const dl=(L>=0)?Math.abs(t-positionsOnly[L]):Infinity;
            const dr=(R<n)?Math.abs(t-positionsOnly[R]):Infinity;
            if(dl<=dr){ if(isFinite(dl))d.push(dl); L--; }
            else { if(isFinite(dr))d.push(dr); R++; }
          }
          if(!d.length) return C;
          d.sort((a,b)=>a-b);
          const m=d.length>>1;
          const med=(d.length%2===0)?0.5*(d[m-1]+d[m]):d[m];
          return Math.min(C, Math.max(F, A*med));
        }

        const samples=[];
        for(let i=0;i<256;i++){
          const t=i/255;
          const s=localSigmaAt(t);
          const denom=2*s*s;
          let num=0, den=0;
          for(let j=0;j<cps.length;j++){
            const dd=Math.abs(t-cps[j].position);
            const w=Math.exp(-(dd*dd)/Math.max(1e-9,denom));
            num+=cps[j].correction*w;
            den+=w;
          }
          samples[i]=Math.max(0, Math.min(1, t + (den>0?(num/den):0)));
        }
        samples[0]=0.0; samples[255]=1.0;
        return {
          domainMin:0,
          domainMax:1,
          samples,
          originalData: originalData.slice(),
          format: 'Manual L* Entry',
          sourceSpace: DataSpace.SPACE.PRINTER
        };
      } catch(e){
        console.warn('buildManualLinearizationFromOriginal failed:', e);
        return linearizationData;
      }
    }

    // Helper to prefix edited filenames for display
    function getEditedDisplayName(name, edited) {
      if (!name) return '';
      return edited ? `✦Edited✦ ${name}` : name;
    }

    // Helper to describe base/editable point counts for linearization datasets
    function getBasePointCountLabel(data) {
      if (!data) return '';
      const fmt = (data.format || '').toUpperCase();
      // Normalize all types to a compact "N points" label
      if (fmt === 'ACV' && Array.isArray(data.controlPointsTransformed)) {
        return `${data.controlPointsTransformed.length} points`;
      }
      if ((fmt.includes('LAB') || fmt.includes('MANUAL')) && Array.isArray(data.originalData)) {
        return `${data.originalData.length} points`;
      }
      if (Array.isArray(data.originalSamples)) return `${data.originalSamples.length} points`;
      if (Array.isArray(data.samples)) return `${data.samples.length} points`;
      return '';
    }

    function refreshGlobalLinearizationDisplay() {
      if (!elements.globalLinearizationBtn || !elements.globalLinearizationFilename) return;
      if (linearizationData) {
        const base = linearizationData.filename || 'unknown file';
        const disp = getEditedDisplayName(base, !!linearizationData.edited);
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${disp}`);
        elements.globalLinearizationFilename.textContent = disp;
        try {
          const rev = document.getElementById('revertGlobalToMeasurementBtn');
          if (rev) { rev.disabled = false; rev.removeAttribute('disabled'); }
        } catch {}
      }
    }

    function refreshPerChannelLinearizationDisplay(channelName) {
      const tr = getChannelRow(channelName);
      if (!tr) return;
      const perChannelBtn = tr.querySelector('.per-channel-btn');
      if (perChannelBtn) {
        const base = perChannelFilenames[channelName] || 'unknown file';
        const edited = !!(perChannelLinearization[channelName] && perChannelLinearization[channelName].edited);
        const disp = getEditedDisplayName(base, edited);
        perChannelBtn.setAttribute('data-tooltip', `Loaded: ${disp}`);
      }
    }

    function refreshOpenProcessingPanels() {
      // Always-visible labels: refresh all channel rows
      const rows = document.querySelectorAll('tr[data-channel]');
      rows.forEach(tr => {
        const channelName = tr.getAttribute('data-channel');
        if (channelName) updateProcessingDetailForce(channelName);
      });
    }

    function markLinearizationEdited(channelName) {
      let changed = false;
      if (linearizationData) { linearizationData.edited = true; changed = true; }
      if (perChannelLinearization[channelName]) { perChannelLinearization[channelName].edited = true; changed = true; }
      if (changed) {
        refreshGlobalLinearizationDisplay();
        if (channelName) refreshPerChannelLinearizationDisplay(channelName);
        // When the global dataset is flagged, refresh all open processing panels
        if (linearizationData && linearizationData.edited) refreshOpenProcessingPanels();
      }
    }

    // Initialize dynamic version numbers
    function initializeVersionNumbers() {
      elements.pageTitle.textContent = `quadGEN ${APP_VERSION}`;
      elements.appVersion.textContent = APP_VERSION;
      
    }

    // Initialize version numbers when DOM is ready
    initializeVersionNumbers();
    // Observe global linearization UI changes to keep Revert state in sync
    try {
      const fnameEl = elements.globalLinearizationFilename;
      const infoEl = elements.globalLinearizationInfo;
      const detailsEl = elements.globalLinearizationDetails;
      const targets = [fnameEl, infoEl, detailsEl].filter(Boolean);
      if (targets.length > 0 && window.MutationObserver){
        const mo = new MutationObserver(() => { try { updateRevertButtonsState(); } catch {} });
        targets.forEach(t => mo.observe(t, { attributes: true, attributeFilter: ['class'], childList: true, characterData: true, subtree: true }));
        // Initial sync
        try { updateRevertButtonsState(); } catch {}
      }
    } catch {}

    // Theme handling
    const THEME_KEY = 'quadgen.theme';
    function getSystemPrefersDark(){ try { return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch { return false; } }
    function applyTheme(theme, persist = true){
      try {
        const root = document.documentElement;
        if (theme === 'dark') root.setAttribute('data-theme', 'dark'); else root.removeAttribute('data-theme');
        if (persist) localStorage.setItem(THEME_KEY, theme);
        if (elements.themeToggle){
          const isDark = theme === 'dark';
          elements.themeToggle.textContent = isDark ? '☀️' : '🌙';
          elements.themeToggle.setAttribute('aria-pressed', isDark ? 'true' : 'false');
          elements.themeToggle.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
        }
        try { updateInkChart(); } catch {}
      } catch {}
    }
    (function initTheme(){
      if (!ENABLE_DARK_MODE) return;
      const saved = localStorage.getItem(THEME_KEY);
      const initial = saved || (getSystemPrefersDark() ? 'dark' : 'light');
      applyTheme(initial, false);
      try {
        const mq = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
        if (mq && (mq.addEventListener || mq.addListener)){
          const onChange = (e)=>{
            const override = localStorage.getItem(THEME_KEY);
            if (!override || override === 'system') applyTheme(e.matches ? 'dark' : 'light', false);
          };
          if (mq.addEventListener) mq.addEventListener('change', onChange); else mq.addListener(onChange);
        }
      } catch {}
      if (elements.themeToggle){
        elements.themeToggle.addEventListener('click', ()=>{
          const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
          applyTheme(isDark ? 'light' : 'dark');
        });
      }
    })();

    // (Removed) IndustryReferences bookmarks system — reverted to trusting the model

    (function initIntentTuningPanel(){
      if (!DEBUG_INTENT_TUNING || !elements.intentTuningPanel) return;
      elements.intentTuningPanel.classList.remove('hidden');
      syncIntentTuningInputsFromState();
      if (elements.tuningSmoothingPercent) {
        if (!elements.tuningSmoothingPercent.value) elements.tuningSmoothingPercent.value = 30;
        elements.tuningSmoothingLabel.textContent = `${elements.tuningSmoothingPercent.value}%`;
        elements.tuningSmoothingPercent.addEventListener('input', (e) => {
          if (elements.tuningSmoothingLabel) elements.tuningSmoothingLabel.textContent = `${e.target.value}%`;
        });
      }
      if (elements.tuningPostPercent) {
        if (!elements.tuningPostPercent.value) elements.tuningPostPercent.value = 30;
        if (elements.tuningPostLabel) elements.tuningPostLabel.textContent = `${elements.tuningPostPercent.value}%`;
        elements.tuningPostPercent.addEventListener('input', (e) => {
          if (elements.tuningPostLabel) elements.tuningPostLabel.textContent = `${e.target.value}%`;
        });
      }
      if (elements.tuningPostPasses) {
        const updatePostControls = () => {
          const passes = Number(elements.tuningPostPasses.value) || 0;
          const disabled = passes === 0;
          if (elements.tuningPostPercent) elements.tuningPostPercent.disabled = disabled;
          if (elements.tuningPostAlgorithm) elements.tuningPostAlgorithm.disabled = disabled;
          if (elements.tuningPostLabel) elements.tuningPostLabel.textContent = `${elements.tuningPostPercent ? elements.tuningPostPercent.value : 0}%`;
        };
        elements.tuningPostPasses.addEventListener('change', updatePostControls);
        updatePostControls();
      }
      if (elements.tuningApplyBtn) {
        elements.tuningApplyBtn.addEventListener('click', (evt) => {
          evt.preventDefault();
          applyIntentTuningFromUI();
        });
      }
      if (elements.tuningRestoreBtn) {
        elements.tuningRestoreBtn.addEventListener('click', (evt) => {
          evt.preventDefault();
          restoreIntentTuning();
        });
      }
      setTuningStatus('Adjust parameters and click Apply.');
    })();

    // Sample data constants
    const SAMPLE_DATA = {
      colorMuse: `GRAY\tLAB_L\tLAB_A\tLAB_B
0\t97.15\t0.00\t0.00
5\t97.14\t0.00\t0.00
10\t95.90\t0.00\t0.00
15\t93.30\t0.00\t0.00
20\t90.06\t0.00\t0.00
25\t85.89\t0.00\t0.00
30\t79.22\t0.00\t0.00
35\t71.65\t0.00\t0.00
40\t64.43\t0.00\t0.00
45\t58.21\t0.00\t0.00
50\t52.13\t0.00\t0.00
55\t46.63\t0.00\t0.00
60\t41.83\t0.00\t0.00
65\t38.50\t0.00\t0.00
70\t35.63\t0.00\t0.00
75\t31.53\t0.00\t0.00
80\t29.94\t0.00\t0.00
85\t27.34\t0.00\t0.00
90\t25.91\t0.00\t0.00
95\t24.17\t0.00\t0.00
100\t21.33\t0.00\t0.00`,

      gammaCube: `# Test LUT - Gamma 2.2 curve
TITLE "Test Gamma 2.2"
LUT_1D_SIZE 11
DOMAIN_MIN 0.0 0.0 0.0
DOMAIN_MAX 1.0 1.0 1.0

# Gamma 2.2 curve: output = input^2.2
0.0 0.0 0.0
0.01 0.01 0.01
0.05 0.05 0.05
0.13 0.13 0.13
0.24 0.24 0.24
0.41 0.41 0.41
0.61 0.61 0.61
0.78 0.78 0.78
0.90 0.90 0.90
0.97 0.97 0.97
1.0 1.0 1.0`
    };

    // Input validation utilities
    class InputValidator {
      static clampPercent(p) { 
        const num = parseFloat(p);
        return isNaN(num) ? 0 : Math.min(100, Math.max(0, num)); 
      }
      
      static clampEnd(e) { 
        const num = parseInt(e);
        return isNaN(num) ? 0 : Math.min(TOTAL, Math.max(0, num)); 
      }
      
      static computeEndFromPercent(p) { 
        return Math.round((TOTAL * p) / 100); 
      }
      
      static computePercentFromEnd(e) { 
        return (e / TOTAL) * 100; 
      }

      static validateInput(input, validator) {
        const originalValue = input.value;
        const validatedValue = validator(originalValue);
        const isValid = validatedValue.toString() === originalValue || Math.abs(parseFloat(originalValue) - validatedValue) < 0.01;
        
        input.classList.toggle('border-red-300', !isValid);
        input.classList.toggle('border-gray-300', isValid);
        
        if (!isValid) {
          input.value = validatedValue.toString();
        }
        
        return validatedValue;
      }
    }

    // ===== Edit Curves panel logic =====
    // Global edit mode toggle (off by default)
    window.EDIT_MODE_ENABLED = false;
    const EDIT = { selectedChannel: null, selectedOrdinal: 1 };

    function isEditModeEnabled(){ return window.EDIT_MODE_ENABLED === true; }
    function setEditMode(on, opts = {}){
      const options = opts || {};
      const prev = isEditModeEnabled();
      window.EDIT_MODE_ENABLED = !!on;
      // Update toggle button visuals
      try {
        const btn = document.getElementById('editModeToggleBtn');
        const label = document.getElementById('editModeLabel');
        if (btn){
          btn.setAttribute('aria-pressed', String(!!on));
          btn.setAttribute('aria-checked', String(!!on));
          // Reset color classes
          btn.classList.remove(
            'bg-slate-600','hover:bg-slate-700',
            'bg-black','hover:bg-gray-900',
            'bg-orange-600','hover:bg-orange-700',
            'bg-rose-800','hover:bg-rose-900',
            'border','border-blue-200'
          );
          // Always ensure white bold text and no border
          btn.classList.add('text-white','font-bold','border-0');
          if (on) {
            // Black style when ON
            btn.classList.add('bg-black','hover:bg-gray-900');
          } else {
            // Slate style when OFF
            btn.classList.add('bg-slate-600','hover:bg-slate-700');
          }
        }
        if (label){ label.textContent = on ? '◈ Edit Mode: ON' : '⟐ Edit Mode: OFF'; }
      } catch {}
      // On first enable of Edit Mode, silently pre-create AI key points for all channels that need them
      try {
        if (on && !window.__EDIT_MODE_PRIMED) {
          const current = getCurrentPrinter();
          const channels = (current && current.channels) ? current.channels.slice() : [];
          const entries = [];
          const persistOnly = [];
          channels.forEach((ch) => {
            try {
              const existing = ControlPoints.get(ch)?.points;
              if (existing && existing.length >= 2) return; // already has AI points
              // If a correction is already applied (global or per-channel), avoid applying Smart curve during priming
              const hasGlobalApplied = !!(linearizationApplied && linearizationData);
              const hasPerApplied = !!(perChannelLinearization[ch] && perChannelEnabled[ch]);
              const applyInPrime = !(hasGlobalApplied || hasPerApplied);
              // ACV sources (per-channel or global): seed directly from anchors without simplification
              try {
                const per = perChannelLinearization[ch];
                const perFmt = (per?.format || '').toUpperCase();
                const hasPerACVAnchors = perFmt === 'ACV' && Array.isArray(per?.controlPointsTransformed) && per.controlPointsTransformed.length >= 2;
                if (hasPerACVAnchors) {
                  const anchors = per.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
                  if (anchors.length >= 2) {
                    const row = getChannelRow(ch);
                    const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                  if (!applyInPrime || endVal === 0) persistOnly.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    return;
                  }
                }
                const hasPerLAB = (perFmt.includes('LAB') || perFmt.includes('MANUAL')) && Array.isArray(per?.originalData) && per.originalData.length > 0;
                if (hasPerLAB) {
                  const row = getChannelRow(ch);
                  const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
                  const sampleEnd = endVal > 0 ? endVal : TOTAL; // for disabled channels, sample at full scale
                  const values = make256(sampleEnd, ch, true);
                  let kps;
                  if (per.originalData.length <= DIRECT_SEED_MAX_POINTS) {
                    const Nvals = values.length - 1;
                    kps = per.originalData.map(d => {
                      const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                      const t = (x / 100) * Nvals;
                      const i0 = Math.floor(t);
                      const i1 = Math.min(Nvals, Math.ceil(t));
                      const a = t - i0;
                      const v = (1 - a) * values[i0] + a * values[i1];
                      const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                      return { input: x, output: outPct };
                    });
                  } else {
                    kps = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
                  }
                  if (Array.isArray(kps) && kps.length >= 2) {
                    const row2 = getChannelRow(ch);
                    const e2 = row2 ? InputValidator.clampEnd(row2.querySelector('.end-input')?.value || 0) : 0;
                    if (e2 === 0) persistOnly.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    return;
                  }
                }
                const glbFmt = (linearizationData?.format || '').toUpperCase();
                const hasGlobalACVAnchors = glbFmt === 'ACV' && Array.isArray(linearizationData?.controlPointsTransformed) && linearizationData.controlPointsTransformed.length >= 2;
                if (hasGlobalACVAnchors) {
                  const anchors = linearizationData.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
                  if (anchors.length >= 2) {
                    const row = getChannelRow(ch);
                    const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                    if (endVal === 0) persistOnly.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    return;
                  }
                }
                const hasGlobalLAB = (glbFmt.includes('LAB') || glbFmt.includes('MANUAL')) && Array.isArray(linearizationData?.originalData) && linearizationData.originalData.length > 0;
                if (hasGlobalLAB) {
                  const row = getChannelRow(ch);
                  const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
                  const sampleEnd = endVal > 0 ? endVal : TOTAL;
                  const values = make256(sampleEnd, ch, true);
                  let kps;
                  if (linearizationData.originalData.length <= DIRECT_SEED_MAX_POINTS) {
                    const Nvals = values.length - 1;
                    kps = linearizationData.originalData.map(d => {
                      const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                      const t = (x / 100) * Nvals;
                      const i0 = Math.floor(t);
                      const i1 = Math.min(Nvals, Math.ceil(t));
                      const a = t - i0;
                      const v = (1 - a) * values[i0] + a * values[i1];
                      const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                      return { input: x, output: outPct };
                    });
                  } else {
                    kps = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
                  }
                  if (Array.isArray(kps) && kps.length >= 2) {
                    const row2 = getChannelRow(ch);
                    const e2 = row2 ? InputValidator.clampEnd(row2.querySelector('.end-input')?.value || 0) : 0;
                    if (!applyInPrime || e2 === 0) persistOnly.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    return;
                  }
                }
              } catch {}
              // Prefer raw loaded .quad curve if present; otherwise use displayed curve
              let values = (window.loadedQuadData?.curves?.[ch] && Array.isArray(window.loadedQuadData.curves[ch]))
                ? window.loadedQuadData.curves[ch]
                : (function(){
                    const row = getChannelRow(ch);
                    const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
                    const sampleEnd = endVal > 0 ? endVal : TOTAL;
                    return make256(sampleEnd, ch, true);
                  })();
              if (!Array.isArray(values) || values.length < 2) return;
              const keyPoints = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
              if (Array.isArray(keyPoints) && keyPoints.length >= 2) {
                const row = getChannelRow(ch);
                const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                if (!applyInPrime || endVal === 0) persistOnly.push({ channelName: ch, keyPoints, interpolationType: 'smooth' });
                else entries.push({ channelName: ch, keyPoints, interpolationType: 'smooth' });
              }
            } catch {}
          });
          if (entries.length > 0) {
            try { quadGenActions.setSmartKeyPointsBatch(entries); } catch {}
          }
          // Persist-only for disabled channels (no curve apply; no enable)
          if (persistOnly.length > 0) {
            try { persistOnly.forEach(e => { ControlPoints.persist(e.channelName, e.keyPoints, e.interpolationType || 'smooth'); }); } catch {}
          }
          // If a global correction is active, mark newly created Smart points as baked-from-global
          try {
            if (linearizationApplied && linearizationData) {
              const setBaked = (ch) => {
                if (!window.loadedQuadData) window.loadedQuadData = {};
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                const prev = window.loadedQuadData.keyPointsMeta[ch] || {};
                window.loadedQuadData.keyPointsMeta[ch] = { ...prev, bakedGlobal: true };
                // Also tag the latest curve action in history so redo restores bakedGlobal
                try {
                  for (let i = CurveHistory.history.length - 1; i >= 0; i--) {
                    const entry = CurveHistory.history[i];
                    if (entry && entry.kind === 'channel') {
                      const a = entry.action;
                      if (a && a.type === 'curve' && a.channelName === ch && typeof a.newBakedGlobal === 'undefined') {
                        a.newBakedGlobal = true;
                        break;
                      }
                    }
                  }
                } catch {}
              };
              // Only mark channels where Smart curves were actually applied (entries),
              // not those where we only persisted key points for overlay (persistOnly).
              entries.forEach(e => setBaked(e.channelName));
            }
          } catch {}
          window.__EDIT_MODE_PRIMED = true;
        }
      } catch {}
      // Defensive: when turning ON with a global correction active, ensure existing Smart points are marked baked
      try {
        if (on && linearizationApplied && linearizationData && window.loadedQuadData?.keyPoints) {
          Object.keys(window.loadedQuadData.keyPoints).forEach((ch) => {
            try {
              // Only adjust Smart-sourced channels; skip file-loaded curves
              if (isSmartCurve(ch)) {
                const prev = (window.loadedQuadData.keyPointsMeta && window.loadedQuadData.keyPointsMeta[ch]) || {};
                if (!prev.bakedGlobal) {
                  if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                  window.loadedQuadData.keyPointsMeta[ch] = { ...prev, bakedGlobal: true };
                }
              }
            } catch {}
          });
        }
      } catch {}
      // Enable/disable panel controls and refresh chart overlays
      try {
        if (on) {
          edit_refreshState();
        } else {
          edit_setControlsEnabled(false);
        }
        if (typeof updateInterpolationControls === 'function') updateInterpolationControls();
        if (typeof updateInkChart === 'function') updateInkChart();
      } catch {}
      // Record UI history for edit mode toggle (only when state actually changes)
      try {
        if (prev !== !!on) {
          const shouldRecord = options.recordHistory === true; // explicit opt-in at call sites
          if (shouldRecord && typeof CurveHistory !== 'undefined' && CurveHistory && !CurveHistory.isRestoring && typeof CurveHistory.recordUIAction === 'function') {
            const desc = `Edit Mode: ${prev ? 'On' : 'Off'} → ${on ? 'On' : 'Off'}`;
            CurveHistory.recordUIAction('editMode', prev, !!on, desc);
          }
        }
      } catch {}
    }

    function edit_isChannelEnabled(ch){
      try {
        const row = getChannelRow(ch);
        const endVal = InputValidator.clampEnd(row?.querySelector('.end-input')?.value || 0);
        return endVal > 0;
      } catch { return false; }
    }

    function edit_populateChannelSelect(){
      if (!elements.editChannelSelect) return;
      const sel = elements.editChannelSelect;
      const rows = Array.from(elements.rows?.children || []).filter(tr => tr.id !== 'noChannelsRow');
      const enabled = rows
        .filter(tr => (InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0)) > 0)
        .map(tr => tr.getAttribute('data-channel'))
        .filter(Boolean);
      const prev = sel.value;
      const prevChannel = EDIT.selectedChannel || prev;
      const prevOrdinal = EDIT.selectedOrdinal || 1;
      sel.innerHTML = '';
      if (enabled.length === 0) {
        const opt = document.createElement('option');
        opt.value = ''; opt.textContent = 'No channels enabled';
        opt.disabled = true; opt.selected = true;
        sel.appendChild(opt);
        EDIT.selectedChannel = null;
        edit_setControlsEnabled(false);
        if (elements.editChannelState) elements.editChannelState.textContent = '';
        return;
      }
      enabled.forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch; opt.textContent = ch;
        sel.appendChild(opt);
      });
      // Prefer previously selected if still enabled; else first enabled
      let desired = (prev && enabled.includes(prev)) ? prev
                  : (prevChannel && enabled.includes(prevChannel)) ? prevChannel
                  : enabled[0];
      if (desired) sel.value = desired;
      const changed = EDIT.selectedChannel !== desired;
      EDIT.selectedChannel = desired;
      EDIT.selectedOrdinal = changed ? 1 : prevOrdinal;
      edit_refreshState();
    }

    function edit_refreshState(){
      const ch = EDIT.selectedChannel;
      if (!ch){
        edit_setControlsEnabled(false);
        if (elements.editChannelState) elements.editChannelState.textContent = '';
        return;
      }
      // Respect global edit mode toggle
      if (!isEditModeEnabled()){
        edit_setControlsEnabled(false);
        if (elements.editChannelState) elements.editChannelState.textContent = '';
        return;
      }
      const isEnabled = edit_isChannelEnabled(ch);
      if (elements.editChannelState) elements.editChannelState.textContent = isEnabled ? '' : '(disabled)';
      // Allow editing even when channel End=0; just show hint
      edit_setControlsEnabled(true);
      if (elements.editDisabledHint){ elements.editDisabledHint.classList.toggle('hidden', isEnabled); }
      // Disable specific controls to reflect channel disabled state visually
      try {
        const disable = !isEnabled;
        const setDisabled = (el, on) => { if (el) el.disabled = !!on; };
        setDisabled(elements.editPointLeft, disable);
        setDisabled(elements.editPointRight, disable);
        setDisabled(elements.editNudgeXNeg, disable);
        setDisabled(elements.editNudgeXPos, disable);
        setDisabled(elements.editNudgeYUp, disable);
        setDisabled(elements.editNudgeYDown, disable);
        setDisabled(elements.editDeleteBtn, disable);
        setDisabled(elements.editRecomputeBtn, disable);
        if (elements.editXYInput) elements.editXYInput.disabled = disable;
        if (elements.editPointIndex) elements.editPointIndex.classList.toggle('is-disabled', disable);
      } catch {}
      // Ensure AI key points exist so we can meaningfully edit/cycle
      try {
        const pts = ControlPoints.get(ch)?.points || [];
        if (!pts || pts.length < 2) {
          const ensured = ensureEditableKeyPointsForChannel(ch, 'smooth');
          if (!ensured?.success) { console.warn('Ensure KP failed:', ensured?.message); }
        }
      } catch (e) { console.warn('Edit panel ensure KP error:', e); }
      edit_refreshPointIndex();
      edit_syncShowPointsAndSmoothing();
    }

    function edit_setControlsEnabled(on){
      // Apply a single disabling class to the entire panel body
      if (elements.editPanelBody){
        elements.editPanelBody.classList.toggle('edit-panel-disabled', !on);
      }
      // Hint should not show while Edit Mode is off, even if controls are disabled
      if (elements.editDisabledHint){
        const hideHint = !!on || !isEditModeEnabled();
        elements.editDisabledHint.classList.toggle('hidden', hideHint);
      }
      // Ensure Recompute is explicitly disabled when Edit Mode is OFF
      try {
        if (elements.editRecomputeBtn) elements.editRecomputeBtn.disabled = !on;
        if (elements.editDeleteBtn) elements.editDeleteBtn.disabled = !on;
        if (elements.editPointIndex) elements.editPointIndex.classList.toggle('is-disabled', !on);
      } catch {}
    }

    function edit_refreshPointIndex(){
      try {
        const ch = EDIT.selectedChannel; if (!ch) return;
        const kp = ControlPoints.get(ch)?.points || [];
        const n = Math.max(2, kp.length || 0);
        if (EDIT.selectedOrdinal < 1) EDIT.selectedOrdinal = 1;
        if (EDIT.selectedOrdinal > n) EDIT.selectedOrdinal = n;
        if (elements.editPointIndex) elements.editPointIndex.textContent = String(EDIT.selectedOrdinal);
        if (elements.editXYInput && kp.length>=2){
          const p = kp[EDIT.selectedOrdinal - 1];
          if (p) {
            let yAbs = p.output;
            try {
              const row = getChannelRow(ch);
              const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
              const scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              yAbs = Math.max(0, Math.min(100, (scale > 0) ? (p.output * scale) : 0));
            } catch {}
            const xDisp = Math.round(p.input*100)/100;
            const yDisp = Math.round(yAbs*100)/100;
            elements.editXYInput.value = `${xDisp},${yDisp}`;
          }
        }
        // Re-render chart overlays so the selected point highlight updates immediately
        if (typeof updateInkChart === 'function') { updateInkChart(); }
      } catch {}
    }

    function edit_cyclePoint(dir){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      const kp = ControlPoints.get(ch)?.points || [];
      const n = Math.max(2, kp.length || 0);
      EDIT.selectedOrdinal = ((EDIT.selectedOrdinal - 1 + dir + n) % n) + 1;
      edit_refreshPointIndex();
    }

    function edit_getStepFromEvent(e){
      if (e && e.shiftKey) return 5; if (e && e.altKey) return 0.1; return 1;
    }

    function edit_nudge(deltaX, deltaY, evt){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      if (!edit_isChannelEnabled(ch)) { showStatus('Channel disabled – enable in Channels to edit'); return; }
      const step = edit_getStepFromEvent(evt);
      const params = {};
      if (deltaX) params.deltaInput = deltaX * step;
      if (deltaY) {
        try {
          const kp = ControlPoints.get(ch)?.points || [];
          const p = kp[EDIT.selectedOrdinal - 1];
          const row = getChannelRow(ch);
          const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
          const scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
          const curAbs = Math.max(0, Math.min(100, (scale > 0 && p) ? (p.output * scale) : 0));
          const nextAbs = Math.max(0, Math.min(100, curAbs + deltaY * step));
          params.outputPercent = nextAbs;
        } catch {}
      }
      const res = quadGenActions.adjustSmartKeyPointByIndex(ch, EDIT.selectedOrdinal, params);
      if (!res?.success){ showStatus(res?.message || 'Edit failed'); return; }
      updateProcessingDetail(ch);
      updatePreview();
      edit_refreshPointIndex();
    }

    function edit_commitXY(){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      try {
        const ch = EDIT.selectedChannel; if (!ch) return;
        const el = elements.editXYInput; if (!el) return;
        const raw = String(el.value || '').trim();
        const parts = raw.split(',');
        if (parts.length !== 2) {
          el.classList.add('border-red-300');
          showStatus('Invalid format. Use X,Y (e.g., 25.5, 72.3)');
          setTimeout(()=> el.classList.remove('border-red-300'), 1500);
          return;
        }
        const parseNum = (s) => {
          const t = String(s).replace(/%/g, '').trim();
          const n = parseFloat(t);
          return isNaN(n) ? null : n;
        };
        let x = parseNum(parts[0]);
        let y = parseNum(parts[1]);
        if (x === null || y === null) {
          el.classList.add('border-red-300');
          showStatus('Invalid numbers. X and Y must be 0–100');
          setTimeout(()=> el.classList.remove('border-red-300'), 1500);
          return;
        }
        x = Math.max(0, Math.min(100, x));
        y = Math.max(0, Math.min(100, y));
      const res = quadGenActions.adjustSmartKeyPointByIndex(ch, EDIT.selectedOrdinal, { inputPercent: x, outputPercent: y });
        if (!res?.success){
          el.classList.add('border-red-300');
          showStatus(res?.message || 'Edit failed');
          setTimeout(()=> el.classList.remove('border-red-300'), 1500);
          return;
        }
        updateProcessingDetail(ch);
        updatePreview();
        edit_refreshPointIndex();
        el.classList.remove('border-red-300');
      } catch (e) { console.warn('edit_commitXY error:', e); }
    }

    function edit_recompute(){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      if (!edit_isChannelEnabled(ch)) { showStatus('Channel disabled – enable in Channels to recompute'); return; }
      const maxError = Math.max(0.05, Math.min(5, parseFloat(elements.editMaxError?.value || String(KP_SIMPLIFY.maxErrorPercent || 0.25))));
      const maxPts = Math.max(2, Math.min(21, parseInt(elements.editMaxPoints?.value || String(KP_SIMPLIFY.maxPoints || 21), 10)));
      const res = quadGenActions.simplifySmartKeyPointsFromCurve(ch, { maxErrorPercent: maxError, maxPoints: maxPts });
      if (!res?.success){ showStatus(res?.message || 'Recompute failed'); return; }
      showStatus(`Recomputed ${ch} key points (${maxPts} max, ${maxError}% max error)`);
      EDIT.selectedOrdinal = Math.min(EDIT.selectedOrdinal, (ControlPoints.get(ch)?.points?.length || 1));
      edit_refreshPointIndex();
      try { updateRevertButtonsState(); } catch {}
    }

    function edit_delete(){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      if (!edit_isChannelEnabled(ch)) { showStatus('Channel disabled – enable in Channels to edit'); return; }
      try {
        const kp = ControlPoints.get(ch)?.points || [];
        const n = kp.length || 0;
        if (n <= 2) { showStatus('At least 2 points required — cannot delete.'); return; }
        if (EDIT.selectedOrdinal === 1 || EDIT.selectedOrdinal === n) {
          showStatus('Endpoint deletion is blocked.');
          return;
        }
      const res = quadGenActions.deleteSmartKeyPointByIndex(ch, EDIT.selectedOrdinal, { allowEndpoint: false });
        if (!res?.success){ showStatus(res?.message || 'Delete failed'); return; }
        // After delete, clamp ordinal and refresh
        const n2 = (ControlPoints.get(ch)?.points?.length || (n-1));
        EDIT.selectedOrdinal = Math.max(1, Math.min(EDIT.selectedOrdinal, n2));
        updateProcessingDetail(ch);
        updatePreview();
        edit_refreshPointIndex();
        showStatus(`Deleted point on ${ch}`);
      } catch (e) { showStatus(`Delete failed: ${e.message}`); }
    }

    function edit_syncShowPointsAndSmoothing(){
      // Mirror smoothing
      if (elements.smoothingSlider && elements.editSmoothingSlider){
        elements.editSmoothingSlider.value = String(elements.smoothingSlider.value);
        if (elements.editSmoothingValue) elements.editSmoothingValue.textContent = `${elements.smoothingSlider.value}%`;
        // Disable the edit smoothing slider whenever the main smoothing is disabled (no linearization active)
        elements.editSmoothingSlider.disabled = !!elements.smoothingSlider.disabled;
        elements.editSmoothingSlider.classList.toggle('opacity-60', !!elements.smoothingSlider.disabled);
      }
    }

    function initEditPanel(){
      // Seed recompute defaults from KP_SIMPLIFY so UI matches silent-conversion settings
      try {
        if (elements.editMaxError) elements.editMaxError.value = String(KP_SIMPLIFY.maxErrorPercent);
        if (elements.editMaxPoints) elements.editMaxPoints.value = String(KP_SIMPLIFY.maxPoints);
      } catch {}
      // Channel select
      if (elements.editChannelSelect){
        elements.editChannelSelect.addEventListener('change', () => {
          if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
          EDIT.selectedChannel = elements.editChannelSelect.value || null;
          EDIT.selectedOrdinal = 1;
          edit_refreshState();
          try { updateInkChart(); } catch {}
        });
      }
      // Channel cycle buttons
      function edit_cycleChannel(dir){
        if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
        const sel = elements.editChannelSelect; if (!sel || sel.options.length === 0) return;
        const idx = sel.selectedIndex;
        const n = sel.options.length;
        const next = ((idx + dir) % n + n) % n; // wrap-around
        sel.selectedIndex = next;
        EDIT.selectedChannel = sel.value || null;
        EDIT.selectedOrdinal = 1;
        edit_refreshState();
        try { updateInkChart(); } catch {}
      }
      if (elements.editChannelPrev){ elements.editChannelPrev.addEventListener('click', ()=> edit_cycleChannel(-1)); }
      if (elements.editChannelNext){ elements.editChannelNext.addEventListener('click', ()=> edit_cycleChannel(+1)); }
      // Recompute
      if (elements.editRecomputeBtn){ elements.editRecomputeBtn.addEventListener('click', edit_recompute); }
      // Point navigation
      if (elements.editPointLeft){ elements.editPointLeft.addEventListener('click', ()=> edit_cyclePoint(-1)); }
      if (elements.editPointRight){ elements.editPointRight.addEventListener('click', ()=> edit_cyclePoint(1)); }
      if (elements.editNudgeYUp){ elements.editNudgeYUp.addEventListener('click', (e)=> edit_nudge(0, +1, e)); }
      if (elements.editNudgeYDown){ elements.editNudgeYDown.addEventListener('click', (e)=> edit_nudge(0, -1, e)); }
      if (elements.editNudgeXNeg){ elements.editNudgeXNeg.addEventListener('click', (e)=> edit_nudge(-1, 0, e)); }
      if (elements.editNudgeXPos){ elements.editNudgeXPos.addEventListener('click', (e)=> edit_nudge(+1, 0, e)); }
      if (elements.editXYInput){ elements.editXYInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ edit_commitXY(); } }); }
      if (elements.editDeleteBtn){ elements.editDeleteBtn.addEventListener('click', edit_delete); }
      // No key-point visibility checkbox; visibility follows Edit Mode
      // Mirror Smoothing
      if (elements.editSmoothingSlider){
        elements.editSmoothingSlider.addEventListener('input', (e)=>{
          const v = Math.round(parseFloat(e.target.value||'0'));
          if (elements.editSmoothingValue) elements.editSmoothingValue.textContent = `${v}%`;
          if (elements.smoothingSlider){ elements.smoothingSlider.value = String(v); elements.smoothingSlider.dispatchEvent(new Event('input', {bubbles:true})); }
        });
      }
      if (elements.smoothingSlider){ elements.smoothingSlider.addEventListener('input', ()=> edit_syncShowPointsAndSmoothing()); }
      // Initial population
      edit_populateChannelSelect();
      // Wire edit mode toggle
      const toggleBtn = document.getElementById('editModeToggleBtn');
      if (toggleBtn){
        toggleBtn.addEventListener('click', () => setEditMode(!isEditModeEnabled(), { recordHistory: true }));
      }
      // Start with edit mode disabled by default (no history)
      setEditMode(false, { recordHistory: false });
      // Re-populate when channel enable states change
      if (elements.rows){
        elements.rows.addEventListener('input', (e)=>{
          const t = e.target;
          if (t && (t.classList?.contains('end-input') || t.classList?.contains('percent-input'))){
            setTimeout(()=>{ try { edit_populateChannelSelect(); } catch {} }, 0);
          }
        });
        elements.rows.addEventListener('channelsChanged', ()=>{
          setTimeout(()=>{ try { edit_populateChannelSelect(); } catch {} }, 0);
        });
      }
    }

    // Initialize Edit Curves panel now that dependencies are defined
    try { initEditPanel(); } catch(e) { console.warn('Edit panel init failed:', e); }

    // Debounce function to prevent excessive updates
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Normalize legacy 'ai' source tags to 'smart'
    function normalizeSmartSourcesInLoadedData() {
      try {
        if (!window.loadedQuadData || !window.loadedQuadData.sources) return;
        const src = window.loadedQuadData.sources;
        Object.keys(src).forEach((ch) => {
          if (src[ch] === 'ai') src[ch] = 'smart';
        });
      } catch {}
    }

    // Helper: treat both historical 'ai' and new 'smart' as Smart Curve source
    function isSmartCurveSourceTag(tag) {
      return tag === 'smart' || tag === 'ai';
    }

    function isSmartCurve(channelName) {
      try {
        const tag = window.loadedQuadData?.sources?.[channelName];
        return isSmartCurveSourceTag(tag);
      } catch {
        return false;
      }
    }

    // Toggle: whether to show assistant status messages in chat
    function shouldShowAssistantStatus() {
      try {
        const el = document.getElementById('aiShowStatusToggle');
        return !el || !!el.checked; // default to true if toggle missing
      } catch { return true; }
    }
    // Back-compat wrapper
    function shouldShowAIStatus() { return shouldShowAssistantStatus(); }

    // Helper: graph-only status filter and simple chat de-duplication
    let __lastStatusChat = { text: '', ts: 0 };
    function isGraphStatusMessage(msg) {
      const graphKeys = ['Preview updated', 'Error updating preview'];
      return graphKeys.some(k => msg.includes(k));
    }

    function showStatus(message) {
      const isGraph = isGraphStatusMessage(message);
      if (isGraph) {
        elements.status.textContent = message;
        elements.status.style.opacity = '1';
      } else {
        // Route non-graph messages to Lab Tech chat (avoid duplicates)
        try {
          if (shouldShowAssistantStatus() && typeof addChatMessage === 'function') {
            const now = Date.now();
            if (__lastStatusChat.text !== message || now - __lastStatusChat.ts > 1000) {
              addChatMessage('system', message);
              __lastStatusChat = { text: message, ts: now };
            }
          }
        } catch {}
      }
      setTimeout(() => {
        if (elements.status.textContent === message) {
          elements.status.style.opacity = '0';
          setTimeout(() => {
            if (elements.status.style.opacity === '0') {
              elements.status.innerHTML = "&nbsp;";
              elements.status.style.opacity = '1';
            }
          }, 500); // Wait for fade transition to complete
        }
      }, 6000);
    }
    
    function animateLogoBars() {
      const cyanBar = document.getElementById('cyanBar');
      const magentaBar = document.getElementById('magentaBar');
      const yellowBar = document.getElementById('yellowBar');
      const blackBar = document.getElementById('blackBar');
      const logoPath = document.getElementById('logoPath');
      const node1 = document.getElementById('node1');
      const node2 = document.getElementById('node2');
      const node3 = document.getElementById('node3');
      const node4 = document.getElementById('node4');
      
      if (!cyanBar || !magentaBar || !yellowBar || !blackBar) return;
      
      // Original values
      const originalHeights = { cyan: 40, magenta: 60, yellow: 80, black: 110 };
      const originalYs = { cyan: 90, magenta: 70, yellow: 50, black: 22 };
      
      let animationStep = 0;
      const maxSteps = 32; // Number of back-and-forth movements
      
      function animateStep() {
        if (animationStep >= maxSteps) {
          // Final return to original state
          cyanBar.setAttribute('height', originalHeights.cyan);
          cyanBar.setAttribute('y', originalYs.cyan);
          magentaBar.setAttribute('height', originalHeights.magenta);
          magentaBar.setAttribute('y', originalYs.magenta);
          yellowBar.setAttribute('height', originalHeights.yellow);
          yellowBar.setAttribute('y', originalYs.yellow);
          blackBar.setAttribute('height', originalHeights.black);
          blackBar.setAttribute('y', originalYs.black);
          logoPath.setAttribute('d', 'M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 32, 126 22');
          node1.setAttribute('cy', '88');
          node2.setAttribute('cy', '68');
          node3.setAttribute('cy', '48');
          node4.setAttribute('cy', '18');
          return;
        }
        
        // Generate oscillating variations that get smaller over time
        const damping = 1 - (animationStep / maxSteps) * 0.7; // Reduce intensity over time
        const frequency = Math.sin(animationStep * 0.8) * damping; // Oscillating pattern
        
        const cyanVariation = originalHeights.cyan + frequency * 12;
        const magentaVariation = originalHeights.magenta + frequency * 15;
        const yellowVariation = originalHeights.yellow + frequency * 18;
        const blackVariation = originalHeights.black + frequency * 25;
        
        // Update bar heights and positions
        cyanBar.setAttribute('height', Math.max(5, cyanVariation));
        cyanBar.setAttribute('y', 132 - Math.max(5, cyanVariation));
        
        magentaBar.setAttribute('height', Math.max(5, magentaVariation));
        magentaBar.setAttribute('y', 132 - Math.max(5, magentaVariation));
        
        yellowBar.setAttribute('height', Math.max(5, yellowVariation));
        yellowBar.setAttribute('y', 132 - Math.max(5, yellowVariation));
        
        blackBar.setAttribute('height', Math.max(5, blackVariation));
        blackBar.setAttribute('y', 132 - Math.max(5, blackVariation));
        
        // Update curve and nodes to match bar heights
        const newCyanY = 132 - Math.max(5, cyanVariation) + 2;
        const newMagentaY = 132 - Math.max(5, magentaVariation) + 2;
        const newYellowY = 132 - Math.max(5, yellowVariation) + 2;
        const newBlackY = 132 - Math.max(5, blackVariation) + 2;
        
        // Update curve path
        const newPath = `M30 ${newCyanY} C 44 ${newCyanY-4}, 50 ${newMagentaY+4}, 62 ${newMagentaY} S 86 ${newYellowY+2}, 94 ${newYellowY} S 118 ${newBlackY+10}, 126 ${newBlackY}`;
        logoPath.setAttribute('d', newPath);
        
        // Update node positions
        node1.setAttribute('cy', newCyanY);
        node2.setAttribute('cy', newMagentaY);
        node3.setAttribute('cy', newYellowY);
        node4.setAttribute('cy', newBlackY);
        
        animationStep++;
        setTimeout(animateStep, 100); // 100ms between each step
      }
      
      animateStep(); // Start the animation sequence
    }
    

    function updateProcessingDetailForce(channelName) {
      // Always-visible single-line label updater
      const row = getChannelRow(channelName);
      const processingLabel = row ? row.querySelector('.processing-label') : null;
      if (!processingLabel) return;

      const segmentsApplied = [];

      // Helper: determine effective Smart status (ignore tag if curve matches original .quad)
      function isSmartEffective(ch){
        try {
          const tag = window.loadedQuadData?.sources?.[ch];
          let smart = (tag === 'smart' || tag === 'ai');
          if (smart) {
            const curv = window.loadedQuadData?.curves?.[ch];
            const orig = window.loadedQuadData?.originalCurves?.[ch];
            if (Array.isArray(curv) && Array.isArray(orig) && curv.length === orig.length) {
              const same = curv.every((v,i)=>v===orig[i]);
              if (same) smart = false;
            }
          }
          return smart;
        } catch { return false; }
      }

      // Consolidated display: if a Smart Curve is active and there is a loaded per‑channel source that is disabled,
      // show a single line with the source filename and the current Smart key‑point count.
      const hasSmartCurve = !!(window.loadedQuadData && window.loadedQuadData.curves && window.loadedQuadData.curves[channelName] && isSmartEffective(channelName));
      const per = perChannelLinearization[channelName];
      const perIsDisabled = !!(per && !perChannelEnabled[channelName]);
      if (hasSmartCurve && per && perIsDisabled) {
        const baseName = (perChannelFilenames && perChannelFilenames[channelName]) || per.filename || 'unknown file';
        const dispName = getEditedDisplayName(baseName, !!per.edited);
        const smartPts = ControlPoints.get(channelName).points;
        const smartCount = Array.isArray(smartPts) ? smartPts.length : null;
        const countLabel = smartCount ? `${smartCount} key points` : getBasePointCountLabel(per);
        const text = `${dispName} (${countLabel})`;
        processingLabel.textContent = text;
        processingLabel.setAttribute('title', text);
        return; // Do not list separate Smart/per‑channel lines
      }

      // Base curve segment (Smart vs loaded .quad)
      if (window.loadedQuadData && window.loadedQuadData.curves && window.loadedQuadData.curves[channelName]) {
        const isSmart = isSmartEffective(channelName);
        if (isSmart) {
          const kp = ControlPoints.get(channelName).points;
          const kpLabel = Array.isArray(kp) ? ` (${kp.length} key points)` : '';
          segmentsApplied.push(`Smart Curve${kpLabel}`);
        } else {
          const baseFile = window.loadedQuadData.filename || 'loaded .quad';
          segmentsApplied.push(`${baseFile}`);
        }
      }

      // Per-channel linearization segment (show even if disabled)
      if (perChannelLinearization[channelName]) {
        const data = perChannelLinearization[channelName];
        const format = data.format || 'curve data';
        const baseName = (perChannelFilenames && perChannelFilenames[channelName]) || data.filename || 'unknown file';
        const dispName = getEditedDisplayName(baseName, !!data.edited);
        const applied = !!perChannelEnabled[channelName];
        const countLabel = getBasePointCountLabel(data);
        if (applied) {
          segmentsApplied.push(`channel: ${format} • ${dispName} (${countLabel})`);
        }
      }

      // Global linearization segment (show even if disabled)
      if (linearizationData && Array.isArray(linearizationData.samples)) {
        const format = linearizationData.format || 'linearization';
        const baseName = linearizationData.filename || 'unknown file';
        const dispName = getEditedDisplayName(baseName, !!linearizationData.edited);
        const countLabel = getBasePointCountLabel(linearizationData);
        if (linearizationApplied) {
          segmentsApplied.push(`Global: ${format} • ${dispName} (${countLabel})`);
        }
      }

      // Auto endpoint rolloff annotation (if enabled and detected)
      try {
        const autoWhiteOn = !!elements?.autoWhiteLimitToggle?.checked;
        const autoBlackOn = !!elements?.autoBlackLimitToggle?.checked;
        if ((autoWhiteOn || autoBlackOn) && window._autoLimitState && window._autoLimitState[channelName]) {
          const meta = window._autoLimitState[channelName];
          const parts = [];
          if (autoBlackOn && meta.black && isFinite(meta.black.widthPercent)) parts.push(`B ${meta.black.widthPercent.toFixed(1)}%`);
          if (autoWhiteOn && meta.white && isFinite(meta.white.widthPercent)) parts.push(`W ${meta.white.widthPercent.toFixed(1)}%`);
          if (parts.length) segmentsApplied.push(`Auto limit: ${parts.join(', ')}`);
        }
      } catch {}

      // Build display text; show each applied segment on a new line.
      if (segmentsApplied.length === 0) {
        processingLabel.textContent = '→ Linear ramp';
        processingLabel.setAttribute('title', 'Linear ramp');
      } else {
        // Preserve clean tooltip without decoration
        const tooltip = segmentsApplied.join(' | ');
        // Add a downward arrow to the first line if multiple segments
        if (segmentsApplied.length > 1) {
          segmentsApplied[0] = `${segmentsApplied[0]} \u21B4`;
        }
        const html = segmentsApplied.map(s => `<span>${s}</span>`).join('<br>');
        processingLabel.innerHTML = html;
        processingLabel.setAttribute('title', tooltip);
      }
    }

    function updateProcessingDetail(channelName) {
      // Panels are always visible now; delegate to force updater
      updateProcessingDetailForce(channelName);
    }

    // Lightweight .quad preview highlighter
    function escapeHTML(s){
      try {
        return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
      } catch { return s; }
    }
    function hexToRgb(hex){
      try {
        let h = String(hex || '').trim();
        if (h.startsWith('#')) h = h.slice(1);
        if (h.length === 3) h = h.split('').map(c => c + c).join('');
        const num = parseInt(h, 16);
        if (isNaN(num) || h.length !== 6) return {r:0,g:0,b:0};
        return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
      } catch { return {r:0,g:0,b:0}; }
    }
    function srgbToLinear(c){
      const cs = c / 255;
      return cs <= 0.04045 ? cs / 12.92 : Math.pow((cs + 0.055) / 1.055, 2.4);
    }
    function relativeLuminance(hex){
      const {r,g,b} = hexToRgb(hex);
      const R = srgbToLinear(r), G = srgbToLinear(g), B = srgbToLinear(b);
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }
    function pickGutterTextColor(hex){
      // Choose black or white by WCAG contrast vs background
      try {
        const L = relativeLuminance(hex);
        const contrastWhite = (1.0 + 0.05) / (L + 0.05);
        const contrastBlack = (L + 0.05) / 0.05;
        // Prefer higher contrast; use near-black token for black, white for white
        return (contrastBlack >= contrastWhite) ? '#111827' : '#ffffff';
      } catch { return '#111827'; }
    }
    function highlightQuad(text){
      try {
        const lines = String(text || '').split('\n');
        let currentCh = null;       // active channel code (e.g., K, C, ...)
        let chIndex = -1;           // index of numeric line within current channel
        const fgCache = Object.create(null);
        return lines.map((raw, i) => {
          const t = raw.trim();
          let inner;
          let dataCh = null; // channel marker for this line (for colored bar)
          if (t.length === 0) {
            inner = '&nbsp;';
          } else if (/^##\s/.test(t)) {
            // Meta header (first line with channels, etc.)
            inner = `<span class="quad-meta">${escapeHTML(raw)}</span>`;
          } else if (/^#(?=\s|$)/.test(t)){
            const m = t.match(/^#\s+([A-Z]{1,3})\s+curve$/);
            if (m){
              currentCh = m[1];
              chIndex = -1; // reset index for next numeric line
              inner = `<span class="quad-comment">${escapeHTML(raw)}</span>`; // uniform comment color
            } else {
              inner = `<span class="quad-comment">${escapeHTML(raw)}</span>`;
            }
          } else if (/^\d+$/.test(t)){
            // Pure integers (curve rows)
            const n = parseInt(t, 10);
            const classes = ['quad-number'];
            // Detect first/last numeric within channel block
            let isFirst = false, isLast = false;
            if (currentCh) {
              dataCh = currentCh; // mark this line for channel bar
              chIndex += 1;
              isFirst = (chIndex === 0);
              const next = (lines[i+1] || '').trim();
              if (!next || /^#(?=\s|$)/.test(next)) {
                isLast = true;
                // reset for safety after last value
                currentCh = null;
                chIndex = -1;
              }
            }
            if (isFirst || isLast) classes.push('quad-emph');
            inner = `<span class="${classes.join(' ')}">${escapeHTML(raw)}</span>`;
          } else {
            // Anything unexpected in data area
            inner = `<span class="quad-error">${escapeHTML(raw)}</span>`;
          }
          const attr = dataCh ? ` data-ch="${dataCh}"` : '';
          const styleVars = dataCh ? (function(){
            const bg = INK_COLORS && INK_COLORS[dataCh] ? INK_COLORS[dataCh] : '#666666';
            const fg = fgCache[dataCh] || (fgCache[dataCh] = pickGutterTextColor(bg));
            return ` style="--ln-bg: ${bg}; --ln-fg: ${fg};"`;
          })() : '';
          return `<span class="quad-line"${attr}${styleVars}>${inner}</span>`;
        }).join('');
      } catch { return escapeHTML(String(text || '')); }
    }

    function ensurePreviewCopyHandler(){
      try {
        const el = elements.previewFull;
        if (!el || el.dataset.copyHandlerAttached === 'true') return;
        el.addEventListener('copy', (e)=>{
          try {
            const raw = el.dataset.raw || el.textContent || '';
            e.clipboardData.setData('text/plain', raw);
            e.preventDefault();
          } catch {}
        });
        el.dataset.copyHandlerAttached = 'true';
      } catch {}
    }

    function updatePreview(options = {}) {
      requestAnimationFrame(() => {
        try {
          const fileText = buildFile();
          // render highlighted HTML but preserve raw for copy
          if (elements.previewFull.dataset.raw !== fileText) {
            elements.previewFull.dataset.raw = fileText;
            elements.previewFull.innerHTML = highlightQuad(fileText);
            // Adjust line-number gutter width based on line count
            try {
              const total = (fileText.match(/\n/g) || []).length + 1;
              const digits = String(Math.max(1, total)).length;
              elements.previewFull.style.setProperty('--lnw', `calc(${digits}ch + 2ch)`);
              elements.previewFull.style.setProperty('--lngap', '1ch');
            } catch {}
          }
          ensurePreviewCopyHandler();
          if (!options.onlyNotes) {
            updateInkChart();
            updateFilename(); // Update filename when preview updates
            try { updateSessionStatus(); } catch {}
            // Delta UI disabled; summaries are posted to Lab Tech chat instead
            showStatus("Preview updated");
          }
          try { updateRevertButtonsState(); } catch {}
        } catch (error) {
          console.error('Preview update error:', error);
          showStatus("Error updating preview");
        }
      });
    }

    function populatePerChannelDeltaSelect() {
      const sel = elements.perChannelDeltaSelect;
      if (!sel) return;
      const channels = getCurrentPrinter().channels || [];
      const current = sel.value;
      sel.innerHTML = '';
      channels.forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch; opt.textContent = ch;
        sel.appendChild(opt);
      });
      // Prefer previously selected, else first enabled, else first channel
      let desired = current && channels.includes(current) ? current : null;
      if (!desired) {
        const rows = Array.from(elements.rows?.children || []).filter(tr => tr.id !== 'noChannelsRow');
        const enabledRow = rows.find(tr => (InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0)) > 0);
        desired = enabledRow ? enabledRow.getAttribute('data-channel') : (channels[0] || '');
      }
      if (desired) sel.value = desired;
    }

    // Deprecated UI summary (hidden). Kept for reference; use chat summaries instead.
    function updatePerChannelDeltaSummary() {
      const out = elements.perChannelDeltaSummary;
      const sel = elements.perChannelDeltaSelect;
      if (!out || !sel) return;
      const ch = sel.value;
      if (!ch) { out.textContent = ''; return; }
      try {
        // Find end value for channel
        const row = getChannelRow(ch);
        if (!row) { out.textContent=''; return; }
        const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
        if (endVal <= 0) { out.textContent = '(disabled)'; return; }
        // Build before/after plotted values with/without global linearization
        const before = make256(endVal, ch, false); // integers 0..endVal
        const after  = make256(endVal, ch, true);  // integers 0..endVal
        if (!Array.isArray(before) || before.length < 2 || !Array.isArray(after) || after.length !== before.length) { out.textContent=''; return; }
        const N = after.length;
        // Compute absolute change as percent of full scale (TOTAL)
        let minChange=Infinity, maxChange=-Infinity, minIdx=0, maxIdx=0;
        for (let i=0;i<N;i++) {
          const dAbs = ((after[i] - before[i]) / TOTAL) * 100; // absolute ink % of full scale
          if (dAbs < minChange){ minChange=dAbs; minIdx=i; }
          if (dAbs > maxChange){ maxChange=dAbs; maxIdx=i; }
        }
        const fmtPct = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
        const kind = (v)=> v>0 ? 'add ink' : (v<0 ? 'reduce ink' : 'no change');
        const maxLabel = `${fmtPct(maxChange)} (${kind(maxChange)}) @ ${(maxIdx/(N-1)*100).toFixed(1)}%`;
        const minLabel = `${fmtPct(minChange)} (${kind(minChange)}) @ ${(minIdx/(N-1)*100).toFixed(1)}%`;
        out.textContent = `${ch}: ${maxLabel}, ${minLabel}`;
        out.title = 'Absolute change vs original plotted curve (percent of full scale)';
      } catch (e) { out.textContent=''; }
    }

    // Compute and display delta vs selected target when LAB/Manual global linearization is active
    // Deprecated UI summary (hidden). Kept for reference; use chat summaries instead.
    function updateDeltaSummary() {
      const el = elements.deltaSummary;
      if (!el) return;
      if (!linearizationData || !linearizationApplied) { el.textContent = ''; return; }
      const fmt = String(linearizationData.format || '').toUpperCase();
      // Show delta for LAB files and Manual L* generated corrections
      if (!(fmt.includes('LAB') || fmt.includes('MANUAL'))) { el.textContent = ''; return; }
      try {
      const smoothingPercent = 0;
        // Build normalized mapping 0..1 using current interpolation and smoothing
        let samples, lutX;
        if (typeof linearizationData.getSmoothingControlPoints === 'function') {
          const cp = linearizationData.getSmoothingControlPoints(smoothingPercent);
          samples = cp?.samples || linearizationData.samples;
          lutX = cp?.xCoords || null;
        } else {
          samples = linearizationData.samples;
          lutX = null;
        }
        if (!Array.isArray(samples) || samples.length < 2) { el.textContent=''; return; }
        const K = samples.length;
        if (!lutX) {
          lutX = new Array(K);
          for (let i=0;i<K;i++) lutX[i] = i/(K-1);
        }
        // Choose interpolation type similarly to global apply
        const interpType = getGlobalLinearizationInterpolationType(linearizationData, elements.curveSmoothingMethod.value);
        let interp;
        if (interpType === 'pchip') interp = createPCHIPSpline(lutX, samples);
        else if (interpType === 'cubic') interp = createCubicSpline(lutX, samples);
        else if (interpType === 'catmull') interp = createCatmullRomSpline(lutX, samples, (elements.catmullTension?.value||50)/100);
        else {
          interp = (t)=>{
            if (t<=lutX[0]) return samples[0];
            if (t>=lutX[K-1]) return samples[K-1];
            let i0=0; for(let i=0;i<K-1;i++){ if (t>=lutX[i] && t<=lutX[i+1]) { i0=i; break; } }
            const i1=Math.min(i0+1,K-1);
            const x0=lutX[i0], x1=lutX[i1];
            const y0=samples[i0], y1=samples[i1];
            const a = x1===x0?0:(t-x0)/(x1-x0);
            return (1-a)*y0 + a*y1;
          };
        }
        // Evaluate 256 mapping and compute delta vs target intent
        const N = 256;
        let minDelta=Infinity, maxDelta=-Infinity, minIdx=0, maxIdx=0;
        for (let i=0;i<N;i++){
          const x = i/(N-1);
          const y = interp(x);
          const tgt = getTargetRelAt(x);
          const d = (y - tgt) * 100; // percent points vs target
          if (d < minDelta){ minDelta = d; minIdx = i; }
          if (d > maxDelta){ maxDelta = d; maxIdx = i; }
        }
        // Zero crossing (first sign change)
        let zeroAt = null;
        for (let i=1;i<N;i++){
          const prev = (interp((i-1)/(N-1)) - getTargetRelAt((i-1)/(N-1)));
          const curr = (interp(i/(N-1)) - getTargetRelAt(i/(N-1)));
          if (prev===0){ zeroAt = (i-1)/(N-1); break; }
          if ((prev<0 && curr>0) || (prev>0 && curr<0)){
            const t = Math.abs(curr - prev) > 1e-12 ? (-prev)/(curr - prev) : 0;
            zeroAt = ((i-1) + t)/(N-1);
            break;
          }
        }
        const fmtPct = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
        const kind = (v)=> v>0 ? 'add ink' : (v<0 ? 'reduce ink' : 'no change');
        const maxLabel = `${fmtPct(maxDelta)} (${kind(maxDelta)}) @ ${(maxIdx/(N-1)*100).toFixed(1)}% input`;
        const minLabel = `${fmtPct(minDelta)} (${kind(minDelta)}) @ ${(minIdx/(N-1)*100).toFixed(1)}% input`;
        const zeroLabel = zeroAt!=null ? `, zero ≈ ${(zeroAt*100).toFixed(1)}% input` : '';
        const intentName = (contrastIntent?.name) || 'Linear';
        el.textContent = `Δ vs target (${intentName}): ${maxLabel}, ${minLabel}${zeroLabel}`;
        el.title = 'Delta computed vs selected target (contrast intent)';
      } catch (e) {
        try { elements.deltaSummary.textContent=''; } catch {}
      }
    }

    // Build a one-line global delta summary for Lab Tech chat
    function buildGlobalDeltaSummaryText() {
      try {
        if (!linearizationData || !linearizationApplied) return '';
        const fmt = String(linearizationData.format || '').toUpperCase();
        if (!(fmt.includes('LAB') || fmt.includes('MANUAL'))) return '';
      const smoothingPercent = 0;
        let samples, lutX;
        if (typeof linearizationData.getSmoothingControlPoints === 'function') {
          const cp = linearizationData.getSmoothingControlPoints(smoothingPercent);
          samples = cp?.samples || linearizationData.samples;
          lutX = cp?.xCoords || null;
        } else {
          samples = linearizationData.samples;
          lutX = null;
        }
        if (!Array.isArray(samples) || samples.length < 2) return '';
        const K = samples.length;
        if (!lutX) { lutX = Array.from({length: K}, (_, i) => i/(K-1)); }
        const interpType = getGlobalLinearizationInterpolationType(linearizationData, elements.curveSmoothingMethod.value);
        let interp;
        if (interpType === 'pchip') interp = createPCHIPSpline(lutX, samples);
        else if (interpType === 'cubic') interp = createCubicSpline(lutX, samples);
        else if (interpType === 'catmull') interp = createCatmullRomSpline(lutX, samples, (elements.catmullTension?.value||50)/100);
        else interp = (t)=>{
          if (t<=lutX[0]) return samples[0];
          if (t>=lutX[K-1]) return samples[K-1];
          let i0=0; for(let i=0;i<K-1;i++){ if (t>=lutX[i] && t<=lutX[i+1]) { i0=i; break; } }
          const i1=Math.min(i0+1,K-1);
          const x0=lutX[i0], x1=lutX[i1];
          const y0=samples[i0], y1=samples[i1];
          const a = x1===x0?0:(t-x0)/(x1-x0);
          return (1-a)*y0 + a*y1;
        };
        const N = 256;
        let minDelta=Infinity, maxDelta=-Infinity, minIdx=0, maxIdx=0;
        for (let i=0;i<N;i++){
          const x = i/(N-1);
          const y = interp(x);
          const tgt = getTargetRelAt(x);
          const d = (y - tgt) * 100; // percent points vs target
          if (d < minDelta){ minDelta = d; minIdx = i; }
          if (d > maxDelta){ maxDelta = d; maxIdx = i; }
        }
        // zero crossing
        let zeroAt = null;
        for (let i=1;i<N;i++){
          const prev = (interp((i-1)/(N-1)) - getTargetRelAt((i-1)/(N-1)));
          const curr = (interp(i/(N-1)) - getTargetRelAt(i/(N-1)));
          if (prev===0){ zeroAt=(i-1)/(N-1); break; }
          if ((prev<0 && curr>0) || (prev>0 && curr<0)){
            const t = Math.abs(curr - prev) > 1e-12 ? (-prev)/(curr - prev) : 0;
            zeroAt = ((i-1) + t)/(N-1);
            break;
          }
        }
        const fmtPct = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
        const kind = (v)=> v>0 ? 'add ink' : (v<0 ? 'reduce ink' : 'no change');
        const maxLabel = `${fmtPct(maxDelta)} (${kind(maxDelta)}) @ ${(maxIdx/(N-1)*100).toFixed(1)}% input`;
        const minLabel = `${fmtPct(minDelta)} (${kind(minDelta)}) @ ${(minIdx/(N-1)*100).toFixed(1)}% input`;
        const zeroLabel = zeroAt!=null ? `, zero ≈ ${(zeroAt*100).toFixed(1)}% input` : '';
        const intentName = (contrastIntent?.name) || 'Linear';
        return `Δ vs target (${intentName}): ${maxLabel}, ${minLabel}${zeroLabel}`;
      } catch { return ''; }
    }

    function buildPerChannelChangeSummaryAllChannelsText() {
      try {
        if (!linearizationData || !linearizationApplied) return '';
        const channels = getCurrentPrinter().channels || [];
        const parts = [];
        channels.forEach(ch => {
          const row = getChannelRow(ch);
          if (!row) return;
          const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
          if (endVal <= 0) return;
          const before = make256(endVal, ch, false);
          const after  = make256(endVal, ch, true);
          if (!Array.isArray(before) || !Array.isArray(after) || before.length !== after.length) return;
          let minChange=Infinity, maxChange=-Infinity;
          const N = after.length;
          for (let i=0;i<N;i++){
            const dAbs = ((after[i] - before[i]) / TOTAL) * 100;
            if (dAbs < minChange){ minChange=dAbs; }
            if (dAbs > maxChange){ maxChange=dAbs; }
          }
          const fmtShort = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
          parts.push(`${ch}:${fmtShort(maxChange)}/${fmtShort(minChange)}`);
        });
        if (parts.length === 0) return '';
        return `Channel changes (max/min vs original): ${parts.join('; ')}`;
      } catch { return ''; }
    }

    function postGlobalDeltaChatSummary() {
      try {
        const line1 = buildGlobalDeltaSummaryText();
        const line2 = buildPerChannelChangeSummaryAllChannelsText();
        if (line1) addChatMessage('system', line1);
        if (line2) addChatMessage('system', line2);
      } catch {}
    }

    // Graph semantics: ink mapping (output vs input). Y=X = no correction; dips (Y<X) lighten; humps (Y>X) darken.
    // See docs/LAB_LINEARIZATION_WORKFLOW.md for plotting conventions and cross-tool comparisons.
  function updateInkChart() {
      // Stable mapping: X left→right (0→100), Y bottom→top (0→100)
      if (DEBUG_LOGS) console.log('DEBUG: Global linearization state:', {
        hasLinearizationData: !!linearizationData,
        linearizationApplied: linearizationApplied,
        samplesCount: linearizationData?.samples?.length || 0,
        hasAnyLinearization: hasAnyLinearization()
      });
      
      if (elements.rows.children.length === 0) return;
      
      const canvas = elements.inkChart;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      // Resolve theme colors for chart elements
      const styles = getComputedStyle(document.documentElement);
      const COLOR_GRID = (styles.getPropertyValue('--chart-grid') || '#e5e7eb').trim();
      const COLOR_AXIS = (styles.getPropertyValue('--chart-axis') || '#374151').trim();
      const COLOR_TEXT = (styles.getPropertyValue('--chart-text') || '#000000').trim();
      const COLOR_HELPER = (styles.getPropertyValue('--chart-helper-border') || '#9ca3af').trim();
      const COLOR_BORDER = (styles.getPropertyValue('--border') || '#e5e7eb').trim();
      const COLOR_BG = (styles.getPropertyValue('--chart-bg') || 'transparent').trim();
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Set up coordinate system
      const padding = 60;
      const leftPadding = padding - 6; // Shift chart 6px left
      const rightPadding = padding + 6; // Maintain total width
      const chartWidth = width - leftPadding - rightPadding;
      const chartHeight = height - 2 * padding;
      const minZoomIdx = getMinimumAllowedZoomIndex();
      if (chartZoomIndex < minZoomIdx) {
        setChartZoomIndex(minZoomIdx, { persist: true, refresh: false });
      }

      const displayMax = normalizeDisplayMax({ displayMax: getChartZoomPercent() });
      const geom = { leftPadding, chartWidth, padding, chartHeight, height, width, displayMax };

      // Lighten/differentiate chart area background per theme
      if (COLOR_BG && COLOR_BG !== 'transparent') {
        ctx.save();
        ctx.fillStyle = COLOR_BG;
        ctx.fillRect(leftPadding, padding, chartWidth, chartHeight);
        ctx.restore();
      }

      // Determine how many ink channels are currently enabled (selected)
      const activeEnabledCount = Array.from(elements.rows.children).reduce((count, row) => {
        if (row.id === 'noChannelsRow') return count;
        const input = row.querySelector('.end-input');
        if (!input) return count;
        const endVal = InputValidator.clampEnd(input.value);
        return count + (endVal > 0 ? 1 : 0);
      }, 0);
      
      // Auto-toggle off overlays when multiple channels are enabled, but allow users to re-enable them
      if (elements.aiLabelToggle) {
        if (activeEnabledCount > 1) {
          if (elements.aiLabelToggle.checked && !overlayAutoToggledOff) {
            elements.aiLabelToggle.checked = false;
            overlayAutoToggledOff = true;
          }
        } else {
          // Reset guard when back to single/no channels
          overlayAutoToggledOff = false;
        }
      }
      
      // No additional status messaging; overlays are user-togglable via the toggle
      
      // Check conditions for showing original curve overlay (smoothing deprecated)
      const shouldShowOriginal = false;
      
      // Draw grid
      ctx.strokeStyle = COLOR_GRID;
      ctx.lineWidth = 1;
      
      // Vertical grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Horizontal grid lines (dynamic based on zoom)
      const tickStep = displayMax <= 50 ? 5 : 10;
      const tickValues = [];
      for (let value = 0; value <= displayMax; value += tickStep) {
        tickValues.push(Math.round(value * 100) / 100);
      }
      if (tickValues[tickValues.length - 1] !== displayMax) {
        tickValues.push(displayMax);
      }
      tickValues.forEach((value) => {
        const y = mapPercentToY(value, geom);
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(leftPadding + chartWidth, y);
        ctx.stroke();
      });
      
      // Draw axes
      ctx.strokeStyle = COLOR_AXIS;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(leftPadding, padding);
      ctx.lineTo(leftPadding, height - padding);
      ctx.lineTo(leftPadding + chartWidth, height - padding);
      ctx.stroke();
      
      // Draw axis labels
      ctx.fillStyle = COLOR_TEXT;
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      
      // Ink-level orientation helper: vertical white↕black gradient beside Y-axis
      // White at 0% (bottom), Black at 100% (top)
      (function drawInkLevelGradient() {
        const gradientWidth = 10; // slim vertical strip for orientation
        // Place outside chart area, just to the left of the Y-axis line
        const gradientX = leftPadding - gradientWidth - 1;
        const grad = ctx.createLinearGradient(0, padding, 0, height - padding);
        grad.addColorStop(0, '#000000'); // top = 100% ink = black
        grad.addColorStop(1, '#ffffff'); // bottom = 0% ink = white
        ctx.fillStyle = grad;
        ctx.fillRect(gradientX, padding, gradientWidth, chartHeight);
        // subtle border using theme border color
        ctx.strokeStyle = COLOR_BORDER;
        ctx.lineWidth = 1;
        ctx.strokeRect(gradientX, padding, gradientWidth, chartHeight);
      })();

      // Input-level orientation helper: white→black gradient under X-axis
      // White at 0% (left), Black at 100% (right)
      (function drawInputLevelGradient() {
        const gradientHeight = 10; // small strip for orientation
        // Position so the strip touches the axis line
        const gradientY = height - padding + 1; // flush with axis bottom
        const grad = ctx.createLinearGradient(leftPadding, 0, leftPadding + chartWidth, 0);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#000000');
        ctx.fillStyle = grad;
        ctx.fillRect(leftPadding, gradientY, chartWidth, gradientHeight);
        // subtle border for visibility on light/dark backgrounds (theme border)
        ctx.strokeStyle = COLOR_BORDER;
        ctx.lineWidth = 1;
        ctx.strokeRect(leftPadding, gradientY, chartWidth, gradientHeight);
      })();
      
      // Ensure text labels use theme text color regardless of prior fills
      ctx.fillStyle = COLOR_TEXT;
      
      // X-axis labels (0% to 100%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        const value = i * 10;
        // Make 0 and 100 bold
        if (value === 0 || value === 100) {
          ctx.font = 'bold 12px system-ui';
        } else {
          ctx.font = '12px system-ui';
        }
        // Nudge labels slightly lower to avoid overlapping the gradient strip
        ctx.fillText(`${value}`, x, height - padding + 28);
      }
      
      // Y-axis labels (respect current zoom)
      ctx.textAlign = 'right';
      ctx.fillStyle = COLOR_TEXT;
      const yAxisLabelX = leftPadding - (10 /* gradient */ + 1 /* gap */ + 10 /* original offset */ + 1 /* margin */) + 4;
      tickValues.forEach((value) => {
        const y = mapPercentToY(value, geom);
        const isEdge = Math.abs(value) < 0.001 || Math.abs(value - displayMax) < 0.001;
        ctx.font = isEdge ? 'bold 12px system-ui' : '12px system-ui';
        const label = (Math.abs(value - Math.round(value)) < 0.001) ? Math.round(value).toString() : value.toFixed(1);
        ctx.fillText(label, yAxisLabelX, y + 4);
      });
      
      // Axis titles
      ctx.textAlign = 'center';
      ctx.font = '14px system-ui';
      ctx.fillStyle = COLOR_TEXT;
      ctx.fillText('Input Level %', width / 2, height - 10);
      
      ctx.save();
      // Shift Y-axis title left; clamp to keep it inside canvas
      const yAxisTitleBaseX = 15;
      const yAxisTitleShift = (10 /* gradient */ + 1 /* gap */ + 1 /* margin */);
      // Nudge a bit further left while keeping it inside canvas
      const yAxisTitleX = Math.max(11, yAxisTitleBaseX - yAxisTitleShift);
      ctx.translate(yAxisTitleX, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = COLOR_TEXT;
      ctx.fillText('Output Ink Level %', 0, 0);
      ctx.restore();

      // Update chart cursor tooltip mapping and listeners
      setupChartCursorTooltip(geom);
      
      // Draw curves and collect label info
      const labels = [];
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      const allowIntentPreview = canApplyIntentRemap();
      
      // Build draw order; in Edit Mode draw the selected channel last (on top)
      const isEdit = isEditModeEnabled();
      const selectedName = (isEdit && EDIT && EDIT.selectedChannel) ? String(EDIT.selectedChannel) : null;
      const drawRows = Array.from(elements.rows.children)
        .filter(row => row.id !== 'noChannelsRow')
        .sort((a, b) => {
          try {
            if (!selectedName) return 0;
            const aName = a.querySelector('td span span:nth-child(2)')?.textContent?.trim();
            const bName = b.querySelector('td span span:nth-child(2)')?.textContent?.trim();
            const aSel = (aName === selectedName) ? 1 : 0;
            const bSel = (bName === selectedName) ? 1 : 0;
            return aSel - bSel; // selected (1) sorts after non-selected (0)
          } catch { return 0; }
        });
      
      drawRows.forEach((row, index) => {
        // Skip the placeholder row
        if (row.id === 'noChannelsRow') return;
        
        const channelName = row.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(row.querySelector('.end-input').value);
        
        if (endVal === 0) return; // Skip disabled channels
        
        const percent = InputValidator.computePercentFromEnd(endVal);
        const inkColor = INK_COLORS[channelName] || '#000000';
        
        // Generate the 256 values with linearization
        const values = make256(endVal, channelName, true);
        const maxValue = TOTAL; // 65535
        
        if (DEBUG_LOGS) console.log('DEBUG: Chart values for', channelName, {
          valuesCount: values.length,
          valuesMin: Math.min(...values),
          valuesMax: Math.max(...values),
          maxValue: maxValue,
          endVal: endVal,
          hasInvalidValues: values.some(v => isNaN(v) || !isFinite(v) || v < 0),
          firstFewValues: values.slice(0, 10),
          lastFewValues: values.slice(-5)
        });
        
        
        // Draw a faded target reference line (matches current Intent)
        const isAICurve = isSmartCurve(channelName);
        const showRef = hasLinearization || allowIntentPreview || isAICurve;
        if (showRef) {
          // Build intent-based reference: y = Intent(t) scaled to current End (ink output)
          const refValues = (() => {
            const Nvals = 256;
            const arr = new Array(Nvals);
            for (let i = 0; i < Nvals; i++) {
              const t = i / (Nvals - 1);
              const yRel = clamp01(getTargetRelAt(t)); // 0..1
              arr[i] = Math.round(yRel * endVal);
            }
            return arr;
          })();
          // Draw faded reference line (dotted)
          ctx.strokeStyle = inkColor;
          // Dim further when Edit Mode is on and this is not the selected channel
          const isEdit = isEditModeEnabled();
          const isSelectedChannel = isEdit && EDIT && EDIT.selectedChannel === channelName;
          ctx.globalAlpha = (isEdit && !isSelectedChannel) ? 0.125 : 0.25;
          ctx.lineWidth = 1;
          ctx.setLineDash([2, 2]); // Dotted line
          ctx.beginPath();
          
          for (let i = 0; i < refValues.length; i++) {
            const x = leftPadding + (i / (refValues.length - 1)) * chartWidth;
            const valuePercent = (refValues[i] / maxValue) * 100;
            const y = mapPercentToY(valuePercent, geom);
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
          ctx.setLineDash([]); // Reset line dash
          ctx.globalAlpha = 1.0; // Reset opacity
        }
        
        // Draw original curve (before smoothing) if conditions are met
        if (shouldShowOriginal && hasLinearization) {
          // Generate the original curve without smoothing by temporarily storing and overriding smoothing
          const currentSmoothing = elements.smoothingSlider.value;
          elements.smoothingSlider.value = '0';
          const originalValues = make256(endVal, channelName, true);
          elements.smoothingSlider.value = currentSmoothing; // Restore original smoothing
          
          // Draw original curve as gray dashed line
          ctx.strokeStyle = '#9CA3AF'; // Gray-400
          ctx.globalAlpha = 0.8;
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 2]); // Dashed line
          ctx.beginPath();
          
          for (let i = 0; i < originalValues.length; i++) {
            const x = leftPadding + (i / (originalValues.length - 1)) * chartWidth;
            const valuePercent = (originalValues[i] / maxValue) * 100;
            const y = mapPercentToY(valuePercent, geom);
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
          ctx.setLineDash([]); // Reset line dash
          ctx.globalAlpha = 1.0; // Reset opacity
        }
        
        // Draw the actual linearized curve (dim unselected channels in Edit Mode)
      const isSelectedChannel = isEdit && EDIT && EDIT.selectedChannel === channelName;
      const dimUnselected = isEdit && !isSelectedChannel;
      ctx.strokeStyle = inkColor;
      ctx.globalAlpha = dimUnselected ? 0.5 : 1.0;
      ctx.lineWidth = 2;
      ctx.beginPath();
        
        // Plot the curve
        for (let i = 0; i < values.length; i++) {
          const x = leftPadding + (i / (values.length - 1)) * chartWidth;
          const valuePercent = (values[i] / maxValue) * 100;
          const y = mapPercentToY(valuePercent, geom);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
      ctx.stroke();
      ctx.globalAlpha = 1.0; // reset

      // Auto endpoint rolloff markers (debug overlay)
      try {
        const autoWhiteOn = !!elements?.autoWhiteLimitToggle?.checked;
        const autoBlackOn = !!elements?.autoBlackLimitToggle?.checked;
        if ((autoWhiteOn || autoBlackOn) && window._autoLimitState && window._autoLimitState[channelName]) {
          const meta = window._autoLimitState[channelName];
          const drawMarker = (idx, color) => {
            const x = leftPadding + (idx / (values.length - 1)) * chartWidth;
            ctx.save();
            ctx.strokeStyle = color;
            ctx.setLineDash([6, 3]);
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x, padding);
            ctx.lineTo(x, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
          };
          // Marker colors: blue = black end (right/knee start), red = white end (left/knee end)
          if (autoBlackOn && meta.black && isFinite(meta.black.startIndex)) drawMarker(meta.black.startIndex, '#3b82f6');
          if (autoWhiteOn && meta.white && isFinite(meta.white.endIndex)) drawMarker(meta.white.endIndex, '#ef4444');
        }
      } catch {}
        
        // Lightweight overlay: key points visibility follows Edit Mode
        // Prefer explicit AI key points when available; otherwise show adapter overlays (ACV/LUT/LAB)
        let hasAIKeyPoints = false;
        try {
          const cp = (typeof ControlPoints !== 'undefined' && ControlPoints && ControlPoints.get) ? ControlPoints.get(channelName) : null;
          hasAIKeyPoints = !!(cp && Array.isArray(cp.points) && cp.points.length > 0);
        } catch {}
        if (!hasAIKeyPoints) {
          const aiPts = window.loadedQuadData?.keyPoints?.[channelName];
          hasAIKeyPoints = Array.isArray(aiPts) && aiPts.length > 0;
        }
        if (hasAIKeyPoints && isEdit) {
          const showAIlabels = !!isSelectedChannel; // hide ordinal labels on unselected channels
          const showMarkers = !!isSelectedChannel; // hide point boxes on unselected channels
          ctx.save();
          if (dimUnselected) ctx.globalAlpha = 0.5;
          renderAIKeyPointOverlay(ctx, channelName, values, maxValue, { leftPadding, chartWidth, padding, height, chartHeight, displayMax }, inkColor, { showLabels: showAIlabels, drawMarkers: showMarkers });
          ctx.restore();
        } else if (isEdit) {
          // Only show adapter overlays (LAB/LUT/ACV) in Edit Mode
          const sets = getAdapterOverlayXPositions(channelName);
          const showOverlayLabels = !!isSelectedChannel; // show labels only for selected channel
          ctx.save();
          if (dimUnselected) ctx.globalAlpha = 0.5;
          sets.forEach(set => {
            renderXPositionsOverlay(ctx, set.xPercents, values, maxValue, { leftPadding, chartWidth, padding, height, chartHeight, displayMax }, inkColor, showOverlayLabels);
          });
          ctx.restore();
        }
        
        // Store label info for later positioning
        const actualEndValue = values[values.length - 1];
        const actualEndPercent = (actualEndValue / maxValue) * 100;
        const endY = mapPercentToY(actualEndPercent, geom);
        
        labels.push({
          channelName,
          percent: Math.round(percent),
          inkColor,
          endY
        });
      });
      
      // Draw labels with collision avoidance
      if (labels.length > 0) {
        labels.sort((a, b) => a.endY - b.endY); // Sort by Y position
        
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        
        const minSpacing = 20; // Minimum spacing between labels
        const endX = leftPadding + chartWidth; // Position labels at the right edge of chart
        
        // Adjust label positions to avoid overlaps
        for (let i = 0; i < labels.length; i++) {
          let labelY = labels[i].endY + 4;
          
          // Check for overlap with previous label
          if (i > 0) {
            const prevLabelY = labels[i-1].adjustedY || (labels[i-1].endY + 4);
            if (labelY - prevLabelY < minSpacing) {
              labelY = prevLabelY + minSpacing;
            }
          }
          
          // Store adjusted position
          labels[i].adjustedY = labelY;
          
          // Draw the label with theme-aware background and ink color chip
          const labelText = `${labels[i].channelName} ${labels[i].percent}%`;
          const textMetrics = ctx.measureText(labelText);
          const chipW = 8, chipH = 12, pad = 6;
          const textHeight = 16; // Background height for 11px text with padding
          const bgW = chipW + pad + Math.ceil(textMetrics.width) + pad; // chip + gap + text + pad
          const bgH = textHeight + 2;
          // Anchor label at the right edge; shift down slightly for clarity
          const bgX = endX;
          
          const bgY = labelY - textHeight + 5; // shift down 3px

          // Read theme colors
          const labelBG = (styles.getPropertyValue('--bg-elevated') || '#ffffff').trim();
          const labelBorder = (styles.getPropertyValue('--border') || '#e5e7eb').trim();
          const labelTextColor = (styles.getPropertyValue('--text') || '#111827').trim();

          // Background + border
          ctx.fillStyle = labelBG;
          ctx.fillRect(bgX, bgY, bgW, bgH);
          ctx.strokeStyle = labelBorder;
          ctx.lineWidth = 1;
          ctx.strokeRect(bgX + 0.5, bgY + 0.5, bgW - 1, bgH - 1);

          // Ink color chip
          const chipX = bgX + pad/2;
          const chipY = bgY + Math.round((bgH - chipH)/2);
          ctx.fillStyle = labels[i].inkColor;
          ctx.fillRect(Math.round(chipX) + 0.5, Math.round(chipY) + 0.5, chipW, chipH);
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.strokeRect(Math.round(chipX) + 0.5, Math.round(chipY) + 0.5, chipW, chipH);

          // Text
          const textX = bgX + chipW + pad;
          const textCenterY = bgY + Math.round(bgH/2) + 5 - 2; // vertical align tweak
          ctx.fillStyle = labelTextColor;
          ctx.fillText(labelText, textX, textCenterY);
      }
    }

    // After drawing right-edge ink limit labels, re-render selected channel's ordinal labels on top
    try {
      const isEditTop = isEditModeEnabled();
      const selCh = isEditTop && EDIT && EDIT.selectedChannel ? String(EDIT.selectedChannel) : null;
      if (isEditTop && selCh) {
        const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
        if (row) {
          const endVal = InputValidator.clampEnd(row.querySelector('.end-input').value);
          if (endVal > 0) {
            const values = make256(endVal, selCh, true);
            const inkColor = INK_COLORS[selCh] || '#000000';
            ctx.save();
            // Ensure full opacity for topmost labels
            ctx.globalAlpha = 1.0;
            renderAIKeyPointOverlay(ctx, selCh, values, TOTAL, { leftPadding, chartWidth, padding, height, chartHeight, displayMax }, inkColor, { showLabels: true, drawMarkers: false, requireExplicit: true });
            ctx.restore();
          }
        }
      }
    } catch {}
      
      // Animate logo bars only once (avoid re-trigger on mousemove redraws)
      if (!LOGO_ANIMATED_ONCE) { try { animateLogoBars(); } catch {} LOGO_ANIMATED_ONCE = true; }

      try { updateChartZoomButtons(); } catch {}
    }

    // Cursor tooltip over the chart: show X,Y in percent (locks to selected channel in Edit Mode)
    let CHART_CURSOR_MAP = null;
    function setupChartCursorTooltip(map){
      CHART_CURSOR_MAP = map;
      const canvas = elements.inkChart;
      const tip = elements.chartCursorTooltip;
      if (!canvas || !tip) return;
      if (!canvas._cursorTooltipBound){
        const container = canvas.closest('.relative') || canvas.parentElement || document.body;
        const onMove = (e)=>{
          if (!CHART_CURSOR_MAP) return;
          // Re-render chart to clear prior cursor marker overlay
          try { updateInkChart(); } catch {}
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const cx = (e.clientX - rect.left) * scaleX;
          const cy = (e.clientY - rect.top) * scaleY;
          const { leftPadding, chartWidth, padding, chartHeight, width, height, displayMax } = CHART_CURSOR_MAP;
          let xPct = ((cx - leftPadding) / chartWidth) * 100;
          xPct = Math.max(0, Math.min(100, xPct));
          let yPct = mapYToPercent(cy, CHART_CURSOR_MAP);
          let drawX = cx;
          let drawY = mapPercentToY(yPct, CHART_CURSOR_MAP);

          // If Edit Mode is ON and a selected channel exists and is enabled, lock Y to that channel's plot
          try {
            if (isEditModeEnabled() && EDIT && EDIT.selectedChannel) {
              const selCh = EDIT.selectedChannel;
              const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
              if (row) {
                const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
                if (endVal > 0) {
                  // Build plotted values with linearization and sample at the cursor X
                  const values = make256(endVal, selCh, true);
                  const t = Math.max(0, Math.min(1, (xPct/100))) * (values.length - 1);
                  const i0 = Math.floor(t);
                  const i1 = Math.min(values.length - 1, i0 + 1);
                  const a = t - i0;
                  const v = (1 - a) * values[i0] + a * values[i1];
                  const vPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                  yPct = vPct; // lock tooltip Y to curve value
                  drawY = mapPercentToY(vPct, CHART_CURSOR_MAP);
                  // Draw a bolded circle at (drawX, drawY) using channel color
                  const ctx = canvas.getContext('2d');
                  if (ctx) {
                    const inkColor = INK_COLORS[selCh] || '#000000';
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(Math.max(leftPadding, Math.min(leftPadding + chartWidth, drawX)), drawY, 5, 0, Math.PI * 2);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = inkColor;
                    ctx.stroke();
                    ctx.restore();
                  }
                }
              }
            }
          } catch {}

          const canInsert = (function(){
            try {
              if (!isEditModeEnabled() || !EDIT || !EDIT.selectedChannel) return false;
              const selCh = EDIT.selectedChannel;
              const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
              if (!row) return false;
              const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
              return endVal > 0;
            } catch { return false; }
          })();
          tip.innerHTML = `${xPct.toFixed(1)}, ${yPct.toFixed(1)}${canInsert ? '<br>click to add point' : ''}`;
          const contRect = container.getBoundingClientRect();
          const left = e.clientX - contRect.left + 12;
          const top = e.clientY - contRect.top - 24;
          tip.style.left = `${left}px`;
          tip.style.top = `${top}px`;
          tip.classList.remove('hidden');
        };
        const onLeave = ()=>{ tip.classList.add('hidden'); try { updateInkChart(); } catch {} };
        const onClick = (e)=>{
          try {
            if (!isEditModeEnabled() || !EDIT || !EDIT.selectedChannel) return;
            const selCh = EDIT.selectedChannel;
            // Ensure enabled
            const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
            if (!row) return;
            const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
            if (endVal <= 0) return;
            // Compute raw cursor X,Y in percent (not curve-locked)
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = (e.clientX - rect.left) * scaleX;
            const cy = (e.clientY - rect.top) * scaleY;
            const { leftPadding, chartWidth, padding, chartHeight, height } = CHART_CURSOR_MAP;
            let xPct = ((cx - leftPadding) / chartWidth) * 100;
            // Lock Y to the selected channel's plotted curve at this X
            // Sample current plotted values with linearization and compute absolute percent
            const values = make256(endVal, selCh, true);
            const t = Math.max(0, Math.min(1, (xPct/100))) * (values.length - 1);
            const i0 = Math.floor(t);
            const i1 = Math.min(values.length - 1, i0 + 1);
            const a = t - i0;
            const v = (1 - a) * values[i0] + a * values[i1];
            let yPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
            xPct = Math.max(0, Math.min(100, xPct));
            yPct = Math.max(0, Math.min(100, yPct));
            const res = quadGenActions.insertSmartKeyPointAt(selCh, xPct, yPct);
            if (res && res.success) {
              // Set selection to the newly inserted point (nearest to xPct)
              try {
                const kp = ControlPoints.get(selCh)?.points || [];
                const idx = ControlPoints.nearestIndex(kp, xPct, 100); // large tolerance to find nearest
                if (idx !== null && typeof idx === 'number') {
                  EDIT.selectedOrdinal = idx + 1;
                  edit_refreshPointIndex();
                }
              } catch {}
              updateProcessingDetail(selCh);
              updatePreview();
            } else if (res && !res.success && res.message) {
              showStatus(res.message);
            }
          } catch (err) { console.warn('Click-to-insert failed:', err); }
        };
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseenter', onMove);
        canvas.addEventListener('mouseleave', onLeave);
        canvas.addEventListener('click', onClick);
        canvas._cursorTooltipBound = true;
      }
    }

    // Overlay renderer for AI key points
    function renderAIKeyPointOverlay(ctx, channelName, values, maxValue, geom, inkColor, options = {}) {
      if (!isEditModeEnabled()) return; // Hide key-point overlay when edit mode is off
      const { leftPadding, chartWidth, padding, height } = geom;
      const showLabels = options.showLabels !== false;
      const drawMarkers = options.drawMarkers !== false; // allow hiding square markers
      const requireExplicit = options.requireExplicit === true; // if true, do not synthesize fallback points
      try {
        // Prefer explicit Smart key points if available (use ControlPoints store first)
        let points = [];
        try {
          const cp = (typeof ControlPoints !== 'undefined' && ControlPoints && ControlPoints.get) ? ControlPoints.get(channelName) : null;
          if (cp && Array.isArray(cp.points) && cp.points.length > 0) points = cp.points.slice();
        } catch {}
        if (!points || points.length === 0) {
          const aiPoints = window.loadedQuadData?.keyPoints?.[channelName];
          if (Array.isArray(aiPoints) && aiPoints.length > 0) points = aiPoints.slice();
        }
        if (requireExplicit && (!points || points.length === 0)) return;

        // Determine current End scaling so pre-scale key-point outputs map to absolute Y on the chart
        let scale = 1.0;
        try {
          const row = getChannelRow(channelName);
          const endVal = InputValidator.clampEnd(row?.querySelector('.end-input')?.value || 0);
          const endPct = InputValidator.computePercentFromEnd(endVal);
          scale = Math.max(0, endPct) / 100; // fraction of TOTAL
        } catch {}

        // Fallback: if no explicit points, derive marker positions from current curve
        if ((!points || points.length === 0) && !requireExplicit) {
          // Detect linear ramp from provided values; if linear, collapse to 2 markers at 0 and 100
          let useTwo = false;
          const last = values[values.length - 1];
          if (last > 0) {
            const N = values.length - 1;
            const samples = [0, Math.floor(N*0.25), Math.floor(N*0.5), Math.floor(N*0.75), N];
            const EPS = 0.005;
            useTwo = samples.every((idx) => {
              const expected = (idx / N);
              const actual = (values[idx] / last);
              return Math.abs(actual - expected) <= EPS;
            });
          }
          if (useTwo) {
            points = [{ input: 0 }, { input: 100 }];
          } else {
            const target = 16; // compact set to keep overlay readable
            points = [];
            for (let i = 0; i < target; i++) {
              const x = (i / (target - 1)) * 100;
              points.push({ input: x });
            }
          }
        }

        // Guard against excessive points (allow up to 32 so 21‑point LUTs still render after conversion)
        const MAX_LABEL_POINTS = 32;
        if (!Array.isArray(points) || points.length === 0 || points.length > MAX_LABEL_POINTS) return;

        const boxSize = 6;
        const sortedPoints = [...points].sort((a, b) => (a.input || 0) - (b.input || 0));
        ctx.save();
        ctx.strokeStyle = inkColor;
        ctx.lineWidth = 1.5;
        const defaultFont = 'bold 12px system-ui';
        ctx.font = defaultFont;
        ctx.textBaseline = 'bottom';
        ctx.textAlign = 'center';

        const isSelectedChannel = (typeof EDIT !== 'undefined' && EDIT && EDIT.selectedChannel === channelName);
        const selectedOrdinal = isSelectedChannel ? (EDIT.selectedOrdinal || 1) : -1;

        sortedPoints.forEach((pt, i) => {
          const xNorm = Math.max(0, Math.min(1, (pt.input || 0) / 100));
          const x = leftPadding + xNorm * chartWidth;
          // Convert pre‑scale stored output (0..100) to absolute chart percent using current End scale
          let valuePercent;
          if (typeof pt.output === 'number' && isFinite(pt.output)) {
            const pre = Math.max(0, Math.min(100, Number(pt.output)));
            valuePercent = Math.max(0, Math.min(100, pre * scale));
          } else {
            // Fallback: sample absolute Y from the plotted curve values
            const t = xNorm * (values.length - 1);
            const i0 = Math.floor(t);
            const i1 = Math.min(values.length - 1, i0 + 1);
            const a = t - i0;
            const v = (1 - a) * values[i0] + a * values[i1];
            valuePercent = Math.max(0, Math.min(100, (v / maxValue) * 100));
          }
          const y = mapPercentToY(valuePercent, geom);
          const hx = boxSize / 2;
          const hy = boxSize / 2;
          // Square marker (highlight current selected ordinal)
          const isSelected = isSelectedChannel && (i + 1 === selectedOrdinal);
          const bx = Math.round(x - hx) + 0.5;
          const by = Math.round(y - hy) + 0.5;
          if (drawMarkers) {
          if (isSelected) {
            ctx.save();
            ctx.lineWidth = 3;
            ctx.strokeStyle = inkColor;
            ctx.strokeRect(bx - 2, by - 2, boxSize + 4, boxSize + 4);
            ctx.restore();
            ctx.fillStyle = 'rgba(255,255,255,1)';
          } else {
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
          }
          ctx.fillRect(bx, by, boxSize, boxSize);
          ctx.strokeRect(bx, by, boxSize, boxSize);
          }

          if (!showLabels) return;
          // Label positioning
          let labelX = x;
          let labelY = y - hy - 3;
          if (valuePercent <= 5) labelX += 8;
          if (valuePercent >= 95) labelX -= 8;
          const minY = padding + 8;
          const maxY = height - padding - 2;
          if (labelY < minY) labelY = minY;
          if (labelY > maxY) labelY = maxY;

          const num = String(i + 1);
          // Enlarge and bold the selected label number
          const labelFontSize = isSelected ? 24 : 12; // double size for selected
          ctx.font = `bold ${labelFontSize}px system-ui`;
          const metrics = ctx.measureText(num);
          const bgPadX = isSelected ? 6 : 4;
          const bgW = Math.ceil(metrics.width) + bgPadX * 2;
          const bgH = Math.round(labelFontSize * 1.33);
          const bgX = Math.round(labelX - bgW / 2) + 0.5;
          const bgY = Math.round(labelY - bgH + 1) + 0.5;

          // Ordinal label colors: use the exact channel ink color for the chip, like index203.html
          // Compute text color (black/white) using YIQ for readability
          let r = 0, g = 0, b = 0;
          try {
            const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i.exec(String(inkColor));
            if (m) { r = parseInt(m[1], 16); g = parseInt(m[2], 16); b = parseInt(m[3], 16); }
          } catch {}
          const yiq = (r * 299 + g * 587 + b * 114) / 1000;
          const labelTextColor = yiq >= 140 ? '#000000' : '#FFFFFF';
          ctx.fillStyle = inkColor;
          ctx.fillRect(bgX, bgY, bgW, bgH);
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(bgX + 0.5, bgY + 0.5, bgW - 1, bgH - 1);
          ctx.fillStyle = labelTextColor;
          ctx.fillText(num, Math.round(labelX) + 0.5, Math.round(labelY) + 0.5);
          // Reset font to default for next iterations
          ctx.font = defaultFont;
        });
        ctx.restore();
      } catch (e) {
        if (DEBUG_LOGS) console.warn('Smart key point overlay failed:', e);
      }
    }

    // Generic overlay for data-type adapters using only X positions (percent)
    function renderXPositionsOverlay(ctx, xPercents, values, maxValue, geom, color, showLabels = true) {
      if (!Array.isArray(xPercents) || xPercents.length === 0) return;
      const { leftPadding, chartWidth, padding, height } = geom;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      ctx.font = 'bold 12px system-ui';
      ctx.textBaseline = 'bottom';
      ctx.textAlign = 'center';
      const boxSize = 6;
      const hx = boxSize / 2;
      const hy = boxSize / 2;
      xPercents.forEach((xp, i) => {
        const xNorm = Math.max(0, Math.min(1, (xp || 0) / 100));
        const x = leftPadding + xNorm * chartWidth;
        // Interpolate Y from plotted values for precise alignment
        const t = xNorm * (values.length - 1); // model t (do not flip for interpolation)
        const i0 = Math.floor(t);
        const i1 = Math.min(values.length - 1, Math.ceil(t));
        const a = t - i0;
        const v = (1 - a) * values[i0] + a * values[i1];
        const valuePercent = (v / maxValue) * 100;
        const y = mapPercentToY(valuePercent, geom);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(Math.round(x - hx) + 0.5, Math.round(y - hy) + 0.5, boxSize, boxSize);
        ctx.strokeRect(Math.round(x - hx) + 0.5, Math.round(y - hy) + 0.5, boxSize, boxSize);

        if (showLabels) {
          let labelX = x;
          let labelY = y - hy - 3;
          if (valuePercent <= 5) labelX += 8;
          if (valuePercent >= 95) labelX -= 8;
          const minY = padding + 8;
          const maxY = height - padding - 2;
          if (labelY < minY) labelY = minY;
          if (labelY > maxY) labelY = maxY;

          const num = String(i + 1);
          const metrics = ctx.measureText(num);
          const bgPadX = 4;
          const bgW = Math.ceil(metrics.width) + bgPadX * 2;
          const bgH = 16;
          const bgX = Math.round(labelX - bgW / 2) + 0.5;
          const bgY = Math.round(labelY - bgH + 1) + 0.5;

          // Adapter overlay labels: match ordinal inversion per theme
          const isDarkTheme = (document.documentElement.getAttribute('data-theme') === 'dark');
          const labelBG = isDarkTheme ? '#e5e7eb' : '#1f2937';
          const labelBorder = isDarkTheme ? '#d1d5db' : '#111827';
          const labelTextColor = isDarkTheme ? '#111827' : '#ffffff';
          ctx.fillStyle = labelBG;
          ctx.fillRect(bgX, bgY, bgW, bgH);
          ctx.strokeStyle = labelBorder;
          ctx.lineWidth = 1;
          ctx.strokeRect(bgX + 0.5, bgY + 0.5, bgW - 1, bgH - 1);

          ctx.fillStyle = labelTextColor;
          ctx.fillText(num, Math.round(labelX) + 0.5, Math.round(labelY) + 0.5);
        }
      });
      ctx.restore();
    }

    // Collect overlay point sets from loaded data for a given channel
    function getAdapterOverlayXPositions(channelName) {
      const sets = [];

      // Per-channel linearization overlay
      const per = perChannelLinearization[channelName];
      if (per && Array.isArray(per.samples)) {
        const format = per.format || '';
        const fmtLower = String(format).toLowerCase();
        if (format === 'ACV' && Array.isArray(per.controlPointsTransformed) && per.controlPointsTransformed.length > 0) {
          // Use ACV anchor points if available
          const xs = per.controlPointsTransformed.map(p => p.input);
          sets.push({ id: 'acv-per', label: 'ACV (per)', color: '#374151', xPercents: xs });
        } else if (!fmtLower.includes('lab')) {
          // Use original sample positions when K <= 32; otherwise downsample to 32 using index selection
          const K = per.samples.length;
          const target = Math.min(32, K);
          const xs = [];
          for (let i = 0; i < target; i++) {
            const idx = Math.round(i * (K - 1) / (target - 1));
            xs.push((idx / (K - 1)) * 100);
          }
          sets.push({ id: 'lin-per', label: `${format||'LIN'} (per)`, color: '#7C3AED', xPercents: xs });
        }
      }

      // Global linearization overlay (applies to all channels)
      if (linearizationData && Array.isArray(linearizationData.samples)) {
        const format = linearizationData.format || '';
        const fmtLower = String(format).toLowerCase();
        if (format === 'ACV' && Array.isArray(linearizationData.controlPointsTransformed) && linearizationData.controlPointsTransformed.length > 0) {
          // For ACV loaded globally, use the original ACV anchor points (transformed)
          const xs = linearizationData.controlPointsTransformed.map(p => p.input);
          sets.push({ id: 'acv-global', label: 'ACV (global)', color: '#374151', xPercents: xs });
        } else if (!fmtLower.includes('lab')) {
          // Generic non-LAB data: use original sample positions when K <= 32; else downsample to 32
          const K = linearizationData.samples.length;
          const target = Math.min(32, K);
          const xs = [];
          for (let i = 0; i < target; i++) {
            const idx = Math.round(i * (K - 1) / (target - 1));
            xs.push((idx / (K - 1)) * 100);
          }
          sets.push({ id: 'lin-global', label: `${format||'LIN'} (global)`, color: '#059669', xPercents: xs });
        }
      }

      // LAB original measured points overlay (global or per-channel if used there)
      const addLabOriginal = (data, scopeLabel) => {
        if (data && Array.isArray(data.originalData) && data.originalData.length > 0) {
          const xs = data.originalData.map(d => Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0))));
          if (xs.length > 0) sets.push({ id: `lab-${scopeLabel}`, label: `LAB (${scopeLabel})`, color: '#F59E0B', xPercents: xs });
        }
      };
      if (linearizationData && (linearizationData.format||'').includes('LAB')) addLabOriginal(linearizationData, 'global');
      if (perChannelLinearization[channelName] && (perChannelLinearization[channelName].format||'').includes('LAB')) addLabOriginal(perChannelLinearization[channelName], 'per');

      return sets;
    }

    // Generate filename based on current settings
    function generateFilename() {
      const p = PRINTERS[elements.printerSelect.value];
      // Extract just the printer model (remove "Epson " prefix)
      const printerModel = p.name.replace(/^Epson\s+/, '').replace(/\s+/g, '');
      let parts = [printerModel]; // Start with printer model
      
      // Add active channels with their percentages
      Array.from(elements.rows.children).forEach((tr) => {
        // Skip the placeholder row
        if (tr.id === 'noChannelsRow') return;
        
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        
        if (endVal > 0) {
          const percent = Math.round(InputValidator.computePercentFromEnd(endVal));
          parts.push(name + percent);
        }
      });
      
      // Add CORRECTED suffix if any linearization is applied
      const hasLinearization = (linearizationData && linearizationApplied) || 
                                Object.keys(perChannelLinearization).some(ch => perChannelEnabled[ch]);
      if (hasLinearization) {
        const tag = getIntentFilenameTag();
        if (tag) parts.push(tag);
        parts.push('CORRECTED');
      }
      
      return parts.join('_');
    }

    // Compact tag to embed contrast intent in filename
    function getIntentFilenameTag() {
      try {
        const id = String(contrastIntent?.id || 'linear');
        if (id === 'linear') return 'LIN';
        if (id === 'soft' || id === 'hard' || id === 'custom_gamma') {
          const g = Number(contrastIntent?.params?.gamma ?? (getPresetDefaults(id, 'gamma') || 1.00));
          if (!isFinite(g) || g <= 0) return 'G100';
          const val = Math.round(g * 100);
          return `G${String(val).padStart(3,'0')}`; // e.g., 0.85 => G085, 1.20 => G120
        }
        if (id === 'filmic' || id === 'custom_filmic') {
          // Keep very compact; omit params to keep names short
          return 'FILM';
        }
        if (id === 'pops_standard') return 'POPS';
        if (id === 'custom_points') return 'CUST';
        return 'LIN';
      } catch { return 'LIN'; }
    }

    // Toggle listeners
    if (elements.aiLabelToggle) {
      elements.aiLabelToggle.addEventListener('change', () => {
        // Key-Point Simplifier UI is deprecated under-graph; no visibility toggling
        updateInkChart();
      });
    }

    if (elements.chartZoomInBtn) {
      elements.chartZoomInBtn.addEventListener('click', () => {
        stepChartZoom(1);
      });
    }
    if (elements.chartZoomOutBtn) {
      elements.chartZoomOutBtn.addEventListener('click', () => {
        stepChartZoom(-1);
      });
    }
    updateChartZoomButtons();

    // Update filename input with current settings
    function updateFilename() {
      if (!elements.filenameInput.dataset.userEdited) {
        elements.filenameInput.value = generateFilename();
        // Trigger validation styling
        elements.filenameInput.dispatchEvent(new Event('input'));
      }
    }
    function sanitizeFilename(filename) {
      // Remove or replace invalid characters for Windows and Mac
      // Invalid: \ / : * ? " < > |
      return filename
        .replace(/[\\/:*?"<>|]/g, '_')  // Replace invalid chars with underscore
        .replace(/\s+/g, '_')          // Replace spaces with underscores
        .replace(/_{2,}/g, '_')        // Replace multiple underscores with single
        .replace(/^_+|_+$/g, '')       // Trim underscores from start/end
        .substring(0, 200);            // Limit length to 200 chars
    }

    // Session status (Quad / Global / Intent) displayed near the graph status line
    function updateSessionStatus() {
      try {
        const quadName = (window.loadedQuadData && window.loadedQuadData.filename) ? window.loadedQuadData.filename : 'none';
        let globalName = 'none';
        try {
          if (linearizationData && linearizationApplied) {
            globalName = (elements.globalLinearizationFilename?.textContent || linearizationData.filename || 'data');
          }
        } catch {}
        // Build concise intent label
        const id = String(contrastIntent?.id || 'linear');
        const name = contrastIntent?.name || 'Linear';
        const p = contrastIntent?.params || {};
        let extra = '';
        if (id === 'soft') extra = ' (γ≈0.85)';
        else if (id === 'hard') extra = ' (γ≈1.20)';
        else if (id === 'custom_gamma') extra = ` (γ=${(p.gamma??1).toFixed?Number(p.gamma).toFixed(2):p.gamma})`;
        else if (id === 'filmic' || id === 'custom_filmic') {
          const gain = Number(p.filmicGain ?? p.gain ?? 0.55);
          const shoulder = Number(p.shoulder ?? 0.35);
          extra = ` (gain ${isFinite(gain)?gain.toFixed(2):'0.55'}, shoulder ${isFinite(shoulder)?shoulder.toFixed(2):'0.35'})`;
        }
        const intentLabel = `${name}${extra}`;
        const parts = [];
        if (quadName && quadName !== 'none') parts.push(`Quad: ${quadName}`);
        if (globalName && globalName !== 'none') parts.push(`Global: ${globalName}`);
        // Include Intent only when non-linear
        if (id !== 'linear') {
          parts.push(`Intent: ${intentLabel}`);
        }
        const zoomPercent = getChartZoomPercent();
        if (zoomPercent && zoomPercent !== 100) {
          parts.push(`Zoom: ${zoomPercent}% max`);
        }
        const line = parts.join(' • ');
        if (elements.sessionStatus) elements.sessionStatus.textContent = line || '\u00A0';
      } catch {}
    }

    // ---- Linearization utilities ----
    const clamp01 = (x) => Math.max(0, Math.min(1, x));

    // Linearization data storage
    let linearizationData = null;
    let linearizationApplied = false;
    let loadedQuadData = null; // Stores complete curve data from loaded .quad files
    
    function applyIntentToLoadedCurve() {
      if (!canApplyIntentRemap()) {
        showStatus('Load a .quad without global LAB data to remap intent');
        return;
      }
      try {
        const curves = window.loadedQuadData?.curves;
        if (!curves || !Object.keys(curves).length) {
          showStatus('No curve data available for intent remap');
          return;
        }
        const channelList = Array.isArray(window.loadedQuadData?.channels) && window.loadedQuadData.channels.length
          ? [...window.loadedQuadData.channels]
          : Object.keys(curves);
        if (!channelList.length) {
          showStatus('No channels available for intent remap');
          return;
        }

        const intentId = String(contrastIntent?.id || 'linear');
        const intentName = contrastIntent?.name || 'Linear';
        const restoringLinear = intentId === 'linear';
        const actions = [];
        const updatedChannels = [];
        const total = TOTAL;

        const prevBatchFlag = CurveHistory.isBatchOperation;
        CurveHistory.isBatchOperation = true;

        for (const channelName of channelList) {
          const existing = curves[channelName];
          if (!Array.isArray(existing) || existing.length === 0) continue;

          try {
            const oldCurve = existing.slice();
            const length = existing.length;
            const denom = Math.max(1, length - 1);

            let newCurve;
            if (restoringLinear) {
              const original = window.loadedQuadData?.originalCurves?.[channelName];
              if (!Array.isArray(original) || original.length !== length) {
                throw new Error('Original curve unavailable for restoration');
              }
              const row = getChannelRow(channelName);
              const currentEnd = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : total;
              const baselineEnd = window.loadedQuadData?.baselineEnd?.[channelName] || total;
              const scale = baselineEnd > 0 ? (currentEnd / baselineEnd) : 0;
              newCurve = original.map(v => Math.round(Math.max(0, Math.min(total, v * scale))));
              if (newCurve[0] !== original[0]) newCurve[0] = Math.round(original[0] * scale);
              if (newCurve[length - 1] !== original[length - 1]) newCurve[length - 1] = Math.round(original[length - 1] * scale);
            } else {
              const xs = new Array(length);
              const ys = new Array(length);
              for (let i = 0; i < length; i++) {
                xs[i] = denom === 0 ? 0 : i / denom;
                ys[i] = clamp01(existing[i] / total);
              }

              let sampler = null;
              try {
                sampler = createPCHIPSpline(xs, ys);
              } catch (e) {
                sampler = null;
              }

              const sample = (t) => {
                const tt = clamp01(t);
                if (sampler) {
                  try {
                    const val = sampler(tt);
                    if (Number.isFinite(val)) return clamp01(val);
                  } catch {}
                }
                if (tt <= 0) return ys[0];
                if (tt >= 1) return ys[length - 1];
                const pos = tt * denom;
                const i0 = Math.floor(pos);
                const i1 = Math.min(length - 1, i0 + 1);
                const frac = pos - i0;
                return clamp01(ys[i0] + frac * (ys[i1] - ys[i0]));
              };

              newCurve = new Array(length);
              for (let i = 0; i < length; i++) {
                const inputT = denom === 0 ? 0 : i / denom;
                const target = clamp01(getTargetRelAt(inputT));
                const drive = sample(target);
                newCurve[i] = Math.round(clamp01(drive) * total);
              }
              // Ensure endpoints remain clamped to valid range
              newCurve[0] = Math.max(0, Math.min(total, newCurve[0]));
              newCurve[length - 1] = Math.max(0, Math.min(total, newCurve[length - 1]));
            }

            const oldKeyPointsRaw = window.loadedQuadData?.keyPoints?.[channelName] || null;
            const oldKeyPoints = oldKeyPointsRaw ? oldKeyPointsRaw.map(p => ({ input: p.input, output: p.output })) : null;
            const oldInterpolation = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType;
            const oldSource = window.loadedQuadData?.sources?.[channelName] ?? null;

            curves[channelName] = newCurve;

            let newKeyPoints = null;
            let newInterpolation = oldInterpolation || 'smooth';

            if (restoringLinear) {
              try {
                if (window.loadedQuadData?.keyPoints?.[channelName]) delete window.loadedQuadData.keyPoints[channelName];
              } catch {}
              try {
                if (window.loadedQuadData?.keyPointsMeta?.[channelName]) delete window.loadedQuadData.keyPointsMeta[channelName];
              } catch {}
              try {
                if (window.loadedQuadData?.sources && window.loadedQuadData.sources[channelName] !== undefined) {
                  delete window.loadedQuadData.sources[channelName];
                }
              } catch {}
            } else {
              const newKeyPointsRaw = extractAdaptiveKeyPointsFromValues(newCurve, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
              newKeyPoints = newKeyPointsRaw.map(p => ({ input: p.input, output: p.output }));
              try {
                ControlPoints.persist(channelName, newKeyPoints, newInterpolation);
                if (window.loadedQuadData?.keyPointsMeta?.[channelName] && window.loadedQuadData.keyPointsMeta[channelName].bakedGlobal) {
                  delete window.loadedQuadData.keyPointsMeta[channelName].bakedGlobal;
                }
              } catch (persistErr) {
                console.warn('Intent remap: failed to persist key points', channelName, persistErr);
              }
            }

            if (typeof updateProcessingDetailForce === 'function') {
              try { updateProcessingDetailForce(channelName); } catch {}
            }

            actions.push({
              channelName,
              type: 'curve',
              oldValue: oldCurve,
              newValue: newCurve.slice(),
              oldKeyPoints,
              newKeyPoints,
              oldInterpolation: oldInterpolation,
              newInterpolation,
              oldSource,
              newSource: oldSource,
              clearKeyPoints: restoringLinear,
              linearRestore: restoringLinear
            });
            updatedChannels.push(channelName);
          } catch (channelErr) {
            console.warn('Intent remap: channel update failed', channelName, channelErr);
          }
        }

        CurveHistory.isBatchOperation = prevBatchFlag;

        if (!actions.length) {
          showStatus('No eligible channel data to remap intent');
          return;
        }

        const description = restoringLinear ? 'Intent remap → Linear (restore original)' : `Intent remap → ${intentName}`;
        CurveHistory.recordBatchAction(description, actions);

        updatePreview();
        try { updateInkChart(); } catch {}
        try { updateCompactChannelsList(); } catch {}
        updateSessionStatus();
        updateIntentDropdownState();

        const statusIntent = restoringLinear ? 'Linear' : intentName;
        showStatus(`Applied ${statusIntent} intent to ${updatedChannels.length} channel${updatedChannels.length === 1 ? '' : 's'}`);
      } catch (error) {
        CurveHistory.isBatchOperation = prevBatchFlag;
        const msg = error?.message ? `Intent remap failed: ${error.message}` : 'Intent remap failed';
        console.error(error);
        showStatus(msg);
      }
    }

    // Clear loaded quad data
    function clearLoadedQuadData() {
      window.loadedQuadData = null;
      // Update interpolation controls since loaded data is no longer available
      updateInterpolationControls();
      updateIntentDropdownState();
    }

    // Clear all processing-related data (global + per-channel) and reset related UI
    function clearAllProcessingData() {
      try {
        // 1) Clear global linearization
        linearizationData = null;
        linearizationApplied = false;
        if (elements.globalLinearizationBtn) {
          elements.globalLinearizationBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
        }
        if (elements.globalLinearizationToggle) {
          elements.globalLinearizationToggle.disabled = true;
          elements.globalLinearizationToggle.checked = false;
        }
        if (elements.globalLinearizationInfo) {
          elements.globalLinearizationInfo.classList.add('hidden');
        }

        // 2) Clear per-channel linearization
        perChannelLinearization = {};
        perChannelEnabled = {};
        perChannelFilenames = {};
        // Reset per-channel UI if rows currently exist
        if (elements.rows) {
          Array.from(elements.rows.children).forEach(tr => {
            if (tr.id === 'noChannelsRow') return;
            const perBtn = tr.querySelector('.per-channel-btn');
            const perToggle = tr.querySelector('.per-channel-toggle');
            if (perBtn) perBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
            if (perToggle) { perToggle.disabled = true; perToggle.checked = false; }
            const ch = tr.getAttribute('data-channel');
            if (ch && typeof updateProcessingDetailForce === 'function') updateProcessingDetailForce(ch);
          });
        }

        // 3) Clear AI key points/meta and any prior curves in loaded data (will be replaced on load)
        if (!window.loadedQuadData) window.loadedQuadData = {};
        delete window.loadedQuadData.keyPoints;
        delete window.loadedQuadData.keyPointsMeta;
        delete window.loadedQuadData.sources;
        delete window.loadedQuadData.curves;
        delete window.loadedQuadData.channels;

        // 4) Update interpolation controls and hide overlay note
        updateInterpolationControls();
        // No overlay status messaging to reset

        // 5) Reset undo/redo history so user starts fresh
        if (typeof CurveHistory !== 'undefined' && CurveHistory && typeof CurveHistory.clear === 'function') {
          CurveHistory.clear();
        }

        if (DEBUG_INTENT_TUNING) {
          tuningRestoreState = null;
          if (elements.tuningRestoreBtn) elements.tuningRestoreBtn.disabled = true;
          setTuningStatus('');
        }
        updateIntentDropdownState();
      } catch (e) {
        console.warn('clearAllProcessingData encountered an issue:', e);
      }
    }
    
    // Check if any linearization is available that would benefit from interpolation
    function hasAnyLinearization() {
      // Active when a global correction is applied, or at least one per-channel correction is enabled
      const hasGlobal = !!(linearizationData && linearizationApplied);
      const hasAnyPerEnabled = Object.keys(perChannelLinearization).some(ch => perChannelEnabled[ch]);
      return hasGlobal || hasAnyPerEnabled;
      // Note: Loaded .quad data alone doesn't need interpolation since it already has 256 points
    }

    // Update Intent dropdown based on linearization availability
    function updateIntentDropdownState() {
      if (!elements.contrastIntentSelect) return;

      const hasLinearization = hasAnyLinearization();
      const allowRemap = canApplyIntentRemap();
      const enableControls = hasLinearization || allowRemap;

      if (enableControls) {
        elements.contrastIntentSelect.disabled = false;
        elements.contrastIntentSelect.removeAttribute('disabled');
      } else {
        elements.contrastIntentSelect.disabled = true;
        elements.contrastIntentSelect.setAttribute('disabled', '');
      }

      // Find the Intent label
      const intentLabel = document.querySelector('label[for="contrastIntentSelect"]');

      // Update visual styling to indicate disabled state
      if (enableControls) {
        elements.contrastIntentSelect.style.opacity = '1';
        elements.contrastIntentSelect.style.cursor = 'pointer';
        if (intentLabel) intentLabel.style.opacity = '1';
      } else {
        elements.contrastIntentSelect.style.opacity = '0.5';
        elements.contrastIntentSelect.style.cursor = 'not-allowed';
        if (intentLabel) intentLabel.style.opacity = '0.5';
      }

      const remapBtn = elements.applyIntentToQuadBtn;
      if (remapBtn) {
        if (allowRemap) {
          remapBtn.disabled = false;
          remapBtn.removeAttribute('disabled');
        } else {
          remapBtn.disabled = true;
          remapBtn.setAttribute('disabled', '');
        }
        const intentName = contrastIntent?.name || 'Linear';
        const tooltip = allowRemap
          ? `Bake ${intentName} intent into the loaded curve`
          : 'Load a .quad (without global LAB data) to enable intent remap';
        remapBtn.setAttribute('title', tooltip);
      }
    }

    // Update interpolation description based on selected method
    function updateInterpolationDescription() {
      const method = elements.curveSmoothingMethod.value;
      const hasLinearization = hasAnyLinearization();
      const hasLoadedQuad = loadedQuadData && loadedQuadData.curves;
      
      // Always hide description - controls are self-explanatory
      elements.interpolationDescription.style.display = 'none';
    }
    
    // Update interpolation controls based on linearization availability
    function updateInterpolationControls() {
      const hasLinearization = hasAnyLinearization();
      elements.curveSmoothingMethod.disabled = !hasLinearization;
      elements.catmullTension.disabled = !hasLinearization;
      // Enable smoothing whenever a linearization source exists; do not gate on Edit Mode
      if (elements.smoothingSlider) elements.smoothingSlider.disabled = true;
      if (elements.simplificationMethod) elements.simplificationMethod.disabled = !hasLinearization;

      // Update Intent dropdown state
      updateIntentDropdownState();
      
      // Update visual styling for disabled state
      if (!hasLinearization) {
        elements.curveSmoothingMethod.className = 'standard-dropdown';
      } else {
        elements.curveSmoothingMethod.className = 'standard-dropdown';
      }
      
      // Show/hide tension control for Catmull-Rom
      const method = elements.curveSmoothingMethod.value;
      const showTension = hasLinearization && method === 'catmull';
      elements.catmullTensionContainer.style.display = showTension ? 'block' : 'none';
      
      // Update smoothing warning visibility (smoothing deprecated)
      if (elements.smoothingWarning) {
        elements.smoothingWarning.classList.add('opacity-0', 'invisible');
      }
      
      // Update description
      updateInterpolationDescription();
    }

    function syncIntentTuningInputsFromState() {
      if (!DEBUG_INTENT_TUNING || !elements.intentTuningPanel) return;
      const overrides = LAB_TUNING.exportOverrides();
      const fallback = {
        K_NEIGHBORS: 2,
        SIGMA_FLOOR: 0.036,
        SIGMA_CEIL: 0.15,
        SIGMA_ALPHA: 2.0
      };
      const state = { ...fallback, ...(overrides || {}) };
      if (elements.tuningNeighbors) elements.tuningNeighbors.value = state.K_NEIGHBORS;
      if (elements.tuningSigmaFloor) elements.tuningSigmaFloor.value = state.SIGMA_FLOOR;
      if (elements.tuningSigmaCeil) elements.tuningSigmaCeil.value = state.SIGMA_CEIL;
      if (elements.tuningSigmaAlpha) elements.tuningSigmaAlpha.value = state.SIGMA_ALPHA;
      if (elements.tuningSmoothingPercent) {
        if (!elements.tuningSmoothingPercent.value) elements.tuningSmoothingPercent.value = 30;
        elements.tuningSmoothingLabel.textContent = `${elements.tuningSmoothingPercent.value}%`;
      }
      if (elements.tuningSmoothingAlgorithm) {
        if (!elements.tuningSmoothingAlgorithm.value) elements.tuningSmoothingAlgorithm.value = 'smoothing-splines';
      }
      if (elements.tuningPostPasses) {
        if (!elements.tuningPostPasses.value) elements.tuningPostPasses.value = 1;
      }
      if (elements.tuningPostPercent) {
        if (!elements.tuningPostPercent.value) elements.tuningPostPercent.value = 30;
        elements.tuningPostLabel.textContent = `${elements.tuningPostPercent.value}%`;
        const passes = elements.tuningPostPasses ? Number(elements.tuningPostPasses.value) || 0 : 0;
        elements.tuningPostPercent.disabled = passes === 0;
        if (elements.tuningPostAlgorithm) {
          if (!elements.tuningPostAlgorithm.value) elements.tuningPostAlgorithm.value = 'smoothing-splines';
          elements.tuningPostAlgorithm.disabled = passes === 0;
        }
      }
    }

    function applySmoothingSequence(samples, percent, algorithm) {
      if (!Array.isArray(samples) || !samples.length) return samples;
      const pct = Math.max(0, Number(percent) || 0);
      if (pct <= 0) return samples.slice();
      const algo = algorithm || 'smoothing-splines';
      let normalized;
      try {
        normalized = samples.map((v) => clamp01(Number(v) || 0));
        const reduced = CurveSimplification.applySmoothingReduction(normalized, pct, algo);
        const fn = buildTargetFnFromSamples(reduced);
        const dense = new Array(samples.length);
        const denom = dense.length - 1;
        for (let i = 0; i < dense.length; i++) {
          const t = denom > 0 ? (i / denom) : 0;
          dense[i] = clamp01(fn(t));
        }
        dense[0] = 0;
        dense[dense.length - 1] = 1;
        return dense;
      } catch (e) {
        console.warn('Intent tuning smoothing failed:', e);
        return samples.slice();
      }
    }

    function setTuningStatus(message, isError = false) {
      if (!elements.tuningStatus) return;
      elements.tuningStatus.textContent = message || '';
      elements.tuningStatus.style.color = isError ? '#b91c1c' : '#92400e';
    }

    function applyIntentTuningFromUI() {
      if (!linearizationData || !linearizationApplied) {
        setTuningStatus('Load a global LAB or manual dataset before tuning.', true);
        return;
      }

      const interp = elements.tuningInterpolationSelect ? (elements.tuningInterpolationSelect.value || 'pchip') : 'pchip';
      const smoothingPercent = elements.tuningSmoothingPercent ? Number(elements.tuningSmoothingPercent.value) || 0 : 0;
      const smoothingAlgorithm = elements.tuningSmoothingAlgorithm ? (elements.tuningSmoothingAlgorithm.value || 'smoothing-splines') : 'smoothing-splines';
      const postPasses = elements.tuningPostPasses ? Math.max(0, Number(elements.tuningPostPasses.value) || 0) : 0;
      const postPercent = elements.tuningPostPercent ? Number(elements.tuningPostPercent.value) || 0 : 0;
      const postAlgorithm = elements.tuningPostAlgorithm ? (elements.tuningPostAlgorithm.value || 'smoothing-splines') : 'smoothing-splines';
      const overrides = {
        K_NEIGHBORS: elements.tuningNeighbors ? elements.tuningNeighbors.value : undefined,
        SIGMA_FLOOR: elements.tuningSigmaFloor ? elements.tuningSigmaFloor.value : undefined,
        SIGMA_CEIL: elements.tuningSigmaCeil ? elements.tuningSigmaCeil.value : undefined,
        SIGMA_ALPHA: elements.tuningSigmaAlpha ? elements.tuningSigmaAlpha.value : undefined
      };
      LAB_TUNING.setOverrides(overrides);
      syncIntentTuningInputsFromState();

      if (!tuningRestoreState) {
        tuningRestoreState = {
          linearization: JSON.parse(JSON.stringify(linearizationData)),
          interpolation: elements.curveSmoothingMethod ? elements.curveSmoothingMethod.value : 'pchip',
          labOverrides: LAB_TUNING.exportOverrides(),
          applied: linearizationApplied
        };
        if (elements.tuningRestoreBtn) elements.tuningRestoreBtn.disabled = false;
      }

      const fmt = String(linearizationData?.format || '').toUpperCase();
      let rebuilt = linearizationData;
      try {
        if (fmt.includes('LAB') && Array.isArray(linearizationData.originalData)) {
          rebuilt = buildLabLinearizationFromOriginal(linearizationData.originalData);
          rebuilt.filename = linearizationData.filename || rebuilt.filename || 'LAB tuning';
        } else if (fmt.includes('MANUAL') && Array.isArray(linearizationData.originalData)) {
          rebuilt = buildManualLinearizationFromOriginal(linearizationData.originalData);
          rebuilt.filename = linearizationData.filename || rebuilt.filename || 'Manual tuning';
        } else {
          rebuilt = { ...linearizationData };
        }
      } catch (e) {
        console.warn('Intent tuning rebuild failed:', e);
        setTuningStatus('Failed to rebuild base curve.', true);
        return;
      }

      rebuilt = normalizeLinearizationEntry(rebuilt);
      let samples = rebuilt.samples ? rebuilt.samples.slice() : [];

      samples = applySmoothingSequence(samples, smoothingPercent, smoothingAlgorithm);
      if (postPasses > 0 && postPercent > 0) {
        for (let i = 0; i < postPasses; i++) {
          samples = applySmoothingSequence(samples, postPercent, postAlgorithm);
        }
      }

      rebuilt.samples = samples;
      rebuilt.interpolationType = interp;
      linearizationData = rebuilt;
      linearizationApplied = true;

      if (elements.curveSmoothingMethod) elements.curveSmoothingMethod.value = interp;
      if (typeof updatePreview === 'function') updatePreview();
      if (typeof updateInkChart === 'function') updateInkChart();
      updateRevertButtonsState();
      setTuningStatus(`Applied ${interp} with ${smoothingPercent}% smoothing${postPasses > 0 ? ` + ${postPasses}×${postPercent}%` : ''}.`);
    }

    function restoreIntentTuning() {
      if (!tuningRestoreState) return;
      LAB_TUNING.setOverrides(tuningRestoreState.labOverrides);
      syncIntentTuningInputsFromState();
      linearizationData = normalizeLinearizationEntry(tuningRestoreState.linearization);
      linearizationApplied = tuningRestoreState.applied;
      if (elements.curveSmoothingMethod && tuningRestoreState.interpolation) {
        elements.curveSmoothingMethod.value = tuningRestoreState.interpolation;
      }
      if (typeof updatePreview === 'function') updatePreview();
      if (typeof updateInkChart === 'function') updateInkChart();
      updateRevertButtonsState();
      tuningRestoreState = null;
      if (elements.tuningRestoreBtn) elements.tuningRestoreBtn.disabled = true;
      setTuningStatus('Restored original tuning.');
    }

    // Get selected simplification method
    function getSelectedSimplificationMethod() {
      return elements.simplificationMethod ? (elements.simplificationMethod.value || 'smoothing-splines') : 'smoothing-splines';
    }
    
    // Per-channel linearization storage
    let perChannelLinearization = {};
    let perChannelEnabled = {};
    let perChannelFilenames = {};
    
    // Channel previous values storage (for restore after enable)
    let channelPreviousValues = {};

    // Curve history system for undo functionality
    const CurveHistory = {
      history: [], // Unified timeline of actions and snapshots
      redoStack: [],
      maxHistorySize: 20, // Keep last 20 actions
      isRestoring: false, // Flag to prevent state capture during restore
      isBatchOperation: false, // Flag to prevent individual recording during batch operations
      _pendingKeyPoints: {}, // Pending key-point extras keyed by channel
      
      _pushHistoryEntry(entry) {
        if (this.isRestoring) return;
        this.history.push(entry);
        this.redoStack = [];
        if (this.history.length > this.maxHistorySize) {
          this.history.shift();
        }
      },

      _pushRedoEntry(entry) {
        this.redoStack.push(entry);
        if (this.redoStack.length > this.maxHistorySize) {
          this.redoStack.shift();
        }
      },

      // Record pending key point change for the next curve action on this channel
      recordKeyPointsChange(channelName, oldKeyPoints, newKeyPoints, oldInterpolation, newInterpolation) {
        try {
          this._pendingKeyPoints[channelName] = {
            oldKeyPoints: Array.isArray(oldKeyPoints) ? oldKeyPoints.map(p => ({ input: p.input, output: p.output })) : undefined,
            newKeyPoints: Array.isArray(newKeyPoints) ? newKeyPoints.map(p => ({ input: p.input, output: p.output })) : undefined,
            oldInterpolation,
            newInterpolation
          };
        } catch (e) {
          console.warn('recordKeyPointsChange failed:', e);
        }
      },
      
      /**
       * Record individual channel action
       */
      recordChannelAction(channelName, actionType, oldValue, newValue, extras = null) {
        // Don't record actions during restore operations
        if (this.isRestoring) {
          return;
        }
        
        const action = {
          timestamp: Date.now(),
          type: actionType, // 'enable', 'disable', 'percentage', 'end'
          channelName: channelName,
          oldValue: oldValue,
          newValue: newValue,
          description: `${actionType} ${channelName}: ${oldValue} → ${newValue}`
        };
        if (extras && typeof extras === 'object') {
          Object.assign(action, extras);
        }

        // Create concise, user-friendly descriptions
        if (actionType === 'curve') {
          const kpCount = Array.isArray(action.newKeyPoints) ? action.newKeyPoints.length : undefined;
          const interp = action.newInterpolation || action.oldInterpolation || undefined;
          const parts = [`curve ${channelName}`];
          if (kpCount !== undefined) parts.push(`(${kpCount} key points${interp ? `, ${interp}` : ''})`);
          else if (Array.isArray(newValue)) parts.push(`(${newValue.length} pts)`);
          action.description = parts.join(' ');
        } else {
          // Avoid dumping large arrays/objects in tooltip for other actions
          const summarize = (v) => {
            if (Array.isArray(v)) return `${v.length} items`;
            if (v && typeof v === 'object') return 'updated';
            return String(v);
          };
          action.description = `${actionType} ${channelName}: ${summarize(oldValue)} → ${summarize(newValue)}`;
        }
        
        
        this._pushHistoryEntry({ kind: 'channel', action });
        
        // Update button states
        this.updateUndoButton();
        this.updateRedoButton();
        
      },

      /**
       * Record a UI-level action (non-channel), e.g., toggling Edit Mode
       * @param {string} uiType - e.g., 'editMode'
       * @param {any} oldValue
       * @param {any} newValue
       * @param {string} description - human-friendly description
       */
      recordUIAction(uiType, oldValue, newValue, description) {
        if (this.isRestoring) return;
        const action = {
          timestamp: Date.now(),
          type: 'ui',
          uiType,
          oldValue,
          newValue,
          description: description || `${uiType}: ${String(oldValue)} → ${String(newValue)}`
        };
        this._pushHistoryEntry({ kind: 'channel', action });
        this.updateUndoButton();
        this.updateRedoButton();
      },

      /**
       * Record batch action (multiple channels affected by single command)
       */
      recordBatchAction(description, channelActions) {
        // Don't record actions during restore operations
        if (this.isRestoring) {
          return;
        }
        
        const batchAction = {
          timestamp: Date.now(),
          type: 'batch',
          description: description,
          channelActions: channelActions // Array of individual channel actions
        };
        
        this._pushHistoryEntry({ kind: 'channel', action: batchAction });
        
        this.updateUndoButton();
        this.updateRedoButton();
      },

      /**
       * Legacy method for non-channel actions (curve modifications, etc.)
       */
      captureState(actionDescription = 'Curve modification') {
        // Don't capture state during restore operations
        if (this.isRestoring) {
          return;
        }
        const state = {
          timestamp: Date.now(),
          action: actionDescription,
          channels: {}
        };
        
        // Capture current state of all visible channels
        Array.from(elements.rows.children).forEach(tr => {
          // Skip the placeholder row
          if (tr.id === 'noChannelsRow') return;
          
          const channelName = tr.dataset.channel;
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          const checkbox = tr._virtualCheckbox;
          
          state.channels[channelName] = {
            percentage: parseFloat(percentInput.value) || 0,
            endValue: parseFloat(endInput.value) || 0,
            enabled: checkbox.checked,
            // Capture any loaded curve data for this channel
            curveData: window.loadedQuadData?.curves?.[channelName] ? [...window.loadedQuadData.curves[channelName]] : null
          };
        });
        
        // Capture global linearization state
        state.globalLinearization = {
          enabled: elements.globalLinearizationToggle?.checked || false,
          filename: elements.globalLinearizationFilename?.textContent || '',
          data: linearizationData ? LinearizationState.serializeEntry(linearizationData) : null,
          applied: linearizationApplied
        };
        
        // Capture per-channel linearization state
        state.perChannelLinearization = LinearizationState.serializeMap(perChannelLinearization);
        state.perChannelEnabled = JSON.parse(JSON.stringify(perChannelEnabled));
        
        // Add to legacy history (remove oldest if at max size)
        this._pushHistoryEntry({ kind: 'snapshot', state, action: actionDescription });
        this.updateUndoButton();
        this.updateRedoButton();
        
      },
      
      /**
       * Undo the last action (either individual channel or legacy global action)
       */
      undo() {
        // Check if we have any actions to undo
        if (this.history.length === 0) {
          return { success: false, message: 'No actions to undo' };
        }
        
        try {
          const entry = this.history.pop();
          let message;

          if (entry.kind === 'channel') {
            const action = entry.action;
      if (DEBUG_LOGS) console.log('🔥 UNDO: Processing channel action:', action);
            this.undoSingleAction(action);
            this._pushRedoEntry({ kind: 'channel', action });
            message = `Undid: ${action.description}`;
          } else if (entry.kind === 'snapshot') {
            const label = entry.action || 'Snapshot';
            let restoreStateObj = entry.state;
            let redoPayload = { kind: 'snapshot', entry };
            if (typeof label === 'string' && label.startsWith('After:')) {
              const beforeLabel = label.replace('After:', 'Before:');
              let beforeIndex = -1;
              for (let i = this.history.length - 1; i >= 0; i--) {
                const candidate = this.history[i];
                if (candidate.kind === 'snapshot' && candidate.action === beforeLabel) {
                  beforeIndex = i;
                  break;
                }
              }
              if (beforeIndex !== -1) {
                const beforeEntry = this.history.splice(beforeIndex, 1)[0];
                restoreStateObj = beforeEntry.state;
                redoPayload = { kind: 'snapshot_pair', before: beforeEntry, after: entry };
              }
            }
            this.restoreState(restoreStateObj);
            this._pushRedoEntry(redoPayload);
            message = `Undid: ${label}`;
          }

          try { normalizeSmartSourcesInLoadedData(); } catch {}
          this.updateUndoButton();
          this.updateRedoButton();
          
          return { success: true, message };
          
        } catch (error) {
          console.error('❌ Error during undo:', error);
          return { success: false, message: `Undo failed: ${error.message}` };
        }
      },

      /**
       * Undo a single action by reversing it
       */
      undoSingleAction(action) {
        this.isRestoring = true;

        // Handle UI actions (no channel row)
        if (action.type === 'ui') {
          try {
            if (action.uiType === 'editMode') {
              if (typeof setEditMode === 'function') setEditMode(!!action.oldValue, { recordHistory: false });
            } else if (action.uiType === 'intent') {
              const snap = action.oldValue || null;
              if (snap && snap.id) {
                if (snap.id === 'custom_points' && typeof snap.targetFn === 'function') {
                  setContrastIntent('custom_points', { name: snap.name || 'Custom (points)', targetFn: snap.targetFn }, snap.source || 'custom');
                } else if (snap.id === 'custom_gamma') {
                  setContrastIntent('custom_gamma', { gamma: snap.params?.gamma ?? 1.0 }, 'custom');
                } else if (snap.id === 'custom_filmic') {
                  const gain = snap.params?.gain ?? snap.params?.filmicGain ?? 0.55;
                  const shoulder = snap.params?.shoulder ?? 0.35;
                  setContrastIntent('custom_filmic', { gain, shoulder }, 'custom');
                } else {
                  setContrastIntent(snap.id, snap.params || {}, (snap.id==='linear'||snap.id==='soft'||snap.id==='hard'||snap.id==='filmic')?'preset':'custom');
                }
              }
            }
          } finally {
            this.isRestoring = false;
          }
          return;
        }
        
        // Handle batch actions differently - they don't have a single channelName
        if (action.type === 'batch') {
          // Reverse batch: undo all channel actions in reverse order
          for (let i = action.channelActions.length - 1; i >= 0; i--) {
            const channelAction = action.channelActions[i];
            const channelTr = getChannelRow(channelAction.channelName);
            if (channelTr) {
              this.undoIndividualAction(channelTr, channelAction);
            }
          }
          
          // Update compact channels list and graphs
          setTimeout(() => updateCompactChannelsList(), 50);
          debouncedPreviewUpdate();
          // Refresh processing panels for affected channels
          action.channelActions.forEach(a => {
            if (typeof updateProcessingDetail === 'function') updateProcessingDetail(a.channelName);
          });
          
          this.isRestoring = false;
          return;
        }
        
        // Handle individual channel actions
        const tr = getChannelRow(action.channelName);
        if (!tr) {
          console.error(`Channel row for ${action.channelName} not found`);
          return;
        }
        
        switch (action.type) {
          case 'enable':
            // Reverse: disable the channel (same logic as handleCheckboxChange)
            const checkbox = tr._virtualCheckbox;
            const percentInput = tr.querySelector('.percent-input');
            const endInput = tr.querySelector('.end-input');
            
            if (checkbox) {
              checkbox.checked = false;
              
              // Store current values and set to 0 (same as normal disable logic)
              const currentPercentVal = InputValidator.clampPercent(percentInput.value);
              const currentEndVal = InputValidator.clampEnd(endInput.value);
              
              channelPreviousValues[action.channelName] = {
                percent: currentPercentVal,
                endValue: currentEndVal
              };
              
              percentInput.value = '0';
              endInput.value = '0';
              tr.setAttribute('data-user-disabled', 'true');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'disable':
            // Reverse: enable the channel (same logic as handleCheckboxChange)
            const enableCheckbox = tr._virtualCheckbox;
            const enablePercentInput = tr.querySelector('.percent-input');
            const enableEndInput = tr.querySelector('.end-input');
            
            if (enableCheckbox) {
              enableCheckbox.checked = true;
              
              // Restore previous values or default to 100% (same as normal enable logic)
              const previousValues = channelPreviousValues[action.channelName];
              
              if (previousValues && previousValues.percent > 0) {
                // Restore previous values
                enablePercentInput.value = previousValues.percent.toString();
                enableEndInput.value = previousValues.endValue.toString();
              } else {
                // Default to 100% if no previous value stored
                enablePercentInput.value = '100';
                enableEndInput.value = String(InputValidator.computeEndFromPercent(100));
              }
              
              tr.removeAttribute('data-user-disabled');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'percentage':
            // Reverse: restore old percentage value
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              rescaleSmartCurveForInkLimit(action.channelName, Number(action.newValue), Number(action.oldValue));
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            // Reverse: restore old end value
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              rescaleSmartCurveForInkLimit(action.channelName, InputValidator.computePercentFromEnd(Number(action.newValue)), InputValidator.computePercentFromEnd(Number(action.oldValue)));
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Reverse: restore old curve data
            if (action.oldValue === null) {
              // Remove curve data if it didn't exist before
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              // Also remove any stored AI key points/meta
              if (window.loadedQuadData?.keyPoints?.[action.channelName]) {
                delete window.loadedQuadData.keyPoints[action.channelName];
              }
              if (window.loadedQuadData?.keyPointsMeta?.[action.channelName]) {
                delete window.loadedQuadData.keyPointsMeta[action.channelName];
              }
              // Clear AI source tag since curve removed
              if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
            } else {
              // Restore old curve data
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[action.channelName] = [...action.oldValue];

              // Restore old AI key points/meta if provided
              if (action.oldKeyPoints && Array.isArray(action.oldKeyPoints)) {
                if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                window.loadedQuadData.keyPoints[action.channelName] = action.oldKeyPoints.map(p => ({ input: p.input, output: p.output }));
              }
              if (action.oldInterpolation) {
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                // Restore interpolation and bakedGlobal meta if present to avoid double-application
                const __meta = { interpolationType: action.oldInterpolation };
                if (typeof action.oldBakedGlobal !== 'undefined') __meta.bakedGlobal = !!action.oldBakedGlobal;
                window.loadedQuadData.keyPointsMeta[action.channelName] = __meta;
              }
              // Restore previous source tag if available; otherwise clear AI tag
              if (action.oldSource !== undefined) {
                if (!window.loadedQuadData.sources) window.loadedQuadData.sources = {};
                if (action.oldSource === null) delete window.loadedQuadData.sources[action.channelName];
                else window.loadedQuadData.sources[action.channelName] = action.oldSource;
              } else if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
              
              // Disable per-channel linearization when restoring Smart Curve (keep metadata for UI display)
          if (perChannelLinearization[action.channelName]) {
            perChannelEnabled[action.channelName] = false;
            try { updateRevertButtonsState(); } catch {}
          }
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }
            }
            break;
        }
        
        // Update compact channels list and graphs
        setTimeout(() => updateCompactChannelsList(), 50);
        debouncedPreviewUpdate();
        // Refresh processing panel for this channel
        if (typeof updateProcessingDetail === 'function') updateProcessingDetail(action.channelName);
        
        this.isRestoring = false;
      },

      /**
       * Helper method to undo individual action (used by both single and batch undo)
       */
      undoIndividualAction(tr, action) {
        if (DEBUG_LOGS) console.log(`🔙 Undoing individual action:`, action);
        switch (action.type) {
          case 'enable':
            // Reverse: restore old enabled state
            const checkbox = tr._virtualCheckbox;
            if (checkbox) {
              checkbox.checked = action.oldValue;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
            break;
            
          case 'percentage':
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Reverse: restore old curve data
            if (action.oldValue === null) {
              // Remove curve data if it didn't exist before
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              // Also remove any stored AI key points/meta
              if (window.loadedQuadData?.keyPoints?.[action.channelName]) {
                delete window.loadedQuadData.keyPoints[action.channelName];
              }
              if (window.loadedQuadData?.keyPointsMeta?.[action.channelName]) {
                delete window.loadedQuadData.keyPointsMeta[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
            } else {
              // Restore old curve data
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[action.channelName] = [...action.oldValue];
              
              // Disable per-channel linearization when restoring Smart Curve (keep metadata for UI display)
          if (perChannelLinearization[action.channelName]) {
            perChannelEnabled[action.channelName] = false;
            try { updateRevertButtonsState(); } catch {}
          }
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }

              // Restore old AI key points/meta if provided
              if (action.oldKeyPoints && Array.isArray(action.oldKeyPoints)) {
                if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                window.loadedQuadData.keyPoints[action.channelName] = action.oldKeyPoints.map(p => ({ input: p.input, output: p.output }));
              }
              if (action.oldInterpolation) {
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                // Restore interpolation and bakedGlobal meta if present to avoid double-application
                const __meta = { interpolationType: action.oldInterpolation };
                if (typeof action.oldBakedGlobal !== 'undefined') __meta.bakedGlobal = !!action.oldBakedGlobal;
                window.loadedQuadData.keyPointsMeta[action.channelName] = __meta;
              }
              // Restore previous source tag if available; otherwise clear AI tag
              if (action.oldSource !== undefined) {
                if (!window.loadedQuadData.sources) window.loadedQuadData.sources = {};
                if (action.oldSource === null) delete window.loadedQuadData.sources[action.channelName];
                else window.loadedQuadData.sources[action.channelName] = action.oldSource;
              } else if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
            }
            
            // CRITICAL: Update graph display for curve changes
            if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            break;
        }
      },
      
      /**
       * Helper method to redo individual action (used by both single and batch redo)
       */
      redoIndividualAction(tr, action) {
        switch (action.type) {
          case 'enable':
            // Re-apply: restore new enabled state
            const checkbox = tr._virtualCheckbox;
            if (checkbox) {
              checkbox.checked = action.newValue;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
            break;
            
          case 'percentage':
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              rescaleSmartCurveForInkLimit(action.channelName, Number(action.oldValue), Number(action.newValue));
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              rescaleSmartCurveForInkLimit(action.channelName, InputValidator.computePercentFromEnd(Number(action.oldValue)), InputValidator.computePercentFromEnd(Number(action.newValue)));
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Re-apply: restore new curve data
            if (action.newValue === null) {
              // Remove curve data
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
              // Clear source tag when removing curve
              if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
            } else {
              // Prefer recomputing curve from newKeyPoints to guarantee overlay/curve parity
              try {
                if (action.newKeyPoints && Array.isArray(action.newKeyPoints)) {
                  if (!window.loadedQuadData) window.loadedQuadData = {};
                  if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                  if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                  window.loadedQuadData.keyPoints[action.channelName] = action.newKeyPoints.map(p => ({ input: p.input, output: p.output }));
                  if (action.newInterpolation) {
                    // Restore interpolation and bakedGlobal meta on redo to prevent double-application
                    const __meta = { interpolationType: action.newInterpolation };
                    if (typeof action.newBakedGlobal !== 'undefined') __meta.bakedGlobal = !!action.newBakedGlobal;
                    window.loadedQuadData.keyPointsMeta[action.channelName] = __meta;
                  }
                  // Recompute curve from key points and apply via internal path (no history during restore)
                  const interp = (action.newInterpolation === 'linear' ? 'linear' : 'smooth');
                  const computed = quadGenActions._interpolateCurve(action.newKeyPoints, interp);
                  // Ensure curves storage exists
                  if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                  window.loadedQuadData.curves[action.channelName] = [...computed];
                } else {
                  // Fallback: restore provided curve array
                  if (!window.loadedQuadData) window.loadedQuadData = { curves: {} };
                  if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                  window.loadedQuadData.curves[action.channelName] = [...action.newValue];
                }
              } catch (e) {
                console.warn('Redo recompute from key points failed; using stored curve:', e);
                if (!window.loadedQuadData) window.loadedQuadData = { curves: {} };
                if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                window.loadedQuadData.curves[action.channelName] = [...action.newValue];
              }

            if (action.clearKeyPoints) {
              try {
                if (window.loadedQuadData?.keyPoints?.[action.channelName]) delete window.loadedQuadData.keyPoints[action.channelName];
              } catch {}
              try {
                if (window.loadedQuadData?.keyPointsMeta?.[action.channelName]) delete window.loadedQuadData.keyPointsMeta[action.channelName];
              } catch {}
            }
              
              // Disable per-channel linearization when restoring Smart Curve (keep metadata for UI display)
          if (perChannelLinearization[action.channelName]) {
            perChannelEnabled[action.channelName] = false;
            try { updateRevertButtonsState(); } catch {}
          }
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }
              // Apply new source if provided (usually 'smart')
              if (action.newSource !== undefined) {
                if (!window.loadedQuadData.sources) window.loadedQuadData.sources = {};
                if (action.newSource === null) delete window.loadedQuadData.sources[action.channelName];
                else window.loadedQuadData.sources[action.channelName] = action.newSource;
              } else if (window.loadedQuadData?.sources?.[action.channelName] !== undefined && action.linearRestore) {
                delete window.loadedQuadData.sources[action.channelName];
              }
            }

            // CRITICAL: Update graph display for curve changes
            if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            break;
        }
      },
      
      /**
       * Redo the next state
       */
      /**
       * Redo the next action (either individual channel or legacy global action)
       */
      redo() {
        if (this.redoStack.length === 0) {
          return { success: false, message: 'No actions to redo' };
        }
        
        try {
          const entry = this.redoStack.pop();
          let message;

          if (entry.kind === 'channel') {
            const action = entry.action;
            this.redoSingleAction(action);
            this.history.push({ kind: 'channel', action });
            message = `Redid: ${action.description}`;
          } else if (entry.kind === 'snapshot') {
            const snap = entry.entry;
            this.restoreState(snap.state);
            this.history.push(snap);
            message = `Redid: ${snap.action || 'Snapshot'}`;
          } else if (entry.kind === 'snapshot_pair') {
            const before = entry.before;
            const after = entry.after;
            // Reapply the pair in order
            this.history.push(before);
            this.restoreState(after.state);
            this.history.push(after);
            message = `Redid: ${after.action || 'Snapshot'}`;
          }

          if (this.history.length > this.maxHistorySize) {
            this.history.shift();
          }

          try { normalizeSmartSourcesInLoadedData(); } catch {}
          this.updateUndoButton();
          this.updateRedoButton();
          
          return { success: true, message };
          
        } catch (error) {
          console.error('❌ Error during redo:', error);
          return { success: false, message: `Redo failed: ${error.message}` };
        }
      },

      /**
       * Redo a single action by re-applying it
       */
      redoSingleAction(action) {
        this.isRestoring = true;

        // Handle UI actions (no channel row)
        if (action.type === 'ui') {
          try {
            if (action.uiType === 'editMode') {
              if (typeof setEditMode === 'function') setEditMode(!!action.newValue, { recordHistory: false });
            } else if (action.uiType === 'intent') {
              const snap = action.newValue || null;
              if (snap && snap.id) {
                if (snap.id === 'custom_points' && typeof snap.targetFn === 'function') {
                  setContrastIntent('custom_points', { name: snap.name || 'Custom (points)', targetFn: snap.targetFn }, snap.source || 'custom');
                } else if (snap.id === 'custom_gamma') {
                  setContrastIntent('custom_gamma', { gamma: snap.params?.gamma ?? 1.0 }, 'custom');
                } else if (snap.id === 'custom_filmic') {
                  const gain = snap.params?.gain ?? snap.params?.filmicGain ?? 0.55;
                  const shoulder = snap.params?.shoulder ?? 0.35;
                  setContrastIntent('custom_filmic', { gain, shoulder }, 'custom');
                } else {
                  setContrastIntent(snap.id, snap.params || {}, (snap.id==='linear'||snap.id==='soft'||snap.id==='hard'||snap.id==='filmic')?'preset':'custom');
                }
              }
            }
          } finally {
            this.isRestoring = false;
          }
          return;
        }

        // Handle batch actions differently - they don't have a single channelName
        if (action.type === 'batch') {
          // Re-apply batch: redo all channel actions in original order
          for (let i = 0; i < action.channelActions.length; i++) {
            const channelAction = action.channelActions[i];
            const channelTr = getChannelRow(channelAction.channelName);
            if (channelTr) {
              this.redoIndividualAction(channelTr, channelAction);
            }
          }
          
          // Update compact channels list and graphs
          setTimeout(() => updateCompactChannelsList(), 50);
          debouncedPreviewUpdate();
          // Refresh processing panels for affected channels
          action.channelActions.forEach(a => {
            if (typeof updateProcessingDetail === 'function') updateProcessingDetail(a.channelName);
          });
          
          this.isRestoring = false;
          return;
        }
        
        // Handle individual channel actions
        const tr = getChannelRow(action.channelName);
        if (!tr) {
          console.error(`Channel row for ${action.channelName} not found`);
          return;
        }
        
        switch (action.type) {
          case 'enable':
            // Re-apply: enable the channel (same logic as handleCheckboxChange)
            const checkbox = tr._virtualCheckbox;
            const enablePercentInput = tr.querySelector('.percent-input');
            const enableEndInput = tr.querySelector('.end-input');
            
            if (checkbox) {
              checkbox.checked = true;
              
              // Restore previous values or default to 100% (same as normal enable logic)
              const previousValues = channelPreviousValues[action.channelName];
              
              if (previousValues && previousValues.percent > 0) {
                // Restore previous values
                enablePercentInput.value = previousValues.percent.toString();
                enableEndInput.value = previousValues.endValue.toString();
              } else {
                // Default to 100% if no previous value stored
                enablePercentInput.value = '100';
                enableEndInput.value = String(InputValidator.computeEndFromPercent(100));
              }
              
              tr.removeAttribute('data-user-disabled');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'disable':
            // Re-apply: disable the channel (same logic as handleCheckboxChange)
            const disableCheckbox = tr._virtualCheckbox;
            const disablePercentInput = tr.querySelector('.percent-input');
            const disableEndInput = tr.querySelector('.end-input');
            
            if (disableCheckbox) {
              disableCheckbox.checked = false;
              
              // Store current values and set to 0 (same as normal disable logic)
              const currentPercentVal = InputValidator.clampPercent(disablePercentInput.value);
              const currentEndVal = InputValidator.clampEnd(disableEndInput.value);
              
              channelPreviousValues[action.channelName] = {
                percent: currentPercentVal,
                endValue: currentEndVal
              };
              
              disablePercentInput.value = '0';
              disableEndInput.value = '0';
              tr.setAttribute('data-user-disabled', 'true');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'percentage':
            // Re-apply: restore new percentage value
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            // Re-apply: restore new end value
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Re-apply: restore new curve data
            if (action.newValue === null) {
              // Remove curve data
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              // Remove AI key points/meta as well
              if (window.loadedQuadData?.keyPoints?.[action.channelName]) {
                delete window.loadedQuadData.keyPoints[action.channelName];
              }
              if (window.loadedQuadData?.keyPointsMeta?.[action.channelName]) {
                delete window.loadedQuadData.keyPointsMeta[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
            } else {
              // Restore new curve data
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[action.channelName] = [...action.newValue];
              
              // Disable per-channel linearization when restoring Smart Curve
          if (perChannelLinearization[action.channelName]) {
            delete perChannelLinearization[action.channelName];
            try { updateRevertButtonsState(); } catch {}
          }
              perChannelEnabled[action.channelName] = false;
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }

              // Restore new AI key points/meta if provided
              if (action.newKeyPoints && Array.isArray(action.newKeyPoints)) {
                if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                window.loadedQuadData.keyPoints[action.channelName] = action.newKeyPoints.map(p => ({ input: p.input, output: p.output }));
              }
              if (action.newInterpolation) {
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                // Restore interpolation and bakedGlobal meta on redo to prevent double-application
                const __meta = { interpolationType: action.newInterpolation };
                if (typeof action.newBakedGlobal !== 'undefined') __meta.bakedGlobal = !!action.newBakedGlobal;
                window.loadedQuadData.keyPointsMeta[action.channelName] = __meta;
              }
            }
            break;
        }
        
        // Update compact channels list and graphs
        setTimeout(() => updateCompactChannelsList(), 50);
        debouncedPreviewUpdate();
        // Refresh processing panel for this channel
        if (typeof updateProcessingDetail === 'function') updateProcessingDetail(action.channelName);
        
        this.isRestoring = false;
      },
      
      /**
       * Restore a specific state
       */
      restoreState(state) {
        // Set flag to prevent capturing state during restore
        this.isRestoring = true;
        
        // Restore channel states
        Object.entries(state.channels).forEach(([channelName, channelState]) => {
          const tr = getChannelRow(channelName);
          if (tr) {
            const percentInput = tr.querySelector('.percent-input');
            const endInput = tr.querySelector('.end-input');
            const checkbox = tr._virtualCheckbox;
            
            if (percentInput) percentInput.value = channelState.percentage;
            if (endInput) endInput.value = channelState.endValue;
            
            // Update checkbox without triggering events
            if (checkbox) {
              checkbox.checked = channelState.enabled;
              
              // Update visual state directly instead of triggering change event
              tr.style.opacity = channelState.enabled ? '1' : '0.5';
              
              // Enable/disable form elements
              const inputs = tr.querySelectorAll('input, select');
              inputs.forEach(input => {
                input.disabled = !channelState.enabled;
              });
            }
            
            // Call refresh function to handle proper visual state transitions (disabled chips <-> enabled rows)
            if (tr.refreshDisplayFn) {
              tr.refreshDisplayFn();
            }
            
            // Restore curve data if available
            if (channelState.curveData) {
              // Ensure loadedQuadData structure exists
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[channelName] = [...channelState.curveData];
            } else {
              // If no curve data in state, remove any existing curve data for this channel
              if (window.loadedQuadData?.curves?.[channelName]) {
                delete window.loadedQuadData.curves[channelName];
              }
            }
            
            // Call the individual channel's refreshDisplay function to handle compact/full display
            const refreshDisplay = tr.refreshDisplayFn;
            if (refreshDisplay) {
              refreshDisplay();
            }
          }
        });
        
        // Update compact channels list after all channels are restored
        setTimeout(() => updateCompactChannelsList(), 50);
        
        // Restore global linearization
        if (state.globalLinearization && state.globalLinearization.data) {
          linearizationData = LinearizationState.rehydrateEntry(state.globalLinearization.data);
          linearizationApplied = !!state.globalLinearization.applied;
          // UI: enable toggle and show info
          if (elements.globalLinearizationToggle) {
            elements.globalLinearizationToggle.disabled = false;
            elements.globalLinearizationToggle.checked = !!state.globalLinearization.enabled;
          }
          const baseName = state.globalLinearization.filename || (linearizationData.filename || '');
          const disp = getEditedDisplayName(baseName, !!linearizationData.edited);
          if (elements.globalLinearizationFilename) elements.globalLinearizationFilename.textContent = disp;
        if (elements.globalLinearizationDetails) elements.globalLinearizationDetails.textContent = ` - ${getBasePointCountLabel(linearizationData)} (${(linearizationData.format||'').toString().split(' ')[0] || ''})`;
        try { updateIntentDetailLabel(); } catch {}
          if (elements.globalLinearizationInfo) elements.globalLinearizationInfo.classList.remove('hidden');
          if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.add('hidden');
          if (elements.globalLinearizationBtn) elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${disp}`);
        } else {
          linearizationData = null;
          linearizationApplied = false;
          // UI: disable toggle and hide info
          if (elements.globalLinearizationToggle) {
            elements.globalLinearizationToggle.disabled = true;
            elements.globalLinearizationToggle.checked = false;
          }
          if (elements.globalLinearizationFilename) elements.globalLinearizationFilename.textContent = '';
          if (elements.globalLinearizationDetails) elements.globalLinearizationDetails.textContent = '';
          if (elements.globalLinearizationInfo) elements.globalLinearizationInfo.classList.add('hidden');
          if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.remove('hidden');
          if (elements.globalLinearizationBtn) elements.globalLinearizationBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
        }
        // Refresh edited display state for global filename (idempotent)
        try { refreshGlobalLinearizationDisplay(); } catch {}
        
        // Restore per-channel linearization (replace rather than merge so undo can remove channels)
        const restoredPerChannel = LinearizationState.rehydrateMap(state.perChannelLinearization);
        const restoredPerEnabled = state.perChannelEnabled && typeof state.perChannelEnabled === 'object'
          ? state.perChannelEnabled
          : {};

        perChannelLinearization = restoredPerChannel;

        perChannelEnabled = {};
        for (const [channelName, enabled] of Object.entries(restoredPerEnabled)) {
          perChannelEnabled[channelName] = !!enabled;
        }

        if (elements.rows) {
          Array.from(elements.rows.children).forEach(tr => {
            if (!tr || tr.id === 'noChannelsRow') return;
            const ch = tr.getAttribute('data-channel');
            if (!ch) return;
            const toggle = tr.querySelector('.per-channel-toggle');
            if (!toggle) return;
            const hasMeasurement = !!perChannelLinearization[ch];
            toggle.disabled = !hasMeasurement;
            toggle.checked = hasMeasurement && !!perChannelEnabled[ch];
          });
        }

        try { updateRevertButtonsState(); } catch {}
        
        // Update UI and preview
        updateInterpolationControls();
        updatePreview();
        // Refresh processing details for all channels since global/per-channel state changed
        try {
          const channelNames = getCurrentPrinter().channels;
          channelNames.forEach((name) => {
            if (typeof updateProcessingDetail === 'function') updateProcessingDetail(name);
          });
        } catch {}
        
        // Clear flag after restore is complete
        this.isRestoring = false;
      },
      
      /**
       * Update undo button state
       */
      updateUndoButton() {
        const undoBtn = document.getElementById('undoBtn');
        if (undoBtn) {
          const canUndo = this.history.length > 0;
          undoBtn.disabled = !canUndo;
          undoBtn.style.opacity = canUndo ? '1' : '0.5';
          
          if (canUndo) {
            const last = this.history[this.history.length - 1];
            let label = 'Action';
            if (last.kind === 'channel' && last.action) {
              label = last.action.description || 'Channel change';
            } else if (last.kind === 'snapshot') {
              label = last.action || 'Snapshot';
            }
            undoBtn.title = `Undo: ${label}`;
          } else {
            undoBtn.title = 'No actions to undo';
          }
        }
      },

      /**
       * Update redo button state
       */
      updateRedoButton() {
        const redoBtn = document.getElementById('redoBtn');
        if (redoBtn) {
          redoBtn.disabled = this.redoStack.length === 0;
          
          if (this.redoStack.length > 0) {
            const next = this.redoStack[this.redoStack.length - 1];
            let label = 'Action';
            if (next.kind === 'channel') {
              label = next.action.description || 'Channel change';
            } else if (next.kind === 'snapshot') {
              label = next.entry.action || 'Snapshot';
            } else if (next.kind === 'snapshot_pair') {
              label = next.after.action || 'Snapshot';
            }
            redoBtn.title = `Redo: ${label}`;
          } else {
            redoBtn.title = 'No actions to redo';
          }
        }
      },
      
      /**
       * Get history summary for AI
       */
      getHistorySummary() {
        return {
          totalStates: this.history.length,
          canUndo: this.history.length > 0,
          canRedo: this.redoStack.length > 0,
          recentActions: this.history.slice(-5).map(entry => {
            if (entry.kind === 'channel') {
              return {
                action: entry.action.description,
                timestamp: entry.action.timestamp ? new Date(entry.action.timestamp).toLocaleTimeString() : undefined
              };
            }
            return {
              action: entry.action,
              timestamp: entry.state?.timestamp ? new Date(entry.state.timestamp).toLocaleTimeString() : undefined
            };
          })
        };
      },
      
      /**
       * Clear history
       */
      clear() {
        this.history = [];
        this.redoStack = [];
        this.updateUndoButton();
        this.updateRedoButton();
      }
    };

    const DataSpace = {
      SPACE: {
        IMAGE: 'image',
        PRINTER: 'printer'
      },

      normalizeSpace(space) {
        if (!space) return null;
        const lowered = String(space).toLowerCase();
        if (lowered === 'printer' || lowered === 'printerspace') return this.SPACE.PRINTER;
        if (lowered === 'image' || lowered === 'imagespace') return this.SPACE.IMAGE;
        return null;
      },

      isPrinterSpace(space) {
        if (space == null) return true; // Legacy data without metadata defaults to printer space
        return this.normalizeSpace(space) === this.SPACE.PRINTER;
      },

      /**
       * Convert normalized samples between coordinate spaces.
       * @param {number[]} samples - array of floats
       * @param {Object} options
       * @param {string} options.from - Source space ('image' or 'printer')
       * @param {string} [options.to='printer'] - Target space
       * @param {Object} [options.metadata] - Existing metadata to extend
       * @returns {{ values:number[], sourceSpace:string, meta:Object }}
       */
      convertSamples(samples, { from, to = 'printer', metadata = {} } = {}) {
        const normalizedFrom = this.normalizeSpace(from);
        const src = (normalizedFrom === null) ? this.SPACE.PRINTER : normalizedFrom;
        const dst = this.normalizeSpace(to) || this.SPACE.PRINTER;
        const input = Array.isArray(samples) ? samples : [];

        if (!input.length || src === dst) {
          return {
            values: input.slice(),
            sourceSpace: dst,
            meta: { ...metadata, sourceSpace: dst }
          };
        }

        let converted = input.slice();

        if (src === this.SPACE.IMAGE && dst === this.SPACE.PRINTER) {
          converted = input.slice().reverse().map(v => 1 - v);
        } else if (src === this.SPACE.PRINTER && dst === this.SPACE.IMAGE) {
          converted = input.map(v => 1 - v).reverse();
        }

        return {
          values: converted,
          sourceSpace: dst,
          meta: {
            ...metadata,
            fromSpace: src,
            sourceSpace: dst,
            convertedAt: Date.now()
          }
        };
      },

      /**
       * Convert control points where inputs/outputs are expressed in [0..scale].
       * @param {Array<{input:number, output:number}>} points
       * @param {Object} options
       * @param {string} options.from - Source space
       * @param {string} [options.to='printer'] - Target space
       * @param {number} [options.scale=100] - Scale applied to both axes for output
       * @param {number} [options.inputScale=1] - Scale of incoming input values
       * @param {number} [options.outputScale=1] - Scale of incoming output values
       * @returns {Array<{input:number, output:number}>}
       */
      convertControlPoints(points, { from, to = 'printer', scale = 100, inputScale = 1, outputScale = 1 } = {}) {
        if (!Array.isArray(points) || !points.length) return [];
        const normalizedFrom = this.normalizeSpace(from);
        const src = (normalizedFrom === null) ? this.SPACE.PRINTER : normalizedFrom;
        const dst = this.normalizeSpace(to) || this.SPACE.PRINTER;
        const targetScale = Number(scale) || 100;

        const normalize = (value, denom) => Math.max(0, Math.min(1, Number(value) / (denom || 1)));

        const normalizedPoints = points.map(p => ({
          input: normalize(p.input, inputScale),
          output: normalize(p.output, outputScale)
        }));

        if (src === dst) {
          return normalizedPoints.map(p => ({
            input: p.input * targetScale,
            output: p.output * targetScale
          }));
        }

        if (src === this.SPACE.IMAGE && dst === this.SPACE.PRINTER) {
          return normalizedPoints.map(p => ({
            input: (1 - p.input) * targetScale,
            output: (1 - p.output) * targetScale
          })).sort((a, b) => a.input - b.input);
        }

        if (src === this.SPACE.PRINTER && dst === this.SPACE.IMAGE) {
          return normalizedPoints.map(p => ({
            input: (1 - p.input) * targetScale,
            output: (1 - p.output) * targetScale
          })).sort((a, b) => a.input - b.input);
        }

        return normalizedPoints.map(p => ({ input: p.input * targetScale, output: p.output * targetScale }));
      }
    };

    function normalizeLinearizationEntry(entry, fallbackSpace = DataSpace.SPACE.PRINTER) {
      if (!entry || typeof entry !== 'object') return entry;
      if (!entry.sourceSpace) entry.sourceSpace = fallbackSpace;
      return entry;
    }

    const channelRowCache = new Map();

    function getChannelRow(channelName) {
      if (!channelName) return null;
      const cached = channelRowCache.get(channelName);
      if (cached && cached.isConnected) return cached;
      const found = document.querySelector(`tr[data-channel="${channelName}"]`);
      if (found) channelRowCache.set(channelName, found);
      return found;
    }

    function registerChannelRow(channelName, tr) {
      if (!channelName || !tr) return;
      channelRowCache.set(channelName, tr);
    }

    function cloneWithoutFunctions(value) {
      if (Array.isArray(value)) {
        return value.map(cloneWithoutFunctions);
      }
      if (value && typeof value === 'object') {
        const out = {};
        Object.keys(value).forEach(key => {
          const v = value[key];
          if (typeof v === 'function') return;
          out[key] = cloneWithoutFunctions(v);
        });
        return out;
      }
      return value;
    }

    function applyLinearizationExtras(target, source) {
      if (!target || !source) return target;
      const copyKeys = ['filename', 'edited', 'conversionMeta', 'sourceSpace', 'format', 'originalSamples', 'controlPointsTransformed', 'lutSize', 'domainMin', 'domainMax', 'is3DLUT', 'neutralAxisSamples'];
      copyKeys.forEach(key => {
        if (source[key] !== undefined) {
          target[key] = cloneWithoutFunctions(source[key]);
        }
      });
      if (Array.isArray(source.samples)) {
        target.samples = source.samples.slice();
      }
      if (Array.isArray(source.originalData)) {
        target.originalData = cloneWithoutFunctions(source.originalData);
      }
      if (source.conversionMeta) {
        target.conversionMeta = cloneWithoutFunctions(source.conversionMeta);
      }
      if (source.sourceSpace && !target.sourceSpace) {
        target.sourceSpace = source.sourceSpace;
      }
      if (source.edited !== undefined) {
        target.edited = !!source.edited;
      }
      return target;
    }

    const LinearizationState = {
      serializeEntry(entry) {
        if (!entry) return null;
        const serialized = cloneWithoutFunctions(entry);
        const format = (entry.format || '').toUpperCase();
        if (typeof entry.getSmoothingControlPoints === 'function') {
          if (format.includes('LAB')) serialized.__linearizationType = 'LAB';
          else if (format.includes('MANUAL')) serialized.__linearizationType = 'MANUAL';
          else serialized.__linearizationType = 'WITH_HELPER';
        }
        return serialized;
      },
      serializeMap(map) {
        const out = {};
        Object.entries(map || {}).forEach(([channel, entry]) => {
          out[channel] = this.serializeEntry(entry);
        });
        return out;
      },
      rehydrateEntry(entry) {
        if (!entry) return null;
        const type = entry.__linearizationType || '';
        let rebuilt = null;
        if (type === 'LAB' && Array.isArray(entry.originalData)) {
          try {
            rebuilt = buildLabLinearizationFromOriginal(entry.originalData);
          } catch (e) {
            console.warn('rehydrate LAB linearization failed; falling back to stored data', e);
          }
        } else if (type === 'MANUAL' && Array.isArray(entry.originalData)) {
          try {
            rebuilt = buildManualLinearizationFromOriginal(entry.originalData);
          } catch (e) {
            console.warn('rehydrate Manual L* linearization failed; falling back to stored data', e);
          }
        }
        if (!rebuilt) {
          rebuilt = cloneWithoutFunctions(entry);
        }
        rebuilt = normalizeLinearizationEntry(rebuilt);
        delete rebuilt.__linearizationType;
        const extras = cloneWithoutFunctions(entry);
        delete extras.__linearizationType;
        return applyLinearizationExtras(rebuilt, extras);
      },
      rehydrateMap(serializedMap) {
        const out = {};
        Object.entries(serializedMap || {}).forEach(([channel, entry]) => {
          out[channel] = this.rehydrateEntry(entry);
        });
        return out;
      }
    };

    /**
     * Parse a .cube file string as a 1D LUT or route to 3D LUT parser.
     * Returns { domainMin, domainMax, samples } where samples are floats (usually 0..1).
     */
    function transformSamplesToPrinterSpace(samples) {
      return DataSpace.convertSamples(samples, { from: DataSpace.SPACE.IMAGE, to: DataSpace.SPACE.PRINTER }).values;
    }

    function getPrinterSpaceSamples(data) {
      if (!data || !Array.isArray(data.samples)) return null;
      const src = DataSpace.normalizeSpace(data.sourceSpace) || DataSpace.SPACE.PRINTER;
      if (src === DataSpace.SPACE.PRINTER) return data.samples.slice();
      return DataSpace.convertSamples(data.samples, { from: src, to: DataSpace.SPACE.PRINTER }).values;
    }

    function ensurePrinterSpaceData(data) {
      if (!data || DataSpace.isPrinterSpace(data.sourceSpace) || !Array.isArray(data.samples)) return data;
      const converted = DataSpace.convertSamples(data.samples, { from: data.sourceSpace, to: DataSpace.SPACE.PRINTER, metadata: data.conversionMeta });
      return {
        ...data,
        samples: converted.values,
        sourceSpace: converted.sourceSpace,
        conversionMeta: converted.meta
      };
    }
    function parseCube1D(cubeText) {
      const lines = cubeText.split(/\r?\n/);
      let domainMin = 0.0;
      let domainMax = 1.0;
      let declaredSize = null;
      const samples = [];

      // Check for 3D LUT indicators early - route to appropriate parser
      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;
        
        // Detect 3D LUT file format and route to 3D parser
        if (/^LUT_3D_SIZE/i.test(s)) {
          return parseCube3D(cubeText);
        }
      }

      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;

        if (/^LUT_1D_SIZE/i.test(s)) {
          const m = s.match(/LUT_1D_SIZE\s+(\d+)/i);
          if (m) declaredSize = parseInt(m[1], 10);
          continue;
        }
        if (/^DOMAIN_MIN/i.test(s)) {
          // 1 or 3 numbers; for 1D we take the first
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMin = parseFloat(parts[1]);
          continue;
        }
        if (/^DOMAIN_MAX/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMax = parseFloat(parts[1]);
          continue;
        }

        // Numeric row: could be 1–3 floats. For LUTs, many files still list RGB triplets.
        const nums = s.split(/\s+/).map(Number);
        if (nums.every((v) => Number.isFinite(v)) && nums.length >= 1 && nums.length <= 3) {
          samples.push(nums[0]); // take the first channel for 1D
        }
      }

      // After parsing, check if this looks like 3D LUT data
      if (samples.length > 100) {
        // LUTs with very high point counts may indicate parsing issues
        throw new Error("This file contains an unusually high number of data points. Please verify the file format and try again.");
      }

      if (declaredSize !== null && samples.length >= declaredSize) {
        samples.length = declaredSize;
      }
      if (!Number.isFinite(domainMin) || !Number.isFinite(domainMax) || domainMin === domainMax) {
        domainMin = 0.0; domainMax = 1.0;
      }
      if (!samples.length) {
        throw new Error("No 1D samples found in .cube text.");
      }

      // Normalize orientation once here via DataSpace helper; do not reapply later
      const converted = DataSpace.convertSamples(samples, { from: DataSpace.SPACE.IMAGE, to: DataSpace.SPACE.PRINTER });
      return {
        domainMin,
        domainMax,
        samples: converted.values,
        originalSamples: samples,
        format: '1DLUT',
        sourceSpace: converted.sourceSpace,
        conversionMeta: converted.meta
      };
    }

    // Centralized policy for control point operations
    const ControlPolicy = {
      minGap: 0.01,
      yMin: 0,
      yMax: 100,
      defaultTolerance: 1.0,
      endpointsLocked: true,
      clampY(y) { return Math.max(this.yMin, Math.min(this.yMax, y)); },
      clampX(x) { return Math.max(0, Math.min(100, x)); }
    };

    // Facade for control point operations (AI set)
    const ControlPoints = {
      // Get current AI control points and interpolation for channel
      get(channelName) {
        const pts = window.loadedQuadData?.keyPoints?.[channelName] || null;
        const interpolation = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth';
        return { points: pts ? pts.map(p => ({ input: p.input, output: p.output })) : null, interpolation };
      },
      // Normalize: clamp, sort by X, and enforce min gap
      normalize(points) {
        if (!Array.isArray(points)) return [];
        const clamped = points.map(p => ({
          input: ControlPolicy.clampX(Number(p.input)),
          output: ControlPolicy.clampY(Number(p.output))
        }));
        clamped.sort((a, b) => a.input - b.input);
        for (let i = 1; i < clamped.length; i++) {
          if (clamped[i].input <= clamped[i - 1].input) {
            clamped[i].input = Math.min(100, clamped[i - 1].input + ControlPolicy.minGap);
          }
        }
        return clamped;
      },
      // Persist to global storage
      persist(channelName, points, interpolation = 'smooth') {
        if (!window.loadedQuadData) window.loadedQuadData = {};
        if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
        if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
        window.loadedQuadData.keyPoints[channelName] = points.map(p => ({ input: p.input, output: p.output }));
        // Preserve existing metadata (e.g., bakedGlobal) and update interpolation only
        const prevMeta = window.loadedQuadData.keyPointsMeta[channelName] || {};
        window.loadedQuadData.keyPointsMeta[channelName] = {
          ...prevMeta,
          interpolationType: (interpolation === 'linear' ? 'linear' : 'smooth')
        };
      },
      // Sample Y at X using current points and interpolation
      sampleY(points, interpolation, x) {
        const xs = points.map(p => p.input);
        const ys = points.map(p => p.output);
        const xi = ControlPolicy.clampX(x);
        if (interpolation === 'linear') {
          if (xi <= xs[0]) return ys[0];
          if (xi >= xs[xs.length - 1]) return ys[ys.length - 1];
          let i = 0; while (i < xs.length - 1 && xs[i + 1] < xi) i++;
          const x0 = xs[i], x1 = xs[i + 1];
          const y0 = ys[i], y1 = ys[i + 1];
          const t = (xi - x0) / (x1 - x0);
          return y0 + t * (y1 - y0);
        } else {
          // PCHIP via createPCHIPSpline requires monotonic xs
          const pchip = createPCHIPSpline(xs, ys);
          return pchip(xi);
        }
      },
      // Find nearest index to x within tolerance
      nearestIndex(points, x, tolerance = ControlPolicy.defaultTolerance) {
        const xi = ControlPolicy.clampX(x);
        let best = { index: -1, delta: Infinity, input: 0 };
        points.forEach((p, i) => {
          const d = Math.abs(p.input - xi);
          if (d < best.delta || (d === best.delta && p.input < best.input)) {
            best = { index: i, delta: d, input: p.input };
          }
        });
        if (best.index === -1 || best.delta > tolerance) return null;
        return best.index;
      }
    };

    // Adaptive key‑point extraction using Ramer–Douglas–Peucker on normalized (0..100) XY
    function _perpDist(p, a, b) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      if (dx === 0 && dy === 0) {
        const ux = p.x - a.x, uy = p.y - a.y;
        return Math.hypot(ux, uy);
      }
      return Math.abs(dy * p.x - dx * p.y + b.x * a.y - b.y * a.x) / Math.hypot(dx, dy);
    }

    function _rdp(points, eps) {
      const keep = new Array(points.length).fill(false);
      keep[0] = true; keep[points.length - 1] = true;
      (function simplify(first, last) {
        if (last <= first + 1) return;
        const a = points[first], b = points[last];
        let maxD = -1, idx = -1;
        for (let i = first + 1; i < last; i++) {
          const d = _perpDist(points[i], a, b);
          if (d > maxD) { maxD = d; idx = i; }
        }
        if (maxD > eps) {
          keep[idx] = true;
          simplify(first, idx);
          simplify(idx, last);
        }
      })(0, points.length - 1);
      const out = [];
      for (let i = 0; i < points.length; i++) if (keep[i]) out.push(points[i]);
      return out;
    }

    function extractAdaptiveKeyPointsFromValues(values, options = {}) {
      const maxErrorPercent = Math.max(0.05, Math.min(5, options.maxErrorPercent || KP_SIMPLIFY.maxErrorPercent || 1.0)); // 0.05%..5%
      const maxPoints = Math.max(2, Math.min(21, options.maxPoints || KP_SIMPLIFY.maxPoints || 21));
      const N = values.length;
      if (!Array.isArray(values) || N < 2) return [ { input: 0, output: 0 }, { input: 100, output: 100 } ];
      const peak = Math.max(0, ...values);
      if (peak <= 0) return [ { input: 0, output: 0 }, { input: 100, output: 100 } ];
      // Build normalized XY relative to peak so endpoint will be 100% for AI scaling logic
      const pts = new Array(N);
      for (let i = 0; i < N; i++) {
        const x = (i / (N - 1)) * 100;
        const y = Math.max(0, Math.min(100, (values[i] / peak) * 100));
        pts[i] = { x, y };
      }
      // Detect near-linear ramp conservatively (across 11 evenly spaced samples)
      let isLinear = false;
      const EPS = 0.002; // 0.2% tolerance to avoid false positives
      const samplesIdx = [];
      for (let k = 0; k <= 10; k++) samplesIdx.push(Math.round((N - 1) * (k / 10)));
      isLinear = samplesIdx.every(idx => {
        const expected = (idx / (N - 1));
        const actual = (values[idx] / peak);
        return Math.abs(actual - expected) <= EPS;
      });
      if (isLinear) {
        return [ { input: 0, output: 0 }, { input: 100, output: 100 } ];
      }
      // Adaptive simplify; increase epsilon if too many points
      let eps = maxErrorPercent; // in percent units (same XY scale)
      let simplified = _rdp(pts, eps);
      let guard = 0;
      while (simplified.length > maxPoints && guard < 8) {
        eps *= 1.3; // relax tolerance progressively
        simplified = _rdp(pts, eps);
        guard++;
      }
      // Map back to key points and normalize X gaps
      const keyPoints = simplified.map(p => ({ input: p.x, output: p.y }));
      return ControlPoints.normalize(keyPoints);
    }

    // Ensure AI key points exist for a channel; if not, create them from source data or current curve
    function ensureEditableKeyPointsForChannel(channelName, interpolationType = 'smooth') {
      try {
        // Don't restore key points during revert operations
        if (window._REVERT_IN_PROGRESS) {
          return { success: false, reason: 'Revert in progress' };
        }

        const existing = ControlPoints.get(channelName).points;
        if (existing && existing.length >= 2) return { success: true };

        // Prefer per-channel linearization source
        let candidate = [];
        const per = perChannelLinearization[channelName];
        if (per) {
          const fmt = (per.format || '').toUpperCase();
          if (fmt === 'ACV' && Array.isArray(per.controlPointsTransformed) && per.controlPointsTransformed.length >= 2) {
            // Seed ACV anchors directly (cap via DIRECT_SEED_MAX_POINTS)
            if (per.controlPointsTransformed.length <= DIRECT_SEED_MAX_POINTS) {
              candidate = per.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
            } else {
              // Too many anchors — sample plotted curve and simplify
              const row = getChannelRow(channelName);
              const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
              const sampleEnd = endVal > 0 ? endVal : TOTAL;
              const values = make256(sampleEnd, channelName, true);
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmt.includes('LAB') || fmt.includes('MANUAL')) && Array.isArray(per.samples) && per.samples.length >= 2) {
            // LAB/Manual: when few measurements, seed at measured Patch % positions; else simplify plotted curve
            const row = getChannelRow(channelName);
            const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
            const sampleEnd = endVal > 0 ? endVal : TOTAL;
            const values = make256(sampleEnd, channelName, true);
            const orig = Array.isArray(per.originalData) ? per.originalData : null;
            if (orig && orig.length > 0 && orig.length <= DIRECT_SEED_MAX_POINTS) {
              // Seed at measured Patch % positions by sampling the plotted mapping
              const Nvals = values.length - 1;
              candidate = orig.map(d => {
                const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                const t = (x / 100) * Nvals;
                const i0 = Math.floor(t);
                const i1 = Math.min(Nvals, Math.ceil(t));
                const a = t - i0;
                const v = (1 - a) * values[i0] + a * values[i1];
                const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                return { input: x, output: outPct };
              });
            } else {
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmt === '1DLUT' || Array.isArray(per.samples)) && Array.isArray(per.samples) && per.samples.length >= 2) {
            // Seed from LUT samples (1D or neutral axis from 3D). Use exact points when modest in count; otherwise adaptively reduce.
            const printerSamples = getPrinterSpaceSamples(per) || per.samples;
            const K = printerSamples.length;
            if (K <= DIRECT_SEED_MAX_POINTS) {
              candidate = printerSamples.map((s, i) => ({
                input: (i / (K - 1)) * 100,
                output: Math.max(0, Math.min(100, s * 100))
              }));
            } else {
              // Too dense for direct seeding; derive a compact, edit-friendly set from the LUT curve
              const values = printerSamples.map(v => Math.round(Math.max(0, Math.min(1, v)) * TOTAL));
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          }
        }
        // If no per-channel anchors, prefer global ACV anchors if available
        if (candidate.length < 2 && linearizationData) {
          const fmtG = (linearizationData.format || '').toUpperCase();
          if (fmtG === 'ACV' && Array.isArray(linearizationData.controlPointsTransformed) && linearizationData.controlPointsTransformed.length >= 2) {
            if (linearizationData.controlPointsTransformed.length <= DIRECT_SEED_MAX_POINTS) {
              candidate = linearizationData.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
            } else {
              const row = getChannelRow(channelName);
              const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
              const sampleEnd = endVal > 0 ? endVal : TOTAL;
              const values = make256(sampleEnd, channelName, true);
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmtG.includes('LAB') || fmtG.includes('MANUAL')) && Array.isArray(linearizationData.samples) && linearizationData.samples.length >= 2) {
            // Global LAB/Manual: seed at measured Patch % when modest; else simplify plotted curve
            const row = getChannelRow(channelName);
            const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
            const values = make256(endVal, channelName, true);
            const orig = Array.isArray(linearizationData.originalData) ? linearizationData.originalData : null;
            if (orig && orig.length > 0 && orig.length <= DIRECT_SEED_MAX_POINTS) {
              const Nvals = values.length - 1;
              candidate = orig.map(d => {
                const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                const t = (x / 100) * Nvals;
                const i0 = Math.floor(t);
                const i1 = Math.min(Nvals, Math.ceil(t));
                const a = t - i0;
                const v = (1 - a) * values[i0] + a * values[i1];
                const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                return { input: x, output: outPct };
              });
            } else {
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmtG === '1DLUT' || Array.isArray(linearizationData.samples)) && Array.isArray(linearizationData.samples) && linearizationData.samples.length >= 2) {
            // Seed from global LUT samples (1D or neutral axis from 3D)
            const printerSamples = getPrinterSpaceSamples(linearizationData) || linearizationData.samples;
            const K = printerSamples.length;
            if (K <= DIRECT_SEED_MAX_POINTS) {
              candidate = printerSamples.map((s, i) => ({
                input: (i / (K - 1)) * 100,
                output: Math.max(0, Math.min(100, s * 100))
              }));
            } else {
              const values = printerSamples.map(v => Math.round(Math.max(0, Math.min(1, v)) * TOTAL));
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          }
        }
        // If no direct anchors, sample from current displayed curve
        if (candidate.length < 2) {
          const row = getChannelRow(channelName);
          const e = row ? InputValidator.clampEnd(row.querySelector('.end-input').value) : TOTAL;
          const sampleEnd = e > 0 ? e : TOTAL;
          const values = make256(sampleEnd, channelName, true);
          // Use adaptive simplification (RDP) to create a compact, edit-friendly set
          candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
        }
        // If channel is disabled (End=0), persist key points only and avoid applying/enabling the channel
        try {
          const row = getChannelRow(channelName);
          const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
          if (endVal === 0) {
            ControlPoints.persist(channelName, candidate, interpolationType);
            return { success: true };
          }
        } catch {}
        // Otherwise, persist and apply curve normally
        const res = quadGenActions.setSmartKeyPoints(channelName, candidate, interpolationType);
        if (res && res.success) return { success: true };
        return { success: false, message: res?.message || 'Failed to create Smart key points' };
      } catch (e) {
        return { success: false, message: e.message };
      }
    }

    /**
     * Parse a 3D LUT (.cube) file and extract neutral axis for linearization.
     * Returns { domainMin, domainMax, samples } where samples represent the neutral axis (R=G=B) response.
     */
    function parseCube3D(cubeText) {
      const lines = cubeText.split(/\r?\n/);
      let domainMin = 0.0;
      let domainMax = 1.0;
      let lutSize = null;
      const lutData = [];

      // Parse header information
      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;

        if (/^LUT_3D_SIZE/i.test(s)) {
          const m = s.match(/LUT_3D_SIZE\s+(\d+)/i);
          if (m) lutSize = parseInt(m[1], 10);
          continue;
        }
        if (/^DOMAIN_MIN/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMin = parseFloat(parts[1]);
          continue;
        }
        if (/^DOMAIN_MAX/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMax = parseFloat(parts[1]);
          continue;
        }

        // Parse RGB data lines
        const parts = s.split(/\s+/);
        if (parts.length === 3) {
          const r = parseFloat(parts[0]);
          const g = parseFloat(parts[1]);
          const b = parseFloat(parts[2]);
          if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
            lutData.push([r, g, b]);
          }
        }
      }

      if (!lutSize) {
        throw new Error("3D LUT size not found. Expected LUT_3D_SIZE declaration.");
      }

      const expectedDataPoints = lutSize * lutSize * lutSize;
      if (lutData.length !== expectedDataPoints) {
        throw new Error(`3D LUT data mismatch. Expected ${expectedDataPoints} points, found ${lutData.length}.`);
      }

      // Extract neutral axis (diagonal where R=G=B)
      const neutralAxisSamples = [];
      const outputSteps = 256; // Generate 256 samples for consistency with other LUT processing

      for (let i = 0; i < outputSteps; i++) {
        const input = i / (outputSteps - 1); // 0 to 1
        const neutralRGB = [input, input, input]; // R=G=B for neutral gray
        
        // Trilinear interpolation in 3D LUT
        const outputRGB = trilinearInterpolate3D(neutralRGB, lutData, lutSize, domainMin, domainMax);
        
        // Convert RGB output to luminance (simple average for neutral axis)
        const luminance = (outputRGB[0] + outputRGB[1] + outputRGB[2]) / 3;
        neutralAxisSamples.push(luminance);
      }

      // Apply coordinate system transformations once here
      const converted = DataSpace.convertSamples(neutralAxisSamples, { from: DataSpace.SPACE.IMAGE, to: DataSpace.SPACE.PRINTER });
      
      return { 
        domainMin, 
        domainMax, 
        samples: converted.values,
        is3DLUT: true,
        lutSize: lutSize,
        originalDataPoints: expectedDataPoints,
        sourceSpace: converted.sourceSpace,
        conversionMeta: converted.meta
      };
    }

    /**
     * Trilinear interpolation for 3D LUT sampling
     * @private
     */
    function trilinearInterpolate3D(inputRGB, lutData, lutSize, domainMin, domainMax) {
      const [r, g, b] = inputRGB;
      
      // Normalize input to LUT coordinates (0 to lutSize-1)
      const normalizedR = (r - domainMin) / (domainMax - domainMin);
      const normalizedG = (g - domainMin) / (domainMax - domainMin);
      const normalizedB = (b - domainMin) / (domainMax - domainMin);
      
      const lutR = Math.max(0, Math.min(lutSize - 1, normalizedR * (lutSize - 1)));
      const lutG = Math.max(0, Math.min(lutSize - 1, normalizedG * (lutSize - 1)));
      const lutB = Math.max(0, Math.min(lutSize - 1, normalizedB * (lutSize - 1)));
      
      // Get integer indices and fractional parts
      const r0 = Math.floor(lutR), r1 = Math.min(lutSize - 1, r0 + 1);
      const g0 = Math.floor(lutG), g1 = Math.min(lutSize - 1, g0 + 1);
      const b0 = Math.floor(lutB), b1 = Math.min(lutSize - 1, b0 + 1);
      
      const fr = lutR - r0;
      const fg = lutG - g0;
      const fb = lutB - b0;
      
      // Get the 8 corner values from the LUT cube
      const corners = [
        lutData[r0 * lutSize * lutSize + g0 * lutSize + b0], // (r0,g0,b0)
        lutData[r1 * lutSize * lutSize + g0 * lutSize + b0], // (r1,g0,b0)
        lutData[r0 * lutSize * lutSize + g1 * lutSize + b0], // (r0,g1,b0)
        lutData[r1 * lutSize * lutSize + g1 * lutSize + b0], // (r1,g1,b0)
        lutData[r0 * lutSize * lutSize + g0 * lutSize + b1], // (r0,g0,b1)
        lutData[r1 * lutSize * lutSize + g0 * lutSize + b1], // (r1,g0,b1)
        lutData[r0 * lutSize * lutSize + g1 * lutSize + b1], // (r0,g1,b1)
        lutData[r1 * lutSize * lutSize + g1 * lutSize + b1]  // (r1,g1,b1)
      ];
      
      // Trilinear interpolation
      const result = [0, 0, 0];
      for (let c = 0; c < 3; c++) {
        const c00 = corners[0][c] * (1 - fr) + corners[1][c] * fr;
        const c01 = corners[2][c] * (1 - fr) + corners[3][c] * fr;
        const c10 = corners[4][c] * (1 - fr) + corners[5][c] * fr;
        const c11 = corners[6][c] * (1 - fr) + corners[7][c] * fr;
        
        const c0 = c00 * (1 - fg) + c01 * fg;
        const c1 = c10 * (1 - fg) + c11 * fg;
        
        result[c] = c0 * (1 - fb) + c1 * fb;
      }
      
      return result;
    }

    // LAB processing summary: see docs/LAB_LINEARIZATION_WORKFLOW.md
    // CIE helpers for L* → Y → optical density
    function lstarToY_CIE(L) {
      const l = Math.max(0, Math.min(100, Number(L)));
      if (l > 8) {
        const f = (l + 16) / 116;
        return f * f * f;
      } else {
        return l / 903.3;
      }
    }
    function log10_safe(x) {
      const v = Math.max(1e-6, Math.min(1, x));
      return Math.log(v) / Math.LN10; // avoids older Math.log10 browser gaps
    }
    function cieDensityFromLstar(L) {
      // Unnormalized optical density from L*
      const Y = lstarToY_CIE(L);
      return -log10_safe(Y);
    }
    /**
     * Parse a LAB measurement data file (tab-separated format)
     * Expected format:
     * GRAY	LAB_L	LAB_A	LAB_B
     * 0	97.50	0.20	-0.50
     * 5	93.40	0.30	-0.70
     * ...
     * Returns { domainMin: 0, domainMax: 1, samples } where samples are normalized 0..1
     */
    function parseLabData(fileContent, filename) {
      const lines = fileContent.split(/\r?\n/);
      const dataPoints = [];

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue; // skip empty
        if (trimmed.startsWith('#') || trimmed.startsWith('//')) continue;
        if (trimmed.toUpperCase().includes('GRAY') && trimmed.toUpperCase().includes('LAB_L')) continue; // header

        const parts = trimmed.split(/\s+/);
        if (parts.length >= 2) {
          const grayPercent = parseFloat(parts[0]);
          const labL = parseFloat(parts[1]);

          // L* values must be 0-100 (CIE LAB standard). Gray input may be 0-100 or 0-255.
          if (!isNaN(grayPercent) && !isNaN(labL) && grayPercent >= 0 && labL >= 0 && labL <= 100) {
            // Auto-detect gray range: if gray value > 100, assume 0-255 range; otherwise 0-100 range
            const normalizedGray = grayPercent > 100 ? (grayPercent / 255) * 100 : grayPercent;
            dataPoints.push({ input: normalizedGray, lab: labL });
          }
        }
      }

      if (dataPoints.length < 2) {
        throw new Error('Not enough valid LAB measurement data points found. Expected format: GRAY\tLAB_L\tLAB_A\tLAB_B');
      }

      // Sort and capture original data for overlays/metadata
      dataPoints.sort((a, b) => a.input - b.input);
      const originalDataPoints = [...dataPoints];

      // Build Gaussian Weighted Correction in printer space using CIE-exact density mapping
      const labValues = dataPoints.map(p => p.lab);
      const D_values = labValues.map(L => cieDensityFromLstar(L));
      const Dmax = Math.max(...D_values, 1e-6);

      const correctionPoints = dataPoints.map(point => {
        const pos = Math.max(0, Math.min(1, point.input / 100));
        const actualDensity = cieDensityFromLstar(point.lab) / Dmax; // normalized 0..1
        const expectedDensity = getTargetRelAt(pos);
        return {
          position: pos,
          // Stable sign convention: expected minus actual
          correction: (expectedDensity - actualDensity),
          originalLab: point.lab,
          originalInput: point.input
        };
      });

      // Local adaptive bandwidth (σ) for Gaussian weights
      // σ(t) = clamp(floor=0.02, alpha * s_local(t), ceil=0.15)
      // s_local(t): median distance to K nearest measured positions (handles uneven spacing)
      const positionsOnly = correctionPoints.map(p => p.position);
      const K_NEIGHBORS = LAB_TUNING.get('K_NEIGHBORS', 6);
      const SIGMA_FLOOR = 0.02;
      const SIGMA_CEIL = 0.15;
      const SIGMA_ALPHA = 3.0;
      function localSigmaAt(t) {
        const n = positionsOnly.length;
        if (n <= 1) return SIGMA_CEIL; // fallback
        // Binary search to find insertion index
        let lo = 0, hi = n;
        while (lo < hi) {
          const mid = (lo + hi) >> 1;
          if (positionsOnly[mid] < t) lo = mid + 1; else hi = mid;
        }
        // Gather K nearest distances from neighbors around index
        const dists = [];
        let L = lo - 1, R = lo;
        while ((L >= 0 || R < n) && dists.length < K_NEIGHBORS) {
          const dl = (L >= 0) ? Math.abs(t - positionsOnly[L]) : Infinity;
          const dr = (R < n) ? Math.abs(t - positionsOnly[R]) : Infinity;
          if (dl <= dr) { if (isFinite(dl)) dists.push(dl); L--; } else { if (isFinite(dr)) dists.push(dr); R++; }
        }
        if (dists.length === 0) return SIGMA_CEIL;
        dists.sort((a,b)=>a-b);
        const mid = dists.length >> 1;
        const med = (dists.length % 2 === 0) ? 0.5*(dists[mid-1]+dists[mid]) : dists[mid];
        const sigma = Math.min(SIGMA_CEIL, Math.max(SIGMA_FLOOR, SIGMA_ALPHA * med));
        return sigma;
      }

      const samples = [];
      for (let i = 0; i < 256; i++) {
        const position = i / 255;
        let weightedCorrection = 0;
        let totalWeight = 0;
        const sigma = localSigmaAt(position);
        const denom = 2 * sigma * sigma;
        for (let j = 0; j < correctionPoints.length; j++) {
          const d = Math.abs(position - correctionPoints[j].position);
          const w = Math.exp(-(d * d) / Math.max(1e-9, denom));
          weightedCorrection += correctionPoints[j].correction * w;
          totalWeight += w;
        }
        const baseline = position;
        const finalCorrection = totalWeight > 0 ? (weightedCorrection / totalWeight) : 0;
        const corrected = Math.max(0, Math.min(1, baseline + finalCorrection));
        samples.push(corrected);
      }
      // Anchor endpoints
      samples[0] = 0.0;
      samples[samples.length - 1] = 1.0;

      // Return LAB linearization object with optional Gaussian smoothing provider
      return {
        domainMin: 0.0,
        domainMax: 1.0,
        samples: samples,
        originalData: originalDataPoints,
        format: 'LAB Data',
        sourceSpace: DataSpace.SPACE.PRINTER,
        getSmoothingControlPoints: function(smoothingPercent) {
          // Local adaptive σ widened by smoothingPercent
          const sp = Math.max(0, Math.min(90, Number(smoothingPercent) || 0));
          const widen = 1 + (sp / 100);
          const dyn = new Array(256);
          for (let i = 0; i < 256; i++) {
            const position = i / 255;
            let weightedCorrection = 0;
            let totalWeight = 0;
            const sigmaLocal = localSigmaAt(position) * widen;
            const sigma = Math.min(SIGMA_CEIL, Math.max(SIGMA_FLOOR, sigmaLocal));
            const denom = 2 * sigma * sigma;
            for (let j = 0; j < correctionPoints.length; j++) {
              const d = Math.abs(position - correctionPoints[j].position);
              const w = Math.exp(-(d * d) / Math.max(1e-9, denom));
              weightedCorrection += correctionPoints[j].correction * w;
              totalWeight += w;
            }
            const baseline = position;
            const finalCorrection = totalWeight > 0 ? (weightedCorrection / totalWeight) : 0;
            dyn[i] = Math.max(0, Math.min(1, baseline + finalCorrection));
          }
          dyn[0] = 0.0;
          dyn[dyn.length - 1] = 1.0;
          // Produce evenly spaced control points from dynamic curve
          const controlPointCount = Math.max(3, 21 - Math.floor(sp / 10));
          const cpY = [];
          const cpX = [];
          for (let i = 0; i < controlPointCount; i++) {
            const x = i / (controlPointCount - 1);
            const idx = Math.round(x * 255);
            cpX.push(x);
            cpY.push(dyn[idx]);
          }
        // Apply dual-axis transformation after interpolation to match industry-standard plot orientation
        // Signal to apply1DLUT() to perform horizontal + vertical flips on the final mapping
          return { samples: cpY, xCoords: cpX, controlPointCount, needsDualTransformation: false, influenceRadius: null };
        }
      };
    }

    /**
     * Parse Adobe Photoshop .acv (curve) files
     * Binary format: version(int16), totalCurves(int16), then for each curve: pointCount(int16), point pairs(int16,int16)
     * Returns { domainMin: 0, domainMax: 1, samples } where samples are normalized 0..1
     */
    function parseACVFile(arrayBuffer) {
      const dataView = new DataView(arrayBuffer);
      let offset = 0;

      // Read version (2 bytes, big-endian)
      const version = dataView.getInt16(offset, false);
      offset += 2;

      // Read total curves count (2 bytes, big-endian)
      const totalCurves = dataView.getInt16(offset, false);
      offset += 2;

      if (totalCurves === 0) {
        throw new Error('ACV file contains no curves');
      }

      // Parse first curve (RGB composite curve)
      const pointCount = dataView.getInt16(offset, false);
      offset += 2;

      if (pointCount === 0) {
        throw new Error('ACV file RGB curve contains no points');
      }

      const curvePoints = [];
      for (let i = 0; i < pointCount; i++) {
        // Read output value (y-coordinate) - this is the correction value
        const output = dataView.getInt16(offset, false);
        offset += 2;
        // Read input value (x-coordinate) - this is the original value
        const input = dataView.getInt16(offset, false);
        offset += 2;

        curvePoints.push({
          input: input / 255,    // Normalize to 0-1
          output: output / 255   // Normalize to 0-1
        });
      }

      // Sort by input value to ensure proper curve order
      curvePoints.sort((a, b) => a.input - b.input);

      // Use cubic spline interpolation like Photoshop for smooth curves
      const xValues = curvePoints.map(p => p.input);
      const yValues = curvePoints.map(p => p.output);
      
      // Create cubic spline interpolator
      const splineInterpolator = createCubicSpline(xValues, yValues);
      
      // Convert to the format expected by quadGEN (256 samples)
      const samples = new Array(256);
      for (let i = 0; i < 256; i++) {
        const inputValue = i / 255;
        samples[i] = Math.max(0, Math.min(1, splineInterpolator(inputValue)));
      }

      // Normalize orientation once here via DataSpace helper; do not reapply later
      const convertedSamples = DataSpace.convertSamples(samples, { from: DataSpace.SPACE.IMAGE, to: DataSpace.SPACE.PRINTER });

      // Also build transformed control points from the original ACV anchors
      // Transform: input' = 1 - input, output' = 1 - output, then scale to 0-100
      const controlPointsTransformed = DataSpace.convertControlPoints(curvePoints, {
        from: DataSpace.SPACE.IMAGE,
        to: DataSpace.SPACE.PRINTER,
        scale: 100,
        inputScale: 1,
        outputScale: 1
      });

      return {
        domainMin: 0,
        domainMax: 1,
        samples: convertedSamples.values,
        originalSamples: samples,
        format: 'ACV',
        controlPointsTransformed,
        sourceSpace: convertedSamples.sourceSpace,
        conversionMeta: convertedSamples.meta
      };
    }

    /**
     * Detect file type and parse appropriately
     * For text files, pass the file content as string
     * For binary files (.acv), pass the ArrayBuffer
     */
    async function parseLinearizationFile(fileContentOrFile, filename) {
      const extension = filename.toLowerCase().split('.').pop();
      
      if (extension === 'cube') {
        return parseCube1D(fileContentOrFile);
      } else if (extension === 'txt') {
        // Check if it's LAB measurement format by looking for the header
        if (fileContentOrFile.includes('GRAY') && fileContentOrFile.includes('LAB_L')) {
          return parseLabData(fileContentOrFile, filename);
        } else {
          throw new Error('TXT file format not recognized. Expected LAB measurement format with GRAY and LAB_L columns.');
        }
      } else if (extension === 'acv') {
        // .acv files are binary, so fileContentOrFile should be an ArrayBuffer
        if (!(fileContentOrFile instanceof ArrayBuffer)) {
          throw new Error('ACV files must be read as binary data');
        }
        return parseACVFile(fileContentOrFile);
      } else {
        throw new Error(`Unsupported file format: ${extension}. Use .cube, .txt, or .acv files.`);
      }
    }

    /**
     * Natural cubic spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCubicSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Use clamped cubic spline with estimated end derivatives for more curvature
      const h = new Array(n - 1);
      const alpha = new Array(n);
      const l = new Array(n);
      const mu = new Array(n);
      const z = new Array(n);
      const c = new Array(n);
      const b = new Array(n);
      const d = new Array(n);
      
      // Step 1: Calculate h
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
      }
      
      // Step 2: Set up alpha with clamped boundary conditions
      // Estimate end derivatives to allow more curvature
      const firstDerivative = (y[1] - y[0]) / h[0];
      const lastDerivative = (y[n-1] - y[n-2]) / h[n-2];
      
      alpha[0] = 3 * ((y[1] - y[0]) / h[0] - firstDerivative);
      alpha[n-1] = 3 * (lastDerivative - (y[n-1] - y[n-2]) / h[n-2]);
      
      for (let i = 1; i < n - 1; i++) {
        alpha[i] = (3 / h[i]) * (y[i + 1] - y[i]) - (3 / h[i - 1]) * (y[i] - y[i - 1]);
      }
      
      // Step 3: Solve tridiagonal system with clamped conditions
      l[0] = 2 * h[0];
      mu[0] = 0.5;
      z[0] = alpha[0] / l[0];
      
      for (let i = 1; i < n - 1; i++) {
        l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
        mu[i] = h[i] / l[i];
        z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
      }
      
      l[n - 1] = h[n - 2] * (2 - mu[n - 2]);
      z[n - 1] = (alpha[n - 1] - h[n - 2] * z[n - 2]) / l[n - 1];
      c[n - 1] = z[n - 1];
      
      // Step 4: Back substitution
      for (let j = n - 2; j >= 0; j--) {
        c[j] = z[j] - mu[j] * c[j + 1];
        b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
        d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
      }
      
      // Return interpolation function
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Evaluate cubic polynomial - clamped cubic spline interpolation
        const dt = t - x[i];
        return y[i] + b[i] * dt + c[i] * dt * dt + d[i] * dt * dt * dt;
      };
    }

    /**
     * Catmull-Rom spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCatmullRomSpline(x, y, tension = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Get the four control points (with boundary handling)
        const p0 = y[Math.max(0, i - 1)];
        const p1 = y[i];
        const p2 = y[Math.min(n - 1, i + 1)];
        const p3 = y[Math.min(n - 1, i + 2)];
        
        // Normalize t to 0-1 within the segment
        const t_norm = (t - x[i]) / (x[i + 1] - x[i]);
        const t2 = t_norm * t_norm;
        const t3 = t2 * t_norm;
        
        // Parameterized Catmull-Rom basis functions with tension control
        // tension = 0.0: very tight (close to linear)
        // tension = 0.5: standard Catmull-Rom
        // tension = 1.0: very loose/curvy
        const q0 = -tension * t3 + 2 * tension * t2 - tension * t_norm;
        const q1 = (2 - tension) * t3 + (tension - 3) * t2 + 1;
        const q2 = (tension - 2) * t3 + (3 - 2 * tension) * t2 + tension * t_norm;
        const q3 = tension * t3 - tension * t2;
        
        // Catmull-Rom interpolation with adjustable tension
        return p0 * q0 + p1 * q1 + p2 * q2 + p3 * q3;
      };
    }

    

    /**
     * PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) - Monotonic cubic spline
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createPCHIPSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate slopes (derivatives) at each point
      const slopes = new Array(n);
      const h = new Array(n - 1);
      const delta = new Array(n - 1);
      
      // Calculate intervals and finite differences
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
        delta[i] = (y[i + 1] - y[i]) / h[i];
      }
      
      // Calculate slopes using PCHIP method
      slopes[0] = delta[0]; // First point - use forward difference
      slopes[n - 1] = delta[n - 2]; // Last point - use backward difference
      
      for (let i = 1; i < n - 1; i++) {
        // Interior points - use monotonic slope calculation
        if (delta[i - 1] * delta[i] <= 0) {
          // Data changes direction - use zero slope to avoid overshooting
          slopes[i] = 0;
        } else {
          // Data is monotonic - use weighted harmonic mean for smooth monotonic interpolation
          const w1 = 2 * h[i] + h[i - 1];
          const w2 = h[i] + 2 * h[i - 1];
          slopes[i] = (w1 + w2) / (w1 / delta[i - 1] + w2 / delta[i]);
        }
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Normalize t within the interval
        const dt = t - x[i];
        const h_i = h[i];
        const t_norm = dt / h_i;
        
        // Hermite basis functions
        const h00 = 2 * t_norm * t_norm * t_norm - 3 * t_norm * t_norm + 1;
        const h10 = t_norm * t_norm * t_norm - 2 * t_norm * t_norm + t_norm;
        const h01 = -2 * t_norm * t_norm * t_norm + 3 * t_norm * t_norm;
        const h11 = t_norm * t_norm * t_norm - t_norm * t_norm;
        
        // PCHIP interpolation formula
        return y[i] * h00 + h_i * slopes[i] * h10 + y[i + 1] * h01 + h_i * slopes[i + 1] * h11;
      };
    }

    /**
     * Curve simplification algorithms for data point reduction
     */
    const CurveSimplification = {
      /**
       * Uniform sampling reduction - reduces points while maintaining even distribution
       * @param {number[]} samples - Original sample array
       * @param {number} reductionPercent - Percentage of points to remove (0-90)
       * @returns {number[]} Reduced sample array
       */
      uniformSampling: function(samples, reductionPercent) {
        if (reductionPercent === 0 || samples.length <= 3) return samples;
        
        const keepRatio = 1.0 - (reductionPercent / 100);
        const targetCount = Math.max(3, Math.round(samples.length * keepRatio));
        const step = (samples.length - 1) / (targetCount - 1);
        
      if (DEBUG_LOGS) console.log(`🔍 Uniform Sampling DEBUG:`, {
          originalPoints: samples.length,
          reductionPercent: reductionPercent,
          keepRatio: keepRatio,
          targetCount: targetCount,
          step: step
        });
        
        const reducedSamples = [];
        for (let i = 0; i < targetCount; i++) {
          const index = Math.round(i * step);
          reducedSamples.push(samples[index]);
        }
        
      if (DEBUG_LOGS) console.log(`✅ Uniform Sampling Result: ${samples.length} → ${reducedSamples.length} points`);
        return reducedSamples;
      },
      

      /**
       * Smoothing splines data reduction with automatic lambda selection
       * @param {number[]} samples - Original sample array
       * @param {number} reductionPercent - Percentage of points to remove (0-90)
       * @returns {number[]} Smoothed and reduced sample array
       */
      smoothingSplines: function(samples, reductionPercent) {
        if (reductionPercent === 0 || samples.length <= 3) return samples;
        
        const n = samples.length;
        const keepRatio = 1.0 - (reductionPercent / 100);
        const targetCount = Math.max(3, Math.round(n * keepRatio));
        
        // Create input points (x values are indices normalized to 0-1)
        const x = [];
        const y = [];
        for (let i = 0; i < n; i++) {
          x.push(i / (n - 1));
          y.push(samples[i]);
        }
        
        // Calculate smoothing parameter lambda based on reduction percentage
        // Higher reduction = more smoothing
        const dataRange = Math.max(...y) - Math.min(...y);
        const lambda = Math.pow(reductionPercent / 100, 2) * dataRange * 0.1;
        
      if (DEBUG_LOGS) console.log(`🔍 Smoothing Splines DEBUG:`, {
          originalPoints: samples.length,
          reductionPercent: reductionPercent,
          keepRatio: keepRatio,
          targetCount: targetCount,
          dataRange: dataRange,
          lambda: lambda
        });
        
        // Build smoothing spline system
        const splineCoefficients = this._buildSmoothingSpline(x, y, lambda);
        
        // Sample the smooth spline at target points
        const reducedSamples = [];
        for (let i = 0; i < targetCount; i++) {
          const t = i / (targetCount - 1);
          const value = this._evaluateSmoothingSpline(splineCoefficients, x, y, t);
          reducedSamples.push(value);
        }
        
      if (DEBUG_LOGS) console.log(`✅ Smoothing Splines Result: ${samples.length} → ${reducedSamples.length} points`);
        return reducedSamples;
      },

      /**
       * Build smoothing spline coefficients using penalized least squares
       * @private
       */
      _buildSmoothingSpline: function(x, y, lambda) {
        const n = x.length;
        if (n < 4) return { x, y, c: new Array(n).fill(0) };
        
        // For simplicity, use natural cubic spline with roughness penalty
        // This is a simplified implementation focused on data reduction
        const h = [];
        for (let i = 0; i < n - 1; i++) {
          h[i] = x[i + 1] - x[i];
        }
        
        // Build tridiagonal system for natural spline with smoothing
        const A = new Array(n).fill(null).map(() => new Array(n).fill(0));
        const b = new Array(n).fill(0);
        
        // Natural spline boundary conditions with smoothing penalty
        A[0][0] = 1 + lambda;
        A[n-1][n-1] = 1 + lambda;
        b[0] = y[0];
        b[n-1] = y[n-1];
        
        // Interior equations with roughness penalty
        for (let i = 1; i < n - 1; i++) {
          const hi_1 = h[i-1];
          const hi = h[i];
          
          // Data fidelity term
          A[i][i] = 1;
          b[i] = y[i];
          
          // Add smoothing penalty (simplified second derivative penalty)
          if (lambda > 0) {
            A[i][i] += lambda * (2 / (hi_1 + hi));
            if (i > 1) A[i][i-1] = -lambda / (hi_1 + hi);
            if (i < n - 2) A[i][i+1] = -lambda / (hi_1 + hi);
          }
        }
        
        // Solve system using Gaussian elimination
        const c = this._solveTridiagonal(A, b);
        
        return { x, y, c };
      },

      /**
       * Evaluate smoothing spline at parameter t
       * @private
       */
      _evaluateSmoothingSpline: function(spline, x, y, t) {
        const { x: sx, y: sy, c } = spline;
        const n = sx.length;
        
        // Clamp t to valid range
        t = Math.max(0, Math.min(1, t));
        
        // Find interval
        let i = 0;
        while (i < n - 1 && sx[i + 1] < t) i++;
        if (i >= n - 1) return sy[n - 1];
        
        // Linear interpolation with spline smoothing
        const h = sx[i + 1] - sx[i];
        const dt = t - sx[i];
        const ratio = h > 0 ? dt / h : 0;
        
        // Hermite interpolation with smoothing coefficient
        const y0 = sy[i];
        const y1 = sy[i + 1];
        const c0 = c[i];
        const c1 = c[i + 1];
        
        // Cubic Hermite interpolation
        const t2 = ratio * ratio;
        const t3 = t2 * ratio;
        
        const h00 = 2*t3 - 3*t2 + 1;  // (1+2t)(1-t)^2
        const h10 = t3 - 2*t2 + ratio; // t(1-t)^2
        const h01 = -2*t3 + 3*t2;      // t^2(3-2t)
        const h11 = t3 - t2;           // t^2(t-1)
        
        return h00 * y0 + h10 * h * c0 + h01 * y1 + h11 * h * c1;
      },

      /**
       * Solve tridiagonal system using simplified Gaussian elimination
       * @private
       */
      _solveTridiagonal: function(A, b) {
        const n = A.length;
        const x = new Array(n).fill(0);
        
        // Simple Gaussian elimination for small systems
        // Forward elimination
        for (let i = 0; i < n - 1; i++) {
          for (let j = i + 1; j < n; j++) {
            if (Math.abs(A[i][i]) < 1e-12) continue;
            const factor = A[j][i] / A[i][i];
            for (let k = i; k < n; k++) {
              A[j][k] -= factor * A[i][k];
            }
            b[j] -= factor * b[i];
          }
        }
        
        // Back substitution
        for (let i = n - 1; i >= 0; i--) {
          x[i] = b[i];
          for (let j = i + 1; j < n; j++) {
            x[i] -= A[i][j] * x[j];
          }
          if (Math.abs(A[i][i]) > 1e-12) {
            x[i] /= A[i][i];
          }
        }
        
        return x;
      },


      /**
       * Apply smoothing reduction using current algorithm
       * @param {number[]} samples - Original sample array
       * @param {number} reductionPercent - Percentage of points to remove (0-90)
       * @param {string} algorithm - 'uniform' or 'smoothing-splines'
       * @returns {number[]} Reduced sample array
       */
      applySmoothingReduction: function(samples, reductionPercent, algorithm = 'smoothing-splines') {
        if (reductionPercent === 0) return samples;
        
        switch (algorithm) {
          case 'smoothing-splines':
            return this.smoothingSplines(samples, reductionPercent);
          case 'uniform':
            return this.uniformSampling(samples, reductionPercent);
          default:
            return this.smoothingSplines(samples, reductionPercent);
        }
      }
    };

    /**
     * Determine the appropriate interpolation type for global linearization
     * @param {Object} linearizationData - The linearization data object
     * @param {string} selectedInterpolationType - User's selected interpolation method
     * @returns {string} Appropriate interpolation type ('linear' or selectedInterpolationType)
     */
    function getGlobalLinearizationInterpolationType(linearizationData, selectedInterpolationType) {
      // If no linearization data, use selected method
      if (!linearizationData) return selectedInterpolationType;
      
      const filename = linearizationData.filename || '';
      const format = linearizationData.format || '';
      
      // Check if data comes from Smart-generated curves (already smooth)
      const hasAICurves = window.loadedQuadData && window.loadedQuadData.curves;
      const hasMultipleAICurves = hasAICurves && Object.keys(window.loadedQuadData.curves).length > 1;
      
      // If multiple Smart Curves exist, use linear to avoid double-smoothing
      if (hasMultipleAICurves) {
      if (DEBUG_LOGS) console.log('DEBUG: Using linear for global linearization (Smart Curves detected)');
        return 'linear';
      }
      
      // Check for measurement data (needs proper smoothing)
      const isMeasurementData = filename.includes('LAB') || 
                               filename.includes('Color Muse') || 
                               filename.includes('Manual-L') || 
                               filename.includes('Sample Data');
      
      if (isMeasurementData) {
      if (DEBUG_LOGS) console.log('DEBUG: Using selected method for global linearization (measurement data detected)');
        return selectedInterpolationType; // Use user's choice (PCHIP/Linear)
      }
      
      // For pre-processed data (.cube, .acv), use selected method
      const isPreprocessed = format === '1DLUT' || format === 'ACV' || filename.includes('.cube');
      if (isPreprocessed) {
      if (DEBUG_LOGS) console.log('DEBUG: Using selected method for global linearization (preprocessed data detected)');
        return selectedInterpolationType;
      }
      
      // Default fallback: use selected method
      if (DEBUG_LOGS) console.log('DEBUG: Using selected method for global linearization (fallback)');
      return selectedInterpolationType;
    }

    /**
     * Apply a LUT to a list of integers using linear, cubic spline, Catmull-Rom, Bezier, or PCHIP interpolation.
     * Preserves the endpoint values - always starts at 0 and ends at the original max value.
     * @param {number[]} values - input integers in [0..maxValue]
     * @param {number[]} lut - samples (floats), typically 0..1
     * @param {number} domainMin - LUT input domain min (typically 0)
     * @param {number} domainMax - LUT input domain max (typically 1)
     * @param {number} maxValue - the maximum value from the original linear ramp
     * @param {string} interpolationType - 'cubic', 'catmull', or 'linear'
     * @returns {number[]} adjusted integer outputs with preserved endpoints
     */
    function apply1DLUT(values, lutOrData, domainMin = 0, domainMax = 1, maxValue = TOTAL, interpolationType = 'cubic', smoothingPercent = 0) {
      // Handle both direct samples array and linearization data object
      let processedLUT, lutX;
      let sourceSpace = DataSpace.normalizeSpace(lutOrData && lutOrData.sourceSpace) || DataSpace.SPACE.PRINTER;
      
      if (DEBUG_LOGS) console.log(`🔍 apply1DLUT DEBUG:`, {
        lutOrDataType: typeof lutOrData,
        isArray: Array.isArray(lutOrData),
        hasGetSmoothingMethod: lutOrData && typeof lutOrData === 'object' && !!lutOrData.getSmoothingControlPoints,
        lutOrDataKeys: lutOrData && typeof lutOrData === 'object' ? Object.keys(lutOrData) : 'N/A',
        samplesLength: Array.isArray(lutOrData) ? lutOrData.length : (lutOrData?.samples?.length || 'N/A'),
        smoothingPercent: smoothingPercent
      });
      
      if (Array.isArray(lutOrData)) {
        // Direct samples array
        if (smoothingPercent > 0) {
          // Apply smoothing using current algorithm
          const simplificationMethod = getSelectedSimplificationMethod();
          processedLUT = CurveSimplification.applySmoothingReduction(lutOrData, smoothingPercent, simplificationMethod);
          const K = processedLUT.length;
          lutX = new Array(K);
          for (let i = 0; i < K; i++) {
            lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
          }
        } else {
          processedLUT = lutOrData;
          const K = processedLUT.length;
          lutX = new Array(K);
          for (let i = 0; i < K; i++) {
            lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
          }
        }
      } else if (lutOrData && typeof lutOrData === 'object' && lutOrData.getSmoothingControlPoints) {
        // Linearization data object with smoothing method
        const controlPoints = lutOrData.getSmoothingControlPoints(smoothingPercent);
        if (controlPoints) {
          // Use sparse control points for interpolation
          processedLUT = controlPoints.samples;
          lutX = controlPoints.xCoords;
          if (controlPoints.sourceSpace) {
            sourceSpace = DataSpace.normalizeSpace(controlPoints.sourceSpace) || sourceSpace;
          }
        } else {
          // Use original full-resolution samples (no smoothing)
          processedLUT = lutOrData.originalSamples || lutOrData.samples;
          const K = processedLUT.length;
          lutX = new Array(K);
          for (let i = 0; i < K; i++) {
            lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
          }
        }
        if (!controlPoints || !controlPoints.sourceSpace) {
          sourceSpace = DataSpace.normalizeSpace(lutOrData.sourceSpace) || sourceSpace;
        }
      } else if (lutOrData && lutOrData.samples) {
        // Linearization data object without smoothing method
        processedLUT = smoothingPercent > 0 ? CurveSimplification.applySmoothingReduction(lutOrData.samples, smoothingPercent, getSelectedSimplificationMethod()) : lutOrData.samples;
        const K = processedLUT.length;
        lutX = new Array(K);
        for (let i = 0; i < K; i++) {
          lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
        }
        sourceSpace = DataSpace.normalizeSpace(lutOrData.sourceSpace) || sourceSpace;
      } else {
        // Fallback
        processedLUT = lutOrData;
        const K = processedLUT.length;
        lutX = new Array(K);
        for (let i = 0; i < K; i++) {
          lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
        }
      }
      
      const K = processedLUT.length;
      if (K < 2) return values; // Not enough points for interpolation

      if (sourceSpace && sourceSpace !== DataSpace.SPACE.PRINTER) {
        const converted = DataSpace.convertSamples(processedLUT, { from: sourceSpace, to: DataSpace.SPACE.PRINTER });
        processedLUT = converted.values;
        sourceSpace = converted.sourceSpace;
      }
      
      // Ensure LUT starts at 0 and we know the end value
      const lutStart = processedLUT[0];
      const lutEnd = processedLUT[K - 1];
      
      let interpolationFunction;
      
      if (interpolationType === 'cubic') {
        // Cubic spline interpolation for smoothest curves - pure interpolation
        interpolationFunction = createCubicSpline(lutX, processedLUT);
      } else if (interpolationType === 'catmull') {
        // Catmull-Rom spline interpolation - passes through control points like GIMP
        const tension = elements.catmullTension.value / 100; // Convert 0-100 to 0-1
        interpolationFunction = createCatmullRomSpline(lutX, processedLUT, tension);
      } else if (interpolationType === 'pchip') {
        // PCHIP interpolation for monotonic, shape-preserving curves
        interpolationFunction = createPCHIPSpline(lutX, processedLUT);
      } else {
        // Linear interpolation for exact point-to-point behavior
        interpolationFunction = (t) => {
          // Handle edge cases
          if (t <= lutX[0]) return processedLUT[0];
          if (t >= lutX[K - 1]) return processedLUT[K - 1];
          
          // Find the correct interval in the potentially non-evenly spaced lutX array
          let i0 = 0;
          for (let i = 0; i < K - 1; i++) {
            if (t >= lutX[i] && t <= lutX[i + 1]) {
              i0 = i;
              break;
            }
          }
          
          const i1 = Math.min(i0 + 1, K - 1);
          const x0 = lutX[i0];
          const x1 = lutX[i1];
          const y0 = processedLUT[i0];
          const y1 = processedLUT[i1];
          
          // Linear interpolation between the two points
          if (x1 === x0) return y0; // Avoid division by zero
          const a = (t - x0) / (x1 - x0);
          return (1 - a) * y0 + a * y1;
        };
      }
      
      const result = values.map((v) => {
        // Forward mapping implementation: Input value → LUT output transformation
        const t = (v / maxValue) * (domainMax - domainMin) + domainMin;
        const lutValue = interpolationFunction(t);
        
        // Scale LUT value directly to maxValue range
        return Math.round(clamp01(lutValue) * maxValue);
      });
      return result;
    }

    const debouncedPreviewUpdate = debounce(updatePreview, 300);

  // Optimized 256 value generation with optional linearization
  function buildBaseCurve(endValue, channelName, smartCurveDetected = false) {
      if (window.loadedQuadData && window.loadedQuadData.curves && window.loadedQuadData.curves[channelName]) {
        const loadedCurve = window.loadedQuadData.curves[channelName];
        if (Math.max(...loadedCurve) === 0) {
          return { values: new Array(N).fill(0), shortCircuit: true };
        }

        let treatAsSmart = smartCurveDetected;
        if (!treatAsSmart) {
          try {
            const curveMax = Math.max(...loadedCurve);
            const baseline = window.loadedQuadData?.baselineEnd?.[channelName];
            if (curveMax >= TOTAL * 0.99 && typeof baseline === 'number' && baseline > 0) {
              treatAsSmart = true;
            }
          } catch {}
        }

        if (treatAsSmart) {
          const scale = endValue / TOTAL;
          return { values: loadedCurve.map(v => Math.round(v * scale)), shortCircuit: false };
        }

        const baseline = (window.loadedQuadData.baselineEnd && window.loadedQuadData.baselineEnd[channelName])
          ? window.loadedQuadData.baselineEnd[channelName]
          : Math.max(...loadedCurve);
        const scale = baseline > 0 ? (endValue / baseline) : 0;
        return { values: loadedCurve.map(v => Math.round(v * scale)), shortCircuit: false };
      }

      const arr = new Array(N);
      const step = endValue / DENOM;
      for (let i = 0; i < N; i++) {
        arr[i] = Math.round(i * step);
      }
      return { values: arr, shortCircuit: false };
    }

    function applyPerChannelLinearizationStep(values, { channelName, endValue, interpolationType, smoothingPercent, smartApplied }) {
      const perEntry = perChannelLinearization[channelName] ? ensurePrinterSpaceData(perChannelLinearization[channelName]) : null;
      if (perEntry && perEntry !== perChannelLinearization[channelName]) {
        perChannelLinearization[channelName] = normalizeLinearizationEntry(perEntry);
      }
      if (channelName && perEntry && perChannelEnabled[channelName] && !smartApplied) {
        return apply1DLUT(values, perEntry, perEntry.domainMin, perEntry.domainMax, endValue, interpolationType, smoothingPercent);
      }
      return values;
    }

    function applyGlobalLinearizationStep(values, { channelName, endValue, applyLinearization, interpolationType, smoothingPercent, smartApplied }) {
      const globalDataCandidate = linearizationData ? ensurePrinterSpaceData(linearizationData) : null;
      if (globalDataCandidate && globalDataCandidate !== linearizationData) {
        linearizationData = normalizeLinearizationEntry(globalDataCandidate);
      }

      const meta = window.loadedQuadData?.keyPointsMeta?.[channelName] || {};
      const bakedGlobal = !!meta.bakedGlobal;
      const shouldSkipGlobal = bakedGlobal || smartApplied;
      if (applyLinearization && linearizationData && linearizationApplied && !shouldSkipGlobal) {
        if (DEBUG_LOGS) console.log('DEBUG: Applying global linearization in make256:', {
          linearizationDataStructure: {
            hasSamples: !!linearizationData.samples,
            samplesCount: linearizationData.samples?.length || 0,
            domainMin: linearizationData.domainMin,
            domainMax: linearizationData.domainMax,
            firstFewSamples: linearizationData.samples?.slice(0, 5) || []
          },
          arrBefore: values.slice(0, 10).concat(['...'], values.slice(-5)),
          arrMin: Math.min(...values),
          arrMax: Math.max(...values)
        });

        const globalInterpolationType = getGlobalLinearizationInterpolationType(linearizationData, interpolationType);
        const result = apply1DLUT(values, linearizationData, linearizationData.domainMin, linearizationData.domainMax, endValue, globalInterpolationType, smoothingPercent);

        if (DEBUG_LOGS) console.log('DEBUG: After applying global linearization:', {
          arrAfter: result.slice(0, 10).concat(['...'], result.slice(-5)),
          arrMin: Math.min(...result),
          arrMax: Math.max(...result),
          hasNaN: result.some(v => isNaN(v)),
          hasInfinity: result.some(v => !isFinite(v))
        });
        return result;
      }
      return values.slice();
    }

    function applyAutoEndpointAdjustments(values, endValue, channelName, smartApplied) {
      try {
        const metaForAuto = window.loadedQuadData?.keyPointsMeta?.[channelName] || {};
        const autoWhiteOn = !!elements?.autoWhiteLimitToggle?.checked;
        const autoBlackOn = !!elements?.autoBlackLimitToggle?.checked;
        const applyWhite = autoWhiteOn && !(smartApplied && metaForAuto.bakedAutoWhite);
        const applyBlack = autoBlackOn && !(smartApplied && metaForAuto.bakedAutoBlack);
        if (applyWhite || applyBlack) {
          return applyAutoEndpointRolloff(values, endValue, channelName, { applyWhite, applyBlack });
        }
        if (window._autoLimitState && channelName) delete window._autoLimitState[channelName];
      } catch (e) {
        if (DEBUG_LOGS) console.warn('Auto endpoint rolloff error:', e);
      }
      return values;
    }

    function make256(endValue, channelName, applyLinearization = false) {
      if (endValue === 0) return new Array(N).fill(0);
      
      if (DEBUG_LOGS) console.log('DEBUG: make256() called:', {
        endValue,
        channelName,
        applyLinearization,
        hasGlobalLinearizationData: !!linearizationData,
        globalLinearizationApplied: linearizationApplied,
        hasPerChannelLinearization: !!perChannelLinearization[channelName]
      });
      
      const smartApplied = (typeof isSmartCurve === 'function') ? isSmartCurve(channelName) : false;
      const base = buildBaseCurve(endValue, channelName, smartApplied);
      if (base.shortCircuit) return base.values;
      let arr = base.values.slice();
      
      const interpolationType = elements.curveSmoothingMethod.value;
      const smoothingPercent = 0; // Smoothing slider deprecated; always off for computation

      arr = applyPerChannelLinearizationStep(arr, { channelName, endValue, interpolationType, smoothingPercent, smartApplied });
      arr = applyGlobalLinearizationStep(arr, { channelName, endValue, applyLinearization, interpolationType, smoothingPercent, smartApplied });
      arr = applyAutoEndpointAdjustments(arr, endValue, channelName, smartApplied);

      return arr;
    }

    // Auto endpoint rolloff (soft knee/toe) utilities
    function applyAutoEndpointRolloff(values, endValue, channelName, options = {}) {
      try {
        const Np = values.length;
        if (Np < 8 || endValue <= 0) return values;
        const applyWhite = !!options.applyWhite;
        const applyBlack = !!options.applyBlack;
        if (!applyWhite && !applyBlack) return values;
        const arr = values.slice();
        const last = Np - 1;

        // Compute slopes (first differences)
        const slopes = new Array(Np).fill(0);
        for (let i = 1; i < Np; i++) slopes[i] = arr[i] - arr[i-1];

        // Median slope around midtones (30–70%) as baseline
        const iLo = Math.floor(0.30 * last), iHi = Math.ceil(0.70 * last);
        const midSlopes = slopes.slice(iLo+1, iHi+1).map(Math.abs).filter(isFinite);
        const midMedian = median(midSlopes) || 0;

        // Thresholds
        const epsY = Math.max(1, Math.round(0.03 * endValue)); // 3% of End (min 1)
        const epsSlope = Math.max(1, Math.round(0.15 * (midMedian || 1))); // 15% of mid median
        const sustain = 4; // sustained samples
        const minWidthIdx = Math.round(0.05 * last); // 5% domain

        if (DEBUG_LOGS) console.log('[AUTO LIMIT] begin', {
          channelName,
          Np,
          endValue,
          epsY,
          epsSlope,
          sustain,
          minWidthIdx,
          arrHead: arr.slice(0,8), arrTail: arr.slice(-8)
        });

        let whiteStart = null;
        if (applyBlack) {
          // Scan last 10%
          const startScanW = Math.max(1, Math.floor(0.80 * last));
          for (let i = startScanW; i <= last - sustain; i++) {
            const nearCap = (endValue - arr[i]) <= epsY;
            if (!nearCap) continue;
            // Rolling low slope sustain
            let ok = true;
            for (let k = 0; k < sustain; k++) {
              if (Math.abs(slopes[i + k]) > epsSlope) { ok = false; break; }
            }
            if (ok) { whiteStart = i; break; }
          }
        }

        let blackEnd = null;
        if (applyWhite) {
          // Scan first 10%
          const endScanB = Math.min(last-1, Math.ceil(0.10 * last));
          for (let j = endScanB; j >= sustain; j--) {
            const nearFloor = arr[j] <= epsY;
            if (!nearFloor) continue;
            let ok = true;
            for (let k = 0; k < sustain; k++) {
              if (Math.abs(slopes[j - k]) > epsSlope) { ok = false; break; }
            }
            if (ok) { blackEnd = j; break; }
          }
        }

        if (DEBUG_LOGS) console.log('[AUTO LIMIT] detected indices', { whiteStart, blackEnd });

        // Apply soft shoulder for white end
        let whiteWidth = 0;
        if (applyBlack && whiteStart != null) {
          // Backtrack to ensure y0 is meaningfully below End (avoid degenerate knee)
          let ws = whiteStart;
          const backLimit = Math.max(0, ws - Math.round(0.10 * last)); // search up to 10% back
          while (ws > backLimit && (endValue - arr[ws]) < epsY) ws--;
          if ((endValue - arr[ws]) >= epsY) whiteStart = ws;
          // Fallback: if still too close to End, force a start earlier than the first near-cap crossing
          if ((endValue - arr[whiteStart]) < epsY) {
            const capThresh = Math.max(Math.round(0.02 * endValue), 2 * epsY); // ≥2% or 2×epsY
            let firstCross = last;
            for (let i = Math.floor(0.70 * last); i <= last; i++) { if ((endValue - arr[i]) <= epsY) { firstCross = i; break; } }
            let forced = Math.max(1, firstCross - Math.round(0.05 * last));
            while (forced > 1 && (endValue - arr[forced]) < capThresh) forced--;
            whiteStart = Math.max(1, Math.min(whiteStart, forced));
          }
          const width = last - whiteStart;
            const debugBefore = DEBUG_LOGS ? arr.slice(Math.max(0, whiteStart - 2), Math.min(last + 1, whiteStart + Math.max(6, Math.round(0.2 * width)))) : null;
          if (width >= Math.max(3, minWidthIdx)) {
            // Ensure the join value is not below the left neighbor to keep monotone
            const y0 = Math.max(arr[whiteStart], arr[Math.max(0, whiteStart - 1)] || 0);
            const m0 = Math.max(0, slopes[Math.max(1, whiteStart)]); // incoming slope
            const m1 = 0; // flat at the endpoint
            const W = (last - whiteStart) || 1;
            // C1-continuous cubic Hermite shoulder
            for (let i = whiteStart; i <= last; i++) {
              const t = (i - whiteStart) / W;
              const t2 = t * t, t3 = t2 * t;
              const h00 = 2*t3 - 3*t2 + 1;
              const h10 = t3 - 2*t2 + t;
              const h01 = -2*t3 + 3*t2;
              const h11 = t3 - t2;
              let y = h00 * y0 + h10 * m0 * W + h01 * endValue + h11 * m1 * W;
              y = Math.max(0, Math.min(endValue, y));
              const prev = (i > 0) ? arr[i-1] : 0;
              arr[i] = Math.max(prev, Math.round(y)); // enforce monotone non-decreasing
            }
            whiteWidth = Math.round((width / last) * 1000) / 10; // percentage with 0.1 precision
            if (DEBUG_LOGS) {
              const debugAfter = arr.slice(Math.max(0, whiteStart - 2), Math.min(last + 1, whiteStart + Math.max(6, Math.round(0.2 * width))));
              console.log('[AUTO LIMIT] black segment', { startIndex: whiteStart, width, before: debugBefore, after: debugAfter });
            }
          } else {
            if (DEBUG_LOGS) console.log('[AUTO LIMIT] white knee too narrow, skipping', { whiteStart, width, minWidthIdx });
          }
        }

        // Apply soft toe for black end
        let blackWidth = 0;
        if (applyWhite && blackEnd != null) {
          // Advance to ensure y1 is meaningfully above 0 (avoid degenerate toe)
          let be = blackEnd;
          const fwdLimit = Math.min(last, be + Math.round(0.10 * last));
          while (be < fwdLimit && arr[be] < epsY) be++;
          if (arr[be] >= epsY) blackEnd = be;
          // Fallback: if still near 0, force a later join beyond the floor crossing
          if (arr[blackEnd] < epsY) {
            const floorThresh = Math.max(Math.round(0.02 * endValue), 2 * epsY);
            let lastFloor = 0;
            for (let i = Math.ceil(0.30 * last); i >= 0; i--) { if (arr[i] <= epsY) { lastFloor = i; break; } }
            let forced = Math.min(last - 1, lastFloor + Math.round(0.05 * last));
            while (forced < last - 1 && arr[forced] < floorThresh) forced++;
            blackEnd = Math.min(blackEnd, forced);
          }
          const width = blackEnd - 0;
          const debugBeforeB = DEBUG_LOGS ? arr.slice(Math.max(0, blackEnd - Math.max(6, Math.round(0.2 * width))), Math.min(last + 1, blackEnd + 2)) : null;
          if (width >= Math.max(3, minWidthIdx)) {
            const y1 = arr[blackEnd];
            const m0 = 0; // slope 0 at x=0
            // outgoing slope at the join (use forward diff if possible)
            const m1 = Math.max(0, slopes[Math.max(1, blackEnd)]);
            const W = Math.max(1, blackEnd - 0);
            for (let i = 0; i <= blackEnd; i++) {
              const t = i / W;
              const t2 = t * t, t3 = t2 * t;
              const h00 = 2*t3 - 3*t2 + 1;
              const h10 = t3 - 2*t2 + t;
              const h01 = -2*t3 + 3*t2;
              const h11 = t3 - t2;
              let y = h00 * 0 + h10 * m0 * W + h01 * y1 + h11 * m1 * W;
              y = Math.max(0, Math.min(endValue, y));
              // Raise toward y but do not exceed the later segment
              const next = (i < last) ? arr[Math.min(last, i+1)] : y;
              arr[i] = Math.min(Math.max(arr[i], Math.round(y)), next);
            }
            blackWidth = Math.round((width / last) * 1000) / 10;
            if (DEBUG_LOGS) {
              const debugAfterB = arr.slice(Math.max(0, blackEnd - Math.max(6, Math.round(0.2 * width))), Math.min(last + 1, blackEnd + 2));
              console.log('[AUTO LIMIT] white segment', { endIndex: blackEnd, width, before: debugBeforeB, after: debugAfterB });
            }
          } else {
            if (DEBUG_LOGS) console.log('[AUTO LIMIT] black toe too narrow, skipping', { blackEnd, width, minWidthIdx });
          }
        }

        // Record meta for UI labels
        try {
          if (!window._autoLimitState) window._autoLimitState = {};
          const meta = { debug: { epsY, epsSlope, sustain, minWidthIdx, whiteStart, blackEnd } };
          // Store printer-space semantics: right-side = black, left-side = white
          if (applyBlack && whiteStart != null && whiteWidth > 0) meta.black = { startIndex: whiteStart, widthPercent: whiteWidth };
          if (applyWhite && blackEnd != null && blackWidth > 0) meta.white = { endIndex: blackEnd, widthPercent: blackWidth };
          if (channelName) {
            if (Object.keys(meta).length > 0) window._autoLimitState[channelName] = meta;
            else if (window._autoLimitState[channelName]) delete window._autoLimitState[channelName];
          }
          if (DEBUG_LOGS && channelName) console.log('[AUTO LIMIT] result', channelName, meta);
        } catch {}

        return arr;
      } catch { return values; }
    }

    function median(arr){
      try {
        const a = arr.slice().sort((x,y)=>x-y);
        const n = a.length; if (!n) return 0;
        const m = Math.floor(n/2);
        return (n%2) ? a[m] : 0.5*(a[m-1]+a[m]);
      } catch { return 0; }
    }

    

    // Extract channel row creation
    function createChannelRow(name, printerKey) {
      // Set default values based on printer and channel
      let defaultPercent = 0; // Default to disabled
      let channelEnabled = false; // Default to disabled

      // Preferred default channel selection: prefer MK if available, otherwise K
      const cfg = PRINTERS[printerKey] || { channels: [] };
      const hasMK = Array.isArray(cfg.channels) && cfg.channels.includes('MK');
      const preferredDefault = hasMK ? 'MK' : 'K';
      if (name === preferredDefault) {
        defaultPercent = 100;
        channelEnabled = true;
      }
      
      const defaultEndValue = InputValidator.computeEndFromPercent(defaultPercent);
      
      const tr = document.createElement('tr');
      tr.className = "border-t border-gray-200 channel-row";
      tr.setAttribute('data-channel', name);
      tr.innerHTML = `
        <td class=\"p-0 text-center\" style=\"width:0;\">
        </td>
        <td class=\"px-1 pt-2 pb-1 font-medium align-middle text-left\" style=\"width: 100px;\">
          <span class=\"flex items-center gap-2 w-full\">
            <span class=\"inline-block w-3.5 h-3.5 rounded-sm border border-black/10 flex-shrink-0\" style=\"background-color: ${INK_COLORS[name] || '#000'}\"></span>
            <span class=\"w-8 channel-name\">${name}</span>
            <span class=\"text-xs text-gray-500 invisible\" data-disabled>(disabled)</span>
          </span>
        </td>
        <td class="px-1 pt-2 pb-1 text-center" style="width: 250px;">
          <div class="inline-flex items-center gap-2">
            <input type="file" id="perChannel_${name}" accept=".cube,.txt,.acv" class="hidden per-channel-file">
            <button class="per-channel-btn px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded transition-colors font-bold" data-channel="${name}" data-tooltip="Load LUT.cube, LABdata.txt, or .acv curve files">load file</button>
            <label class="slider-toggle" title="Enable/disable per-channel linearization">
              <input type="checkbox" class="per-channel-toggle" data-channel="${name}" disabled>
              <span class="slider"></span>
            </label>
          </div>
        </td>
        <td class="px-1 pt-2 pb-1 align-middle text-left">
          <span class="inline-flex items-center">
            <span class="text-sm text-blue-600 mr-1" title="Processing details">ⓘ</span>
            <span class="processing-label italic font-normal text-xs text-gray-600 min-w-0" data-channel="${name}" style="white-space: pre-wrap; word-break: break-word;"></span>
          </span>
        </td>
        <td class="pr-0 pt-2 pb-1 text-right" style="width:120px;">
          <input type="number" step="1" min="0" max="100" value="${defaultPercent}" class="percent-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
        <td class="pl-0 pt-2 pb-1 text-right" style="width:120px;">
          <input type="number" step="1" min="0" max="65535" value="${defaultEndValue}" class="end-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
      `;
      
      return tr;
    }

    function setupChannelRow(tr) {
      const percentInput = tr.querySelector('.percent-input');
      const endInput = tr.querySelector('.end-input');
      const disabledTag = tr.querySelector('[data-disabled]');
      // Create virtual checkbox object since physical checkbox is removed
      // Chips section now handles enable/disable, but we need compatibility with existing logic
      const enableCheckbox = {
        checked: !tr.hasAttribute('data-user-disabled'),
        addEventListener: function(event, handler) {
          // Store the handler for later use by chips
          tr._checkboxChangeHandler = handler;
        },
        dispatchEvent: function(event) {
          if (tr._checkboxChangeHandler && event.type === 'change') {
            tr._checkboxChangeHandler();
          }
        }
      };
      // Store virtual checkbox on tr for chips access
      tr._virtualCheckbox = enableCheckbox;
      const channelName = tr.dataset.channel;
      registerChannelRow(channelName, tr);
      const perChannelBtn = tr.querySelector('.per-channel-btn');
      const perChannelFile = tr.querySelector('.per-channel-file');
      const perChannelToggle = tr.querySelector('.per-channel-toggle');

      // Add per-channel Revert button next to the Load button if not present
      try {
        const btnGroup = perChannelBtn?.parentElement;
        if (btnGroup && !btnGroup.querySelector('.per-channel-revert')){
          const btn = document.createElement('button');
          btn.className = 'per-channel-revert px-2 py-1 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed';
          btn.textContent = 'Revert';
          // Title is updated dynamically based on measurement vs smart in refreshDisplay/updateRevertButtonsState
          btn.title = `Revert / Clear Smart`;
          btn.addEventListener('click', () => {
            const savedSel = (isEditModeEnabled() && typeof EDIT !== 'undefined' && EDIT && EDIT.selectedChannel) ? EDIT.selectedChannel : null;

            // Set flag to prevent ensureEditableKeyPointsForChannel from restoring data during revert
            window._REVERT_IN_PROGRESS = true;

            try { CurveHistory.captureState(`Before: Revert ${channelName} to Measurement`); } catch {}
            // Clear Smart curve and points for this channel
            try {
              const hasSmart = (typeof isSmartCurve === 'function') ? isSmartCurve(channelName) : false;

              // Always clear Smart metadata when reverting, regardless of hasSmart check
              // This ensures we clear any lingering key points that might not be detected by isSmartCurve
              if (window.loadedQuadData?.keyPoints?.[channelName]) delete window.loadedQuadData.keyPoints[channelName];
              if (window.loadedQuadData?.keyPointsMeta?.[channelName]) delete window.loadedQuadData.keyPointsMeta[channelName];
              if (window.loadedQuadData?.sources?.[channelName]) delete window.loadedQuadData.sources[channelName];

              if (hasSmart) {
                // Attempt to restore the prior curve (likely the loaded .quad) from history
                let restored = false;
                try {
                  const orig = window.loadedQuadData?.originalCurves?.[channelName];
                  if (Array.isArray(orig) && orig.length === 256) {
                    if (!window.loadedQuadData) window.loadedQuadData = {};
                    if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                    window.loadedQuadData.curves[channelName] = [...orig];
                    restored = true;
                  }
                } catch {}
                // If we couldn't restore from history and a curve exists, leave it as-is; otherwise fall back to no curve
                if (!restored && window.loadedQuadData?.curves?.[channelName]) {
                  // keep existing curve
                }
              }
            } catch {}
            const hasMeasNow = !!perChannelLinearization[channelName];
            // Re-enable per-channel measurement if available; otherwise clear Smart UI state
              if (hasMeasNow) {
                perChannelEnabled[channelName] = true;
                if (perChannelToggle) { perChannelToggle.disabled = false; perChannelToggle.checked = true; }
                try { perChannelLinearization[channelName].edited = false; } catch {}
                refreshPerChannelLinearizationDisplay(channelName);
              } else {
                if (perChannelToggle) { perChannelToggle.disabled = false; perChannelToggle.checked = false; }
              }
            // Refresh row UI to drop any Smart-specific visuals
            try { if (tr.refreshDisplayFn) tr.refreshDisplayFn(); } catch {}
            updateInterpolationControls();
            // Force immediate update of processing detail to reflect cleared Smart curve status
            setTimeout(() => {
              updateProcessingDetailForce(channelName);
              debouncedPreviewUpdate();
            }, 0);
            try {
              if (hasMeasNow) showStatus(`Reverted ${channelName} to measurement`);
              else showStatus(`Cleared Smart on ${channelName} (restored loaded .quad)`);
            } catch {}
            try { updateRevertButtonsState(); } catch {}
            // Restore prior selection if still enabled
            try {
              if (savedSel && isEditModeEnabled()) {
                const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === savedSel);
                const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                if (endVal > 0) {
                  if (elements.editChannelSelect) elements.editChannelSelect.value = savedSel;
                  EDIT.selectedChannel = savedSel;
                  edit_refreshState();
                  updateInkChart();
                }
              }
            } catch {}

            // Clear the revert flag
            window._REVERT_IN_PROGRESS = false;
          });
          // Initialize disabled state based on whether a measurement is loaded for this channel
          try {
            const hasMeas = !!perChannelLinearization[channelName];
            const hasSmart = (typeof isSmartCurve === 'function') ? isSmartCurve(channelName) : false;
            btn.disabled = !(hasMeas || hasSmart);
            if (!btn.disabled) btn.title = hasMeas ? `Revert ${channelName} to measurement source` : `Clear Smart (restore loaded .quad)`;
            // Reserve space: hide visually but keep layout when disabled
            btn.classList.toggle('invisible', btn.disabled);
          } catch {}
          btnGroup.appendChild(btn);
        }
      } catch {}

      function refreshDisplay() {
        const endVal = InputValidator.clampEnd(endInput.value);
        endInput.value = String(endVal);
        
        const isUserDisabled = tr.hasAttribute('data-user-disabled');
        const isAtZero = endVal === 0;
        const percentValue = InputValidator.clampPercent(percentInput.value);
        
        // Show disabled label if channel is at 0 (either user-disabled or set to 0%)
        disabledTag.classList.toggle('invisible', !isAtZero);
        
        // Update per‑channel Revert button enable/title (measurement or smart present)
        try {
          const btn = tr.querySelector('.per-channel-revert');
          if (btn) {
            const hasMeas = !!perChannelLinearization[channelName];
            const hasSmart = (typeof isSmartCurve === 'function') ? isSmartCurve(channelName) : false;
            btn.disabled = !(hasMeas || hasSmart);
            if (!btn.disabled) btn.title = hasMeas ? `Revert ${channelName} to measurement source` : `Clear Smart (restore loaded .quad)`;
            btn.classList.toggle('invisible', btn.disabled);
          }
        } catch {}

        // Handle ultra-compact layout for disabled channels
        if (isAtZero) {
          // Hide from main table and show in compact view
          tr.setAttribute('data-compact', 'true');
          updateCompactChannelsList();
        } else {
          // Show in main table and remove from compact view
          tr.setAttribute('data-compact', 'false');
          updateCompactChannelsList();
          
          // Update normal table row styling for enabled channels
          const channelLabel = tr.querySelector('td:nth-child(2) span');
          channelLabel.style.opacity = '1';
          
          // Restore all visual states for enabled channels
          const linearizationCell = tr.querySelector('td:nth-child(3)');
          const percentCell = tr.querySelector('td:nth-child(4)');
          const endCell = tr.querySelector('td:nth-child(5)');
          
          linearizationCell.style.visibility = 'visible';
          percentCell.style.opacity = '1';
          endCell.style.opacity = '1';
        }
        
        // Update checkbox state based on channel status
        enableCheckbox.checked = !isAtZero;
      }
      
      // Store refreshDisplay function on the tr element for access from apply functions
      tr.refreshDisplayFn = refreshDisplay;

      // Initial refresh to set up display state
      refreshDisplay();

      // Channel enable/disable checkbox functionality
      const handleCheckboxChange = () => {
        const currentEndVal = InputValidator.clampEnd(endInput.value);
        const currentPercentVal = InputValidator.clampPercent(percentInput.value);
        const channelName = tr.dataset.channel;
        
        
        // Record the individual channel action only if not during batch operation
        if (!CurveHistory.isBatchOperation) {
          const actionType = enableCheckbox.checked ? 'enable' : 'disable';
          const oldValue = !enableCheckbox.checked; // Previous state (opposite of current)
          const newValue = enableCheckbox.checked;   // Current state
          CurveHistory.recordChannelAction(channelName, actionType, oldValue, newValue);
        }
        
        if (enableCheckbox.checked) {
          // Enable: restore previous values or default to 100%
          const previousValues = channelPreviousValues[channelName];
          
          if (previousValues && previousValues.percent > 0) {
            // Restore previous values
            percentInput.value = previousValues.percent.toString();
            endInput.value = previousValues.endValue.toString();
            showStatus(`Enabled ${channelName} (restored to ${previousValues.percent}%)`);
          } else {
            // Default to 100% if no previous value stored
            percentInput.value = '100';
            endInput.value = String(InputValidator.computeEndFromPercent(100));
            showStatus(`Enabled ${channelName} (set to default 100%)`);
          }
          
          tr.removeAttribute('data-user-disabled'); // Mark as not disabled by user
        } else {
          // Disable: store current values first, then set to 0
          channelPreviousValues[channelName] = {
            percent: currentPercentVal,
            endValue: currentEndVal
          };
          
          percentInput.value = '0';
          endInput.value = '0';
          tr.setAttribute('data-user-disabled', 'true'); // Mark as disabled by user
          showStatus(`Disabled ${channelName} (saved ${currentPercentVal}% for restore)`);
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
        try { if (elements.rows) elements.rows.dispatchEvent(new Event('channelsChanged', { bubbles: true })); } catch {}
      };
      
      enableCheckbox.addEventListener('change', handleCheckboxChange);

      // Track input changes with debounced action recording
      let percentHistoryTimeout = null;
      let endHistoryTimeout = null;
      let oldPercentValue = percentInput.value; // Store initial value
      let oldEndValue = endInput.value; // Store initial value
      
      const debouncedPercentActionRecord = (newValue) => {
        clearTimeout(percentHistoryTimeout);
        percentHistoryTimeout = setTimeout(() => {
          // Only record if the value actually changed and not during batch operation
          if (oldPercentValue !== newValue && !CurveHistory.isBatchOperation) {
            CurveHistory.recordChannelAction(channelName, 'percentage', oldPercentValue, newValue);
            oldPercentValue = newValue; // Update for next change
            // Also announce the change to the user
            const pct = parseFloat(newValue);
            if (!isNaN(pct)) {
              showStatus(`${channelName} ink limit changed to ${pct.toFixed(1)}%`);
            }
          }
        }, 1000); // Record action 1 second after user stops typing
      };
      
      const debouncedEndActionRecord = (newValue) => {
        clearTimeout(endHistoryTimeout);
        endHistoryTimeout = setTimeout(() => {
          // Only record if the value actually changed and not during batch operation
          if (oldEndValue !== newValue && !CurveHistory.isBatchOperation) {
            CurveHistory.recordChannelAction(channelName, 'end', oldEndValue, newValue);
            oldEndValue = newValue; // Update for next change
            // Also announce the change to the user (convert end ⇒ percent)
            const e = parseInt(newValue, 10);
            if (!isNaN(e)) {
              const pct = InputValidator.computePercentFromEnd(e);
              showStatus(`${channelName} ink limit changed to ${pct.toFixed(1)}%`);
            }
          }
        }, 1000); // Record action 1 second after user stops typing
      };

      // Use debounced updates to prevent excessive recalculations
      percentInput.addEventListener('input', () => {
        const newValue = percentInput.value;
        debouncedPercentActionRecord(newValue); // Record action after typing stops
        
        const p = InputValidator.validateInput(percentInput, InputValidator.clampPercent);
        const endVal = InputValidator.computeEndFromPercent(p);
        endInput.value = String(endVal);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (endVal > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (endVal > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: endVal
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      endInput.addEventListener('input', () => {
        const newValue = endInput.value;
        debouncedEndActionRecord(newValue); // Record action after typing stops
        
        const e = InputValidator.validateInput(endInput, InputValidator.clampEnd);
        const p = InputValidator.computePercentFromEnd(e);
        percentInput.value = p.toFixed(1);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (e > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (e > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: e
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      // Per-channel linearization button
      perChannelBtn.addEventListener('click', () => {
        perChannelFile.click();
      });
      
      // Per-channel file upload
      perChannelFile.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
          // Capture state before loading per-channel linearization for proper undo/redo pairing
          CurveHistory.captureState(`Before: Load Per-Channel Linearization (${channelName})`);
          // Per-channel supports curves (.cube), LAB data (.txt), and Photoshop curves (.acv)
          const extension = file.name.toLowerCase().split('.').pop();
          let fileInput;
          if (extension === 'acv') {
            fileInput = await file.arrayBuffer();
          } else {
            fileInput = await file.text();
          }
          const parsed = await parseLinearizationFile(fileInput, file.name);
          parsed.edited = false;
          perChannelLinearization[channelName] = normalizeLinearizationEntry(parsed);
          perChannelEnabled[channelName] = true;
          perChannelFilenames[channelName] = file.name;
          
          // Enable and check toggle
          perChannelToggle.disabled = false;
          perChannelToggle.checked = true;
          
          // Update button tooltip with filename (respect edited flag)
          refreshPerChannelLinearizationDisplay(channelName);
          
          // Note: No auto-smoothing; base samples come from the chosen source. Smoothing is optional via slider.
          
          // Update interpolation controls since we now have linearization data
          updateInterpolationControls();
          
          // Show appropriate status message based on LUT type
          if (parsed.is3DLUT) {
            showStatus(`Loaded 3D LUT and extracted ${parsed.samples.length} neutral axis points for ${channelName} (${parsed.lutSize}³ grid)`);
          } else {
          // Append small method note for LAB/Manual L* datasets
          let methodNote = '';
          try {
            const fmtLower = String(parsed.format || '').toLowerCase();
            if (fmtLower.includes('lab') || fmtLower.includes('manual')) {
              methodNote = ' (CIE density; Gaussian-weighted reconstruction with PCHIP interpolation)';
            }
          } catch {}
          showStatus(`Loaded per-channel correction for ${channelName}: ${parsed.samples.length} points${methodNote}`);
          }
          debouncedPreviewUpdate();
          // Capture an after-state so undo/redo works for per-channel loads as well
          try { CurveHistory.captureState(`After: Load Per-Channel Linearization (${channelName})`); } catch {}
          // No intent mismatch warning (Positive-only workflow)
          
          // Update processing detail for this channel
          updateProcessingDetail(channelName);
        } catch (error) {
          console.error('Per-channel linearization file error:', error);
          showStatus(`Error loading ${channelName} linearization: ${error.message}`);
          
          // Reset state on error
          delete perChannelLinearization[channelName];
          delete perChannelFilenames[channelName];
          perChannelEnabled[channelName] = false;
          perChannelToggle.disabled = true;
          perChannelToggle.checked = false;
          
          // Reset button tooltip
          perChannelBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
          
          // Update interpolation controls since linearization may no longer be available
          updateInterpolationControls();
        }
      });
      
      // Per-channel toggle slider
      perChannelToggle.addEventListener('change', (e) => {
        if (perChannelLinearization[channelName]) {
          perChannelEnabled[channelName] = e.target.checked;
          if (perChannelEnabled[channelName]) {
            showStatus(`Enabled per-channel linearization for ${channelName}`);
          } else {
            showStatus(`Disabled per-channel linearization for ${channelName}`);
          }
          
          // Update filename to reflect current state
          updateFilename();
          
          // Update processing detail for this channel
          updateProcessingDetail(channelName);
          
          debouncedPreviewUpdate();
        }
      });
      
      // Initialize per-channel state
      perChannelEnabled[channelName] = false;
      
      // Initial sync
      const initialP = InputValidator.clampPercent(percentInput.value);
      percentInput.value = initialP.toString();
      endInput.value = String(InputValidator.computeEndFromPercent(initialP));
      refreshDisplay();
      // Populate the always-visible processing label
      updateProcessingDetail(channelName);
    }

    // Optimized setPrinter with DocumentFragment
    function setPrinter(key) {
      try {
        // Clear loaded quad data when switching printers (unless we're switching due to a quad load)
        if (!window.loadedQuadData || window.loadedQuadData.switchingPrinter !== true) {
          clearLoadedQuadData();
        }
        
        const p = PRINTERS[key];
        const fragment = document.createDocumentFragment();
        channelRowCache.clear();
        
        p.channels.forEach(ch => {
          const tr = createChannelRow(ch, key);
          tr.dataset.channel = ch; // Add channel name to dataset
          fragment.appendChild(tr);
        });
        
        // Clear and update DOM in one operation
        elements.rows.innerHTML = "";
        elements.rows.appendChild(fragment);
        
        // Add the no channels placeholder row with exact column structure
        const noChannelsRow = document.createElement('tr');
        noChannelsRow.id = 'noChannelsRow';
        noChannelsRow.className = 'hidden border-t border-gray-200';
        noChannelsRow.innerHTML = `
          <td class="p-0 text-center" style="width:0;">
          </td>
          <td class="px-1 pt-2 pb-1 font-medium" style="width: 100px;">
            <span class="inline-flex items-center gap-2 invisible">
              <span class="inline-block w-3.5 h-3.5 rounded-sm border border-black/10"></span>
              <span class="w-8 channel-name">XX</span>
              <span class="text-xs text-gray-500 invisible">(disabled)</span>
            </span>
            <div class="text-center text-gray-500 italic" style="margin-top: -24px;">No channels enabled</div>
          </td>
          <td class="px-1 pt-2 pb-1 text-center" style="width: 250px;">
            <div class="inline-flex items-center gap-2 invisible">
              <input type="file" class="hidden per-channel-file">
              <button class="px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded transition-colors font-bold">
                📁 Load
              </button>
              <span class="text-xs text-gray-500">No file</span>
            </div>
          </td>
          <td class="px-1 pt-2 pb-1 text-left">
            <span class="text-xs text-gray-500 invisible">—</span>
          </td>
          <td class="pr-0 pt-2 pb-1 text-right" style="width:120px;">
            <input type="number" step="1" min="0" max="100" value="100" class="percent-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right invisible" disabled>
          </td>
          <td class="pl-0 pt-2 pb-1 text-right" style="width:120px;">
            <input type="number" step="1" min="0" max="65535" value="65535" class="end-input w-20 m-0 rounded-lg border border-gray-300 px-2 py-1 text-right invisible" disabled>
          </td>
        `;
        elements.rows.appendChild(noChannelsRow);
        try { updateRevertButtonsState(); } catch {}
        
        // Setup event listeners after DOM update
        Array.from(elements.rows.children).forEach(tr => {
          // Skip the placeholder row when setting up channel rows
          if (tr.id !== 'noChannelsRow') {
            setupChannelRow(tr);
          }
        });

        // Update compact channels display
        setTimeout(() => updateCompactChannelsList(), 100);

        // Repopulate Edit Curves channel dropdown to reflect new printer
        setTimeout(() => { try { edit_populateChannelSelect(); } catch {} }, 0);

        elements.channelInfo.innerHTML = "Channels: " + p.channels.map(ch => {
          const color = INK_COLORS[ch] || '#000000';
          return `<span class=\"inline-flex items-center mr-1\"><span style=\"color:${color}; margin-right:0px;\">■</span><strong>${ch}</strong></span>`;
        }).join("");
        elements.printerDescription.innerHTML = "";
        
        // Use requestAnimationFrame for smooth UI update
        requestAnimationFrame(() => {
          updatePreview();
          updateInkChart();
          updateFilename(); // Update filename when printer changes
        });
        showStatus(`Switched to ${p.name}`);
      } catch (error) {
        console.error('Error setting printer:', error);
        showStatus("Error changing printer");
      }
    }

    function buildLimitsSummary() {
      const lines = ["# Limits summary:"];
      
      Array.from(elements.rows.children).forEach((tr) => {
        // Skip the placeholder row
        if (tr.id === 'noChannelsRow') return;
        
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const e = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        const p = InputValidator.computePercentFromEnd(e);
        
        if (e === 0) {
          lines.push("#   " + name + ": disabled");
        } else {
          const isWhole = Math.abs(p - Math.round(p)) < 1e-9;
          const percentFormatted = isWhole ? String(Math.round(p)) : p.toFixed(1);
          lines.push("#   " + name + ": = " + percentFormatted + "%");
        }
      });
      
      return lines;
    }

    function buildFile() {
      const p = PRINTERS[elements.printerSelect.value];
      const lines = [
        "## QuadToneRIP " + p.channels.join(","),
        "# Printer: " + p.name,
        `# quadGEN ${APP_VERSION} by David Marsh`
      ];
      // Positive-only workflow: no Print Intent annotation
      
      // Add user notes if provided
      const userNotes = elements.userNotes.value.trim();
      if (userNotes) {
        lines.push("#");
        lines.push("# Notes:");
        // Split notes by lines and add # prefix to each non-empty line
        userNotes.split('\n').forEach(line => {
          const t = line.trim();
          lines.push(t ? ("# " + t) : "#");
        });
      }
      
      // Add linearization information
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      if (hasLinearization) {
        lines.push("#");
        lines.push("# Linearization Applied:");
        
        // Global linearization
        if (linearizationData && linearizationApplied) {
        const globalFilename = getEditedDisplayName(linearizationData.filename || "unknown file", !!linearizationData.edited);
        const globalCount = getBasePointCountLabel(linearizationData);
        lines.push(`# - Global: ${globalFilename} (${globalCount}, affects all channels)`);
          // Contrast intent annotation (compact but readable)
          try {
            const id = String(contrastIntent?.id || 'linear');
            let intentLine = '#   Intent: ';
            if (id === 'linear') intentLine += 'Linear';
            else if (id === 'soft' || id === 'hard' || id === 'custom_gamma') {
              const g = Number(contrastIntent?.params?.gamma ?? (getPresetDefaults(id, 'gamma') || 1.00));
              intentLine += `Gamma ${isFinite(g)?g.toFixed(2):'1.00'}`;
            } else if (id === 'filmic' || id === 'custom_filmic') {
              const gain = Number(contrastIntent?.params?.filmicGain ?? contrastIntent?.params?.gain ?? 0.55);
              const shoulder = Number(contrastIntent?.params?.shoulder ?? 0.35);
              intentLine += `Filmic (gain ${isFinite(gain)?gain.toFixed(2):'0.55'}, shoulder ${isFinite(shoulder)?shoulder.toFixed(2):'0.35'})`;
            } else if (id === 'pops_standard') intentLine += 'POPS‑Compat (Standard)';
            else if (id === 'custom_points') intentLine += 'Custom';
            else intentLine += id;
            lines.push(intentLine);
            // Also add compact tag used in filename
            lines.push(`#   Intent tag: ${getIntentFilenameTag()}`);
          } catch {}
        }
        
        // Per-channel linearization
        const perChannelList = [];
        Object.keys(perChannelLinearization).forEach(channelName => {
          if (perChannelEnabled[channelName]) {
            const data = perChannelLinearization[channelName] || {};
            const baseName = perChannelFilenames[channelName] || "unknown file";
            const editedFlag = !!(perChannelLinearization[channelName] && perChannelLinearization[channelName].edited);
            const filename = getEditedDisplayName(baseName, editedFlag);
            const countLabel = getBasePointCountLabel(data);
            const measuredSuffix = data.measurementIntent ? ` (measured: ${data.measurementIntent})` : '';
            perChannelList.push(`${channelName}: ${filename} (${countLabel})${measuredSuffix}`);
          }
        });
        
        if (perChannelList.length > 0) {
          lines.push("# - Per-channel:");
          perChannelList.forEach(item => {
            lines.push(`#   ${item}`);
          });
        }
        
        // (Interpolation details removed from exported comments)
      }
      
      // Visually separate preceding sections from the limits summary
      lines.push("#");
      lines.push(...buildLimitsSummary());

      // Build channel blocks efficiently
      p.channels.forEach((ch, idx) => {
        const row = elements.rows.children[idx];
        const e = InputValidator.clampEnd(row.querySelector('.end-input').value);
        const arr = make256(e, ch, true); // Apply linearization if enabled
        lines.push("# " + ch + " curve");
        lines.push(...arr.map(String));
      });

      return lines.join("\n") + "\n";
    }

    


    // Undo button event handler
    document.getElementById('undoBtn').addEventListener('click', () => {
      const result = CurveHistory.undo();
      if (!result.success) {
        showStatus(`Undo failed: ${result.message}`);
      }
    });

    // Redo button event handler
    document.getElementById('redoBtn').addEventListener('click', () => {
      const result = CurveHistory.redo();
      if (!result.success) {
        showStatus(`Redo failed: ${result.message}`);
      }
    });

    // Download with enhanced error handling
    elements.downloadBtn.addEventListener('click', () => {
      try {
        const text = buildFile();
        const p = PRINTERS[elements.printerSelect.value];
        
        // Get custom filename or use default
        let filename;
        const customName = elements.filenameInput.value.trim();
        if (customName) {
          // Remove .quad extension if user added it, then sanitize
          const cleanName = customName.replace(/\.quad$/, '');
          const sanitizedName = sanitizeFilename(cleanName);
          
          // If sanitization removed everything, fall back to default (sanitized printer name)
          if (!sanitizedName) {
            const defaultBase = sanitizeFilename(p.name.replace(/\s+/g, '')) || 'quadGEN';
            filename = defaultBase + "_linear.quad";
            showStatus("Invalid filename, using default");
          } else {
            filename = sanitizedName + '.quad';
            
            // Show warning if filename was changed
            if (sanitizedName !== cleanName) {
              showStatus(`Filename sanitized: ${filename}`);
            }
          }
        } else {
          // Use default naming (sanitized printer name)
          const defaultBase = sanitizeFilename(p.name.replace(/\s+/g, '')) || 'quadGEN';
          filename = defaultBase + "_linear.quad";
        }
        
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus(`Downloaded ${filename}`);
      } catch (error) {
        console.error('Download error:', error);
        showStatus("Error downloading file");
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 's':
            e.preventDefault();
            elements.downloadBtn.click();
            break;
          case 'r':
            e.preventDefault();
            updatePreview();
            break;
        }
      }
    });

    // Note: Smoothing slider deprecated. Measurement reconstruction + decimation provide stable curves; fidelity is controlled via Recompute.

    // Initialize Auto endpoint rolloff toggles
    try {
      const parseStoredBool = (value) => {
        if (!value) return null;
        const v = value.trim().toLowerCase();
        if (v === '1' || v === 'true') return true;
        if (v === '0' || v === 'false') return false;
        return null;
      };

      let savedWhite = parseStoredBool(localStorage.getItem('autoWhiteLimitV1') || '');
      let savedBlack = parseStoredBool(localStorage.getItem('autoBlackLimitV1') || '');

      if (savedWhite === null && savedBlack === null) {
        const legacy = parseStoredBool(localStorage.getItem('autoEndpointRolloffV1') || '');
        if (legacy !== null) {
          savedWhite = legacy;
          savedBlack = legacy;
          try { localStorage.removeItem('autoEndpointRolloffV1'); } catch {}
        }
      }

      if (savedWhite === null) savedWhite = false; // default: white off
      if (savedBlack === null) savedBlack = true;  // default: black on

      if (elements.autoWhiteLimitToggle) {
        elements.autoWhiteLimitToggle.checked = savedWhite;
        elements.autoWhiteLimitToggle.addEventListener('change', (e) => {
          const enabled = !!e.target.checked;
          try { localStorage.setItem('autoWhiteLimitV1', enabled ? '1' : '0'); } catch {}
          showStatus(enabled ? 'Auto white limit enabled' : 'Auto white limit disabled');
          try { (getCurrentPrinter()?.channels || []).forEach(ch => updateProcessingDetail(ch)); } catch {}
          try { updateSessionStatus(); } catch {}
          debouncedPreviewUpdate();
        });
      }

      if (elements.autoBlackLimitToggle) {
        elements.autoBlackLimitToggle.checked = savedBlack;
        elements.autoBlackLimitToggle.addEventListener('change', (e) => {
          const enabled = !!e.target.checked;
          try { localStorage.setItem('autoBlackLimitV1', enabled ? '1' : '0'); } catch {}
          showStatus(enabled ? 'Auto black limit enabled' : 'Auto black limit disabled');
          try { (getCurrentPrinter()?.channels || []).forEach(ch => updateProcessingDetail(ch)); } catch {}
          try { updateSessionStatus(); } catch {}
          debouncedPreviewUpdate();
        });
      }
    } catch {}

    // Sample data loading functions
    function loadSampleData(type) {
      try {
        // Capture state before loading sample data for proper undo functionality
        CurveHistory.captureState('Before loading sample data');
        
        let correctionData;
        let filename;
        
        if (type === 'labData') {
          correctionData = parseLabData(SAMPLE_DATA.colorMuse, 'LAB-Data-sample.txt');
          // Positive-only workflow: record measurement intent as positive
          correctionData.measurementIntent = 'positive';
          filename = 'LAB-Data-sample.txt';
        } else if (type === 'cube') {
          correctionData = parseCube1D(SAMPLE_DATA.gammaCube);
          filename = 'LUT Sample Data';
        } else {
          throw new Error('Invalid sample data type');
        }
        
        // Apply the correction as global linearization
        correctionData.filename = filename;
        correctionData.edited = false;
        linearizationData = normalizeLinearizationEntry(correctionData);
        linearizationApplied = true;
        
        // Update UI to show applied correction
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${filename}`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        try { updateRevertButtonsState(); } catch {}
        try { const rev = document.getElementById('revertGlobalToMeasurementBtn'); if (rev) { rev.disabled = false; rev.removeAttribute('disabled'); } } catch {}
        
        // Show file info
        elements.globalLinearizationInfo.classList.remove('hidden');
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.add('hidden');
        refreshGlobalLinearizationDisplay();
        // Details: show only point count + simplified type label
        (function(){
          const ptsLabel = getBasePointCountLabel(correctionData);
          const fmtLower = String(correctionData.format || '').toLowerCase();
          let typeLabel = '';
          if (fmtLower.includes('lab')) typeLabel = 'LAB';
          else if (fmtLower === 'acv') typeLabel = 'curve';
          else if (fmtLower === '1dlut' || correctionData.is3DLUT) typeLabel = 'LUT';
          else typeLabel = (correctionData.format || '').toUpperCase();
          elements.globalLinearizationDetails.textContent = ` - ${ptsLabel} (${typeLabel})`;
        })();
        
        // Note: Smoothing control deprecated. Base samples come from the chosen source; fidelity controlled via Recompute.
        
        // Update interpolation controls
        updateInterpolationControls();
        updatePreview();
        
        // Update filename to reflect current state
        updateFilename();
        
        // Update processing details for all channels since global affects all
        const channelNames = getCurrentPrinter().channels;
        channelNames.forEach(channelName => {
          updateProcessingDetail(channelName);
        });
        
      // Status note: CIE density; Gaussian-weighted reconstruction with PCHIP interpolation (LAB sample)
      showStatus(`Loaded sample data as a global correction: ${filename} (CIE density; Gaussian-weighted reconstruction with PCHIP interpolation)`);
        
      } catch (error) {
        console.error('Error loading sample data:', error);
        showStatus(`Error loading sample data: ${error.message}`);
      }
    }


    // Initialize
    elements.printerSelect.addEventListener('change', (e) => setPrinter(e.target.value));
    
    // Add real-time filename validation
    elements.filenameInput.addEventListener('input', (e) => {
      const input = e.target;
      const value = input.value.trim();
      
      // Mark as user-edited if they've typed something different from auto-generated
      if (value !== generateFilename()) {
        input.dataset.userEdited = 'true';
      } else {
        delete input.dataset.userEdited;
      }
      
      if (value) {
        const cleanName = value.replace(/\.quad$/, '');
        const sanitized = sanitizeFilename(cleanName);
        const hasInvalidChars = sanitized !== cleanName;
        
        // Visual feedback for invalid characters
        input.classList.toggle('border-yellow-300', hasInvalidChars);
        input.classList.toggle('bg-yellow-50', hasInvalidChars);
        input.classList.toggle('border-gray-300', !hasInvalidChars);
        input.classList.toggle('bg-white', !hasInvalidChars);
        
        if (hasInvalidChars) {
          input.title = `Will be saved as: ${sanitized}.quad`;
        } else {
          input.title = '';
        }
      } else {
        input.classList.remove('border-yellow-300', 'bg-yellow-50');
        input.classList.add('border-gray-300', 'bg-white');
        input.title = '';
      }
    });

    // Positive-only workflow: no Print Intent control or warnings
    // (Intent mismatch warnings removed; EDN mapping fixed to Positive.)
    
    
    
    // Global linearization button click
      elements.globalLinearizationBtn.addEventListener('click', () => {
        elements.linearizationFile.click();
      });

    // Revert to measurement (global): clear Smart curves/points and re-enable global correction
    const revertGlobalBtn = document.getElementById('revertGlobalToMeasurementBtn');
    if (revertGlobalBtn){
      revertGlobalBtn.addEventListener('click', () => {
        // Guard: only perform revert when a global measurement dataset is actually loaded
        try {
          const fmt = String(linearizationData?.format || '').toUpperCase();
          const isMeasurement = !!linearizationData && (fmt.includes('LAB') || fmt.includes('MANUAL')) && Array.isArray(linearizationData.originalData);
          if (!isMeasurement) return;
        } catch {}
          const savedSel = (isEditModeEnabled() && typeof EDIT !== 'undefined' && EDIT && EDIT.selectedChannel) ? EDIT.selectedChannel : null;
          try {
            CurveHistory.captureState('Before: Revert Global to Measurement');
          } catch {}
          const chs = (getCurrentPrinter()?.channels || []).slice();
          chs.forEach((ch) => {
            try {
              // Only clear Smart-derived curves/points; preserve file-loaded .quad curves
              if (isSmartCurve && isSmartCurve(ch)) {
                // Restore original .quad curve if available
                try {
                  const orig = window.loadedQuadData?.originalCurves?.[ch];
                  if (Array.isArray(orig) && orig.length === 256) {
                    if (!window.loadedQuadData) window.loadedQuadData = {};
                    if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                    window.loadedQuadData.curves[ch] = [...orig];
                  } else {
                    // If no original is available, remove the Smart curve (will fall back to linear)
                    if (window.loadedQuadData?.curves?.[ch]) delete window.loadedQuadData.curves[ch];
                  }
                } catch {}
                if (window.loadedQuadData?.keyPoints?.[ch]) delete window.loadedQuadData.keyPoints[ch];
                if (window.loadedQuadData?.keyPointsMeta?.[ch]) delete window.loadedQuadData.keyPointsMeta[ch];
                if (window.loadedQuadData?.sources?.[ch]) delete window.loadedQuadData.sources[ch];
              }
            } catch {}
          });
          if (elements.globalLinearizationToggle) {
            elements.globalLinearizationToggle.disabled = false;
            elements.globalLinearizationToggle.checked = true;
          }
          // Clear edited flag on global measurement (we are reverting to the loaded source)
          if (linearizationData) { try { linearizationData.edited = false; } catch {} }
          linearizationApplied = !!linearizationData;
          updateInterpolationControls();
          // Refresh filename/details to drop the Edited prefix
          try { refreshGlobalLinearizationDisplay(); } catch {}
          updatePreview();
        try {
          const chans = getCurrentPrinter().channels;
          chans.forEach((name)=> updateProcessingDetail(name));
        } catch {}
        showStatus('Reverted to measurement (global)');
        updateRevertButtonsState();
        // Restore prior Edit selection to avoid defaulting to MK
        try {
          if (savedSel && isEditModeEnabled()) {
            const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === savedSel);
            const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
            if (endVal > 0) {
              if (elements.editChannelSelect) elements.editChannelSelect.value = savedSel;
              EDIT.selectedChannel = savedSel;
              edit_refreshState();
              updateInkChart();
            }
          }
        } catch {}
      });
    }

    elements.linearizationFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Capture state before loading file for proper undo/redo pairing
        CurveHistory.captureState('Before: Load Global Linearization');
        // Read file content based on file type
        const extension = file.name.toLowerCase().split('.').pop();
        let fileInput;
        if (extension === 'acv') {
          fileInput = await file.arrayBuffer();
        } else {
          fileInput = await file.text();
        }
        
        const parsed = await parseLinearizationFile(fileInput, file.name);
        parsed.filename = file.name; // Store filename for documentation
        linearizationData = normalizeLinearizationEntry(parsed);
        linearizationApplied = true; // Auto-apply when file is loaded
        
        // Update button tooltip and enable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${file.name} (${getBasePointCountLabel(parsed)})`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        try { updateRevertButtonsState(); } catch {}
        try { const rev = document.getElementById('revertGlobalToMeasurementBtn'); if (rev) { rev.disabled = false; rev.removeAttribute('disabled'); } } catch {}
        
        // Show file info below Data Source label
        // Set base filename and refresh display with edited prefix logic
        linearizationData.filename = file.name;
        linearizationData.edited = false;
        refreshGlobalLinearizationDisplay();
        // Details: show only point count + simplified type label
        const ptsLabel = getBasePointCountLabel(parsed);
        const fmtLower = String(parsed.format || '').toLowerCase();
        const nameLower = file.name.toLowerCase();
        let typeLabel = '';
        if (fmtLower.includes('lab')) typeLabel = 'LAB';
        else if (nameLower.endsWith('.acv') || fmtLower === 'acv') typeLabel = 'curve';
        else if (nameLower.endsWith('.cube') || fmtLower === '1dlut' || parsed.is3DLUT) typeLabel = 'LUT';
        else typeLabel = (parsed.format || '').toUpperCase();
        elements.globalLinearizationDetails.textContent = ` - ${ptsLabel} (${typeLabel})`;
        try { updateIntentDetailLabel(); } catch {}
        elements.globalLinearizationInfo.classList.remove('hidden');
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.add('hidden');
        
        // Note: Smoothing control deprecated. Base samples come from the chosen source; fidelity controlled via Recompute.
        
        // Update interpolation controls
        updateInterpolationControls();
        
        // Show appropriate status message based on LUT type
      if (parsed.is3DLUT) {
          showStatus(`Loaded 3D LUT and extracted ${parsed.samples.length} neutral axis points as a global correction from ${file.name} (${parsed.lutSize}³ grid)`);
          try { postGlobalDeltaChatSummary(); } catch {}
      } else {
          // Append small method note for LAB/Manual L* datasets
          let methodNote = '';
          try {
            const fmtLower = String(parsed.format || '').toLowerCase();
            if (fmtLower.includes('lab') || fmtLower.includes('manual')) {
              methodNote = ' (CIE density; Gaussian-weighted reconstruction with PCHIP interpolation)';
            }
          } catch {}
          showStatus(`Loaded and applied ${parsed.samples.length} data points as a global correction from ${file.name}${methodNote}`);
          try { postGlobalDeltaChatSummary(); } catch {}
      }
        debouncedPreviewUpdate(); // Update preview to show the applied linearization
        // Capture an after-state so undo/redo works symmetrically
        try { CurveHistory.captureState('After: Load Global Linearization'); } catch {}
        
        // Update processing details for all channels since global affects all
        const channelNames = getCurrentPrinter().channels;
        channelNames.forEach(channelName => {
          updateProcessingDetail(channelName);
        });
      } catch (error) {
        console.error('Cube file parsing error:', error);
        showStatus(`Error loading file: ${error.message}`);
        linearizationData = null;
        linearizationApplied = false;
        
        // Update filename to reflect no corrections
        updateFilename();
        
        // Reset button tooltip and disable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
        elements.globalLinearizationToggle.disabled = true;
        elements.globalLinearizationToggle.checked = false;
        try { updateRevertButtonsState(); } catch {}
        
        // Hide file info and show hint again
        elements.globalLinearizationInfo.classList.add('hidden');
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.remove('hidden');
        
        // Update interpolation controls
        updateInterpolationControls();
      }
    });

    // Global linearization toggle
    elements.globalLinearizationToggle.addEventListener('change', (e) => {
          if (DEBUG_LOGS) console.log('DEBUG: Global toggle change event fired:', {
        checked: e.target.checked,
        hasLinearizationData: !!linearizationData,
        linearizationDataSamples: linearizationData?.samples?.length || 0
      });
      
      if (linearizationData) {
        linearizationApplied = e.target.checked;
        if (linearizationApplied) {
          showStatus('Global linearization enabled');
          try { postGlobalDeltaChatSummary(); } catch {}
        } else {
          showStatus('Global linearization disabled');
        }
        
            if (DEBUG_LOGS) console.log('DEBUG: After toggle change:', {
          linearizationApplied,
          linearizationData: linearizationData
        });
        
        // Update processing details for all channels since global affects all
        const channelNames = getCurrentPrinter().channels;
        channelNames.forEach(channelName => {
          updateProcessingDetail(channelName);
        });
        
        // Update interpolation controls
        updateInterpolationControls();
        
        // Update filename to reflect current state
        updateFilename();
        
        debouncedPreviewUpdate();
        try { updateRevertButtonsState(); } catch {}
      }
    });

    // Curve smoothing method selection
    elements.curveSmoothingMethod.addEventListener('change', (e) => {
      const method = e.target.value;
      
      // Update interpolation controls (including intensity slider visibility and description)
      updateInterpolationControls();
      
      if (hasAnyLinearization()) {
        const methodNames = {
          'cubic': 'Cubic Spline',
          'catmull': 'Catmull-Rom',
          'pchip': 'PCHIP (monotonic)',
          'linear': 'Linear (none)'
        };
        showStatus(`Curve method: ${methodNames[method]}`);
        debouncedPreviewUpdate(); // Update preview with new smoothing setting
      }
    });
    
    // Catmull-Rom tension slider
    elements.catmullTension.addEventListener('input', (e) => {
      if (hasAnyLinearization() && elements.curveSmoothingMethod.value === 'catmull') {
        const tension = Math.round(e.target.value);
        showStatus(`Catmull-Rom tension: ${tension}%`);
        debouncedPreviewUpdate(); // Update preview with new tension setting
      }
    });
    
    // (Removed) Smoothing slider functionality — smoothing deprecated

    // Simplifier controls listeners
    // Legacy key-point simplifier listeners removed; replaced by Edit Curves panel
    
    // Notes toggle functionality
    if (elements.notesToggle && elements.notesContent && elements.notesChevron) {
      elements.notesToggle.addEventListener('click', () => {
        const isHidden = elements.notesContent.classList.contains('hidden');
        if (isHidden) {
          elements.notesContent.classList.remove('hidden');
          elements.notesChevron.style.transform = 'rotate(180deg)';
        } else {
          elements.notesContent.classList.add('hidden');
          elements.notesChevron.style.transform = 'rotate(0deg)';
        }
      });
    }

    // Live-preview user notes into the .quad File Preview (debounced, notes-only)
    function debounce(fn, wait = 200){ let t; return (...args)=>{ clearTimeout(t); t = setTimeout(() => fn(...args), wait); }; }
    if (elements.userNotes) {
      const updatePreviewNotes = debounce(() => updatePreview({ onlyNotes: true }), 200);
      elements.userNotes.addEventListener('input', updatePreviewNotes);
    }

    // Lab Tech functionality (always visible console-style; no collapse/expand)

    // Initialize Lab Tech as ready (API key is handled by Cloudflare Worker)
    // Keep panel collapsed by default; compact input is primary
    if (elements.sendMessageBtn) elements.sendMessageBtn.disabled = false;
    if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.disabled = false;
    // Set initial Lab Tech icon state
    refreshLabTechIcon();
    
    // Initialize usage counter - disabled for now
    // updateUsageCounter();
    
    // Skip API key management - no longer needed
    /*
    elements.setApiKeyBtn.addEventListener('click', async () => {
      const apiKey = elements.apiKeyInput.value.trim();
      
      if (!apiKey) {
        addChatMessage('system', 'Please enter an API key.');
        elements.apiKeyInput.style.borderColor = '#ef4444';
        setTimeout(() => {
          elements.apiKeyInput.style.borderColor = '';
        }, 2000);
        return;
      }

      // Show validation in progress
      elements.setApiKeyBtn.disabled = true;
      elements.setApiKeyBtn.textContent = 'Validating...';
      if (elements.aiStatus) elements.aiStatus.textContent = 'Validating API key...';
      if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-blue-600';
      if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '⏳';

      try {
        // Validate the API key
        const validation = await claudeAssistant.validateApiKey(apiKey);
        
        if (validation.success) {
          // API key is valid - set it
          claudeAssistant.setApiKey(apiKey);
          elements.sendMessageBtn.disabled = false;
          elements.apiKeyInput.value = '';
          if (elements.aiStatus) elements.aiStatus.textContent = 'API key validated — Ready to chat!';
          if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-green-600';
          if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '✅';
          addChatMessage('system', `✅ ${validation.message}. You can now chat with Lab Tech!`);
        } else {
          // API key is invalid
          if (elements.aiStatus) elements.aiStatus.textContent = 'Invalid API key';
          if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
          if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '❌';
          addChatMessage('system', `❌ ${validation.message}`);
          
          // Flash the input field red
          elements.apiKeyInput.style.borderColor = '#ef4444';
          setTimeout(() => {
            elements.apiKeyInput.style.borderColor = '';
          }, 3000);
        }
      } catch (error) {
        if (elements.aiStatus) elements.aiStatus.textContent = 'Validation failed';
        if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
        if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '❌';
        addChatMessage('system', `❌ Could not validate API key: ${error.message}`);
      } finally {
        elements.setApiKeyBtn.disabled = false;
        elements.setApiKeyBtn.textContent = 'Set Key';
      }
    });

    elements.clearApiKeyBtn.addEventListener('click', () => {
      claudeAssistant.setApiKey(null);
      elements.sendMessageBtn.disabled = true;
      elements.apiKeyInput.value = '';
      if (elements.aiStatus) elements.aiStatus.textContent = 'API key required';
      if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
      if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '🔑';
      addChatMessage('system', 'API key cleared. Please set a new API key to continue chatting.');
    });

    // Force set API key without validation (for testing)
    elements.forceSetKeyBtn.addEventListener('click', () => {
      const apiKey = elements.apiKeyInput.value.trim();
      
      if (!apiKey) {
        addChatMessage('system', 'Please enter an API key.');
        elements.apiKeyInput.style.borderColor = '#ef4444';
        setTimeout(() => {
          elements.apiKeyInput.style.borderColor = '';
        }, 2000);
        return;
      }

      // Set the API key without validation
      claudeAssistant.setApiKey(apiKey);
      elements.sendMessageBtn.disabled = false;
      elements.apiKeyInput.value = '';
      if (elements.aiStatus) elements.aiStatus.textContent = 'API key set (unvalidated) — Try chatting';
      if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-yellow-600';
      if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '⚠️';
      addChatMessage('system', '⚠️ API key set WITHOUT validation. Try sending a message to test if it works.');
    });

    elements.testConnectionBtn.addEventListener('click', async () => {
      elements.testConnectionBtn.disabled = true;
      elements.testConnectionBtn.textContent = 'Testing...';
      
      try {
        const result = await claudeAssistant.testConnection();
        addChatMessage('system', `Connection test: ${result.message}`);
        elements.aiStatus.textContent = result.message;
        elements.aiStatus.className = result.success ? 'text-xs text-green-600' : 'text-xs text-red-600';
        elements.aiStatusIcon.textContent = result.success ? '🟢' : '🔴';
      } catch (error) {
        addChatMessage('system', `Connection test failed: ${error.message}`);
        if (elements.aiStatus) elements.aiStatus.textContent = 'Connection test failed';
        if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
        if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '🔴';
      } finally {
        elements.testConnectionBtn.disabled = false;
        elements.testConnectionBtn.textContent = 'Test';
      }
    });
    */

    // Update usage counter display
    function updateUsageCounter(serverHeaders = null) {
      // Try to use server-provided rate limit info first
      if (serverHeaders) {
        const limit = serverHeaders['x-ratelimit-limit'];
        const remaining = serverHeaders['x-ratelimit-remaining'];
        
        if (limit && remaining !== undefined) {
          const used = parseInt(limit) - parseInt(remaining);
          elements.usageCounter.textContent = `${used}/${limit} requests`;
          
          // Change color based on remaining
          const remainingNum = parseInt(remaining);
          if (remainingNum < 10) {
            elements.usageCounter.className = 'text-xs text-red-500 ml-auto';
          } else if (remainingNum < 25) {
            elements.usageCounter.className = 'text-xs text-orange-500 ml-auto';
          } else {
            elements.usageCounter.className = 'text-xs text-gray-500 ml-auto';
          }
          return;
        }
      }
      
      // Fall back to client-side tracking
      const stats = claudeAssistant.getUsageStats();
      const remaining = stats.remainingHourly;
      const used = stats.requestsLastHour;
      
      elements.usageCounter.textContent = `${used}/100 requests`;
      
      // Change color based on usage
      if (remaining < 10) {
        elements.usageCounter.className = 'text-xs text-red-500 ml-auto';
      } else if (remaining < 25) {
        elements.usageCounter.className = 'text-xs text-orange-500 ml-auto';
      } else {
        elements.usageCounter.className = 'text-xs text-gray-500 ml-auto';
      }
    }

    // Chat functionality
    async function sendChatMessage() {
      const srcEl = elements.aiInputCompact || elements.aiInput;
      const message = (srcEl && typeof srcEl.value === 'string') ? srcEl.value.trim() : '';
      if (!message) return;

      // Record command into history and add user message to chat
      try {
        if (message) {
          if (aiCommandHistory.length === 0 || aiCommandHistory[aiCommandHistory.length - 1] !== message) {
            aiCommandHistory.push(message);
          }
          aiHistoryIndex = aiCommandHistory.length; // reset pointer to one past end
        }
      } catch {}
      // Add user message to chat
      addChatMessage('user', message);
      // Show processing status in chat as well
      if (shouldShowAssistantStatus()) addChatMessage('system', 'Assistant: processing request…');
      if (srcEl) srcEl.value = '';
      if (elements.sendMessageBtn) elements.sendMessageBtn.disabled = true;
      if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.disabled = true;
      if (elements.aiStatus) {
        if (elements.aiStatus) elements.aiStatus.textContent = 'Assistant is thinking...';
        if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-blue-600';
      }

      try {
        const response = await claudeAssistant.sendMessage(message);
        
        // Add AI response to chat
        addChatMessage('assistant', response.response);
        
        // Suppress detailed AI function result lines in chat

        if (elements.aiStatus) {
          elements.aiStatus.textContent = response.actionsPerformed ? 'Assistant: actions completed!' : 'Assistant: response received';
          elements.aiStatus.className = response.success ? 'text-xs text-green-600' : 'text-xs text-red-600';
        }
        
        // Update usage counter with server headers if available - disabled for now
        // updateUsageCounter(response.rateLimitHeaders);

      } catch (error) {
        addChatMessage('system', `Error: ${error.message}`);
        if (elements.aiStatus) {
          if (elements.aiStatus) elements.aiStatus.textContent = 'Assistant: error occurred';
          if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
        }
        // Update usage counter even on error (request was still made) - disabled for now
        // updateUsageCounter();
      } finally {
        if (elements.sendMessageBtn) elements.sendMessageBtn.disabled = false;
        if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.disabled = false;
      }
    }

    function addChatMessage(role, message) {
      const line = document.createElement('div');
      line.className = `chat-line ${role}`;

      // Prefix user prompts like a terminal
      const prefix = role === 'user' ? '> ' : '';

      if (role === 'assistant') {
        // Minimal formatting for readability; keep console feel
        let formatted = message
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\*(.*?)\*/g, '<em>$1</em>')
          .replace(/^- (.+)$/gm, '• $1')
          .replace(/^\* (.+)$/gm, '• $1')
          .replace(/^(\d+\.\s)/gm, '$1');
        line.innerHTML = formatted;
      } else {
        line.textContent = prefix + message;
      }

      // Tag system messages as error/info when applicable (for theming)
      if (role === 'system') {
        const t = String(message || '');
        if (/^\s*error\s*:/i.test(t)) line.classList.add('error');
        else if (/^\s*assistant\s*:/i.test(t) || /processing request/i.test(t)) line.classList.add('info');
      }

      elements.chatHistory.appendChild(line);
      elements.chatHistory.scrollTop = elements.chatHistory.scrollHeight;
      try {
        if (role === 'system' && typeof claudeAssistant?.addSystemContext === 'function') {
          claudeAssistant.addSystemContext(message);
        }
      } catch {}
    }

    if (elements.sendMessageBtn) elements.sendMessageBtn.addEventListener('click', sendChatMessage);
    if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.addEventListener('click', sendChatMessage);

    // Expanded textarea: Enter sends, Shift+Enter inserts newline
    if (elements.aiInput) {
      elements.aiInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (!(elements.sendMessageBtn && elements.sendMessageBtn.disabled)) sendChatMessage();
        }
      });
    }

    // Compact input: Enter sends; ArrowUp/ArrowDown navigate command history
    if (elements.aiInputCompact) {
      elements.aiInputCompact.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !(elements.sendMessageBtnCompact && elements.sendMessageBtnCompact.disabled)) {
          e.preventDefault();
          sendChatMessage();
        }
      });
      elements.aiInputCompact.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (aiCommandHistory.length === 0) return;
            if (aiHistoryIndex > 0) aiHistoryIndex--;
            const cmd = aiCommandHistory[aiHistoryIndex] || '';
            elements.aiInputCompact.value = cmd;
            const len = cmd.length;
            elements.aiInputCompact.setSelectionRange(len, len);
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (aiCommandHistory.length === 0) return;
            if (aiHistoryIndex < aiCommandHistory.length - 1) {
              aiHistoryIndex++;
              const cmd = aiCommandHistory[aiHistoryIndex] || '';
              elements.aiInputCompact.value = cmd;
              const len = cmd.length;
              elements.aiInputCompact.setSelectionRange(len, len);
            } else {
              // Move to empty prompt
              aiHistoryIndex = aiCommandHistory.length;
              elements.aiInputCompact.value = '';
            }
          }
      });
    }

    elements.clearChatBtn.addEventListener('click', () => {
      elements.chatHistory.innerHTML = '<!-- Chat messages will appear here -->';
      claudeAssistant.clearHistory();
      addChatMessage('system', 'Chat history cleared.');
    });
    

    // Sample data button event listeners
    if (elements.loadSampleLabData) {
      elements.loadSampleLabData.addEventListener('click', () => {
        loadSampleData('labData');
      });
    }
    if (elements.loadSampleCube) {
      elements.loadSampleCube.addEventListener('click', () => {
        loadSampleData('cube');
      });
    }
    
    // Download sample data functionality
    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }
    
    // Download sample data event listeners
    const dlSampleLabEl = document.getElementById('downloadSampleLabData');
    if (dlSampleLabEl) {
      dlSampleLabEl.addEventListener('click', (e) => {
        e.preventDefault();
        downloadFile(SAMPLE_DATA.colorMuse, 'LAB-Data-sample.txt', 'text/plain');
      });
    }
    const dlSampleCubeEl = document.getElementById('downloadSampleCube');
    if (dlSampleCubeEl) {
      dlSampleCubeEl.addEventListener('click', (e) => {
        e.preventDefault();
        downloadFile(SAMPLE_DATA.gammaCube, 'LUT_sample.cube', 'text/plain');
      });
    }
    
    // Function to check if all channels are disabled and show/hide message
    function updateNoChannelsMessage() {
      const rows = Array.from(elements.rows.children);
      const noChannelsRow = document.getElementById('noChannelsRow');
      
      if (!noChannelsRow) return;
      
      // Get actual channel rows (excluding the noChannelsRow itself)
      const channelRows = rows.filter(tr => tr.id !== 'noChannelsRow');
      
      // Check if all channel rows have end value of 0
      const allDisabled = channelRows.length > 0 && channelRows.every(tr => {
        const endInput = tr.querySelector('.end-input');
        return parseInt(endInput.value) === 0;
      });
      
      if (allDisabled) {
        noChannelsRow.classList.remove('hidden');
      } else {
        noChannelsRow.classList.add('hidden');
      }
    }

    // Function to update the ultra-compact disabled channels list
    function updateCompactChannelsList() {
      const compactContainer = document.getElementById('disabledChannelsCompact');
      const compactRow = document.getElementById('disabledChannelsRow');
      
      if (!compactContainer || !compactRow) return;
      
      // Clear existing chips
      compactRow.innerHTML = '';
      
      // Find all channels (enabled and disabled)
      const allChannels = Array.from(elements.rows.children).filter(tr => 
        tr.getAttribute('data-channel') // Has a valid channel name
      );
      
      // Always show compact container since we always have channels
      compactContainer.classList.add('show');
      
      // Create chips for each channel
      allChannels.forEach(tr => {
        const channelName = tr.getAttribute('data-channel');
        if (!channelName) return;
        
        // Get channel elements directly from the row
        const percentInput = tr.querySelector('.percent-input');
        // Get virtual checkbox created in setupChannelRow
        const enableCheckbox = tr._virtualCheckbox || { checked: !tr.hasAttribute('data-user-disabled') };
        
        if (!percentInput) return;
        
        const channelColor = INK_COLORS[channelName] || '#000000';
        
        const chip = document.createElement('div');
        chip.className = 'disabled-channel-chip';
        
        // Add 'active' class if channel is enabled
        if (enableCheckbox.checked) {
          chip.classList.add('active');
        }
        
        chip.innerHTML = `
          <input type="checkbox" class="channel-checkbox" ${enableCheckbox.checked ? 'checked' : ''}>
          <div class="channel-color" style="background-color: ${channelColor}"></div>
          <span class="channel-name">${channelName}</span>
        `;
        
        // Add click handler to toggle channel
        chip.addEventListener('click', (e) => {
          e.stopPropagation();
          
          if (e.target.classList.contains('channel-checkbox')) {
            // Handle checkbox click directly
            enableCheckbox.checked = e.target.checked;
            
            // Update chip appearance
            if (e.target.checked) {
              chip.classList.add('active');
            } else {
              chip.classList.remove('active');
            }
            
            enableCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          } else {
            // Handle chip click - toggle channel
            const checkbox = chip.querySelector('.channel-checkbox');
            checkbox.checked = !checkbox.checked;
            enableCheckbox.checked = checkbox.checked;
            
            // Update chip appearance
            if (checkbox.checked) {
              chip.classList.add('active');
            } else {
              chip.classList.remove('active');
            }
            
            enableCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        compactRow.appendChild(chip);
      });
      
      // Update the no channels message
      updateNoChannelsMessage();
    }
    
    // Disable/Enable all channels functionality
    
    // Load .quad file functionality
    function parseQuadFile(content) {
      const lines = content.split('\n').map(line => line.trim());
      
      // Look for the QuadToneRIP header line to extract channel names
      let channels = [];
      let dataStartIndex = -1;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Look for QuadToneRIP header: ## QuadToneRIP K,C,M,Y,LC,LM,LK,LLK
        if (line.startsWith('## QuadToneRIP ')) {
          const channelPart = line.substring('## QuadToneRIP '.length);
          channels = channelPart.split(',').map(ch => ch.trim());
          continue;
        }
        
        // Find where numeric data starts (first line that starts with a digit)
        if (dataStartIndex === -1 && line && line.match(/^\d/)) {
          dataStartIndex = i;
          break;
        }
      }
      
      if (channels.length === 0) {
        throw new Error('Could not find QuadToneRIP header with channel names in .quad file');
      }
      
      if (dataStartIndex === -1) {
        throw new Error('Could not find numeric data in .quad file');
      }
      
      // Parse the actual numeric data portion
      // Skip to where numeric data starts and collect all numeric lines
      const numericLines = [];
      let invalidDataLines = [];
      
      for (let i = dataStartIndex; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line) {
          if (/^\d+$/.test(line)) {
            const value = parseInt(line, 10);
            
            // Validate reasonable value range for QuadToneRIP (0-65535)
            if (value < 0 || value > 65535) {
              throw new Error(`Invalid data value ${value} at line ${i + 1}. QuadToneRIP values must be 0-65535.`);
            }
            
            numericLines.push(value);
          } else if (!line.startsWith('#')) {
            // Track non-numeric, non-comment lines as potentially problematic
            invalidDataLines.push(`Line ${i + 1}: "${line}"`);
            if (invalidDataLines.length > 10) break; // Don't flood with errors
          }
        }
      }
      
      // Warn about mixed content if found
      if (invalidDataLines.length > 0) {
        const sampleLines = invalidDataLines.slice(0, 3).join(', ');
        console.warn(`Found ${invalidDataLines.length} non-numeric lines in data section: ${sampleLines}`);
      }
      
      // Each channel should have exactly 256 data points
      const expectedDataPoints = channels.length * 256;
      if (numericLines.length < expectedDataPoints) {
        throw new Error(`Insufficient data: found ${numericLines.length} values, expected ${expectedDataPoints} (${channels.length} channels × 256 points each)`);
      }
      
      // Extract all 256 data points for each channel
      const channelCurves = {};
      const values = []; // Final values for UI display
      
      for (let channelIdx = 0; channelIdx < channels.length; channelIdx++) {
        const channelName = channels[channelIdx];
        const channelStartIdx = channelIdx * 256;
        const channelEndIdx = channelStartIdx + 255; // 0-indexed, so 255 is the 256th value
        
        if (channelEndIdx >= numericLines.length) {
          throw new Error(`Not enough data for channel ${channelName}: need point ${channelEndIdx + 1}, have ${numericLines.length}`);
        }
        
        // Extract all 256 points for this channel
        const curveData = numericLines.slice(channelStartIdx, channelStartIdx + 256);
        channelCurves[channelName] = curveData;
        
        // Store the maximum value for UI display (percentage calculation)
        values.push(Math.max(...curveData));
      }
      
      return { channels, values, curves: channelCurves };
    }
    
    function findMatchingPrinter(channels) {
      for (const [printerId, config] of Object.entries(PRINTERS)) {
        if (config.channels.length === channels.length && 
            config.channels.every((ch, i) => ch === channels[i])) {
          return printerId;
        }
      }
      return null;
    }
    
    // Load .quad file button click handler
    elements.loadQuadBtn.addEventListener('click', () => {
      elements.quadFile.click();
    });
    
    // Load .quad file change handler
    elements.quadFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Check file type
        if (!file.name.toLowerCase().endsWith('.quad')) {
          throw new Error(`Unsupported file type. Expected .quad file, got: ${file.name}`);
        }
        
        // Check file size (reasonable limits)
        if (file.size > 10 * 1024 * 1024) { // 10MB limit
          throw new Error(`File too large: ${(file.size / (1024*1024)).toFixed(1)}MB. Maximum supported size is 10MB.`);
        }
        
        if (file.size < 100) { // Minimum reasonable size
          throw new Error(`File too small: ${file.size} bytes. This doesn't appear to be a valid .quad file.`);
        }
        
        // Clear all existing processing data before loading a new .quad
        clearAllProcessingData();

        const content = await file.text();
        
        // Check for reasonable file structure
        if (!content.includes('QuadToneRIP')) {
          throw new Error('File does not appear to be a valid .quad file (missing QuadToneRIP header).');
        }
        
        // Check for reasonable data content
        const numericLines = content.split('\n').filter(line => line.trim() && /^\d+$/.test(line.trim()));
        if (numericLines.length < 256) {
          throw new Error(`File appears corrupted or incomplete. Found only ${numericLines.length} data points, expected at least 256.`);
        }
        
        const parsed = parseQuadFile(content);
        
        // Store the complete curve data for use in generation and keep an immutable copy
        window.loadedQuadData = {
          filename: file.name,
          curves: parsed.curves,
          channels: parsed.channels
        };
        try {
          // Preserve original .quad curves for future restore (e.g., clearing Smart)
          window.loadedQuadData.originalCurves = {};
          parsed.channels.forEach((ch) => {
            const arr = parsed.curves?.[ch];
            if (Array.isArray(arr)) window.loadedQuadData.originalCurves[ch] = arr.slice();
          });
        } catch {}
        // Normalize any legacy source tags immediately after load
        normalizeSmartSourcesInLoadedData();
        
        // Find matching printer
        const matchingPrinter = findMatchingPrinter(parsed.channels);
        if (!matchingPrinter) {
          const channelList = parsed.channels.join(', ');
          throw new Error(`No supported printer matches channels: ${channelList}. Supported printers: P400 (K,C,M,Y,LC,LM), x800-x890 (K,C,M,Y,LC,LM,LK,LLK), P4-6-8000 (K,C,M,Y,LC,LM,LK,LLK), P5-7-9000 (K,C,M,Y,LC,LM,LK,LLK,OR,GR), x900 (K,C,M,Y,LC,LM,LK,LLK,OR,GR), 3880-7880 (K,C,M,Y,LC,LM,LK,LLK), P600-P800 (K,C,M,Y,LC,LM,LK,LLK), P700-P900 (K,C,M,Y,LC,LM,LK,LLK,V,MK)`);
        }
        
        // Switch to matching printer (mark that we're switching due to quad load)
        if (window.loadedQuadData) window.loadedQuadData.switchingPrinter = true;
        elements.printerSelect.value = matchingPrinter;
        setPrinter(matchingPrinter);
        if (window.loadedQuadData) delete window.loadedQuadData.switchingPrinter;
        
        // Wait a moment for the channel table to rebuild
        setTimeout(() => {
          // Set the channel values
          const rows = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
          parsed.values.forEach((value, index) => {
            if (index < rows.length) {
              const row = rows[index];
              const endInput = row.querySelector('.end-input');
              const percentInput = row.querySelector('.percent-input');
              
              if (endInput && percentInput) {
                endInput.value = value.toString();
                const percent = InputValidator.computePercentFromEnd(value);
                percentInput.value = percent.toString();
                
                // Refresh the row display
                const refreshFn = row.refreshDisplayFn;
                if (refreshFn) refreshFn();
              }
            }
          });

          // Record baseline End per channel for scaling loaded .quad uniformly when End changes
          try {
            if (!window.loadedQuadData.baselineEnd) window.loadedQuadData.baselineEnd = {};
            const rows2 = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
            rows2.forEach((row) => {
              const ch = row.getAttribute('data-channel');
              const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
              if (ch) window.loadedQuadData.baselineEnd[ch] = endVal;
            });
          } catch (e) { console.warn('Baseline End capture failed:', e); }

          // Precompute editable AI key points from the loaded .quad curves using the same
          // adaptive method used on first edit. This avoids visible point “jumps” on first change.
          try {
            if (window.loadedQuadData && window.loadedQuadData.curves) {
              parsed.channels.forEach((ch) => {
                const curve = window.loadedQuadData.curves[ch];
                if (Array.isArray(curve) && curve.length === 256) {
                  const keyPoints = extractAdaptiveKeyPointsFromValues(curve, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
                  try { ControlPoints.persist(ch, keyPoints, 'smooth'); } catch (e) { console.warn('Persist precomputed KP failed:', ch, e); }
                }
              });
            }
          } catch (e) { console.warn('Precompute AI key points from .quad failed:', e); }
          
          updatePreview();
          updateIntentDropdownState();
          
          // If no channels are enabled, enable the first available channel
          try {
            const rows3 = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
            const anyEnabled = rows3.some(tr => (InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0)) > 0);
            if (!anyEnabled && rows3.length > 0) {
              const firstCh = rows3[0].getAttribute('data-channel');
              if (firstCh && typeof quadGenActions?.enableDisableChannel === 'function') {
                quadGenActions.enableDisableChannel(firstCh, true);
              }
            }
          } catch {}
          
          // Refresh Edit Curves dropdown and set selection to first enabled channel in the .quad
          try {
            if (typeof edit_populateChannelSelect === 'function') edit_populateChannelSelect();
            if (elements.editChannelSelect && elements.editChannelSelect.options.length > 0) {
              const firstVal = elements.editChannelSelect.options[0].value;
              if (firstVal) {
                EDIT.selectedChannel = firstVal;
                EDIT.selectedOrdinal = 1;
                elements.editChannelSelect.value = firstVal;
                if (typeof edit_refreshState === 'function') edit_refreshState();
              }
            }
          } catch {}
          
          // Set the filename input to copy of the loaded file (remove .quad extension)
          const baseName = file.name.replace(/\.quad$/i, '');
          elements.filenameInput.value = `${baseName}_copy`;
          // Mark as user-edited so it won't be auto-generated over
          elements.filenameInput.dataset.userEdited = 'true';
          
          showStatus(`Loaded ${file.name} - switched to ${PRINTERS[matchingPrinter].name}`);
        }, 50);
        
      } catch (error) {
        console.error('Error loading .quad file:', error);
        showStatus(`Error loading .quad file: ${error.message}`);
      }
      
      // Clear the file input
      e.target.value = '';
    });
    
    // Manual L* entry functionality
    let lstarInputCount = 5;
    let lastLstarValues = []; // Store the last entered values
    
    // Convert CIE L* (0..100) to sRGB grayscale hex (approx).
    function lstarToHex(L) {
      const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
      const l = clamp(Number(L), 0, 100);
      // Convert L* to relative luminance Y
      let Y;
      if (l > 8) {
        const f = (l + 16) / 116;
        Y = f * f * f;
      } else {
        Y = l / 903.3;
      }
      // Linear to sRGB
      let s = (Y <= 0.0031308) ? (12.92 * Y) : (1.055 * Math.pow(Y, 1 / 2.4) - 0.055);
      s = clamp(s, 0, 1);
      const v = Math.round(s * 255);
      const hex = v.toString(16).padStart(2, '0');
      return `#${hex}${hex}${hex}`;
    }

    function createLstarInput(index, value = '') {
      const hasValue = (value !== '' && !isNaN(parseFloat(value)));
      const measuredColor = hasValue ? lstarToHex(value) : '#ffffff';
      // Default measured X position (evenly spaced)
      const total = Math.max(2, lstarInputCount);
      const defaultX = (index / (total - 1)) * 100;
      const targetFloor = 20; // Display-only floor for target L* swatch (most prints don't reach L* 0)
      const targetL = Math.max(targetFloor, 100 - defaultX);
      const targetColor = lstarToHex(targetL);
      return `
        <tr>
          <td class="px-2 py-1 w-8 text-xs text-gray-500">${index + 1}.</td>
          <td class="px-2 py-1 w-24">
            <input type="number" class="lstar-measured-x w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" value="${defaultX.toFixed(1)}" min="0" max="100" step="0.1" title="Patch % (0–100)">
          </td>
          <td class="px-2 py-1 w-24 text-center">
            <span class="inline-flex items-center justify-center gap-[2px]">
            <span class="lstar-target-swatch inline-flex items-center justify-center w-6 h-6 rounded border border-gray-300" style="background-color: ${targetColor};" title="Linear target preview (based on Patch %, min L* = 20)"></span>
              <span class="lstar-swatch inline-flex items-center justify-center w-6 h-6 rounded border border-gray-300 ${hasValue ? '' : 'border-dashed'}" style="${hasValue ? `background-color: ${measuredColor};` : 'background-image: repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px); background-color: #ffffff; border-style: dashed;'}" title="Measured L* preview">${hasValue ? '' : '<span class=\"text-[10px] text-gray-500\">—</span>'}</span>
            </span>
          </td>
          <td class="px-2 py-1 w-24">
            <input type="number" class="lstar-input w-24 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" 
                   placeholder="L*" 
                   min="0" max="100" step="0.1" value="${value}">
          </td>
        </tr>
      `;
    }
    
    function updateLstarInputs() {
      const container = elements.lstarInputs;
      container.innerHTML = '';
      
      for (let i = 0; i < lstarInputCount; i++) {
        const savedValue = lastLstarValues[i] || '';
        const inputHtml = createLstarInput(i, savedValue);
        container.insertAdjacentHTML('beforeend', inputHtml);
      }
      
      elements.lstarCountInput.value = lstarInputCount;
      elements.removeLstarInput.disabled = lstarInputCount <= 5;
      
      // Update validation
      validateLstarInputs();
    }

    
    function validateLstarInputs() {
      // Validate measured inputs and update measured swatches
      const inputs = elements.lstarInputs.querySelectorAll('input.lstar-input');
      const values = [];
      let hasErrors = false;
      let errorMessage = '';
      // Collect measured Xs
      const measuredXs = [];
      const measuredXInputs = elements.lstarInputs.querySelectorAll('.lstar-measured-x');
      Array.from(measuredXInputs).forEach((xInput) => {
        const row = xInput.closest('tr');
        const idx = Array.from(elements.lstarInputs.children).indexOf(row);
        const xv = parseFloat(xInput.value);
        if (!isNaN(xv) && xv >= 0 && xv <= 100) {
          measuredXs[idx] = xv;
          xInput.style.borderColor = '#d1d5db';
          // Update target swatch color (linear expectation = 100 - Patch%)
          const target = Math.max(20, 100 - xv); // clamp display to L* ≥ 20 (white remains 100)
          const targetSwatch = row ? row.querySelector('.lstar-target-swatch') : null;
          if (targetSwatch) targetSwatch.style.backgroundColor = lstarToHex(target);
        } else {
          xInput.style.borderColor = '#ef4444';
          // If invalid, leave target swatch as-is
        }
      });
      
      inputs.forEach((input, index) => {
        const value = parseFloat(input.value);
        // Update swatch color live
        const row = input.closest('tr');
        const swatch = row ? row.querySelector('.lstar-swatch') : null;
        if (input.value.trim() && !isNaN(value)) {
          if (value < 0 || value > 100) {
            hasErrors = true;
            errorMessage = 'L* values must be between 0 and 100';
            input.style.borderColor = '#d1d5db';
            if (swatch) {
              swatch.style.backgroundColor = '#ffffff';
              swatch.style.backgroundImage = 'repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px)';
              swatch.style.borderStyle = 'dashed';
              swatch.innerText = '—';
            }
          } else {
            values.push({ index, value });
            input.style.borderColor = '#d1d5db';
            if (swatch) {
              swatch.style.backgroundImage = 'none';
              swatch.style.borderStyle = 'solid';
              swatch.style.backgroundColor = lstarToHex(value);
              swatch.innerText = '';
            }
          }
        } else if (input.value.trim()) {
          hasErrors = true;
          errorMessage = 'Invalid L* value';
          input.style.borderColor = '#d1d5db';
          if (swatch) {
            swatch.style.backgroundColor = '#ffffff';
            swatch.style.backgroundImage = 'repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px)';
            swatch.style.borderStyle = 'dashed';
            swatch.innerText = '—';
          }
        } else {
          input.style.borderColor = '#d1d5db';
          if (swatch) {
            swatch.style.backgroundColor = '#ffffff';
            swatch.style.backgroundImage = 'repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px)';
            swatch.style.borderStyle = 'dashed';
            swatch.innerText = '—';
          }
        }
      });
      
      if (values.length < 5) {
        hasErrors = true;
        // No user-facing message; keep the button disabled without showing the old text
      }
      // Require all L* values to be provided for reconstruction
      const totalInputs = inputs.length;
      if (values.length !== totalInputs) {
        hasErrors = true;
        if (!errorMessage) errorMessage = 'All L* values must be set (0–100)';
      }
      // Validate monotonic increasing Xs for target and measured
      function isStrictlyIncreasing(arr) {
        for (let i = 1; i < arr.length; i++) if (!(arr[i] > arr[i - 1])) return false;
        return true;
      }
      if (measuredXs.length === inputs.length) {
        if (!isStrictlyIncreasing(measuredXs)) {
          hasErrors = true;
          if (!errorMessage) errorMessage = 'Patch % must be strictly increasing (0→100)';
        }
      } else {
        hasErrors = true;
        if (!errorMessage) errorMessage = 'All Patch % must be set (0–100)';
      }
      
      if (hasErrors) {
        elements.generateFromLstar.disabled = true;
        if (errorMessage) {
          elements.lstarValidation.textContent = errorMessage;
          // Center only the specific message requesting all L* values
          if (errorMessage === 'All L* values must be set (0–100)') {
            elements.lstarValidation.classList.add('text-center');
          } else {
            elements.lstarValidation.classList.remove('text-center');
          }
          elements.lstarValidation.classList.remove('hidden');
        } else {
          elements.lstarValidation.classList.add('hidden');
          elements.lstarValidation.classList.remove('text-center');
        }
      } else {
        elements.lstarValidation.classList.add('hidden');
        elements.lstarValidation.classList.remove('text-center');
        elements.generateFromLstar.disabled = false;
      }
      
      // Return aligned arrays in row order
      const measuredPairs = [];
      if (!hasErrors) {
        // values[] preserves row order via index, but to be explicit map per row
        const valueByIndex = new Map(values.map(v => [v.index, v.value]));
        elements.lstarInputs.querySelectorAll('tr').forEach((row, idx) => {
          const v = valueByIndex.get(idx);
          const xEl = row.querySelector('.lstar-measured-x');
          const xv = xEl ? parseFloat(xEl.value) : NaN;
          if (!isNaN(v) && !isNaN(xv)) measuredPairs.push({ x: xv, l: v });
        });
      }
      return { valid: !hasErrors, values, measuredX: measuredXs, measuredPairs };
    }
    
    function parseManualLstarData(validation) {
      const measuredPairs = validation.measuredPairs || [];
      const measuredXs = measuredPairs.map(p => p.x);
      const measuredL = measuredPairs.map(p => p.l);
      const N = measuredL.length;
      // Auto-detect range for input values: if any input value > 100, assume 0-255 range; otherwise 0-100 range
      // L* values are always 0-100 by CIE LAB standard
      const maxInputValue = measuredXs.length > 0 ? Math.max(...measuredXs) : 0;
      const divisor = maxInputValue > 100 ? 255 : 100;
      const posNorm = measuredXs.map(v => Math.max(0, Math.min(divisor, v)) / divisor);
      const expectedDensity = posNorm.map(t => getTargetRelAt(t));
      const Dvals = measuredL.map(L => cieDensityFromLstar(L));
      const Dmax = Math.max(...Dvals, 1e-6);
      const actualDensity = Dvals.map(D => D / Dmax);
      const correctionPoints = posNorm.map((pos, i) => ({
        position: pos,
        correction: (expectedDensity[i] - actualDensity[i]),
        originalLab: measuredL[i],
        originalInput: measuredXs[i]
      }));
      const positionsOnly = correctionPoints.map(p => p.position);
      const K_NEIGHBORS = LAB_TUNING.get('K_NEIGHBORS', 6);
      const SIGMA_FLOOR = 0.02;
      const SIGMA_CEIL = 0.15;
      const SIGMA_ALPHA = 3.0;
      function localSigmaAt(t) {
        const n = positionsOnly.length;
        if (n <= 1) return SIGMA_CEIL;
        let lo = 0, hi = n;
        while (lo < hi) {
          const mid = (lo + hi) >> 1;
          if (positionsOnly[mid] < t) lo = mid + 1; else hi = mid;
        }
        const dists = [];
        let L = lo - 1, R = lo;
        while ((L >= 0 || R < n) && dists.length < K_NEIGHBORS) {
          const dl = (L >= 0) ? Math.abs(t - positionsOnly[L]) : Infinity;
          const dr = (R < n) ? Math.abs(t - positionsOnly[R]) : Infinity;
          if (dl <= dr) { if (isFinite(dl)) dists.push(dl); L--; } else { if (isFinite(dr)) dists.push(dr); R++; }
        }
        if (dists.length === 0) return SIGMA_CEIL;
        dists.sort((a,b)=>a-b);
        const mid = dists.length >> 1;
        const med = (dists.length % 2 === 0) ? 0.5*(dists[mid-1]+dists[mid]) : dists[mid];
        return Math.min(SIGMA_CEIL, Math.max(SIGMA_FLOOR, SIGMA_ALPHA * med));
      }
      const samples = new Array(256);
      for (let i = 0; i < 256; i++) {
        const t = i / 255;
        const sigma = localSigmaAt(t);
        const denom = 2 * sigma * sigma;
        let num = 0, den = 0;
        for (let j = 0; j < correctionPoints.length; j++) {
          const d = Math.abs(t - correctionPoints[j].position);
          const w = Math.exp(-(d * d) / Math.max(1e-9, denom));
          num += correctionPoints[j].correction * w;
          den += w;
        }
        const corr = den > 0 ? (num / den) : 0;
        samples[i] = Math.max(0, Math.min(1, t + corr));
      }
      samples[0] = 0.0;
      samples[255] = 1.0;
      const originalData = measuredL.map((lab, i) => ({ input: measuredXs[i], lab }));
      return {
        domainMin: 0.0,
        domainMax: 1.0,
        samples,
        originalData,
        format: 'Manual L* Entry',
        sourceSpace: DataSpace.SPACE.PRINTER,
        getSmoothingControlPoints: function(smoothingPercent) {
          const sp = Math.max(0, Math.min(90, Number(smoothingPercent) || 0));
          const widen = 1 + (sp / 100);
          const dyn = new Array(256);
          for (let i = 0; i < 256; i++) {
            const t = i / 255;
            const sigmaLocal = localSigmaAt(t) * widen;
            const sigma = Math.min(SIGMA_CEIL, Math.max(SIGMA_FLOOR, sigmaLocal));
            const denom = 2 * sigma * sigma;
            let num = 0, den = 0;
            for (let j = 0; j < correctionPoints.length; j++) {
              const d = Math.abs(t - correctionPoints[j].position);
              const w = Math.exp(-(d * d) / Math.max(1e-9, denom));
              num += correctionPoints[j].correction * w;
              den += w;
            }
            const corr = den > 0 ? (num / den) : 0;
            dyn[i] = Math.max(0, Math.min(1, t + corr));
          }
          dyn[0] = 0.0;
          dyn[255] = 1.0;
          const controlPointCount = Math.max(3, 21 - Math.floor(sp / 10));
          const cpY = [];
          const cpX = [];
          for (let i = 0; i < controlPointCount; i++) {
            const x = i / (controlPointCount - 1);
            const idx = Math.round(x * 255);
            cpX.push(x);
            cpY.push(dyn[idx]);
          }
          return { samples: cpY, xCoords: cpX, controlPointCount, needsDualTransformation: false, influenceRadius: null };
        }
      };
    }
    
    // Modal event handlers (Manual L*)
    elements.manualLstarBtn.addEventListener('click', () => {
      updateLstarInputs();
      elements.lstarModal.classList.remove('hidden');
      try {
        document.documentElement.classList.add('overflow-hidden');
        document.body.classList.add('overflow-hidden');
      } catch {}
    });
    
    elements.closeLstarModal.addEventListener('click', () => {
      elements.lstarModal.classList.add('hidden');
      try {
        document.documentElement.classList.remove('overflow-hidden');
        document.body.classList.remove('overflow-hidden');
      } catch {}
    });
    
    elements.cancelLstar.addEventListener('click', () => {
      elements.lstarModal.classList.add('hidden');
      try {
        document.documentElement.classList.remove('overflow-hidden');
        document.body.classList.remove('overflow-hidden');
      } catch {}
    });
    
    elements.lstarModal.addEventListener('click', (e) => {
      if (e.target === elements.lstarModal) {
        elements.lstarModal.classList.add('hidden');
        try {
          document.documentElement.classList.remove('overflow-hidden');
          document.body.classList.remove('overflow-hidden');
        } catch {}
      }
    });
    
    elements.addLstarInput.addEventListener('click', () => {
      if (lstarInputCount < 50) { // Increased maximum for more measurement points
        lstarInputCount++;
        updateLstarInputs();
      }
    });
    
    elements.removeLstarInput.addEventListener('click', () => {
      if (lstarInputCount > 5) {
        lstarInputCount--;
        updateLstarInputs();
      }
    });
    
    // Live validation as user types
    elements.lstarInputs.addEventListener('input', validateLstarInputs);
    
    // Handle direct input in the count field
    elements.lstarCountInput.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      if (!isNaN(value) && value >= 5 && value <= 50) {
        lstarInputCount = value;
        updateLstarInputs();
      }
    });

    // Link toggle removed: Target X% is always linked to Measured X% in this simplified workflow
    
    elements.generateFromLstar.addEventListener('click', () => {
      const validation = validateLstarInputs();
      if (!validation.valid) return;
      
      try {
        const correctionData = parseManualLstarData(validation);
        
        // Apply the correction as global linearization
        correctionData.filename = `Manual-L-${validation.values.length}pts`;
        linearizationData = normalizeLinearizationEntry(correctionData);
        linearizationApplied = true;
        
        // Update UI to show applied correction
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: Manual L* (${getBasePointCountLabel(correctionData)})`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        try { updateRevertButtonsState(); } catch {}
        
        // Show file info
        elements.globalLinearizationInfo.classList.remove('hidden');
        elements.globalLinearizationFilename.textContent = `Manual L* Entry`;
        elements.globalLinearizationDetails.textContent = ` (${getBasePointCountLabel(correctionData)})`;
        try { updateIntentDetailLabel(); } catch {}
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.add('hidden');
        
        // Save the values for re-population
        const inputs = elements.lstarInputs.querySelectorAll('.lstar-input');
        lastLstarValues = Array.from(inputs).map(input => input.value);
        lstarInputCount = validation.values.length;
        
        // Update interpolation controls
        updateInterpolationControls();
        updatePreview();
        
        // Update filename to reflect current state
        updateFilename();
        
        elements.lstarModal.classList.add('hidden');
        
        // Status note: CIE density; Gaussian-weighted reconstruction with PCHIP interpolation (Manual L*)
        showStatus(`Applied manual L* correction curve (${getBasePointCountLabel(correctionData)}) (CIE density; Gaussian-weighted reconstruction with PCHIP interpolation)`);
        try { postGlobalDeltaChatSummary(); } catch {}
      } catch (error) {
        console.error('Error processing L* values:', error);
        showStatus(`Error processing L* values: ${error.message}`);
      }
    });

    // Save Manual L* entries as a .txt file (Color-Muse format)
    elements.saveLstarTxt.addEventListener('click', () => {
      const validation = validateLstarInputs();
      if (!validation.valid) {
        // Prompt user to fix entries before saving
        elements.lstarValidation.textContent = 'Please fix errors and complete all fields before saving .txt';
        elements.lstarValidation.classList.remove('hidden');
        elements.lstarValidation.classList.remove('text-center');
        return;
      }
      const measuredPairs = validation.measuredPairs || [];
      // Header and columns match Color-Muse-Data.txt
      const header = 'GRAY\tLAB_L\tLAB_A\tLAB_B\n';
      const lines = measuredPairs.map(p => {
        const gray = Number(p.x).toFixed(2);
        const labL = Number(p.l).toFixed(2);
        return `${gray}\t${labL}\t0.00\t0.00`;
      });
      const content = header + lines.join('\n') + '\n';
      const filename = 'LAB-Data.txt';
      downloadFile(content, filename, 'text/plain');
    });

    // Contrast Intent: main dropdown and modal logic
    if (elements.contrastIntentSelect) {
      elements.contrastIntentSelect.addEventListener('change', (e)=>{
        const v = e.target.value;
        if (v === 'enter_custom') {
          try { document.documentElement.classList.add('overflow-hidden'); document.body.classList.add('overflow-hidden'); } catch {}
          elements.intentModal.classList.remove('hidden');
          try {
            elements.intentPresetSelect.value = contrastIntent?.id || 'linear';
            updatePresetDescription();
            syncPresetControlValuesFromState();
            // Jump to Custom tab for quicker edits
            setActiveIntentTab('custom');
            // Validate any prefilled paste data on open
            try { if (typeof scheduleAutoParseForPasteArea === 'function') scheduleAutoParseForPasteArea(); } catch {}
            // Reset the dropdown away from 'enter_custom' so selecting it again will fire 'change'
            try {
              const idStr = String(contrastIntent?.id || 'linear');
              const desired = idStr.startsWith('custom') ? 'custom' : idStr;
              const opts = Array.from(elements.contrastIntentSelect.options).map(o=>o.value);
              elements.contrastIntentSelect.value = opts.includes(desired) ? desired : (opts.includes('linear') ? 'linear' : opts[0]);
            } catch {}
          } catch {}
        } else {
          if (v === 'custom') {
            // Apply existing custom intent or build from saved prefs/paste
            const idStr = String(contrastIntent?.id || 'linear');
            if (idStr.startsWith('custom')) {
              // Re-apply to ensure consistent state
              setContrastIntent(contrastIntent.id, contrastIntent.params || {}, 'custom');
            } else {
              const prefs = loadCustomPrefs ? loadCustomPrefs() : { gamma:1.00, gain:0.55, shoulder:0.35, pasteText:'' };
              // Priority: imported samples → pasted → filmic → gamma
              let applied = false;
              try {
                const saved = JSON.parse(localStorage.getItem('customIntentSamplesV1')||'null');
                if (saved && Array.isArray(saved.samples) && saved.samples.length >= 2) {
                  const fn = buildTargetFnFromSamples(saved.samples);
                  const nm = saved.filename ? `Custom (imported: ${saved.filename})` : 'Custom (imported)';
                  setContrastIntent('custom_points', { name: nm, targetFn: fn }, 'custom');
                  applied = true;
                }
              } catch {}
              if (!applied && prefs.pasteText && parseIntentPaste) {
                try {
                  const parsed = parseIntentPaste(String(prefs.pasteText));
                  if (parsed && parsed.ok && typeof parsed.targetFn === 'function') {
                    setContrastIntent('custom_points', { name: parsed.name || 'Custom (pasted)', targetFn: parsed.targetFn }, 'custom');
                    applied = true;
                  }
                } catch {}
              }
              if (!applied) {
                const g = Number(prefs.gamma||1.00), gain = Number(prefs.gain||0.55), shoulder = Number(prefs.shoulder||0.35);
                if (Math.abs(gain-0.55)>1e-3 || Math.abs(shoulder-0.35)>1e-3) {
                  setContrastIntent('custom_filmic', { gain, shoulder }, 'custom');
                } else {
                  setContrastIntent('custom_gamma', { gamma: g }, 'custom');
                }
              }
            }
            // Keep selection on 'custom'
            elements.contrastIntentSelect.value = 'custom';
            return;
          }
          // Use central preset definitions
          const preset = getPreset(v);
          if (preset) {
            setContrastIntent(preset.id, preset.params, 'preset');
          } else {
            setContrastIntent('linear', {}, 'preset');
          }
        }
      });
    }

    const remapHandler = () => {
      applyIntentToLoadedCurve();
    };
    if (elements.applyIntentToQuadBtn) {
      elements.applyIntentToQuadBtn.addEventListener('click', remapHandler);
    }
    function setActiveIntentTab(name){
      const tabs=['presets','custom','paste','import'];
      tabs.forEach(t=>{
        const isActive=(t===name);
        const btn=Array.from(elements.intentTabs||[]).find(b=>b.getAttribute('data-intent-tab')===t);
        const panel=document.getElementById(`intentTab-${t}`);
        if(btn){ if(isActive) btn.classList.add('bg-gray-100','text-gray-700'); else btn.classList.remove('bg-gray-100','text-gray-700'); }
        if(panel){ panel.classList.toggle('hidden', !isActive); }
      });
      // Update footer Apply button label based on active tab
      if (elements.applyIntentBtn) {
        if (name === 'custom') elements.applyIntentBtn.textContent = 'Apply Sliders';
        else if (name === 'paste') elements.applyIntentBtn.textContent = 'Apply Pasted';
        else if (name === 'import') elements.applyIntentBtn.textContent = 'Apply Imported';
        else elements.applyIntentBtn.textContent = 'Apply Intent';
      }
      // If switching to Paste tab, auto-validate current text
      if (name === 'paste') {
        try { if (typeof scheduleAutoParseForPasteArea === 'function') scheduleAutoParseForPasteArea(); } catch {}
      }
    }
    function updatePresetDescription(){
      const presetId = elements.intentPresetSelect?.value || 'linear';
      const content = document.getElementById('presetDescriptionContent');
      if (!content) return;

      const preset = getPreset(presetId);
      if (!preset) return;

      content.innerHTML = `
        <h4 class="font-medium text-gray-900 mb-2">${preset.label}</h4>
        <p class="text-sm text-gray-600">${preset.description}</p>
      `;
    }
    const CUSTOM_PREFS_KEY = 'contrastIntentCustomPrefsV1';
    function loadCustomPrefs(){ try { const j = JSON.parse(localStorage.getItem(CUSTOM_PREFS_KEY)||'{}'); return { gamma: Number(j.gamma??1.00)||1.00, gain: Number(j.gain??0.55)||0.55, shoulder: Number(j.shoulder??0.35)||0.35, pasteText: String(j.pasteText||'') }; } catch { return { gamma:1.00, gain:0.55, shoulder:0.35, pasteText:'' }; } }
    function saveCustomPrefs(upd){ try { const cur=loadCustomPrefs(); const nxt={...cur, ...upd}; localStorage.setItem(CUSTOM_PREFS_KEY, JSON.stringify(nxt)); } catch {} }
    function syncPresetControlValuesFromState(){ const id=contrastIntent?.id||'linear'; const prefs = loadCustomPrefs(); if(id==='soft'||id==='hard'||id==='custom_gamma'){ const g=(contrastIntent?.params?.gamma!=null)?contrastIntent.params.gamma:prefs.gamma; elements.intentGamma.value=g; elements.intentGammaVal.textContent=Number(g).toFixed(2);} else { elements.intentGamma.value=prefs.gamma; elements.intentGammaVal.textContent=Number(prefs.gamma).toFixed(2);} if(id==='filmic'||id==='custom_filmic'){ const g=(contrastIntent?.params?.filmicGain!=null)?contrastIntent.params.filmicGain:(contrastIntent?.params?.gain!=null?contrastIntent.params.gain:prefs.gain); const s=(contrastIntent?.params?.shoulder!=null)?contrastIntent.params.shoulder:prefs.shoulder; elements.intentFilmicGain.value=g; elements.intentFilmicGainVal.textContent=Number(g).toFixed(2); elements.intentShoulder.value=s; elements.intentShoulderVal.textContent=Number(s).toFixed(2);} else { elements.intentFilmicGain.value=prefs.gain; elements.intentFilmicGainVal.textContent=Number(prefs.gain).toFixed(2); elements.intentShoulder.value=prefs.shoulder; elements.intentShoulderVal.textContent=Number(prefs.shoulder).toFixed(2);} elements.customGamma.value=prefs.gamma; elements.customGammaVal.textContent=Number(prefs.gamma).toFixed(2); elements.customGain.value=prefs.gain; elements.customGainVal.textContent=Number(prefs.gain).toFixed(2); elements.customShoulder.value=prefs.shoulder; elements.customShoulderVal.textContent=Number(prefs.shoulder).toFixed(2); try{ updateRangeFill(elements.customGamma); updateRangeFill(elements.customGain); updateRangeFill(elements.customShoulder);}catch{} if (elements.intentPasteArea) elements.intentPasteArea.value = prefs.pasteText || ''; }
    (elements.intentTabs||[]).forEach(btn=>{ btn.addEventListener('click', ()=> setActiveIntentTab(btn.getAttribute('data-intent-tab'))); });
    if (elements.intentPresetSelect) { elements.intentPresetSelect.addEventListener('change', ()=>{ updatePresetDescription(); }); }
    if (elements.intentGamma) { elements.intentGamma.addEventListener('input', ()=>{ elements.intentGammaVal.textContent = Number(elements.intentGamma.value).toFixed(2); }); }
    if (elements.intentFilmicGain) { elements.intentFilmicGain.addEventListener('input', ()=>{ elements.intentFilmicGainVal.textContent = Number(elements.intentFilmicGain.value).toFixed(2); }); }
    if (elements.intentShoulder) { elements.intentShoulder.addEventListener('input', ()=>{ elements.intentShoulderVal.textContent = Number(elements.intentShoulder.value).toFixed(2); }); }
    function updateRangeFill(el){ try { const min=Number(el.min??0), max=Number(el.max??100), val=Number(el.value??0); const pct=Math.max(0, Math.min(100, ((val-min)/(max-min))*100)); el.style.setProperty('--percent', pct+'%'); } catch {} }
    if (elements.customGamma) { elements.customGamma.addEventListener('input', ()=>{ elements.customGammaVal.textContent = Number(elements.customGamma.value).toFixed(2); updateRangeFill(elements.customGamma); }); }
    if (elements.customGain) { elements.customGain.addEventListener('input', ()=>{ elements.customGainVal.textContent = Number(elements.customGain.value).toFixed(2); updateRangeFill(elements.customGain); }); }
    if (elements.customShoulder) { elements.customShoulder.addEventListener('input', ()=>{ elements.customShoulderVal.textContent = Number(elements.customShoulder.value).toFixed(2); updateRangeFill(elements.customShoulder); }); }
    function closeIntentModal(){
      elements.intentModal.classList.add('hidden');
      try { document.documentElement.classList.remove('overflow-hidden'); document.body.classList.remove('overflow-hidden'); } catch {}
      // No dynamic height; content uses a fixed CSS height
      try { if (elements.intentContent) elements.intentContent.style.height = ''; } catch {}
    }
    if (elements.closeIntentModal) elements.closeIntentModal.addEventListener('click', closeIntentModal);
    if (elements.cancelIntentBtn) elements.cancelIntentBtn.addEventListener('click', closeIntentModal);
    // Guard against accidental close when dragging/selecting inside the modal
    let intentBackdropMouseDown = false;
    if (elements.intentModal) {
      elements.intentModal.addEventListener('mousedown', (e)=>{ intentBackdropMouseDown = (e.target === elements.intentModal); });
      elements.intentModal.addEventListener('touchstart', (e)=>{ intentBackdropMouseDown = (e.target === elements.intentModal); }, { passive: true });
      elements.intentModal.addEventListener('click', (e)=>{
        if (e.target === elements.intentModal && intentBackdropMouseDown) closeIntentModal();
        intentBackdropMouseDown = false;
      });
    }

    // Fixed height for intent modal content set via CSS class h-[512px]
    if (elements.resetIntentBtn) elements.resetIntentBtn.addEventListener('click', ()=>{ setContrastIntent('linear', {}, 'preset'); closeIntentModal(); });
    if (elements.applyIntentBtn) elements.applyIntentBtn.addEventListener('click', ()=>{
      const active = ['presets','custom','paste','import'].find(t => !document.getElementById(`intentTab-${t}`).classList.contains('hidden')) || 'presets';
      if (active === 'presets'){
        const presetId = elements.intentPresetSelect.value;
        const preset = getPreset(presetId);
        if (preset) {
          setContrastIntent(preset.id, preset.params, 'preset');
        } else {
          setContrastIntent('linear', {}, 'preset');
        }
        closeIntentModal();
      } else if (active === 'custom'){
        const g = Number(elements.customGamma.value); const gain = Number(elements.customGain.value); const shoulder = Number(elements.customShoulder.value);
        if (Math.abs(gain-0.55)>1e-3 || Math.abs(shoulder-0.35)>1e-3) { saveCustomPrefs({gain, shoulder}); setContrastIntent('custom_filmic', { gain, shoulder }, 'custom'); } else { saveCustomPrefs({gamma:g}); setContrastIntent('custom_gamma', { gamma: g }, 'custom'); }
        closeIntentModal();
      } else if (active === 'paste'){
        const text = String(elements.intentPasteArea.value||'').trim(); const parsed = parseIntentPaste(text);
        if (parsed && parsed.ok){ const targetFn = parsed.targetFn; const name = parsed.name || 'Custom (pasted)'; saveCustomPrefs({ pasteText: text }); setContrastIntent('custom_points', { name, targetFn }, 'paste'); elements.intentPasteValidation.classList.add('hidden'); elements.intentPasteValidation.textContent = ''; closeIntentModal(); }
        else { elements.intentPasteValidation.textContent = parsed?.error || 'Could not parse data. Expected CSV percent_input,density_rel or JSON with points/generator.'; elements.intentPasteValidation.classList.remove('hidden'); }
      } else if (active === 'import'){
        if (!intentImportState.samples || intentImportState.samples.length < 2) { showStatus('Import a valid ACV/LUT first'); return; }
        // Helpers (scoped here to avoid hoist issues)
        const _normalizeEndpoints=(samples)=>{ const y0=samples[0], y1=samples[samples.length-1]; const d=Math.max(1e-6,y1-y0); const out=samples.map(v=>clamp01((v-y0)/d)); out[0]=0; out[out.length-1]=1; return out; };
        const _enforceMonotonicIncreasing=(arr)=>{ const out=arr.slice(); for(let i=1;i<out.length;i++){ if(out[i]<out[i-1]) out[i]=out[i-1]; } out[0]=Math.max(0,out[0]); out[out.length-1]=Math.min(1,out[out.length-1]); return out; };
        // Build imported target samples (always anchor endpoints and enforce monotonic; no blending UI)
        let ys = _normalizeEndpoints(intentImportState.samples);
        ys = _enforceMonotonicIncreasing(ys);
        const targetFn = buildTargetFnFromSamples(ys);
        const baseName = intentImportState.filename ? `Custom (imported: ${intentImportState.filename})` : 'Custom (imported)';
        setContrastIntent('custom_points', { name: baseName, targetFn }, 'import');
        // Persist imported samples so Custom (saved) can restore this target later
        try { localStorage.setItem('customIntentSamplesV1', JSON.stringify({ samples: ys, filename: intentImportState.filename||'', kind: intentImportState.kind||'' })); localStorage.setItem('hasCustomIntentV1','1'); } catch {}
        closeIntentModal();
      }
    });

    // Import tab UI wiring
    if (elements.intentImportBtn && elements.intentImportFile){
      elements.intentImportBtn.addEventListener('click', ()=> elements.intentImportFile.click());
      elements.intentImportFile.addEventListener('change', async (e)=>{
        const file = e.target.files[0]; if (!file) return;
        try{
          const ext = file.name.toLowerCase().split('.').pop();
          const input = (ext==='acv') ? await file.arrayBuffer() : await file.text();
          const parsed = await parseLinearizationFile(input, file.name);
          intentImportState = {
            samples: (parsed && Array.isArray(parsed.samples)) ? parsed.samples.slice() : null,
            filename: file.name,
            kind: parsed?.is3DLUT ? 'LUT3D (neutral axis)' : (String(parsed?.format||'').toUpperCase()==='ACV' ? 'ACV' : 'LUT1D')
          };
          if (elements.intentImportInfo) {
            const n = intentImportState.samples?.length || 0;
            const y0 = n? intentImportState.samples[0].toFixed(3):'-';
            const y1 = n? intentImportState.samples[n-1].toFixed(3):'-';
            elements.intentImportInfo.textContent = `Parsed: ${intentImportState.kind} (${n} samples) from ${intentImportState.filename}. Endpoints: [${y0} → ${y1}]. Endpoints will be normalized and monotonic enforced.`;
          }
        } catch(err){
          intentImportState = { samples:null, filename:'', kind:'' };
          if (elements.intentImportInfo) elements.intentImportInfo.textContent = `Error: ${err.message}`;
        }
      });
    }
    // Removed: explicit "Load as correction instead" button from Import tab
    // No blend/anchor/monotonic options; import path always anchors endpoints and enforces monotonic
    if (elements.intentParseBtn) elements.intentParseBtn.addEventListener('click', ()=>{ const parsed = parseIntentPaste(String(elements.intentPasteArea.value||'').trim()); if (parsed && parsed.ok) { elements.intentPasteValidation.textContent = 'Parsed OK. Click Apply Pasted to use it.'; elements.intentPasteValidation.classList.remove('hidden'); elements.intentPasteValidation.classList.remove('text-red-600'); elements.intentPasteValidation.classList.add('text-green-700'); } else { elements.intentPasteValidation.textContent = parsed?.error || 'Could not parse data.'; elements.intentPasteValidation.classList.remove('hidden'); elements.intentPasteValidation.classList.add('text-red-600'); elements.intentPasteValidation.classList.remove('text-green-700'); } });

    // Determine if a saved custom intent exists (applied previously, valid pasted data, or saved slider prefs)
    function hasSavedCustomIntent(){
      try {
        if (String(contrastIntent?.id||'').startsWith('custom')) return true;
        if (localStorage.getItem('hasCustomIntentV1') === '1') return true;
      } catch {}
      try {
        const prefs = loadCustomPrefs ? loadCustomPrefs() : null;
        if (!prefs) return false;
        const txt = String(prefs.pasteText||'').trim();
        if (txt){ try { if (typeof parseIntentPaste === 'function'){ const parsed = parseIntentPaste(txt); if (parsed && parsed.ok) return true; } else { return true; } } catch {} }
        const g = Number(prefs.gamma||1.00), gain = Number(prefs.gain||0.55), shoulder = Number(prefs.shoulder||0.35);
        if (Math.abs(g-1.00)>1e-3 || Math.abs(gain-0.55)>1e-3 || Math.abs(shoulder-0.35)>1e-3) return true;
        // Imported samples persisted
        try { const saved = JSON.parse(localStorage.getItem('customIntentSamplesV1')||'null'); if (saved && Array.isArray(saved.samples) && saved.samples.length>=2) return true; } catch {}
      } catch {}
      return false;
    }
    function updateCustomOptionVisibility(){
      try {
        const sel = elements.contrastIntentSelect; if (!sel) return;
        const opts = Array.from(sel.options);
        let customOpt = opts.find(o=>o.value==='custom');
        const enterOpt = opts.find(o=>o.value==='enter_custom');
        const shouldShow = hasSavedCustomIntent();
        if (shouldShow){
          if (!customOpt){
            const opt = document.createElement('option');
            opt.value = 'custom';
            opt.textContent = 'Custom (saved)';
            if (enterOpt) sel.insertBefore(opt, enterOpt); else sel.appendChild(opt);
          }
        } else {
          if (customOpt){
            if (sel.value === 'custom') sel.value = 'linear';
            sel.removeChild(customOpt);
          }
        }
      } catch {}
    }

    // Auto-parse when user types or pastes into the paste area (debounced)
    let intentPasteDebounceTimer = null;
    function scheduleAutoParseForPasteArea(){
      if (!elements.intentPasteArea || !elements.intentPasteValidation) return;
      const text = String(elements.intentPasteArea.value||'').trim();
      if (intentPasteDebounceTimer) clearTimeout(intentPasteDebounceTimer);
      if (!text){
        // Clear validation if empty
        elements.intentPasteValidation.textContent = '';
        elements.intentPasteValidation.classList.add('hidden');
        elements.intentPasteValidation.classList.remove('text-green-700');
        elements.intentPasteValidation.classList.remove('text-red-600');
        return;
      }
      intentPasteDebounceTimer = setTimeout(()=>{
        try {
          const parsed = parseIntentPaste(text);
          if (parsed && parsed.ok){
            elements.intentPasteValidation.textContent = 'Parsed OK. Click Apply Pasted to use it.';
            elements.intentPasteValidation.classList.remove('hidden');
            elements.intentPasteValidation.classList.remove('text-red-600');
            elements.intentPasteValidation.classList.add('text-green-700');
          } else {
            elements.intentPasteValidation.textContent = parsed?.error || 'Could not parse data.';
            elements.intentPasteValidation.classList.remove('hidden');
            elements.intentPasteValidation.classList.add('text-red-600');
            elements.intentPasteValidation.classList.remove('text-green-700');
          }
          // Content height may change when validation appears/disappears
          
        } catch (err){
          elements.intentPasteValidation.textContent = 'Could not parse data.';
          elements.intentPasteValidation.classList.remove('hidden');
          elements.intentPasteValidation.classList.add('text-red-600');
          elements.intentPasteValidation.classList.remove('text-green-700');
          
        }
      }, 300);
    }
    if (elements.intentPasteArea){
      elements.intentPasteArea.addEventListener('input', scheduleAutoParseForPasteArea);
      elements.intentPasteArea.addEventListener('paste', ()=> setTimeout(scheduleAutoParseForPasteArea, 0));
    }

    // Initialize preset dropdowns from central definitions
    function initializePresetDropdowns() {
      try {
        // Main Intent dropdown
        const mainSelect = elements.contrastIntentSelect;
        if (mainSelect) {
          const presetHTML = generatePresetDropdownHTML();
          const existingOptions = mainSelect.innerHTML;
          // Insert preset options before existing custom options
          const beforeCustom = existingOptions.indexOf('<!-- Preset options will be populated dynamically');
          const afterComment = existingOptions.indexOf('-->') + 3;
          const customOptions = existingOptions.substring(afterComment);
          mainSelect.innerHTML = presetHTML + customOptions;
        }

        // Modal preset dropdown
        const modalSelect = elements.intentPresetSelect;
        if (modalSelect) {
          modalSelect.innerHTML = generatePresetDropdownHTML();
        }

        // Initialize description for modal
        updatePresetDescription();
      } catch (e) {
        console.warn('Failed to initialize preset dropdowns:', e);
      }
    }

    // Initialize dropdowns and custom options
    try { initializePresetDropdowns(); } catch {}
    try { updateIntentDropdownState(); } catch {}
    try { updateCustomOptionVisibility(); } catch {}
    // Initialize Intent dropdown state based on linearization data
    try { updateIntentDropdownState(); } catch {}
    function parseIntentPaste(text){
      try {
        if (!text) return { ok:false, error: 'No data provided' };
        const trimmed = text.trim();
        if (trimmed.startsWith('{') || trimmed.startsWith('[')){
          const obj = JSON.parse(trimmed);
          if (Array.isArray(obj)){
            const fn = compileIntentFromPoints(obj);
            return { ok:true, targetFn: fn, name: 'Custom (points)' };
          }
          if (obj.points && Array.isArray(obj.points)){
            const fn = compileIntentFromPoints(obj.points);
            return { ok:true, targetFn: fn, name: obj.name || 'Custom (points)' };
          }
          // Support schema: { Media: "Matte Inkjet", Curve: [{Input:0, Linear:0, Intent:0}, ...] }
          if (Array.isArray(obj.Curve)){
            const rows = [];
            for (const it of obj.Curve){
              if (!it || typeof it !== 'object') continue;
              // Case-insensitive keys
              const keys = Object.keys(it).reduce((m,k)=>{ m[k.toLowerCase()] = k; return m; }, {});
              const kInput = keys['input'];
              const kIntent = keys['intent'];
              const t = Number(kInput ? it[kInput] : NaN);
              const yv = Number(kIntent ? it[kIntent] : NaN);
              if (!isFinite(t) || !isFinite(yv)) continue;
              const y = yv > 1.000001 ? (yv/100) : yv;
              rows.push([Math.max(0, Math.min(1, t/100)), Math.max(0, Math.min(1, y))]);
            }
            if (rows.length < 2) return { ok:false, error: 'Curve array did not contain valid Input/Intent pairs' };
            const fn = compileIntentFromPoints(rows);
            const media = typeof obj.Media === 'string' && obj.Media.trim() ? obj.Media.trim() : '';
            return { ok:true, targetFn: fn, name: media ? `Custom (${media})` : 'Custom (pasted)' };
          }
          if (obj.generator && obj.generator.type === 'gamma'){
            const g = Number(obj.generator.params?.gamma ?? 1.0);
            return { ok:true, targetFn: (t)=>gammaMap(t,g), name: obj.name || `Gamma ${g.toFixed(2)}` };
          }
          if (obj.generator && obj.generator.type === 'filmic'){
            const gain = Number(obj.generator.params?.mid_slope ?? obj.generator.params?.gain ?? 0.55);
            const shoulder = Number(obj.generator.params?.shoulder ?? 0.35);
            return { ok:true, targetFn: (t)=>filmicSoftShoulder(t,gain,shoulder), name: obj.name || 'Filmic' };
          }
          return { ok:false, error: 'Unsupported JSON generator; provide points[] or gamma/filmic.' };
        }
        const lines = trimmed.split(/\r?\n/).filter(l=>l.trim().length>0);
        // CGATS-like block with BEGIN_DATA_FORMAT / BEGIN_DATA
        if (/BEGIN_DATA_FORMAT/i.test(trimmed) && /BEGIN_DATA/i.test(trimmed)) {
          let fmtStart = -1, fmtEnd = -1, dataStart = -1, dataEnd = lines.length;
          for (let i=0;i<lines.length;i++){
            const L = lines[i].trim();
            if (fmtStart<0 && /^BEGIN_DATA_FORMAT/i.test(L)) fmtStart = i;
            if (fmtEnd<0 && /^END_DATA_FORMAT/i.test(L)) fmtEnd = i;
            if (dataStart<0 && /^BEGIN_DATA/i.test(L)) dataStart = i;
            if (/^END_DATA/i.test(L)) { dataEnd = i; break; }
          }
          const colNames = [];
          if (fmtStart>=0 && fmtEnd>fmtStart){
            for (let i=fmtStart+1;i<fmtEnd;i++){
              const toks = lines[i].trim().split(/\s+/).filter(Boolean);
              if (toks.length) { colNames.push(...toks); break; }
            }
          }
          // Map column indices (case-insensitive)
          const lower = colNames.map(s=>s.toLowerCase());
          const idxInput = Math.max(lower.indexOf('input'), lower.indexOf('gray'));
          // Prefer 'intent' for target
          const idxIntent = lower.indexOf('intent');
          if (idxInput>=0 && idxIntent>=0 && dataStart>=0){
            const rows = [];
            for (let i=dataStart+1;i<dataEnd;i++){
              const parts = lines[i].trim().split(/\s+/).filter(Boolean);
              const t = Number(parts[idxInput]);
              const yv = Number(parts[idxIntent]);
              if (!isFinite(t) || !isFinite(yv)) continue;
              const y = yv > 1.000001 ? (yv/100) : yv;
              rows.push([Math.max(0, Math.min(1, t/100)), Math.max(0, Math.min(1, y))]);
            }
            if (rows.length >= 2){
              const fn = compileIntentFromPoints(rows);
              return { ok:true, targetFn: fn, name: 'Custom (pasted)' };
            }
          }
          // Fall through to generic parsing if mapping failed
        }
        if (!lines.length) return { ok:false, error: 'Empty input' };
        // Detect a label-only first line (no numbers) to use as a name
        const numberRegex = /[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g;
        let labelOnlyFirst = false; let labelName = '';
        try {
          const firstNums = (lines[0].match(numberRegex) || []).map(Number).filter(n=>isFinite(n));
          if (firstNums.length === 0 && /[A-Za-z]/.test(lines[0])) { labelOnlyFirst = true; labelName = lines[0].trim(); }
        } catch {}
        const header = lines[0].toLowerCase();
        let colT=-1, colRel=-1, colAbs=-1, colL=-1;
        const headers = header.split(/[,\t]/).map(h=>h.trim());
        headers.forEach((h,i)=>{ if (['percent_input','t','%input','input','gray','patch','patch%'].includes(h)) colT = i; if (['density_rel','d_rel','rel_density','relative','rel'].includes(h)) colRel = i; if (['density_abs','d_abs','abs_density','absolute','abs'].includes(h)) colAbs = i; if (['lstar','l*','lab_l','lab l','lab l*'].includes(h)) colL = i; });
        const rows = [];
        const nameCandidates = [];
        const startIdx = (colT>=0 || colRel>=0 || colAbs>=0 || colL>=0) ? 1 : (labelOnlyFirst ? 1 : 0);
        for (let i=startIdx;i<lines.length;i++){
          const rawLine = lines[i];
          const parts = rawLine.split(/[,\t]/).map(s=>s.trim());
          if (colT>=0) {
            const t = Number(parts[colT]); if (!isFinite(t)) continue;
            if (colRel>=0) { const y = Number(parts[colRel]); if (!isFinite(y)) continue; rows.push([t/100, y]); }
            else if (colAbs>=0) { const yAbs = Number(parts[colAbs]); if (!isFinite(yAbs)) continue; const y = Math.max(0, Math.min(1, yAbs)); rows.push([t/100, y]); }
            else if (colL>=0) { const L = Number(parts[colL]); if (!isFinite(L)) continue; const y = Math.max(0, Math.min(1, (100 - L)/100)); rows.push([t/100, y]); }
            continue;
          }
          // No header: accept whitespace- or comma-separated numeric rows, optionally with a leading label segment
          // Extract numeric tokens robustly (handles spaces or tabs):
          const numTokens = (rawLine.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g) || []).map(Number).filter(n=>isFinite(n));
          // Gather name candidates only when commas are present (avoid treating a numeric row as a label)
          if (rawLine.includes(',')) {
            const labelParts = rawLine.split(',').map(s=>s.trim());
            for (const lp of labelParts) { if (/[A-Za-z]/.test(lp)) nameCandidates.push(lp); }
          }
          // Also accept label separated by a pipe character
          if (rawLine.includes('|')) {
            const labelParts = rawLine.split('|').map(s=>s.trim());
            for (const lp of labelParts) { if (/[A-Za-z]/.test(lp)) nameCandidates.push(lp); }
          }
          if (numTokens.length >= 2) {
            const t = numTokens[0];
            const yVal = numTokens[numTokens.length-1];

            // Auto-detect range: if values > 100, assume 0-255 range; otherwise 0-100 range
            const maxVal = Math.max(t, yVal);
            const divisor = maxVal > 100 ? 255 : 100;

            const tNorm = Math.max(0, Math.min(1, t / divisor));
            const yNorm = Math.max(0, Math.min(1, yVal / divisor));
            rows.push([tNorm, yNorm]);
          }
        }
        if (rows.length < 2) {
          // Fallback: one-column numeric list interpreted as evenly spaced targets
          const yVals = [];
          for (let i=startIdx;i<lines.length;i++){
            const nums = (lines[i].match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g) || []).map(Number).filter(n=>isFinite(n));
            if (nums.length >= 1) yVals.push(nums[0]);
          }
          if (yVals.length >= 2) {
            const usesPercent = Math.max(...yVals) > 1.000001;
            const n = yVals.length;
            const rows1 = [];
            for (let i=0;i<n;i++){
              const t = (n === 1) ? 0 : (i/(n-1));
              const yn = usesPercent ? (yVals[i]/100) : yVals[i];
              rows1.push([Math.max(0, Math.min(1, t)), Math.max(0, Math.min(1, yn))]);
            }
            const fn = compileIntentFromPoints(rows1);
            return { ok:true, targetFn: fn, name: 'Custom (pasted)' };
          }
          return { ok:false, error: 'No valid rows parsed' };
        }
        const fn = compileIntentFromPoints(rows);
        let commonName = '';
        try {
          const labels = nameCandidates.filter(s => s && isNaN(Number(s)));
          if (labels.length) {
            const freq = labels.reduce((m,s)=>{ m[s]=(m[s]||0)+1; return m; }, {});
            commonName = Object.keys(freq).sort((a,b)=>freq[b]-freq[a])[0] || '';
          }
          if (!commonName && labelOnlyFirst && labelName) commonName = labelName;
        } catch {}
        return { ok:true, targetFn: fn, name: commonName ? `Custom (${commonName})` : 'Custom (pasted)' };
      } catch (e) { return { ok:false, error: e.message }; }
    }
    
    // [removed] About/Changelog popup rendering now lives under Help → Version History tab
    
    // Log capturing system
    const logHistory = [];
    const originalConsoleLog = console.log;
    const originalConsoleError = console.error;
    const originalConsoleWarn = console.warn;
    
    console.log = function(...args) {
      const timestamp = new Date().toISOString();
      logHistory.push(`[${timestamp}] LOG: ${args.join(' ')}`);
      originalConsoleLog.apply(console, args);
    };
    
    console.error = function(...args) {
      const timestamp = new Date().toISOString();
      logHistory.push(`[${timestamp}] ERROR: ${args.join(' ')}`);
      originalConsoleError.apply(console, args);
    };
    
    console.warn = function(...args) {
      const timestamp = new Date().toISOString();
      logHistory.push(`[${timestamp}] WARN: ${args.join(' ')}`);
      originalConsoleWarn.apply(console, args);
    };

    // Minimal Markdown renderer for Help popup
    function renderMarkdown(md){
      // Strip leading top-level title if it's just the app name
      try { md = md.replace(/^\s*#\s*quadGEN\s*(?:\r?\n|$)/i, ''); } catch {}
      function esc(s){
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      }
      function inline(s){
        let t = esc(s);
        t = t.replace(/`([^`]+)`/g,'<code>$1</code>');
        t = t.replace(/\[([^\]]+)\]\(([^)]+)\)/g,'<a href="$2" target="_blank" rel="noopener">$1</a>');
        return t;
      }
      const lines = md.split(/\r?\n/);
      const out = [];
      let inUl = false, inOl = false;
      const closeLists = () => { if (inUl){ out.push('</ul>'); inUl=false; } if (inOl){ out.push('</ol>'); inOl=false; } };
      for (const raw of lines){
        const line = raw; const trim = line.trim();
        if (trim === '') { closeLists(); continue; }
        if (/^#{1,6}\s/.test(trim)){
          closeLists();
          const level = Math.min((trim.match(/^#+/)[0] || '#').length + 1, 4); // map #->h2, ##->h3, etc.
          const text = trim.replace(/^#+\s*/,'');
          out.push(`<h${level}>${inline(text)}</h${level}>`);
          continue;
        }
        if (/^[-—]{1,}\s*$/.test(trim)) { closeLists(); out.push('<hr>'); continue; }
        if (/^\d+[).]\s+/.test(trim)){
          if (!inOl){ closeLists(); out.push('<ol>'); inOl=true; }
          out.push(`<li>${inline(trim.replace(/^\d+[).]\s+/,''))}</li>`);
          continue;
        }
        if (/^-\s+/.test(trim)){
          if (!inUl){ closeLists(); out.push('<ul>'); inUl=true; }
          out.push(`<li>${inline(trim.replace(/^-\s+/,''))}</li>`);
          continue;
        }
        closeLists();
        out.push(`<p>${inline(line)}</p>`);
      }
      closeLists();
      return out.join('\n');
    }

    async function loadReadmeText(){
      // Read embedded README content from this HTML file (no external fetch)
      try {
        const embedded = document.getElementById('embeddedReadme');
        if (embedded) return embedded.textContent || embedded.innerText || '';
      } catch (e) {}
      return '';
    }

    // Readme tab content (embedded HTML)
    function getHelpReadmeHTML(){
      return `
        <section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">
          <div style="display: flex; justify-content: center;">
            <div style="font-size: 10px; font-family: ui-monospace, SFMono-Regular, 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace; white-space: normal; line-height: 1.2; text-align: left; width: 100%;">MIT License

Copyright (c) 2025 David Marsh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Scope: This license applies to this HTML file (quadgen.html) only.</div>
          </div>

          <hr />

          <h2 id="overview">Overview</h2>
          <p>
            <strong>quadGEN</strong> is a free, browser-based tool for generating and refining <code>.quad</code> files used with QuadToneRIP.  
            It supports LAB/LUT/ACV inputs, and an Edit Mode for precise, point-based curve edits.  
            Core features work fully offline; the optional AI assistant requires network access.
          </p>
          <p>
            quadGEN is designed for photographers, printmakers, and alt-process practitioners who create digital negatives or monochrome prints and need reliable tonal calibration.
          </p>

          <h3>What is QuadToneRIP?</h3>
          <p>
            QuadToneRIP (QTR) is a specialized RIP/driver for Epson printers focused on high-quality monochrome printing using multi-shade ink sets.  
            QTR uses <code>.quad</code> files to determine how much ink each printer channel lays down at every input level.  
            A <code>.quad</code> file contains 256-sample curves (0–100% input) for each channel supported by the printer (e.g., K, C, M, Y, LC, LM, LK, LLK, OR, GR, etc.).  
            When you select a <code>.quad</code> in your QTR workflow (often via Print-Tool on macOS), QTR reads these curves and applies the specified per-channel ink outputs to render your print.  
            quadGEN’s role is to help you build and refine those <code>.quad</code> curves so QTR can produce linear, predictable output.  
            See the <a href="https://www.quadtonerip.com/html/QTRoverview.html" target="_blank" rel="noopener">QuadToneRIP Overview</a> for more background.
          </p>

          <hr />

          <h2 id="install">Installation and Access</h2>
          <ul>
            <li><strong>Online:</strong> visit <a href="https://david-marsh-photo.github.io/" target="_blank" rel="noopener">https://david-marsh-photo.github.io/</a>.</li>
            <li><strong>Offline:</strong> right‑click and download this file: <a href="https://david-marsh-photo.github.io/index.html" target="_blank" rel="noopener">https://david-marsh-photo.github.io/index.html</a>, then open it locally (no install required).</li>
            <li><strong>Platforms:</strong> macOS, Windows, Linux (desktop recommended).</li>
            <li><strong>Network note:</strong> AI assistant features require internet; manual editing and exports do not.</li>
          </ul>

          <hr />

<h2 id="quickstart">Quick Start (Beta 2.5.1)</h2>
          <ol>
            <li>Choose your printer and set ink limits (per channel).</li>
            <li>Start with Linear Ramp, or</li>
            <li>Load data: <code>.quad</code>, LAB <code>.txt</code>, LUT <code>.cube</code> (1D/3D), Photoshop <code>.acv</code>, or Manual L*.</li>
            <li>Export the corrected <code>.quad</code>, print a step wedge target.</li>
            <li>Measure print and load data, repeat if necessary.</li>
          </ol>

          <hr />

          <h2 id="features">Features (highlights)</h2>
          <ul>
            <li>Supports most Epson printers.</li>
            <li>Quickly export linear ramps with any single ink channel or combination.</li>
            <li>Inputs: <code>.quad</code>, LAB <code>.txt</code>, LUT <code>.cube</code>, <code>.acv</code>, Manual L*.</li>
            <li>Apply intent remaps directly to a loaded <code>.quad</code> via “Apply to Loaded Curve”.</li>
            <li>Evenly spaced or irregular targets supported.</li>
            <li>Edit Mode: point-based edits at any time.</li>
            <li>Undo/Redo: full history of edits and toggles.</li>
            <li>Recompute key points: simplify Smart Curves with tolerance/max-point controls.</li>
            <li>Graph zoom: use the +/− control in the chart corner to rescale the Y-axis in 10% steps when working with low ink limits; zoom automatically clamps to the highest active ink limit so you never crop a 100% curve.</li>
            <li>Lab Tech: AI assistant for Q&amp;A and automation.</li>
            <li>Contrast intent: presets or custom targets; shows Δ vs target; endpoints fixed (use ink limits to change).</li>
            <li>Auto endpoint rolloff: optional white/black soft knees that detect early plateau and ease into the ink limit with a smooth shoulder/toe (3% proximity threshold).</li>
            <li>Import ACV/LUT as target: in the Custom Intent modal, load <code>.acv</code>/<code>.cube</code> as a target intent (not a correction); includes endpoint anchoring, monotonic enforcement, and blend.</li>
          </ul>

          <hr />

          <h2 id="examples">Usage Examples</h2>
          <ul>
            <li>Digital negatives: cyanotype, Pt/Pd, kallitype, polymer photogravure.</li>
            <li>Inkjet linearization: refine monochrome response for QTR printing.</li>
            <li>Curve editing: enter Edit Mode, nudge an ordinal, export.</li>
            <li>Conversion: load LAB/LUT/ACV and export <code>.quad</code>.</li>
            <li>Intent remap: load your master linearized <code>.quad</code>, audition Gamma/Filmic presets, and bake a contrast variant directly.</li>
          </ul>

          <hr />

          <h2 id="best">Best Practices</h2>
          <p class="text-sm text-gray-600 mb-3">Linearize your process once, keep that <code>.quad</code> as a master, and branch from there. You can either bake an intent into the loaded master with “Apply Intent”, or leave the master untouched and make the contrast move upstream in Photoshop—printing through the linear master yields the same result.</p>
          <ul>
            <li>If your process requires a negative, invert it before printing with your <code>.quad</code>.</li>
            <li>Measure the final positive print (not the negative).</li>
            <li>Anchor endpoints and keep curves monotonic.</li>
            <li>Use ink limits to define deepest black (or cleanest white).</li>
            <li>Make incremental edits; use Undo/Redo liberally.</li>
            <li>Keep a “master” Linear intent <code>.quad</code>. You can bake contrast variants with “Apply Intent”, or do the contrast move in Photoshop and print through the same linear master—both paths land on the same tone curve.</li>
            <li>Zoom the chart so low-limit runs fill the plot—tap +/− in the lower-left to move in 10% steps, and the chart auto-expands again if you enable a higher ink limit later.</li>
          </ul>

          <hr />

          <h2 id="faq">Troubleshooting &amp; FAQ</h2>
          <ul>
            <li><strong>Offline use:</strong> Lab Tech is unavailable offline; manual functions work fully.</li>
            <li><strong>Curve orientation:</strong> quadGEN plots input % (X) vs ink output % (Y), origin = white. Other tools may use tone curves with origin = black.</li>
            <li><strong>Corrections:</strong> Upward curve = more ink (darker); downward = less ink (lighter). Example: raise mids if midtones are too light.</li>
          </ul>

          <hr />

          <h2 id="feedback">Feedback / Contact</h2>
            <p>Contact David Marsh – <a href="mailto:marshmonkey@gmail.com">marshmonkey@gmail.com</a></p>

          <hr />

          <h2 id="credits">Credits / Attribution</h2>
          <ul>
            <li>Tailwind CSS — used via CDN (<code>cdn.tailwindcss.com</code>), MIT License.</li>
            <li>Cloudflare Workers — used as an API proxy (rate-limited edge function).</li>
            <li>Anthropic Claude</li>
            <li>OpenAI ChatGPT / Codex</li>
            <li>Prints on Paper Studio — contrast intent definitions and feature references used with permission under <a href="https://www.gnu.org/licenses/gpl-3.0.html" target="_blank" rel="noopener">GNU Public License</a>.</li>
            <li>Trademarks: QuadToneRIP and Print‑Tool are property of Roy Harrington. Color Muse is a trademark of Variable, Inc. Easy Digital Negatives is a separate project. All product names, logos, and brands are property of their respective owners.</li>
          </ul>


          <hr />        

          <h2 id="refs">External References</h2>
          <ul>
            <li><a href="http://www.easydigitalnegatives.com/" target="_blank" rel="noopener">Easy Digital Negatives</a> – Export correction LUTs (<code>.cube</code>) and load into quadGEN.</li>
            <li><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">QuadToneRIP</a> – RIP software using <code>.quad</code> files. Install/export from quadGEN to QTR’s quad folder.</li>
            <li><a href="https://www.quadtonerip.com/html/QTRprinttool.html" target="_blank" rel="noopener">Print-Tool</a> – Utility for printing through QTR on macOS with color-management off.</li>
            <li><a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a> – Handheld colorimeter for LAB measurement. Exports <code>.txt</code> for import into quadGEN.</li>
            <li><a href="https://clayharmonblog.com/downloads/25-step-ColorMuse-target.zip" target="_blank" rel="noopener">Clay Harmon’s 21-step target</a> – Printable target for iterative calibration.</li>
          </ul>
        </section>
      `;
    }

    // Glossary tab content (embedded, single source of truth)
    function getHelpGlossaryHTML(){
      return `
        <section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">
          <h2>quadGEN Glossary</h2>
          <p>A concise, alphabetized reference to key terms used in quadGEN, QuadToneRIP, and related workflows.</p>
          <dl>
            <dt>Auto black limit</dt>
            <dd>Automatic soft toe at the black end: detects an early plateau near 0% output and eases the first segment so the curve approaches 0 with zero slope, preserving shadow separation.</dd>

            <dt>Auto white limit</dt>
            <dd>Automatic soft shoulder at the white end: detects an early plateau near the ink limit and eases the last segment so the curve reaches the limit exactly at 100% with zero slope, preserving highlight separation.</dd>

            <dt>ACV (Photoshop Curves)</dt>
            <dd>Binary curve format used by Adobe Photoshop (<code>.acv</code>). In quadGEN: can be loaded as a global correction or per-channel adapter; anchors can seed editable Smart curve.</dd>

            <dt>Channel</dt>
            <dd>A printer ink channel (e.g., K, C, M, Y, LC, LM, LK, LLK, OR, GR, MK, V). Channels can be enabled/disabled and have independent End (ink limits).</dd>

            <dt>Color Muse 2</dt>
            <dd><a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Handheld colorimeter</a> for measuring LAB values from printed wedges/targets. Exports <code>.txt</code> files compatible with quadGEN.</dd>

            <dt>Correction (curve)</dt>
            <dd>Mapping that adjusts output ink levels versus input to achieve a target response. In quadGEN, plotted as Y (output ink %) vs X (input %).</dd>

            <dt>EDN (Easy Digital Negatives)</dt>
            <dd><a href="http://www.easydigitalnegatives.com/" target="_blank" rel="noopener">Workflow</a> to build correction LUTs for digital negatives. Export <code>.cube</code> LUTs from EDN for use as global/per-channel corrections in quadGEN.</dd>

            <dt>Edit Mode</dt>
            <dd>Gated state that enables key-point editing and shows overlays. Selected channel draws on top; unselected enabled channels dim.</dd>

            <dt>End (ink limit)</dt>
            <dd>Per-channel maximum ink level. Edits that require more ink can raise End when feasible; when End is effectively locked, edits that exceed it are blocked with status.</dd>

            <dt>Gaussian Weighted Correction</dt>
            <dd>LAB processing method that spreads each measurement's influence smoothly across inputs; reduces artifacts versus naive inversion techniques.</dd>

            <dt>Gamma value</dt>
            <dd>Numerical parameter that controls the shape of a power-law tone curve. In quadGEN's contrast intent presets: gamma < 1.0 (e.g., 0.85) lowers contrast by brightening shadows; gamma > 1.0 (e.g., 1.2, 1.6, 2.2) increases contrast by darkening shadows. Gamma = 1.0 produces a linear curve with no tonal adjustment.</dd>

            <dt>Global correction</dt>
            <dd>A correction that applies uniformly to all channels (e.g., LAB/LUT/ACV loaded as global data or computed from measurements).</dd>

            <dt>Graph orientation</dt>
            <dd>quadGEN plots printer-space ink mapping with 0% = white (no ink) at the origin. Photoshop/other "tone" tools often use 0,0 = black.</dd>

            <dt>Image space</dt>
            <dd>Coordinate system where 0 represents black (shadow) and 100 represents white (highlight), matching how images are typically viewed and edited. Point (0,0) = black input produces black pixel output; point (100,100) = white input produces white pixel output. ACV files, LUTs, and most user input use image space conventions. quadGEN automatically converts image space data to printer space for internal processing and display.</dd>

            <dt>Input Level %</dt>
            <dd>X-axis value representing the input level (0–100%) in printer space; corresponds to the source tone step being mapped.</dd>

            <dt>Intent (Contrast Intent)</dt>
            <dd>A target tonal mapping the correction aims to match. Choose a preset (Linear, Soft/Hard gamma, Filmic, etc...) or define a custom target via sliders or pasted CSV/JSON. Intents affect Δ vs target and exported filename/comments (compact tag), but do not change measurement ingestion; endpoints (0% and 100%) remain fixed. To alter black/white points, adjust ink limits/end values.</dd>

            <dt>Interpolation</dt>
            <dd>Method to form a smooth curve between key points. quadGEN favors monotonic PCHIP for predictable, non-overshooting results.</dd>

            <dt>Endpoint rolloff (shoulder/toe)</dt>
            <dd>A smooth, monotone easing near the ends of the curve (white shoulder, black toe) that prevents a hard plateau and maintains step separation at the last few percent.</dd>

            <dt>Key point</dt>
            <dd>An editable control point of a Smart Curve. Identified by ordinal (1-based). Insert/adjust/delete supported; endpoints often guarded. Coordinates are defined in printer space with the origin at (0,0), where X = input % (0–100) and Y = output ink % (0–100).</dd>

            <dt>LAB data (<code>.txt</code>)</dt>
            <dd>Text file with measured L*, A*, B* (quadGEN expects GRAY and LAB columns). Used to compute or validate corrections.</dd>

            <dt>Lab Tech</dt>
            <dd>The built-in assistant that can answer questions and perform actions (when networked). Optional; core editing/export features work offline.</dd>

            <dt>Linearization</dt>
            <dd>Process of adjusting printer output so that equal input steps (e.g., 0–100%) produce perceptually equal changes in print density or L*. In quadGEN and QuadToneRIP, linearization involves measuring printed step wedges, comparing them to the ideal response, and generating correction curves that enforce a near-linear relationship between input values and visual tone.</dd>

            <dt>Linear ramp</dt>
            <dd>Identity mapping (input % = output %) used as a neutral baseline for tests/export and certain workflows.</dd>

            <dt>Max error %</dt>
            <dd>Used for Smart curve Key point calculation. The largest deviation allowed from data file before a new Key point will be generated. Lower this number to create a tight fitting curve with more Key points. Raise this number to create a smoother curve with fewer Key points.</dd>

            <dt>Max points</dt>
            <dd>The upper limit on the number of Key points that quadGEN will generate when creating a Smart curve. Above this threshold, imported data (e.g., ACV/LUT/LAB) is simplified or interpolated to maintain performance and stability. Maximum is 25 points.</dd>

            <dt>Output Ink Level %</dt>
            <dd>Y-axis value representing the ink output (0–100%) after applying the curve and current End; higher values mean more ink (darker).</dd>

            <dt>Printer space</dt>
            <dd>Coordinate system where 0 represents white (no ink) and 100 represents maximum ink (black), matching how printers actually operate. Point (0,0) = white input produces no ink output (white); point (100,100) = black input produces maximum ink output (black). This is quadGEN's native coordinate system for all internal processing, curve display, and .quad file generation. Input data from image space sources (ACV, LUT, custom intents) is automatically transformed to printer space.</dd>

            <dt>Smart curve</dt>
            <dd>Adaptive curve model in quadGEN defined by editable key points and monotonic interpolation. Smart curves allow precise local edits while preserving smoothness and avoiding overshoot, enabling efficient linearization and correction workflows.</dd>

            <dt>Target (21/25-step etc)</dt>
            <dd>Printable step-wedge target used for iterative calibration. Measure the print (e.g., with Color Muse 2), import LAB <code>.txt</code>, refine, and reprint.</dd>

            <dt>PoPS (Prints on Paper Studio)</dt>
            <dd><a href="https://printsonpaper.studio/" target="_blank" rel="noopener">Collaborative printmaking studio</a> specializing in photogravure and digital pigment printing, offering artists a welcoming environment to create and edition fine art prints using innovative techniques. PoPS has developed contrast intent presets included in quadGEN for alternative photographic processes. Note: quadGEN is not affiliated with or part of Prints on Paper Studio.</dd>

            <dt>Print Tool</dt>
            <dd><a href="https://www.quadtonerip.com/html/QTRprinttool.html" target="_blank" rel="noopener">Utility application</a> for macOS that enables color-managed printing from TIFF files while bypassing standard print driver limitations. Commonly used with QuadToneRIP workflows for printing digital negatives and monochrome images.</dd>

            <dt>QuadToneRIP (QTR)</dt>
            <dd><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">Specialized RIP/driver</a> for Epson printers designed for high-quality monochrome printing with multi-shade ink sets. QTR uses <code>.quad</code> files to control how much ink each channel lays down across the 0–100% input range, enabling precise tonal calibration and alternative process workflows such as digital negatives.</dd>

            <dt>Revert (to measurement)</dt>
            <dd>Buttons that return curves to the loaded measurement source for iteration. <strong>Per‑channel Revert</strong> clears Smart curves/points and re‑enables that channel’s measurement (enabled only when measurement data is loaded for that channel). <strong>Global Revert</strong> clears Smart curves/points across all channels and re‑enables the global measurement (enabled only when a global file is loaded and the global toggle is ON). Both actions are undoable.</dd>

            <dt>Recompute</dt>
            <dd>Button in Edit Mode that regenerates Smart curve points for the selected channel from the currently plotted curve using the configured <em>Max error %</em> and <em>Max points</em> settings—useful for simplifying or refreshing an editable set from a loaded <code>.quad</code>.</dd>
          </dl>
        </section>
      `;
    }

    // Version History tab content (reuses existing generator)
    function getHelpHistoryHTML(){
      const licenseYear = new Date().getFullYear();
      const inner = `
        <div class="space-y-4">
          <div class="text-xs text-gray-500">MIT License — quadgen.html © ${licenseYear} David Marsh. HTML file only. Full text is in the page source.</div>
          <div>
            <h3 class="text-base font-semibold mb-2">Version History</h3>
            ${generateAboutDialogVersionHistory()}
          </div>
        </div>
      `;
      return `<section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">${inner}</section>`;
    }

    // Detailed Workflow tab content (based on docs/quadgen_workflow.md)
    function getHelpWorkflowHTML(){
      return `
        <section class="prose prose-gray max-w-none p-6 bg-white rounded-2xl shadow">
          <h2>quadGEN Workflow</h2>
          <h3>Purpose</h3>
          <ul>
            <li>Provide a concise, repeatable workflow to build and refine <code>.quad</code> curves for QuadToneRIP (QTR).</li>
          </ul>
          <h3>Prerequisites</h3>
          <ul>
            <li><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">QuadToneRIP</a> installed; know where your printer’s “quad” folder is.</li>
            <li>Ability to print a step wedge/target via QTR (Print-Tool on macOS recommended).</li>
            <li>Optional (but recommended): <a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a> or equivalent to capture LAB L*.</li>
          </ul>
          <h3>1) Choose Printer</h3>
          <ul>
            <li>At the top of the page, select your Epson printer model.</li>
          </ul>
          <h3>2) Export a starting <code>.quad</code></h3>
          <ul>
            <li>You can skip this step if you already have an existing <code>.quad</code> to refine. Otherwise, start with a single linear ramp of Black (K) — or Matte Black (MK) if available — using the default 100% ink limit.</li>
            <li>Install the <code>.quad</code> into QTR’s quad folder for your printer.</li>
          </ul>
          <h3>3) Verify Ink Choice & Limits</h3>
          <ul>
            <li><strong>Digital negative processes</strong>: Find the lowest ink limit that still achieves paper white by printing a step target and determine the ink limit used at the first patch that matches your paper white.  Invert the target image in your editor before printing with your <code>.quad</code>. For example, if the first patch that matches your paper white occured on the 8th darkest patch of an evenly spaced 10 step negative (referring to the <i>positive</i> target image), you can use an ink limit of 80%</li>
            <li><strong>Positive processes (e.g., polymer photogravure)</strong>: Find the maximum ink limit that <em>does not</em> cause open bite by printing an open‑bite target and increasing the ink limit until the first signs of open bite, then back off.</li>
            <li>Once you’ve identified an ink limit, create a new .quad file with that limit and proceed to calibration.</li>
          </ul>
          <h3>4) Print a Calibration Target</h3>
          <ul>
            <li>
              <p><strong>Option A — LAB workflow</strong></p>
              <ul>
                <li>Use QTR/Print‑Tool and the <code>.quad</code> from step 2/3 to print a 0–100% step wedge (or <a href="https://clayharmonblog.com/downloads" target="_blank" rel="noopener">Clay Harmon’s 21/25‑step target</a>).</li>
                <li>Ensure color management is OFF in Print‑Tool.</li>
              </ul>
            </li>
            <li>
              <p><strong>Option B — EDN workflow</strong></p>
              <ul>
                <li>Visit <a href="http://www.easydigitalnegatives.com/" target="_blank" rel="noopener">Easy Digital Negatives</a> and download the appropriate target file.</li>
                <li>Print the EDN target via QTR/Print‑Tool with color management OFF, using the <code>.quad</code> from step 2/3.</li>
              </ul>
            </li>
          </ul>
          <h3>5) Calibration: Measure the Print</h3>
          <ul>
            <li>
              <p><strong>Option A — LAB workflow</strong></p>
              <ol>
                <li><strong>Set patch count</strong>: choose the number of patches/steps to match your printed target.</li>
                <li><strong>Enter Patch % (X)</strong>: if your target is not evenly spaced, type the input position for each row (0–100). If evenly spaced, keep the defaults.</li>
                <li><strong>Measure and enter L*</strong>: measure each printed patch with your device and enter L* (0–100) in the matching row.</li>
                <li><strong>Apply or save</strong>: click “Generate Correction” to apply immediately, or “Save as .txt” to export the entries for later reuse.</li>
              </ol>
            </li>
            <li>
              <p><strong>Option B — EDN workflow</strong></p>
              <ol>
                <li>Follow the EDN instructions to scan and analyze your print result.</li>
                <li>Download the EDN-generated <code>.acv</code> or <code>.cube</code> file.</li>
              </ol>
            </li>
          </ul>
          <h3>6) Load Data into quadGEN</h3>
          <ul>
            <li>
              <p><strong>Option A — LAB workflow</strong></p>
              <ol>
                <li><strong>Load LAB (.txt)</strong>: If not already applied from the Manual L* Entry window, use the Load Data File in the Global Corrections panel to load your saved measurements.</li>
                <li><strong>Interpretation</strong>: Y = output ink % vs X = input %; Y = X is “no correction”. Too dark at X → dip below diagonal; too light at X → rise above.</li>
              </ol>
            </li>
            <li>
              <p><strong>Option B — EDN workflow</strong></p>
              <ol>
                <li><strong>Load ACV/LUT</strong>: use the Load Data File in the Global Corrections panel to load the downloaded EDN <code>.acv</code> or <code>.cube</code>.</li>
                <li><strong>Interpretation</strong>: same graph semantics — Y = output ink %, X = input %; dips lighten, humps darken.</li>
              </ol>
            </li>
          </ul>
          <h3>7) Export Corrected <code>.quad</code></h3>
          <ul>
            <li>Export the corrected <code>.quad</code> for general use and archive it as your “master” Linear profile.</li>
            <li>Keep this master untouched; branch contrast variants by either baking presets with <strong>Apply Intent</strong> (when no LAB data is loaded) or doing the contrast move upstream in Photoshop before printing through the master. Both paths land on the same tonal response.</li>
          </ul>
          <h3>8) Enter Edit Mode for Fine Tuning (optional)</h3>
          <ul>
            <li>Toggle Edit Mode ON in the Edit Curves panel to expose Smart key‑point edits.</li>
            <li>Selected channel draws on top; others dim.</li>
            <li>Use:</li>
            <ul>
              <li><strong>Recompute</strong>: regenerate Smart curve points from the plotted curve using Max error % and Max points.</li>
              <li><strong>XY input</strong>: type <code>X,Y</code> (Y is absolute after End). Up/Down adjusts absolute Y; Left/Right adjusts X.</li>
              <li><strong>Insert/Delete</strong>: click to insert; delete non‑endpoints only.</li>
            </ul>
          </ul>
          <h3>9) Iterate Until Linear (optional)</h3>
          <ul>
            <li>Repeat from step 5 until corrections become negligible.</li>
            <li>There will be some noise in the measurements for both workflows. Expect diminishing returns on linearization.</li>
          </ul>
          <h3>10) Choose a Contrast Intent (optional)</h3>
          <ul>
            <li>Use the <strong>Intent</strong> dropdown in Global Correction to pick a preset (Linear, Soft, Hard, Filmic) or choose <strong>Enter Custom…</strong> to open the modal.</li>
            <li><strong>Custom</strong>: apply sliders (Gamma or Filmic‑like) or <strong>Paste CSV/JSON</strong> data; the parser auto-validates pasted text.</li>
            <li>Intents shape the target curve only; ingestion and reconstruction are unchanged. Endpoints (0% and 100%) remain fixed — adjust ink limits/end values to move black/white points.</li>
            <li>When no LAB data is active, the <strong>Apply Intent</strong> button bakes the selected preset into the loaded <code>.quad</code>; use it to spin off contrast-specific variants directly from your master.</li>
          </ul>
          <h3>Notes & Tips</h3>
          <ul>
            <li>Keep curves smooth, avoid kinks near endpoints.</li>
            <li>Use the +/− zoom control in the lower-left of the graph to blow up low ink-limit curves; the Y-axis labels reflect the displayed max and the chart auto-expands if a newly enabled channel exceeds it.</li>
            <li>For digital negatives, invert the image in your editor before printing with your <code>.quad</code>.</li>
          </ul>
          <h3>References</h3>
          <ul>
            <li><a href="https://www.quadtonerip.com/" target="_blank" rel="noopener">QuadToneRIP</a></li>
            <li><a href="https://www.quadtonerip.com/html/QTRoverview.html" target="_blank" rel="noopener">QTR Overview</a></li>
            <li><a href="https://www.quadtonerip.com/html/QTRprinttool.html" target="_blank" rel="noopener">Print‑Tool (macOS)</a></li>
            <li><a href="https://amzn.to/45R8rof" target="_blank" rel="noopener">Color Muse 2</a></li>
          </ul>
        </section>
      `;
    }

    function setHelpActiveTab(tab){
      const readmeBtn = elements.helpTabReadme;
      const glossaryBtn = elements.helpTabGlossary;
      const workflowBtn = elements.helpTabWorkflow;
      const historyBtn = elements.helpTabHistory;
      if (!readmeBtn || !glossaryBtn || !workflowBtn || !historyBtn) return;
      if (tab === 'glossary'){
        glossaryBtn.classList.remove('text-gray-500','border-transparent');
        glossaryBtn.classList.add('text-gray-800','border-slate-700');
        readmeBtn.classList.remove('text-gray-800','border-slate-700');
        readmeBtn.classList.add('text-gray-500','border-transparent');
        workflowBtn.classList.remove('text-gray-800','border-slate-700');
        workflowBtn.classList.add('text-gray-500','border-transparent');
        historyBtn.classList.remove('text-gray-800','border-slate-700');
        historyBtn.classList.add('text-gray-500','border-transparent');
        elements.helpContent.innerHTML = getHelpGlossaryHTML();
      } else if (tab === 'history') {
        historyBtn.classList.remove('text-gray-500','border-transparent');
        historyBtn.classList.add('text-gray-800','border-slate-700');
        readmeBtn.classList.remove('text-gray-800','border-slate-700');
        readmeBtn.classList.add('text-gray-500','border-transparent');
        glossaryBtn.classList.remove('text-gray-800','border-slate-700');
        glossaryBtn.classList.add('text-gray-500','border-transparent');
        workflowBtn.classList.remove('text-gray-800','border-slate-700');
        workflowBtn.classList.add('text-gray-500','border-transparent');
        elements.helpContent.innerHTML = getHelpHistoryHTML();
      } else if (tab === 'workflow') {
        workflowBtn.classList.remove('text-gray-500','border-transparent');
        workflowBtn.classList.add('text-gray-800','border-slate-700');
        readmeBtn.classList.remove('text-gray-800','border-slate-700');
        readmeBtn.classList.add('text-gray-500','border-transparent');
        glossaryBtn.classList.remove('text-gray-800','border-slate-700');
        glossaryBtn.classList.add('text-gray-500','border-transparent');
        historyBtn.classList.remove('text-gray-800','border-slate-700');
        historyBtn.classList.add('text-gray-500','border-transparent');
        elements.helpContent.innerHTML = getHelpWorkflowHTML();
      } else {
        readmeBtn.classList.remove('text-gray-500','border-transparent');
        readmeBtn.classList.add('text-gray-800','border-slate-700');
        glossaryBtn.classList.remove('text-gray-800','border-slate-700');
        glossaryBtn.classList.add('text-gray-500','border-transparent');
        workflowBtn.classList.remove('text-gray-800','border-slate-700');
        workflowBtn.classList.add('text-gray-500','border-transparent');
        historyBtn.classList.remove('text-gray-800','border-slate-700');
        historyBtn.classList.add('text-gray-500','border-transparent');
        elements.helpContent.innerHTML = getHelpReadmeHTML();
      }
    }

    // Help popup content (initialize tabs and default content)
    function populateHelp() {
      try { document.getElementById('helpAppVersion').textContent = APP_VERSION; } catch {}
      setHelpActiveTab('readme');
    }

    // Intent Help (Correction vs Intent)
    function getIntentVsCorrectionHTML(){
      return `
        <div class="grid gap-4">
          <!-- Process Overview Card -->
          <div class="border border-gray-200 rounded-lg p-4">
            <h3 class="font-semibold text-base mb-3 flex items-center">
              📋 Making Corrections Overview
            </h3>
            <p class="text-sm mb-3">
              The correction process involves: 1) Load a .quad file, 2) Test print and measure results, 3) Load measurement data to create corrections, 4) Export corrected .quad and repeat until linear.
            </p>
            <p class="text-xs">
              For complete step-by-step guidance, see <button onclick="try{if(elements.intentHelpPopup){elements.intentHelpPopup.classList.add('hidden');}setHelpActiveTab('workflow');if(elements.helpPopup){elements.helpPopup.classList.remove('hidden');lockBodyScroll();}}catch{}" class="underline hover:text-gray-800">Detailed Workflow in the main Help</button>.
            </p>
          </div>

          <!-- When Intent Works Card -->
          <div class="border border-gray-200 rounded-lg p-4">
            <h3 class="font-semibold text-base mb-3">⚠️ When Intent Takes Effect</h3>
            <p class="text-sm mb-3">
              <strong>Intent only affects linearization data</strong> (LAB measurements, not existing .quad curves). If you see no changes when adjusting Intent, you likely need to load measurement data first.
            </p>
            <ul class="text-sm space-y-2">
              <li><strong>Intent works with:</strong> LAB .txt files, Manual L* entries</li>
              <li><strong>Intent doesn't affect:</strong> Loaded .quad files, existing curves</li>
              <li><strong>To modify existing curves:</strong> Load them as corrections via "Load Data File"</li>
            </ul>
          </div>

          <!-- Main Content Card -->
          <div class="border border-gray-200 rounded-lg p-4">
            <h3 class="font-semibold text-base mb-3 flex items-center">
              🎼 Understanding the Difference
            </h3>
            <p class="mb-4">
              Choose a target tonal intent (the target you want to aim for if not the default Linear). This shapes how linearization data is applied but does not directly modify existing curves.
              To apply ACV/LUT as a correction, use <span class="font-semibold">Global Corrections → Load Data File</span>.
            </p>

            <div class="space-y-4">
              <div>
                <h4 class="font-semibold mb-2">Correction = the tuning process.</h4>
                <p class="text-sm">
                  Before the orchestra plays, each instrument is tuned to a linear, evenly spaced scale of notes so that pitches are objectively accurate.
                  This provides a neutral, consistent foundation, much like linearizing a printer in L*.
                </p>
              </div>

              <div>
                <h4 class="font-semibold mb-2">Intent = the interpretation chosen by the conductor.</h4>
                <p class="text-sm mb-3">
                  Once tuned, the orchestra can perform a written piece in different ways, much like choosing a <em>Linear</em>, <em>Filmic</em>, <em>Perceptual</em>, etc. intent.
                </p>
                <ul class="list-disc list-inside text-sm space-y-1 ml-4">
                  <li><span class="italic font-medium">literalist</span> — a literal performance, playing the score exactly as notated, without taking any liberties.</li>
                  <li><span class="italic font-medium">Rubato</span> — literally "stolen time"; the flexible stretching/compressing of tempo to heighten expression.</li>
                  <li><span class="italic font-medium">Marcato</span> — accented, marked style; adds weight and emphasis.</li>
                </ul>
              </div>

              <div class="bg-gray-50 rounded p-3">
                <p class="text-sm italic">
                  Changing the intent will adjust how the printed image appears, but it is still based on an underlying calibration that was <span class="italic">tuned</span> to match a linear target response first.
                </p>
              </div>

              <div class="bg-gray-50 rounded p-3">
                <p class="text-sm">
                  Another way to think of the intent is as an image filter that tweaks how the end result looks. However before you can apply a filter, you need to be able to render the original image correctly on it's own.
                </p>
              </div>
            </div>
          </div>
        </div>
      `;
    }
    if (elements.intentHelpBtn && elements.intentHelpPopup && elements.closeIntentHelpBtn) {
      elements.intentHelpBtn.addEventListener('click', () => {
        const c = document.getElementById('intentHelpContent');
        if (c) c.innerHTML = getIntentVsCorrectionHTML();
        elements.intentHelpPopup.classList.remove('hidden');
        lockBodyScroll();
      });
      elements.closeIntentHelpBtn.addEventListener('click', () => {
        elements.intentHelpPopup.classList.add('hidden');
        unlockBodyScrollIfNoHelpOpen();
      });
      elements.intentHelpPopup.addEventListener('click', (e) => {
        if (e.target === elements.intentHelpPopup) {
          elements.intentHelpPopup.classList.add('hidden');
          unlockBodyScrollIfNoHelpOpen();
        }
      });
    }

    // Wire sample buttons in Global Correction Help popup
    function wireGlobalHelpSamples() {
      const helpLoadLab = document.getElementById('helpLoadSampleLab');
      if (helpLoadLab && !helpLoadLab._wired) {
        helpLoadLab.addEventListener('click', () => loadSampleData('labData'));
        helpLoadLab._wired = true;
      }
      const helpLoadCube = document.getElementById('helpLoadSampleCube');
      if (helpLoadCube && !helpLoadCube._wired) {
        helpLoadCube.addEventListener('click', () => loadSampleData('cube'));
        helpLoadCube._wired = true;
      }
      const helpDlLab = document.getElementById('helpDownloadSampleLab');
      if (helpDlLab && !helpDlLab._wired) {
        helpDlLab.addEventListener('click', (e) => { e.preventDefault(); downloadFile(SAMPLE_DATA.colorMuse, 'LAB-Data-sample.txt', 'text/plain'); });
        helpDlLab._wired = true;
      }
      const helpDlCube = document.getElementById('helpDownloadSampleCube');
      if (helpDlCube && !helpDlCube._wired) {
        helpDlCube.addEventListener('click', (e) => { e.preventDefault(); downloadFile(SAMPLE_DATA.gammaCube, 'LUT_sample.cube', 'text/plain'); });
        helpDlCube._wired = true;
      }
    }

    // Info popup functionality
    // Close popups with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && elements.helpPopup && !elements.helpPopup.classList.contains('hidden')) {
        elements.helpPopup.classList.add('hidden');
      }
      if (e.key === 'Escape' && elements.globalCorrectionHelpPopup && !elements.globalCorrectionHelpPopup.classList.contains('hidden')) {
        elements.globalCorrectionHelpPopup.classList.add('hidden');
      }
      if (e.key === 'Escape' && elements.editModeHelpPopup && !elements.editModeHelpPopup.classList.contains('hidden')) {
        elements.editModeHelpPopup.classList.add('hidden');
      }
      // Re-enable body scroll if no help popups remain open
      try { unlockBodyScrollIfNoHelpOpen(); } catch {}
    });

    // Help popup functionality
    // Helpers to lock/unlock body scroll when help popups are open
    function lockBodyScroll(){ try { document.body.style.overflow = 'hidden'; } catch {} }
    function unlockBodyScrollIfNoHelpOpen(){
      try {
        const anyOpen = (
          (elements.helpPopup && !elements.helpPopup.classList.contains('hidden')) ||
          (elements.globalCorrectionHelpPopup && !elements.globalCorrectionHelpPopup.classList.contains('hidden')) ||
          (elements.editModeHelpPopup && !elements.editModeHelpPopup.classList.contains('hidden'))
        );
        if (!anyOpen) { document.body.style.overflow = ''; }
      } catch {}
    }

    if (elements.helpBtn) {
      elements.helpBtn.addEventListener('click', () => {
        populateHelp();
        if (elements.helpPopup) { elements.helpPopup.classList.remove('hidden'); lockBodyScroll(); }
      });
    }
    // Help tabs
    if (elements.helpTabReadme) {
      elements.helpTabReadme.addEventListener('click', () => setHelpActiveTab('readme'));
    }
    if (elements.helpTabGlossary) {
      elements.helpTabGlossary.addEventListener('click', () => setHelpActiveTab('glossary'));
    }
    if (elements.helpTabWorkflow) {
      elements.helpTabWorkflow.addEventListener('click', () => setHelpActiveTab('workflow'));
    }
    if (elements.helpTabHistory) {
      elements.helpTabHistory.addEventListener('click', () => setHelpActiveTab('history'));
    }
    // Inline Edit Mode Help link under the Edit Curves panel
    const editModeHelpLink = document.getElementById('editModeHelpLink');
    if (editModeHelpLink) {
      editModeHelpLink.addEventListener('click', () => {
        populateHelp();
        if (elements.helpPopup) {
          elements.helpPopup.classList.remove('hidden');
          // Scroll to Edit Mode section once visible
          setTimeout(() => {
            try { document.getElementById('helpEditModeSection')?.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch {}
          }, 0);
        }
      });
    }
    if (elements.perChannelDeltaSelect) {
      elements.perChannelDeltaSelect.addEventListener('change', updatePerChannelDeltaSummary);
    }
    if (elements.closeHelpBtn) {
      elements.closeHelpBtn.addEventListener('click', () => {
        if (elements.helpPopup) { elements.helpPopup.classList.add('hidden'); unlockBodyScrollIfNoHelpOpen(); }
      });
    }
    if (elements.helpPopup) {
      elements.helpPopup.addEventListener('click', (e) => {
        if (e.target === elements.helpPopup) {
          elements.helpPopup.classList.add('hidden');
          unlockBodyScrollIfNoHelpOpen();
        }
      });
    }
    
    // Global Correction Help button: open main Help with Detailed Workflow tab
    if (elements.globalCorrectionHelpBtn) {
      elements.globalCorrectionHelpBtn.addEventListener('click', () => {
        try { setHelpActiveTab('workflow'); } catch {}
        if (elements.helpPopup) { elements.helpPopup.classList.remove('hidden'); lockBodyScroll(); }
      });
    }
    if (elements.closeGlobalCorrectionHelpBtn && elements.globalCorrectionHelpPopup) {
      elements.closeGlobalCorrectionHelpBtn.addEventListener('click', () => {
        elements.globalCorrectionHelpPopup.classList.add('hidden');
        unlockBodyScrollIfNoHelpOpen();
      });
    }
    if (elements.globalCorrectionHelpPopup) {
      elements.globalCorrectionHelpPopup.addEventListener('click', (e) => {
        if (e.target === elements.globalCorrectionHelpPopup) {
          elements.globalCorrectionHelpPopup.classList.add('hidden');
          unlockBodyScrollIfNoHelpOpen();
        }
      });
    }
    // Edit Mode Help popup functionality
    if (elements.editModeHelpBtn && elements.editModeHelpPopup) {
      elements.editModeHelpBtn.addEventListener('click', () => {
        elements.editModeHelpPopup.classList.remove('hidden');
        lockBodyScroll();
      });
    }
    if (elements.closeEditModeHelpBtn && elements.editModeHelpPopup) {
      elements.closeEditModeHelpBtn.addEventListener('click', () => {
        elements.editModeHelpPopup.classList.add('hidden');
        unlockBodyScrollIfNoHelpOpen();
      });
    }
    if (elements.editModeHelpPopup) {
      elements.editModeHelpPopup.addEventListener('click', (e) => {
        if (e.target === elements.editModeHelpPopup) {
          elements.editModeHelpPopup.classList.add('hidden');
          unlockBodyScrollIfNoHelpOpen();
        }
      });
    }

    // Resizers for Lab Tech console and .quad File Preview
    (function initResizers(){
      const chat = document.getElementById('chatHistory');
      const chatResizer = document.getElementById('labTechResizer');
      const prev = document.getElementById('previewFull');
      const prevResizer = document.getElementById('previewResizer');
      if (chat && chatResizer) attachResizer(chatResizer, chat, { min: 120, max: 520, prop: 'height' });
      if (prev && prevResizer) attachResizer(prevResizer, prev, { min: 160, max: 640, prop: 'maxHeight' });
      
      function attachResizer(handle, target, opts){
        let startY = 0, startVal = 0, active = false;
        const getVal = ()=> parseInt(window.getComputedStyle(target)[opts.prop], 10) || (opts.prop==='height'?target.clientHeight:target.clientHeight);
        const setVal = (px)=> { target.style[camel(opts.prop)] = Math.max(opts.min, Math.min(opts.max, px)) + 'px'; };
        handle.addEventListener('mousedown', (e)=>{ active=true; startY=e.clientY; startVal=getVal(); document.body.classList.add('select-none'); e.preventDefault(); });
        window.addEventListener('mousemove', (e)=>{ if(!active) return; const dy=e.clientY-startY; setVal(startVal + dy); });
        window.addEventListener('mouseup', ()=>{ if(active){ active=false; document.body.classList.remove('select-none'); }});
      }
      function camel(prop){ return prop.replace(/-([a-z])/g,(_,c)=>c.toUpperCase()); }
    })();
    
    // Update version displays using centralized variable
    function updateVersionDisplays() {
      document.title = `quadGEN ${APP_VERSION}`;
      document.getElementById('appVersion').textContent = APP_VERSION;
      
      try { document.getElementById('helpAppVersion').textContent = APP_VERSION; } catch {}
    }
    
    // Initial setup with error handling
    try {
      updateVersionDisplays(); // Set all version displays
      setPrinter('P700P900');
      // Normalize any preexisting legacy source tags
      normalizeSmartSourcesInLoadedData();
      
      // Capture initial state for undo system
      setTimeout(() => {
        CurveHistory.captureState('Initial state');
        if (DEBUG_LOGS) console.log('📸 Initial state captured for undo system');
      }, 100); // Small delay to ensure UI is fully initialized
    } catch (error) {
      console.error('Initialization error:', error);
      showStatus("Initialization error. Please refresh the page.");
    }
  </script>

</body>
</html>
