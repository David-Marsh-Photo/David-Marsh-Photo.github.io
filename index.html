<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>quadGEN v1.0</title>
  <meta name="description" content="quadGEN - Generate Epson P900/P800 QuadToneRIP .quad files with 256-step ramps per channel." />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Always show number input arrows */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: inner-spin-button !important;
      opacity: 1 !important;
    }
    
    input[type="number"] {
      -moz-appearance: textfield;
    }
    
    input[type="number"]::-moz-number-spin-box {
      -moz-appearance: spin-textfield !important;
    }
  </style>
</head>
<body class="min-h-screen bg-gray-50 p-6">
  <main class="mx-auto max-w-6xl">
    <section class="bg-white rounded-2xl shadow-lg p-6 md:p-8">
      <header class="mb-6">
        <div class="flex items-center gap-4 mb-2">
          <svg id="quadgenLogo" xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 160 160" role="img" aria-labelledby="quadgenTitle quadgenDesc">
            <title id="quadgenTitle">quadGEN icon (CMYK)</title>
            <desc id="quadgenDesc">Four CMYK bars with a rising Bezier-style curve and nodes, flat design.</desc>
            <!-- baseline -->
            <path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round"/>
            <!-- CMYK bars -->
            <rect id="cyanBar" x="20" y="90" width="20" height="40" rx="6" ry="6" fill="#00B5E2"/>
            <rect id="magentaBar" x="52" y="70" width="20" height="60" rx="6" ry="6" fill="#FF2A8A"/>
            <rect id="yellowBar" x="84" y="50" width="20" height="80" rx="6" ry="6" fill="#FFD400"/>
            <rect id="blackBar" x="116" y="22" width="20" height="110" rx="6" ry="6" fill="#1A1A1A"/>
            <!-- Bezier-like curve -->
            <path id="logoPath" d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18"
                  fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
            <!-- curve nodes -->
            <circle id="node1" cx="30" cy="88" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
            <circle id="node2" cx="62" cy="68" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
            <circle id="node3" cx="94" cy="48" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
            <circle id="node4" cx="126" cy="18" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
          </svg>
          <div>
            <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">
              quadGEN
              <span class="text-gray-400 text-lg">v1.0</span>
            </h1>
            <p class="text-gray-400 text-sm -mt-1">by David Marsh</p>
          </div>
        </div>
        <p id="printerDescription" class="text-gray-600 mt-1"></p>
      </header>

      <!-- Printer selector -->
      <div class="mb-6">
        <div class="bg-gray-50 rounded-xl border border-gray-200 p-4">
          <div class="font-medium text-gray-700">Select Printer</div>
          <div class="flex flex-wrap items-center gap-3 mt-1">
            <label for="printerSelect" class="sr-only">Printer</label>
            <select id="printerSelect" class="rounded-lg border border-gray-300 px-3 py-2">
              <option value="P700">Epson P700</option>
              <option value="P800">Epson P800</option>
              <option value="P900" selected>Epson P900</option>
            </select>
            <p id="channelInfo" class="text-sm text-gray-600"></p>
          </div>
        </div>
      </div>

      <!-- Ink Limits Graph and Linearization -->
      <div class="mb-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- Graph Section -->
        <div class="lg:col-span-2">
          <div class="bg-white border border-gray-200 rounded-xl p-4">
            <h3 class="text-lg font-semibold mb-3">Ink Limits Visualization</h3>
            <div class="bg-gray-50 rounded-lg p-4">
              <canvas id="inkChart" width="950" height="600" class="w-full h-auto max-h-96"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Linearization Section -->
        <div class="lg:col-span-1">
          <div class="bg-white border border-gray-200 rounded-xl p-4">
            <h3 class="text-lg font-semibold mb-3">Linearization Data</h3>
            <p class="text-sm text-gray-600 mb-4">Apply correction curves to modify ink channel outputs uniformly.</p>
            
            <!-- Linearization Controls -->
            <div class="space-y-4">              
              <!-- File Upload -->
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Upload Linearization File</label>
                <input type="file" id="linearizationFile" accept=".cube,.txt,.csv,.quad" class="w-full text-sm text-gray-700 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-black file:text-white hover:file:bg-black/90">
                <p class="text-xs text-gray-500 mt-1">accepts EDN 1D .cube files</p>
              </div>
              
              <!-- Apply Button -->
              <button id="applyLinearization" class="w-full rounded-lg px-4 py-2 bg-gray-300 text-gray-500 cursor-not-allowed" disabled>
                Apply Linearization
              </button>
              
              <!-- Smoothing Method -->
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Curve Smoothing Method</label>
                <select id="curveSmoothingMethod" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" disabled>
                  <option value="cubic">Cubic Spline</option>
                  <option value="pchip" selected>PCHIP (monotonic)</option>
                  <option value="linear">Linear (none)</option>
                </select>
                <p class="text-xs text-gray-500 mt-1">Choose how to interpolate between LUT data points</p>
                
                <!-- Smoothing Intensity -->
                <div class="mt-3" id="smoothingIntensityContainer" style="display: none;">
                  <label class="block text-sm font-medium text-gray-700 mb-1">Smoothing Intensity</label>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-500">None</span>
                    <input type="range" id="smoothingIntensity" min="0" max="100" value="100" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" disabled>
                    <span class="text-xs text-gray-500">Full</span>
                  </div>
                  <p class="text-xs text-gray-500 mt-1">Adjust the strength of curve smoothing</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Status Display -->
      <div class="mb-6">
        <div class="bg-gray-50 rounded-lg border border-gray-200 p-3 text-center min-h-[2.5rem] flex items-center justify-center">
          <span id="status" class="text-sm text-gray-600 font-medium transition-opacity duration-500 ease-in-out">&nbsp;</span>
        </div>
      </div>

      <!-- Apply-to-all controls -->
      <div class="grid md:grid-cols-3 gap-4 items-end">
        <div>
          <label class="block text-sm font-medium text-gray-700">Apply percent to all (0–100)</label>
          <div class="flex gap-2">
            <input id="applyPercent" type="number" step="1" min="0" max="100" value="33" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
            <button id="btnApplyPercent" class="rounded-lg px-4 py-2 bg-black text-white hover:bg-black/90">Apply</button>
          </div>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Apply end value to all (0–64,000)</label>
          <div class="flex gap-2">
            <input id="applyEnd" type="number" step="1" min="0" max="64000" value="21120" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
            <button id="btnApplyEnd" class="rounded-lg px-4 py-2 bg-black text-white hover:bg-black/90">Apply</button>
          </div>
        </div>
        <div class="text-sm text-gray-600">
          Edit either <em>Percent</em> or <em>End</em> – they stay in sync. A value of <strong>0</strong> disables the channel (all zeros).
        </div>
      </div>

      <!-- Channel table -->
      <div class="mt-6 overflow-auto">
        <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden">
          <thead class="bg-gray-50 text-gray-700">
            <tr>
              <th class="text-center px-3 py-2"></th>
              <th class="text-left px-3 py-2">Channel</th>
              <th class="text-left px-3 py-2">Percent (0–100)</th>
              <th class="text-left px-3 py-2">End (0–64,000)</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>

      <!-- Actions -->
      <div class="mt-6 space-y-3">
        <div class="flex items-center gap-2">
          <label for="filenameInput" class="text-sm font-medium text-gray-700">Filename:</label>
          <input id="filenameInput" type="text" placeholder="P900_K33_C33_M33..." class="w-[36rem] rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
          <span class="text-sm text-gray-500">.quad</span>
        </div>
        <div class="flex flex-wrap items-center gap-3">
          <button id="downloadBtn" class="inline-flex items-center justify-center rounded-lg px-5 py-3 font-medium shadow-sm bg-black text-white hover:bg-black/90">
            ↓ Download .quad
          </button>
        </div>
      </div>

      <!-- Full Preview -->
      <div class="mt-8">
        <h2 class="text-lg font-semibold">Full file preview</h2>
        <p class="text-sm text-gray-600 mb-3">This shows the complete file exactly as it will be saved.</p>
        <div class="border border-gray-200 rounded-xl overflow-hidden">
          <div class="bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700">Preview</div>
          <pre id="previewFull" class="p-4 text-sm leading-6 overflow-auto max-h-[70vh] bg-black text-white font-mono">–</pre>
        </div>
      </div>
    </section>
  </main>

  <script>
    const TOTAL = 64000;
    const N = 256;
    const DENOM = N - 1;

    const PRINTERS = {
      P700: { name: "Epson P700", channels: ["K","C","M","Y","LC","LM","LK","LLK","V","MK"] },
      P800: { name: "Epson P800", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      P900: { name: "Epson P900", channels: ["K","C","M","Y","LC","LM","LK","LLK","V","MK"] }
    };

    const INK_COLORS = {
      K: "#111111",
      C: "#00AEEF",
      M: "#EC008C",
      Y: "#FFF200",
      LC: "#8FD3FF",
      LM: "#FF9AD5",
      LK: "#777777",
      LLK: "#BBBBBB",
      V: "#7F00FF",
      MK: "#000000"
    };


    // Cache DOM elements
    const elements = {
      rows: document.getElementById('rows'),
      printerSelect: document.getElementById('printerSelect'),
      channelInfo: document.getElementById('channelInfo'),
      printerDescription: document.getElementById('printerDescription'),
      applyPercent: document.getElementById('applyPercent'),
      btnApplyPercent: document.getElementById('btnApplyPercent'),
      applyEnd: document.getElementById('applyEnd'),
      btnApplyEnd: document.getElementById('btnApplyEnd'),
      downloadBtn: document.getElementById('downloadBtn'),
      previewFull: document.getElementById('previewFull'),
      status: document.getElementById('status'),
      inkChart: document.getElementById('inkChart'),
      filenameInput: document.getElementById('filenameInput'),
      linearizationFile: document.getElementById('linearizationFile'),
      applyLinearization: document.getElementById('applyLinearization'),
      curveSmoothingMethod: document.getElementById('curveSmoothingMethod'),
      smoothingIntensity: document.getElementById('smoothingIntensity'),
      smoothingIntensityContainer: document.getElementById('smoothingIntensityContainer'),
    };

    // Input validation utilities
    class InputValidator {
      static clampPercent(p) { 
        const num = parseFloat(p);
        return isNaN(num) ? 0 : Math.min(100, Math.max(0, num)); 
      }
      
      static clampEnd(e) { 
        const num = parseInt(e);
        return isNaN(num) ? 0 : Math.min(64000, Math.max(0, num)); 
      }
      
      static computeEndFromPercent(p) { 
        return Math.round((TOTAL * p) / 100); 
      }
      
      static computePercentFromEnd(e) { 
        return (e / TOTAL) * 100; 
      }

      static validateInput(input, validator) {
        const originalValue = input.value;
        const validatedValue = validator(originalValue);
        const isValid = validatedValue.toString() === originalValue || Math.abs(parseFloat(originalValue) - validatedValue) < 0.01;
        
        input.classList.toggle('border-red-300', !isValid);
        input.classList.toggle('border-gray-300', isValid);
        
        if (!isValid) {
          input.value = validatedValue.toString();
        }
        
        return validatedValue;
      }
    }

    // Debounce function to prevent excessive updates
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function showStatus(message) {
      elements.status.textContent = message;
      elements.status.style.opacity = '1';
      setTimeout(() => {
        if (elements.status.textContent === message) {
          elements.status.style.opacity = '0';
          setTimeout(() => {
            if (elements.status.style.opacity === '0') {
              elements.status.innerHTML = "&nbsp;";
              elements.status.style.opacity = '1';
            }
          }, 500); // Wait for fade transition to complete
        }
      }, 6000);
    }
    
    function animateLogoBars() {
      const cyanBar = document.getElementById('cyanBar');
      const magentaBar = document.getElementById('magentaBar');
      const yellowBar = document.getElementById('yellowBar');
      const blackBar = document.getElementById('blackBar');
      const logoPath = document.getElementById('logoPath');
      const node1 = document.getElementById('node1');
      const node2 = document.getElementById('node2');
      const node3 = document.getElementById('node3');
      const node4 = document.getElementById('node4');
      
      if (!cyanBar || !magentaBar || !yellowBar || !blackBar) return;
      
      // Original values
      const originalHeights = { cyan: 40, magenta: 60, yellow: 80, black: 110 };
      const originalYs = { cyan: 90, magenta: 70, yellow: 50, black: 22 };
      
      let animationStep = 0;
      const maxSteps = 32; // Number of back-and-forth movements
      
      function animateStep() {
        if (animationStep >= maxSteps) {
          // Final return to original state
          cyanBar.setAttribute('height', originalHeights.cyan);
          cyanBar.setAttribute('y', originalYs.cyan);
          magentaBar.setAttribute('height', originalHeights.magenta);
          magentaBar.setAttribute('y', originalYs.magenta);
          yellowBar.setAttribute('height', originalHeights.yellow);
          yellowBar.setAttribute('y', originalYs.yellow);
          blackBar.setAttribute('height', originalHeights.black);
          blackBar.setAttribute('y', originalYs.black);
          logoPath.setAttribute('d', 'M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 32, 126 22');
          node1.setAttribute('cy', '88');
          node2.setAttribute('cy', '68');
          node3.setAttribute('cy', '48');
          node4.setAttribute('cy', '18');
          return;
        }
        
        // Generate oscillating variations that get smaller over time
        const damping = 1 - (animationStep / maxSteps) * 0.7; // Reduce intensity over time
        const frequency = Math.sin(animationStep * 0.8) * damping; // Oscillating pattern
        
        const cyanVariation = originalHeights.cyan + frequency * 12;
        const magentaVariation = originalHeights.magenta + frequency * 15;
        const yellowVariation = originalHeights.yellow + frequency * 18;
        const blackVariation = originalHeights.black + frequency * 25;
        
        // Update bar heights and positions
        cyanBar.setAttribute('height', Math.max(5, cyanVariation));
        cyanBar.setAttribute('y', 132 - Math.max(5, cyanVariation));
        
        magentaBar.setAttribute('height', Math.max(5, magentaVariation));
        magentaBar.setAttribute('y', 132 - Math.max(5, magentaVariation));
        
        yellowBar.setAttribute('height', Math.max(5, yellowVariation));
        yellowBar.setAttribute('y', 132 - Math.max(5, yellowVariation));
        
        blackBar.setAttribute('height', Math.max(5, blackVariation));
        blackBar.setAttribute('y', 132 - Math.max(5, blackVariation));
        
        // Update curve and nodes to match bar heights
        const newCyanY = 132 - Math.max(5, cyanVariation) + 2;
        const newMagentaY = 132 - Math.max(5, magentaVariation) + 2;
        const newYellowY = 132 - Math.max(5, yellowVariation) + 2;
        const newBlackY = 132 - Math.max(5, blackVariation) + 2;
        
        // Update curve path
        const newPath = `M30 ${newCyanY} C 44 ${newCyanY-4}, 50 ${newMagentaY+4}, 62 ${newMagentaY} S 86 ${newYellowY+2}, 94 ${newYellowY} S 118 ${newBlackY+10}, 126 ${newBlackY}`;
        logoPath.setAttribute('d', newPath);
        
        // Update node positions
        node1.setAttribute('cy', newCyanY);
        node2.setAttribute('cy', newMagentaY);
        node3.setAttribute('cy', newYellowY);
        node4.setAttribute('cy', newBlackY);
        
        animationStep++;
        setTimeout(animateStep, 100); // 100ms between each step
      }
      
      animateStep(); // Start the animation sequence
    }
    

    function updatePreview() {
      requestAnimationFrame(() => {
        try {
          const fileText = buildFile();
          elements.previewFull.textContent = fileText;
          updateInkChart();
          updateFilename(); // Update filename when preview updates
          showStatus("Preview updated");
        } catch (error) {
          console.error('Preview update error:', error);
          showStatus("Error updating preview");
        }
      });
    }

    function updateInkChart() {
      if (elements.rows.children.length === 0) return;
      
      const canvas = elements.inkChart;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Set up coordinate system
      const padding = 60;
      const leftPadding = padding - 6; // Shift chart 6px left
      const rightPadding = padding + 6; // Maintain total width
      const chartWidth = width - leftPadding - rightPadding;
      const chartHeight = height - 2 * padding;
      
      // Draw grid
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      
      // Vertical grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Horizontal grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const y = padding + (i * chartHeight / 10);
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(leftPadding + chartWidth, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(leftPadding, padding);
      ctx.lineTo(leftPadding, height - padding);
      ctx.lineTo(leftPadding + chartWidth, height - padding);
      ctx.stroke();
      
      // Draw axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      
      // X-axis labels (0% to 100%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        ctx.fillText(`${i * 10}`, x, height - padding + 20);
      }
      
      // Y-axis labels (0% to 100%)
      ctx.textAlign = 'right';
      for (let i = 0; i <= 10; i++) {
        const y = height - padding - (i * chartHeight / 10);
        ctx.fillText(`${i * 10}`, leftPadding - 10, y + 4);
      }
      
      // Axis titles
      ctx.textAlign = 'center';
      ctx.font = '14px system-ui';
      ctx.fillText('Input Level (1-100)', width / 2, height - 10);
      
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Ink Limit Percentage', 0, 0);
      ctx.restore();
      
      // Draw curves and collect label info
      const labels = [];
      
      Array.from(elements.rows.children).forEach((row, index) => {
        const channelName = row.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(row.querySelector('.end-input').value);
        
        if (endVal === 0) return; // Skip disabled channels
        
        const percent = InputValidator.computePercentFromEnd(endVal);
        const inkColor = INK_COLORS[channelName] || '#000000';
        
        // Generate the 256 values
        const values = make256(endVal, true); // Apply linearization if enabled
        const maxValue = TOTAL; // 64000
        
        ctx.strokeStyle = inkColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        // Plot the curve
        for (let i = 0; i < values.length; i++) {
          const x = leftPadding + (i / (values.length - 1)) * chartWidth;
          const valuePercent = (values[i] / maxValue) * 100;
          const y = height - padding - (valuePercent / 100) * chartHeight;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        
        // Store label info for later positioning
        const actualEndValue = values[values.length - 1];
        const actualEndPercent = (actualEndValue / maxValue) * 100;
        const endY = height - padding - (actualEndPercent / 100) * chartHeight;
        
        labels.push({
          channelName,
          percent: Math.round(percent),
          inkColor,
          endY
        });
      });
      
      // Draw labels with collision avoidance
      if (labels.length > 0) {
        labels.sort((a, b) => a.endY - b.endY); // Sort by Y position
        
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        
        const minSpacing = 20; // Minimum spacing between labels
        const endX = leftPadding + chartWidth; // Position labels at the right edge of chart
        
        // Adjust label positions to avoid overlaps
        for (let i = 0; i < labels.length; i++) {
          let labelY = labels[i].endY + 4;
          
          // Check for overlap with previous label
          if (i > 0) {
            const prevLabelY = labels[i-1].adjustedY || (labels[i-1].endY + 4);
            if (labelY - prevLabelY < minSpacing) {
              labelY = prevLabelY + minSpacing;
            }
          }
          
          // Store adjusted position
          labels[i].adjustedY = labelY;
          
          // Draw the label with background for better readability
          const labelText = `${labels[i].channelName} (${labels[i].percent}%)`;
          const textMetrics = ctx.measureText(labelText);
          const textWidth = textMetrics.width;
          const textHeight = 18; // Background height for 12px text with padding
          
          // Draw solid white background
          ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
          ctx.fillRect(endX, labelY - textHeight + 2, textWidth + 4, textHeight + 2);
          
          // Calculate centered text position within the background
          const textCenterY = labelY - (textHeight / 2) + 2 + (textHeight / 2);
          
          // Draw text shadow first
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillText(labelText, endX + 3, textCenterY + 1);
          
          // Draw the text
          ctx.fillStyle = labels[i].inkColor;
          ctx.fillText(labelText, endX + 2, textCenterY);
        }
      }
      
      // Animate logo bars when chart is redrawn
      animateLogoBars();
    }

    // Generate filename based on current settings
    function generateFilename() {
      const p = PRINTERS[elements.printerSelect.value];
      let parts = [p.name.replace(/\s+/g, '')]; // Start with printer name
      
      // Add active channels with their percentages
      Array.from(elements.rows.children).forEach((tr) => {
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        
        if (endVal > 0) {
          const percent = Math.round(InputValidator.computePercentFromEnd(endVal));
          parts.push(name + percent);
        }
      });
      
      return parts.join('_');
    }

    // Update filename input with current settings
    function updateFilename() {
      if (!elements.filenameInput.dataset.userEdited) {
        elements.filenameInput.value = generateFilename();
        // Trigger validation styling
        elements.filenameInput.dispatchEvent(new Event('input'));
      }
    }
    function sanitizeFilename(filename) {
      // Remove or replace invalid characters for Windows and Mac
      // Invalid: \ / : * ? " < > |
      return filename
        .replace(/[\\/:*?"<>|]/g, '_')  // Replace invalid chars with underscore
        .replace(/\s+/g, '_')          // Replace spaces with underscores
        .replace(/_{2,}/g, '_')        // Replace multiple underscores with single
        .replace(/^_+|_+$/g, '')       // Trim underscores from start/end
        .substring(0, 200);            // Limit length to 200 chars
    }

    // ---- Linearization utilities ----
    const clamp01 = (x) => Math.max(0, Math.min(1, x));

    // Linearization data storage
    let linearizationData = null;
    let linearizationApplied = false;

    /**
     * Parse a .cube file string as a 1D LUT.
     * Returns { domainMin, domainMax, samples } where samples are floats (usually 0..1).
     */
    function parseCube1D(cubeText) {
      const lines = cubeText.split(/\r?\n/);
      let domainMin = 0.0;
      let domainMax = 1.0;
      let declaredSize = null;
      const samples = [];

      // Check for 3D LUT indicators early
      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;
        
        // Detect 3D LUT file format
        if (/^LUT_3D_SIZE/i.test(s)) {
          throw new Error("3D LUT files are not supported. Please use a 1D LUT (.cube) file for linearization.");
        }
      }

      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;

        if (/^LUT_1D_SIZE/i.test(s)) {
          const m = s.match(/LUT_1D_SIZE\s+(\d+)/i);
          if (m) declaredSize = parseInt(m[1], 10);
          continue;
        }
        if (/^DOMAIN_MIN/i.test(s)) {
          // 1 or 3 numbers; for 1D we take the first
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMin = parseFloat(parts[1]);
          continue;
        }
        if (/^DOMAIN_MAX/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMax = parseFloat(parts[1]);
          continue;
        }

        // Numeric row: could be 1–3 floats. For 1D LUTs, many files still list RGB triplets.
        const nums = s.split(/\s+/).map(Number);
        if (nums.every((v) => Number.isFinite(v)) && nums.length >= 1 && nums.length <= 3) {
          samples.push(nums[0]); // take the first channel for 1D
        }
      }

      // After parsing, check if this looks like 3D LUT data
      if (samples.length > 100) {
        // 3D LUTs typically have many more data points than 1D LUTs
        // 1D LUTs usually have 16-256 points, 3D LUTs have thousands
        throw new Error("This file contains too many data points for a 1D LUT. It appears to be a 3D LUT file which is not supported. Please use a 1D LUT file for ink linearization.");
      }

      if (declaredSize !== null && samples.length >= declaredSize) {
        samples.length = declaredSize;
      }
      if (!Number.isFinite(domainMin) || !Number.isFinite(domainMax) || domainMin === domainMax) {
        domainMin = 0.0; domainMax = 1.0;
      }
      if (!samples.length) {
        throw new Error("No 1D samples found in .cube text.");
      }

      return { domainMin, domainMax, samples };
    }

    /**
     * Natural cubic spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCubicSpline(x, y, intensity = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate second derivatives using natural spline conditions
      const h = new Array(n - 1);
      const alpha = new Array(n - 1);
      const l = new Array(n);
      const mu = new Array(n);
      const z = new Array(n);
      const c = new Array(n);
      const b = new Array(n);
      const d = new Array(n);
      
      // Step 1: Calculate h and alpha
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
      }
      
      for (let i = 1; i < n - 1; i++) {
        alpha[i] = (3 / h[i]) * (y[i + 1] - y[i]) - (3 / h[i - 1]) * (y[i] - y[i - 1]);
      }
      
      // Step 2: Solve tridiagonal system
      l[0] = 1;
      mu[0] = 0;
      z[0] = 0;
      
      for (let i = 1; i < n - 1; i++) {
        l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
        mu[i] = h[i] / l[i];
        z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
      }
      
      l[n - 1] = 1;
      z[n - 1] = 0;
      c[n - 1] = 0;
      
      // Step 3: Back substitution
      for (let j = n - 2; j >= 0; j--) {
        c[j] = z[j] - mu[j] * c[j + 1];
        b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
        d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
      }
      
      // Return interpolation function
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Evaluate cubic polynomial
        const dt = t - x[i];
        const interpolated = y[i] + b[i] * dt + c[i] * dt * dt + d[i] * dt * dt * dt;
        
        // Blend between linear and interpolated based on intensity
        const linear = y[i] + (y[i + 1] - y[i]) * (dt / (x[i + 1] - x[i]));
        return linear + intensity * (interpolated - linear);
      };
    }

    /**
     * Catmull-Rom spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCatmullRomSpline(x, y, intensity = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Get the four control points (with boundary handling)
        const p0 = y[Math.max(0, i - 1)];
        const p1 = y[i];
        const p2 = y[Math.min(n - 1, i + 1)];
        const p3 = y[Math.min(n - 1, i + 2)];
        
        // Normalize t to 0-1 within the segment
        const t_norm = (t - x[i]) / (x[i + 1] - x[i]);
        const t2 = t_norm * t_norm;
        const t3 = t2 * t_norm;
        
        // Catmull-Rom basis functions
        const q0 = -0.5 * t3 + t2 - 0.5 * t_norm;
        const q1 = 1.5 * t3 - 2.5 * t2 + 1;
        const q2 = -1.5 * t3 + 2 * t2 + 0.5 * t_norm;
        const q3 = 0.5 * t3 - 0.5 * t2;
        
        const interpolated = p0 * q0 + p1 * q1 + p2 * q2 + p3 * q3;
        
        // Blend between linear and interpolated based on intensity
        const linear = p1 + (p2 - p1) * t_norm;
        return linear + intensity * (interpolated - linear);
      };
    }

    /**
     * Bezier curve interpolation using cubic Bezier segments
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createBezierSpline(x, y, intensity = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate control points for smooth Bezier curves
      const segments = [];
      
      for (let i = 0; i < n - 1; i++) {
        const p0 = { x: x[i], y: y[i] };
        const p3 = { x: x[i + 1], y: y[i + 1] };
        
        // Calculate control points based on neighboring points
        let p1, p2;
        
        if (i === 0) {
          // First segment - use forward difference
          const slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + slope * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - slope * dist };
        } else if (i === n - 2) {
          // Last segment - use backward difference
          const slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + slope * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - slope * dist };
        } else {
          // Middle segments - use centered differences for smooth transitions
          const prevSlope = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);
          const nextSlope = (y[i + 2] - y[i + 1]) / (x[i + 2] - x[i + 1]);
          const currentSlope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          
          // Smooth the slopes for continuity
          const smoothSlope1 = (prevSlope + currentSlope) / 2;
          const smoothSlope2 = (currentSlope + nextSlope) / 2;
          
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + smoothSlope1 * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - smoothSlope2 * dist };
        }
        
        segments.push({ p0, p1, p2, p3 });
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find the segment
        let segmentIndex = 0;
        while (segmentIndex < segments.length - 1 && x[segmentIndex + 1] < t) {
          segmentIndex++;
        }
        
        const segment = segments[segmentIndex];
        
        // Normalize t within the segment (0 to 1)
        const segmentT = (t - segment.p0.x) / (segment.p3.x - segment.p0.x);
        
        // Cubic Bezier formula: B(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃
        const u = 1 - segmentT;
        const tt = segmentT * segmentT;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * segmentT;
        
        const interpolated = uuu * segment.p0.y +
               3 * uu * segmentT * segment.p1.y +
               3 * u * tt * segment.p2.y +
               ttt * segment.p3.y;
        
        // Blend between linear and interpolated based on intensity
        const linear = segment.p0.y + (segment.p3.y - segment.p0.y) * segmentT;
        return linear + intensity * (interpolated - linear);
      };
    }

    /**
     * PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) - Monotonic cubic spline
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createPCHIPSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate slopes (derivatives) at each point
      const slopes = new Array(n);
      const h = new Array(n - 1);
      const delta = new Array(n - 1);
      
      // Calculate intervals and finite differences
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
        delta[i] = (y[i + 1] - y[i]) / h[i];
      }
      
      // Calculate slopes using PCHIP method
      slopes[0] = delta[0]; // First point - use forward difference
      slopes[n - 1] = delta[n - 2]; // Last point - use backward difference
      
      for (let i = 1; i < n - 1; i++) {
        // Interior points - use monotonic slope calculation
        if (delta[i - 1] * delta[i] <= 0) {
          // Data changes direction - use zero slope to avoid overshooting
          slopes[i] = 0;
        } else {
          // Data is monotonic - use weighted harmonic mean for smooth monotonic interpolation
          const w1 = 2 * h[i] + h[i - 1];
          const w2 = h[i] + 2 * h[i - 1];
          slopes[i] = (w1 + w2) / (w1 / delta[i - 1] + w2 / delta[i]);
        }
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Normalize t within the interval
        const dt = t - x[i];
        const h_i = h[i];
        const t_norm = dt / h_i;
        
        // Hermite basis functions
        const h00 = 2 * t_norm * t_norm * t_norm - 3 * t_norm * t_norm + 1;
        const h10 = t_norm * t_norm * t_norm - 2 * t_norm * t_norm + t_norm;
        const h01 = -2 * t_norm * t_norm * t_norm + 3 * t_norm * t_norm;
        const h11 = t_norm * t_norm * t_norm - t_norm * t_norm;
        
        // PCHIP interpolation formula
        return y[i] * h00 + h_i * slopes[i] * h10 + y[i + 1] * h01 + h_i * slopes[i + 1] * h11;
      };
    }

    /**
     * Apply a 1D LUT to a list of integers using linear, cubic spline, Catmull-Rom, Bezier, or PCHIP interpolation.
     * Preserves the endpoint values - always starts at 0 and ends at the original max value.
     * @param {number[]} values - input integers in [0..maxValue]
     * @param {number[]} lut - samples (floats), typically 0..1
     * @param {number} domainMin - LUT input domain min (typically 0)
     * @param {number} domainMax - LUT input domain max (typically 1)
     * @param {number} maxValue - the maximum value from the original linear ramp
     * @param {string} interpolationType - 'cubic', 'catmull', or 'linear'
     * @returns {number[]} adjusted integer outputs with preserved endpoints
     */
    function apply1DLUT(values, lut, domainMin = 0, domainMax = 1, maxValue = 64000, interpolationType = 'cubic', intensity = 0.5) {
      const K = lut.length;
      if (K < 2) return values; // Not enough points for interpolation
      
      // Ensure LUT starts at 0 and we know the end value
      const lutStart = lut[0];
      const lutEnd = lut[K - 1];
      
      // Create x coordinates for LUT points
      const lutX = new Array(K);
      for (let i = 0; i < K; i++) {
        lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
      }
      
      let interpolationFunction;
      
      if (interpolationType === 'cubic') {
        // Cubic spline interpolation for smoothest curves
        interpolationFunction = createCubicSpline(lutX, lut, intensity);
      } else if (interpolationType === 'pchip') {
        // PCHIP interpolation for monotonic, shape-preserving curves
        interpolationFunction = createPCHIPSpline(lutX, lut);
      } else {
        // Linear interpolation for exact point-to-point behavior
        const denom = (domainMax - domainMin) || 1;
        interpolationFunction = (t) => {
          const tNorm = clamp01((t - domainMin) / denom);
          const u = tNorm * (K - 1);
          const i0 = Math.floor(u);
          const i1 = Math.min(i0 + 1, K - 1);
          const a = u - i0;
          return (1 - a) * lut[i0] + a * lut[i1];
        };
      }
      
      return values.map((v, index) => {
        // Apply LUT curve to all values, including endpoints
        const t = (v / maxValue) * (domainMax - domainMin) + domainMin;
        const lutValue = interpolationFunction(t);
        
        // Scale LUT value directly to maxValue range
        return Math.round(clamp01(lutValue) * maxValue);
      });
    }

    const debouncedPreviewUpdate = debounce(updatePreview, 300);

    // Optimized 256 value generation with optional linearization
    function make256(endValue, applyLinearization = false) {
      if (endValue === 0) return new Array(N).fill(0);
      
      const arr = new Array(N);
      const step = endValue / DENOM;
      
      for (let i = 0; i < N; i++) {
        arr[i] = Math.round(i * step);
      }
      
      // Apply linearization based on smoothing method selection
      if (applyLinearization && linearizationData && linearizationApplied) {
        const interpolationType = elements.curveSmoothingMethod.value;
        const intensity = elements.smoothingIntensity.value / 100; // Convert 0-100 to 0-1
        return apply1DLUT(arr, linearizationData.samples, linearizationData.domainMin, linearizationData.domainMax, endValue, interpolationType, intensity);
      }
      
      return arr;
    }

    // Randomized starting ink limits for visual variety
    function getRandomInkLimit(inkName) {
      // Define realistic ranges for different ink types - all with 100% upper bound for maximum variation
      const inkRanges = {
        K: [30, 100],     // Black: 30-100%
        C: [35, 100],     // Cyan: 35-100%
        M: [30, 100],     // Magenta: 30-100%
        Y: [40, 100],     // Yellow: 40-100%
        LC: [20, 100],    // Light Cyan: 20-100%
        LM: [20, 100],    // Light Magenta: 20-100%
        LK: [25, 100],    // Light Black: 25-100%
        LLK: [15, 100],   // Light Light Black: 15-100%
        V: [25, 100],     // Violet: 25-100%
        MK: [20, 100]     // Matte Black: 20-100%
      };
      
      const range = inkRanges[inkName] || [25, 45]; // Default range if ink not found
      const min = range[0];
      const max = range[1];
      
      // Generate random percentage within range
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // Extract channel row creation
    function createChannelRow(name) {
      const randomPercent = getRandomInkLimit(name);
      const randomEndValue = InputValidator.computeEndFromPercent(randomPercent);
      
      const tr = document.createElement('tr');
      tr.className = "border-t border-gray-200";
      tr.innerHTML = `
        <td class="px-3 py-2 text-center">
          <button class="disable-btn px-2 py-1 text-xs bg-red-100 text-red-700 hover:bg-red-200 rounded border border-red-300 transition-colors" title="Disable channel (set to 0)">
            Disable
          </button>
        </td>
        <td class="px-3 py-2 font-medium">
          <span class="inline-flex items-center gap-2">
            <span class="inline-block w-3.5 h-3.5 rounded-sm border border-black/10" style="background-color: ${INK_COLORS[name] || '#000'}"></span>
            <span>${name}</span>
            <span class="text-xs text-gray-500 invisible" data-disabled>(disabled)</span>
          </span>
        </td>
        <td class="px-3 py-2">
          <input type="number" step="1" min="0" max="100" value="${randomPercent}" class="percent-input w-28 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
        <td class="px-3 py-2">
          <input type="number" step="1" min="0" max="64000" value="${randomEndValue}" class="end-input w-28 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
      `;
      
      return tr;
    }

    function setupChannelRow(tr) {
      const percentInput = tr.querySelector('.percent-input');
      const endInput = tr.querySelector('.end-input');
      const disabledTag = tr.querySelector('[data-disabled]');
      const disableBtn = tr.querySelector('.disable-btn');

      function refreshDisplay() {
        const endVal = InputValidator.clampEnd(endInput.value);
        endInput.value = String(endVal);
        disabledTag.classList.toggle('invisible', endVal !== 0);
        
        // Update channel label opacity
        const channelLabel = tr.querySelector('td:nth-child(2) span');
        if (endVal === 0) {
          channelLabel.style.opacity = '0.33';
        } else {
          channelLabel.style.opacity = '1';
        }
        
        // Update button appearance and text
        if (endVal === 0) {
          disableBtn.className = 'disable-btn px-2 py-1 text-xs bg-green-100 text-green-700 hover:bg-green-200 rounded border border-green-300 transition-colors';
          disableBtn.textContent = 'Enable';
          disableBtn.title = 'Enable channel (restore to 33%)';
        } else {
          disableBtn.className = 'disable-btn px-2 py-1 text-xs bg-red-100 text-red-700 hover:bg-red-200 rounded border border-red-300 transition-colors';
          disableBtn.textContent = 'Disable';
          disableBtn.title = 'Disable channel (set to 0)';
        }
      }

      // Disable/Enable button functionality
      disableBtn.addEventListener('click', () => {
        const currentEndVal = InputValidator.clampEnd(endInput.value);
        
        if (currentEndVal === 0) {
          // Enable: restore to 33%
          percentInput.value = '33';
          endInput.value = String(InputValidator.computeEndFromPercent(33));
          showStatus(`Enabled ${tr.dataset.channel || 'channel'}`);
        } else {
          // Disable: set to 0
          percentInput.value = '0';
          endInput.value = '0';
          showStatus(`Disabled ${tr.dataset.channel || 'channel'}`);
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      // Use debounced updates to prevent excessive recalculations
      percentInput.addEventListener('input', () => {
        const p = InputValidator.validateInput(percentInput, InputValidator.clampPercent);
        const endVal = InputValidator.computeEndFromPercent(p);
        endInput.value = String(endVal);
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      endInput.addEventListener('input', () => {
        const e = InputValidator.validateInput(endInput, InputValidator.clampEnd);
        const p = InputValidator.computePercentFromEnd(e);
        percentInput.value = p.toFixed(1);
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      // Initial sync
      const initialP = InputValidator.clampPercent(percentInput.value);
      percentInput.value = initialP.toString();
      endInput.value = String(InputValidator.computeEndFromPercent(initialP));
      refreshDisplay();
    }

    // Optimized setPrinter with DocumentFragment
    function setPrinter(key) {
      try {
        const p = PRINTERS[key];
        const fragment = document.createDocumentFragment();
        
        p.channels.forEach(ch => {
          const tr = createChannelRow(ch);
          tr.dataset.channel = ch; // Add channel name to dataset
          fragment.appendChild(tr);
        });
        
        // Clear and update DOM in one operation
        elements.rows.innerHTML = "";
        elements.rows.appendChild(fragment);
        
        // Setup event listeners after DOM update
        Array.from(elements.rows.children).forEach(setupChannelRow);

        elements.channelInfo.textContent = "Channels: " + p.channels.join(", ");
        elements.printerDescription.innerHTML = "";
        
        // Use requestAnimationFrame for smooth UI update
        requestAnimationFrame(() => {
          updatePreview();
          updateInkChart();
          updateFilename(); // Update filename when printer changes
        });
        showStatus(`Switched to ${p.name}`);
      } catch (error) {
        console.error('Error setting printer:', error);
        showStatus("Error changing printer");
      }
    }

    function buildLimitsSummary() {
      const lines = ["# Limits summary:"];
      
      Array.from(elements.rows.children).forEach((tr) => {
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const e = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        const p = InputValidator.computePercentFromEnd(e);
        
        if (e === 0) {
          lines.push("#   " + name + ": disabled");
        } else {
          const isWhole = Math.abs(p - Math.round(p)) < 1e-9;
          const percentFormatted = isWhole ? String(Math.round(p)) : p.toFixed(1);
          lines.push("#   " + name + ": = " + percentFormatted + "%");
        }
      });
      
      return lines;
    }

    function buildFile() {
      const p = PRINTERS[elements.printerSelect.value];
      const lines = [
        "## QuadToneRIP " + p.channels.join(","),
        "# Printer: " + p.name,
        "# quadGEN v1.0 by David Marsh",
        ...buildLimitsSummary()
      ];

      // Build channel blocks efficiently
      p.channels.forEach((ch, idx) => {
        const row = elements.rows.children[idx];
        const e = InputValidator.clampEnd(row.querySelector('.end-input').value);
        const arr = make256(e, true); // Apply linearization if enabled
        lines.push("# " + ch + " curve");
        lines.push(...arr.map(String));
      });

      return lines.join("\n") + "\n";
    }

    // Apply-to-all with improved performance and error handling
    elements.btnApplyPercent.addEventListener('click', () => {
      try {
        const val = InputValidator.clampPercent(elements.applyPercent.value);
        const endVal = InputValidator.computeEndFromPercent(val);
        
        Array.from(elements.rows.children).forEach(tr => {
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          percentInput.value = val.toString();
          endInput.value = String(endVal);
          
          // Trigger display update
          const disabledTag = tr.querySelector('[data-disabled]');
          disabledTag.classList.toggle('invisible', endVal !== 0);
        });
        
        updatePreview();
        showStatus(`Applied ${val}% to all channels`);
      } catch (error) {
        console.error('Error applying percentage:', error);
        showStatus("Error applying percentage");
      }
    });

    elements.btnApplyEnd.addEventListener('click', () => {
      try {
        const val = InputValidator.clampEnd(elements.applyEnd.value);
        const percentVal = InputValidator.computePercentFromEnd(val);
        
        Array.from(elements.rows.children).forEach(tr => {
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          endInput.value = String(val);
          percentInput.value = percentVal.toFixed(1);
          
          // Trigger display update
          const disabledTag = tr.querySelector('[data-disabled]');
          disabledTag.classList.toggle('invisible', val !== 0);
        });
        
        updatePreview();
        showStatus(`Applied ${val} end value to all channels`);
      } catch (error) {
        console.error('Error applying end value:', error);
        showStatus("Error applying end value");
      }
    });

    // Download with enhanced error handling
    elements.downloadBtn.addEventListener('click', () => {
      try {
        const text = buildFile();
        const p = PRINTERS[elements.printerSelect.value];
        
        // Get custom filename or use default
        let filename;
        const customName = elements.filenameInput.value.trim();
        if (customName) {
          // Remove .quad extension if user added it, then sanitize
          const cleanName = customName.replace(/\.quad$/, '');
          const sanitizedName = sanitizeFilename(cleanName);
          
          // If sanitization removed everything, fall back to default
          if (!sanitizedName) {
            filename = p.name.replace(/\s+/g, '') + "_linear.quad";
            showStatus("Invalid filename, using default");
          } else {
            filename = sanitizedName + '.quad';
            
            // Show warning if filename was changed
            if (sanitizedName !== cleanName) {
              showStatus(`Filename sanitized: ${filename}`);
            }
          }
        } else {
          // Use default naming
          filename = p.name.replace(/\s+/g, '') + "_linear.quad";
        }
        
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus(`Downloaded ${filename}`);
      } catch (error) {
        console.error('Download error:', error);
        showStatus("Error downloading file");
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 's':
            e.preventDefault();
            elements.downloadBtn.click();
            break;
          case 'r':
            e.preventDefault();
            updatePreview();
            break;
        }
      }
    });


    // Initialize
    elements.printerSelect.addEventListener('change', (e) => setPrinter(e.target.value));
    
    // Add real-time filename validation
    elements.filenameInput.addEventListener('input', (e) => {
      const input = e.target;
      const value = input.value.trim();
      
      // Mark as user-edited if they've typed something different from auto-generated
      if (value !== generateFilename()) {
        input.dataset.userEdited = 'true';
      } else {
        delete input.dataset.userEdited;
      }
      
      if (value) {
        const cleanName = value.replace(/\.quad$/, '');
        const sanitized = sanitizeFilename(cleanName);
        const hasInvalidChars = sanitized !== cleanName;
        
        // Visual feedback for invalid characters
        input.classList.toggle('border-yellow-300', hasInvalidChars);
        input.classList.toggle('bg-yellow-50', hasInvalidChars);
        input.classList.toggle('border-gray-300', !hasInvalidChars);
        input.classList.toggle('bg-white', !hasInvalidChars);
        
        if (hasInvalidChars) {
          input.title = `Will be saved as: ${sanitized}.quad`;
        } else {
          input.title = '';
        }
      } else {
        input.classList.remove('border-yellow-300', 'bg-yellow-50');
        input.classList.add('border-gray-300', 'bg-white');
        input.title = '';
      }
    });

    // Linearization event listeners

    elements.linearizationFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const content = await file.text();
        const parsed = parseCube1D(content);
        linearizationData = parsed;
        linearizationApplied = true; // Auto-apply when file is loaded
        
        // Set button to disable state since linearization is now applied
        elements.applyLinearization.disabled = false;
        elements.applyLinearization.className = 'w-full rounded-lg px-4 py-2 bg-red-600 text-white hover:bg-red-700';
        elements.applyLinearization.textContent = 'Disable Linearization';
        
        // Enable smoothing dropdown since linearization is active
        elements.curveSmoothingMethod.disabled = false;
        elements.smoothingIntensity.disabled = false;
        
        // Show intensity slider if appropriate method is selected
        const method = elements.curveSmoothingMethod.value;
        if (method !== 'linear' && method !== 'pchip') {
          elements.smoothingIntensityContainer.style.display = 'block';
        }
        
        showStatus(`Loaded and applied ${parsed.samples.length} data points from ${file.name}`);
        debouncedPreviewUpdate(); // Update preview to show the applied linearization
      } catch (error) {
        console.error('Cube file parsing error:', error);
        showStatus(`Error loading file: ${error.message}`);
        linearizationData = null;
        linearizationApplied = false;
        elements.applyLinearization.disabled = true;
        elements.applyLinearization.className = 'w-full rounded-lg px-4 py-2 bg-gray-300 text-gray-500 cursor-not-allowed';
        elements.applyLinearization.textContent = 'Apply Linearization';
        elements.curveSmoothingMethod.disabled = true; // Disable dropdown on error
        elements.smoothingIntensity.disabled = true;
        elements.smoothingIntensityContainer.style.display = 'none';
      }
    });

    elements.applyLinearization.addEventListener('click', () => {
      if (!linearizationData) return; // No data loaded
      
      if (linearizationApplied) {
        // Currently applied - disable it
        linearizationApplied = false;
        elements.applyLinearization.textContent = 'Apply Linearization';
        elements.applyLinearization.className = 'w-full rounded-lg px-4 py-2 bg-black text-white hover:bg-black/90';
        elements.curveSmoothingMethod.disabled = true; // Disable dropdown when linearization is off
        elements.smoothingIntensity.disabled = true;
        elements.smoothingIntensityContainer.style.display = 'none';
        showStatus('Linearization disabled - using linear curves');
        debouncedPreviewUpdate();
      } else {
        // Currently disabled - apply it
        linearizationApplied = true;
        elements.applyLinearization.textContent = 'Disable Linearization';
        elements.applyLinearization.className = 'w-full rounded-lg px-4 py-2 bg-red-600 text-white hover:bg-red-700';
        elements.curveSmoothingMethod.disabled = false; // Enable dropdown when linearization is on
        elements.smoothingIntensity.disabled = false;
        
        // Show intensity slider if appropriate method is selected
        const method = elements.curveSmoothingMethod.value;
        if (method !== 'linear' && method !== 'pchip') {
          elements.smoothingIntensityContainer.style.display = 'block';
        }
        showStatus('Linearization applied to preview and output');
        debouncedPreviewUpdate();
      }
    });

    // Curve smoothing method selection
    elements.curveSmoothingMethod.addEventListener('change', (e) => {
      const method = e.target.value;
      
      // Show/hide intensity slider based on method
      if (method === 'linear' || method === 'pchip') {
        elements.smoothingIntensityContainer.style.display = 'none';
      } else {
        elements.smoothingIntensityContainer.style.display = 'block';
      }
      
      if (linearizationData && linearizationApplied) {
        const methodNames = {
          'cubic': 'Cubic Spline',
          'pchip': 'PCHIP (monotonic)',
          'linear': 'Linear (none)'
        };
        showStatus(`Curve method: ${methodNames[method]}`);
        debouncedPreviewUpdate(); // Update preview with new smoothing setting
      }
    });
    
    // Smoothing intensity slider
    elements.smoothingIntensity.addEventListener('input', (e) => {
      if (linearizationData && linearizationApplied) {
        const intensity = Math.round(e.target.value);
        showStatus(`Smoothing intensity: ${intensity}%`);
        debouncedPreviewUpdate(); // Update preview with new intensity setting
      }
    });
    
    // Initial setup with error handling
    try {
      setPrinter('P900');
    } catch (error) {
      console.error('Initialization error:', error);
      showStatus("Initialization error. Please refresh the page.");
    }
  </script>
</body>
</html>