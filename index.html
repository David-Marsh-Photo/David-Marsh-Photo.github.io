<!doctype html>
<html lang="en">

<!--
MIT License

Copyright (c) 2025 David Marsh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Scope: This license applies to this HTML file (quadgen.html) only.
-->

<!--
================================================================================
QUADGEN TECHNICAL SPECIFICATION
================================================================================

VERSION: v1.8.5
REVISION DATE: 2025-09-03
PREVIOUS: v1.8.4 (2025-09-04)

================================================================================
⚠️⚠️⚠️ CRITICAL INTERPOLATION REQUIREMENTS ⚠️⚠️⚠️
================================================================================
SMOOTH INTERPOLATION **MUST** USE PCHIP (Piecewise Cubic Hermite Interpolating Polynomial)
- This is the ONLY approved method for natural language curve generation
- VERIFIED WORKING in v1.5 - DO NOT REPLACE with other methods  
- Avoids: horizontal flattening, sharp corners, overshooting
- Linear interpolation acceptable for 'linear' mode only
- If curve issues reported, check PCHIP implementation BEFORE changing algorithms

SYSTEM OVERVIEW
================================================================================
QuadGEN generates QuadToneRIP .quad files for Epson inkjet printer systems. 
Implementation provides 256-step linearization curves with configurable ink 
limits, linearization data processing, and interpolation algorithms.

SUPPORTED HARDWARE (newest → oldest):
 - P700-P900: 10-channel configuration (K,C,M,Y,LC,LM,LK,LLK,V,MK)
 - P5-7-9000: 10-channel configuration (K,C,M,Y,LC,LM,LK,LLK,OR,GR)
 - P600-P800: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)
 - P400: 6-channel configuration (K,C,M,Y,LC,LM)
 - x900: 10-channel configuration (K,C,M,Y,LC,LM,LK,LLK,OR,GR)
 - 3880-7880: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)
 - x800-x890: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)
 - P4-6-8000: 8-channel configuration (K,C,M,Y,LC,LM,LK,LLK)

================================================================================
ARCHITECTURAL IMPLEMENTATION
================================================================================

CURVE PROCESSING PIPELINE:
1. Base curve initialization: Loaded .quad data or linear ramp generation
2. Per-channel linearization: .cube/.txt file application when loaded
3. Global linearization: .cube/.txt file application when loaded
4. Interpolation processing: Sparse data expansion via selected algorithm

⚠️  CRITICAL: INTERPOLATION METHOD REQUIREMENTS ⚠️
- SMOOTH INTERPOLATION MUST USE PCHIP (Piecewise Cubic Hermite Interpolating Polynomial)
- PCHIP is the ONLY method that provides smooth curves through control points WITHOUT:
  * Horizontal flattening around key points (smoothstep problem)
  * Sharp corners at control points (linear problem)  
  * Overshooting between points (spline problem)
- VERIFIED: Smooth Smart Curves use PCHIP with numeric key points (natural‑language presets deprecated)
- DO NOT REPLACE with smoothstep, cosine, Catmull-Rom, or other methods
- Linear interpolation acceptable for 'linear' mode only
- If curve issues reported, check PCHIP implementation BEFORE changing algorithms

⚠️  CRITICAL: SMART CURVE CREATION POLICY ⚠️
- Lab Tech must compute explicit numeric key points based on user intent and apply them with set_ai_key_points.
- Do NOT rely on built-in presets or pre-defined curves; generate_curve_from_description is deprecated.
- Photography terms (e.g., 'S-curve', 'lift shadows', 'salt print range') may guide intent, but the assistant must choose actual numeric key points.
- Interpolation: PCHIP (smooth) is required for smooth curves; Linear allowed only for technical cases.

INTERPOLATION ALGORITHMS:
- Activation condition: Linearization data loaded with sparse control points
- Disabled condition: Loaded .quad files (256-point complete datasets)
- Available methods: Cubic, Catmull-Rom (tension parameter), PCHIP, Linear
- Control point source: LAB data uses original measurements, .cube uses file samples
- Linear interpolation: Handles non-evenly spaced control points via interval search

DATA POINT SMOOTHING SYSTEM:
- Purpose: Reduce control point count while preserving curve characteristics  
- Method: Smoothing Splines (mathematical curve smoothing with automatic lambda selection)
- Range: 0-90% reduction, disabled at 0%
- LAB data processing: Operates on original sparse measurements (0%, 5%, 10%, etc.)
- .cube data processing: Operates on original file sample points
- Control point output: Always generates sparse points to enable interpolation methods

CHANNEL MANAGEMENT SYSTEM:
- State control: Enable/disable via checkbox interface
- Disabled channel behavior: Value set to 0, previous state stored
- Function scope: Apply-to-all operations exclude disabled channels
- UI feedback: Opacity reduction and compact layout for disabled states

FILE FORMAT SPECIFICATIONS:
- .quad: 256-point curve datasets (bidirectional input/output)
- 1DLUT (.cube): 1D LUT linearization correction data
- 3DLUT (.cube): 3D LUT with neutral axis extraction for linearization
- LAB data (.txt): LAB measurement measurement datasets for linearization
- .acv: Adobe Photoshop curve files (binary format, cubic spline interpolation of RGB composite curve)

LINEARIZATION DATA PROCESSING:
- Global LAB data: Applied uniformly to all ink channels via single correction curve
- Per-channel LAB data: Individual correction curves per ink channel for precise control
- 3D LUT processing: Neutral axis extraction (R=G=B diagonal) via trilinear interpolation
- LAB data processing: Wedgie-style inversion to a linear target (Target X% = Measured X%, Target L* = 100→0)
- ACV curve processing: Binary format parsing with cubic spline interpolation of control points
- File processing: parseLinearizationFile() routes files through appropriate parsers (text/binary detection)
- 3D LUT extraction: Samples 256 points along neutral axis, ignores color information
- ACV curve extraction: Uses RGB composite curve (first curve) with smooth interpolation between control points
- Data validation: Format detection and comprehensive error handling
- Coordinate systems: All formats normalized to quadGEN's printing coordinate system
- Interpolation method selection: Intelligent detection prevents double-smoothing on Smart Curves while preserving PCHIP for measurement data
- Data source detection: Smart Curves use linear interpolation, measurement data (LAB/sample) uses user-selected method (PCHIP/Linear)

================================================================================
QUICK REFERENCE - KEY FUNCTIONS & LOCATIONS
================================================================================

CHANNEL MANAGEMENT:
- refreshDisplay(): Visual state management for enabled/disabled channels (~6633)
- handleCheckboxChange(): Channel enable/disable event handler (~6679)  
- _applyCurveToChannel(): Apply Smart Curves to channels (~3042)
- createChannelRow(): Initialize channel table rows with event handlers (~6534)

PROCESSING DETAILS:
- updateProcessingDetail(): Update processing labels (~6011)
- updateProcessingDetailForce(): Force update of processing labels (~5860)
- Info icon: decorative ⓘ shown next to label

SMART CURVE GENERATION:
- generateCustomCurve(): Create curves from numeric key points (~2530)
- setAIKeyPoints(): Apply numeric key points for Smart Curves (~3760)
- adjustAIKeyPointByIndex(): Nudge or set a single point by ordinal (~3807)
- insertAIKeyPointAt()/Between(): Insert new points by X or between ordinals (~3910)
- Natural-language parser removed (deprecated)
- _pchipInterpolate(): PCHIP smooth interpolation algorithm (~2925)

UNDO/HISTORY SYSTEM:
- CurveHistory object: Action-based undo/redo with individual channel tracking (~4865)
- Individual Actions: Track single channel changes (enable, percentage, end, curve) (~5025)
- Batch Actions: Group multiple channel changes from single assistant commands (~5063)
- CurveHistory.recordChannelAction(): Record individual channel state changes (~5025)
- CurveHistory.recordBatchAction(): Record multiple channels as single undoable action (~5063)
- CurveHistory.undo(): Restore previous actions with proper UI refresh (~5150)
- CurveHistory.redo(): Re-apply undone actions maintaining UI state (~5535)
- undoIndividualAction(): Process single channel undos within batch operations (~5365)
- redoIndividualAction(): Process single channel redos within batch operations (~5470)
- Batch Operation Flag: Prevents individual action recording during batch operations (~5557)
- Button State Management: Real-time undo/redo button enabling based on history (~5787)

FILE OPERATIONS:
- buildFile(): Generate .quad file content from current settings (~5490)
- parseQuadFile(): Parse loaded .quad files and extract channel data (~7953)
- parseLinearizationFile(): Handle .cube/.txt/.acv file processing (~8200)
- loadQuadFile(): Load .quad files and update all channel settings (~8045)

APPLY-TO-ALL OPERATIONS:
- Apply percentage buttons: Mass-update all enabled channels (~7020)
- Apply end value buttons: Mass-update all enabled channel limits (~7070)
- Enable/disable all channels: Toggle all channel states with state preservation (~7820)

LAB TECH INTEGRATION:
- LabTech.executeFunction(): Route Lab Tech commands to quadGEN actions (~3720)
- LabTech.sendMessage(): Process user messages and execute assistant responses (~3850)
- LabTech function definitions: 25 specialized functions for system control (~3540)

================================================================================
LAB TECH INTEGRATION
================================================================================

SYSTEM OVERVIEW:
Built-in Lab Tech assistant provides natural language control over quadGEN operations.
Accessible via expandable interface panel with real-time chat functionality.
Supports 25 specialized functions for complete system control without manual interface interaction.

FUNCTION CATEGORIES:

CHANNEL CONTROL FUNCTIONS:
- set_channel_value: Set ink limit percentage for specific channel (0-100%)
- set_channel_end_value: Set ink limit end value for specific channel (0-64000)
- apply_to_all_channels: Apply same ink limit percentage to all enabled channels (creates batch undo)
- apply_end_to_all_channels: Apply same ink limit end value to all enabled channels (creates batch undo)
- enable_disable_channel: Enable/disable individual ink channels
- batch_channel_operations: Multiple enable/disable operations in single call (creates batch undo)

INK LIMIT VALUE SYSTEM:
- Percentages (0-100%) and end values (0-64000) are mathematically linked
- 0% = 0 end value, 33% = 21120 end value, 50% = 32000 end value, 100% = 64000 end value
- Use set_channel_value for percentage-based requests ("set to 50%")
- Use set_channel_end_value for direct end value requests ("set to 32000")

BATCH UNDO INTEGRATION:
- AI operations affecting multiple channels automatically create batch undo actions
- batch_channel_operations: Records only channels with actual state changes
- apply_to_all_channels: Groups percentage changes across multiple enabled channels
- generate_global_custom_curve: Groups custom curve changes across multiple channels
- generate_global_custom_curve: Groups custom curve changes across multiple channels  
- Single undo button press reverts entire batch operation across all affected channels
- Prevents individual action recording during batch operations via isBatchOperation flag
- TIMING CRITICAL: Batch flag maintained for 1.5 seconds to prevent debounced handlers from creating individual actions
- Direct UI updates during batch operations bypass debounced handlers to prevent timing conflicts
- Maintains proper UI state synchronization including graph updates and compact display

FILE OPERATION FUNCTIONS:
- open_global_linearization_file_picker: Open file dialog for global linearization
- open_per_channel_linearization_file_picker: Open file dialog for per-channel linearization
- load_sample_lab_file: Load built-in sample LAB measurement data for testing
- load_sample_cube_file: Load built-in sample LUT cube file for testing
- generate_and_download_quad_file: Generate final .quad file and download to user
- set_filename: Set output filename for generated .quad file (auto-sanitized)

DATA LOADING FUNCTIONS:
- load_lab_data_global: Process pasted LAB measurement text for global linearization
- load_lab_data_per_channel: Process pasted LAB measurement text for specific channel
- load_cube_data_global: Process pasted .cube LUT text for global linearization  
- load_cube_data_per_channel: Process pasted .cube LUT text for specific channel

LINEARIZATION CONTROL FUNCTIONS:
- set_global_linearization: Enable/disable global linearization processing
- set_per_channel_linearization: Enable/disable linearization for specific channel

CURVE GENERATION FUNCTIONS:
- set_smart_key_points (alias: set_ai_key_points): Apply explicit numeric key points (Smart Curves)
- adjust_smart_key_point_by_index: Adjust a single key point by ordinal (1-based, endpoints included)
- get_smart_key_points: Inspect currently stored Smart key points
- insert_smart_key_point_at: Insert a new key point at a given input (X), optional output (Y)
- insert_smart_key_point_between: Insert a new key point between two adjacent ordinals
- generate_custom_curve: Create curve from explicit numerical control points (single channel)
- copy_curve_to_channel: Copy existing curve from source channel to target channel
- generate_global_custom_curve: Create curves from numerical points for multiple channels (batch)
  * Channel filters: 'all' (all printer channels), 'enabled' (only enabled channels)
  * Creates single batch undo action for all affected channels
  * Handles percentage adjustments and channel enabling as needed
  * Full UI synchronization with immediate graph updates

SYSTEM CONTROL FUNCTIONS:
- set_interpolation_method: Select interpolation algorithm (pchip/linear)
- set_smoothing_percentage: Control data point smoothing (0-90% reduction)
- change_printer: Switch between P600-P800 and P700-P900 printer configurations

UTILITY FUNCTIONS:
- get_current_state: Retrieve complete system state for analysis
- undo_last_change: Revert to previous state (integrated with CurveHistory system)
- get_history_summary: Get summary of recent changes for reference

⚠️  CRITICAL LAB TECH INTEGRATION NOTES:
- All functions include comprehensive input validation and error handling
- Function execution results are logged to chat interface for user feedback
- Do NOT use pre-defined/preset curve mappings; generate_curve_from_description is deprecated.
- Lab Tech must compute numeric key points and use set_smart_key_points (set_ai_key_points alias also supported), or generate_global_custom_curve for multiple channels.
- Rate limiting implemented: 10 requests/minute, 100 requests/hour (via Cloudflare Worker)
- Model: Claude Sonnet 4 (claude-sonnet-4-0) - Latest snapshot alias for optimal performance
- Function results integrate with CurveHistory system for undo functionality
- All channel operations respect current printer configuration (P600-P800 vs P700-P900)

⚠️  GLOBAL CURVE GENERATION IMPLEMENTATION NOTES:
- Batch operation flag (CurveHistory.isBatchOperation) prevents individual undo actions during global operations
- 1.5-second timing delay ensures debounced input handlers don't create conflicting undo actions
- Events dispatched during batch operations maintain UI/internal state synchronization
- Automatic percentage adjustments based on curve maximum values (Math.max(...curve) / TOTAL * 100)
- Channel enabling handled automatically for disabled channels receiving curves
- All UI elements synchronized: input fields, graphs, compact display, per-channel toggles
- Error handling maintains batch flag state to prevent orphaned batch operations

================================================================================
PROCESSING LABEL SYSTEM
================================================================================

FEATURE OVERVIEW:
Always-visible channel processing label that summarizes the active processing \
for each ink channel. Uses a ⓘ icon and italic text. When multiple corrections \
are applied, each appears on its own new line.

UI COMPONENTS:
- Info Icon: ⓘ next to each channel name (decorative)
  * Conveys informational context
  * Tooltip: "Processing details"
- Processing Label: italic; multi-line when stacked corrections are present
  * Shows concise pipeline summary, one line per layer
  * Full combined text available on hover via `title`

PIPELINE INFORMATION DISPLAYED:
- Smart Curve: shows key-point count when present (e.g., "Smart Curve (N key points)")
- Per-Channel: format • filename (count) when enabled
- Global: format • filename (count) when enabled
- Linear ramp when no processing is applied
Applied segments are shown as separate lines in order of application.

TECHNICAL IMPLEMENTATION:
Functions:
- updateProcessingDetail(channelName): Updates label for a channel
- updateProcessingDetailForce(channelName): Always recomputes and writes label
- Real-time updates triggered by all data loading operations

Auto-Update Triggers:
- Smart Curve generation (via _applyCurveToChannel)
- Per-channel file loading and toggle changes
- Global linearization file loading and toggle changes  
- Sample data button usage (LAB and cube)

DOM Structure:
- Inline: <span class="processing-label" data-channel="{name}"> ... </span>
- Proper channel identification via data-channel selectors

WORKFLOW INTEGRATION:
- Helps identify double-processing scenarios (Smart + per-channel)
- Shows processing order: Base → Per-Channel → Global
- Always visible; updates immediately when data changes
- Integrates with undo/history system

PERFORMANCE CHARACTERISTICS:
- Event-driven updates; no polling
- Lightweight DOM queries using data-channel attributes
- Minimal memory footprint

⚠️  INTEGRATION NOTES:
- Channel iteration uses array.forEach() not Object.keys() (channels are arrays)
- Works with all data sources: Smart, manual files, sample buttons
- Respects printer configuration (P600-P800 vs P700-P900 channels)

================================================================================
UNDO & HISTORY SYSTEM
================================================================================

SYSTEM OVERVIEW:
Comprehensive state management system providing full undo functionality for all quadGEN operations.
Captures complete system snapshots before every modification, enabling precise state restoration.
Integrated with Lab Tech assistant, manual controls, and file operations for seamless workflow.

CURVHISTORY ARCHITECTURE:
- State storage: Ring buffer with 20-state maximum capacity (oldest automatically removed)
- Capture scope: Complete system state including channels, curves, linearization settings
- Restoration: Full system state rollback with UI synchronization
- Memory management: Automatic cleanup and efficient JSON serialization

STATE CAPTURE SYSTEM:
Automatic state capture triggered by:
- Channel ink limit modifications (individual or batch operations)
- Channel enable/disable operations
- Custom curve generation and copying operations
- Linearization file loading and toggle changes
- Apply-to-all operations (percentage or end values)
- Lab Tech assistant function executions
- Manual user interface interactions

CAPTURED STATE COMPONENTS:
- Channel Configuration: Ink limits, end values, enable/disable status
- Curve Data: Custom curves for each channel (complete 256-point arrays)
- Linearization Data: Global and per-channel linearization settings and data
- UI State: All interface toggles, checkboxes, and form values
- Metadata: Timestamp, action description, system configuration

UNDO FUNCTIONALITY:
- Manual Undo: Physical "↶ Undo" button in main interface
- AI Integration: undo_last_change function callable via Lab Tech assistant
- Smart Button State: Dynamic tooltip showing most recent action available for undo
- Visual Feedback: Button opacity and disable state reflects undo availability
- Error Handling: Graceful failure recovery with user feedback

HISTORY QUERYING:
- getHistorySummary(): Returns structured data for Lab Tech assistant analysis
- State Inspection: Access to last 5 actions with timestamps
- Undo Availability: Boolean flag for interface state management
- Action Descriptions: Human-readable descriptions of each captured state

DEBOUNCED CAPTURE OPTIMIZATION:
User input operations (typing in fields) use 1-second debounce to prevent:
- Excessive state captures during continuous typing
- Memory bloat from intermediate values
- Performance degradation during rapid changes
Final state captured 1 second after user stops interaction

INTEGRATION POINTS:
- QuadGenActions: All programmatic operations automatically capture state
- Manual Controls: Input fields, checkboxes, and buttons trigger state capture
- File Operations: Loading quad/linearization files captures before and after states
- AI Assistant: Every function execution preceded by state capture
- Error Recovery: Failed operations do not corrupt history chain

PERFORMANCE CHARACTERISTICS:
- Capture Time: <5ms for complete system state (synchronous operation)
- Memory Usage: ~2-4KB per state (JSON serialized channel configurations)
- Storage Limit: Maximum 80KB total history storage (20 states × ~4KB average)
- Restoration Time: <10ms for complete system restoration with UI update

⚠️  CRITICAL USAGE NOTES:
- Initial state automatically captured on application startup
- State capture occurs BEFORE modification, not after
- Manual undo button reflects most recent undoable action in tooltip
- Lab Tech assistant undo commands return success/failure status with descriptive messages
- History survives printer configuration changes (P600-P800 ↔ P700-P900)
- Curve data restoration preserves interpolation and smoothing settings

================================================================================
VERSION HISTORY
================================================================================

NOTE: Version history is now centralized in the VERSION_HISTORY JavaScript object.
To update changelog content, modify the VERSION_HISTORY data structure in the JavaScript code.
Both internal documentation and About dialog are generated from this single source.

v1.6 (2025-08-31) - Lab Tech Assistant & Processing Visibility:
ADDED:
- Lab Tech AI assistant with 25 specialized functions for natural language control
- Processing detail panels showing Base Curves → Per-Channel → Global pipeline per channel
- Professional communication style with markdown formatting support
- Quick reference documentation with function locations
ENHANCED:
- Smart Curve generation with natural language descriptions ("palladium curve", "S-curve")
- Undo system integration for Smart‑generated curves
- Visual state restoration for disabled channels
FIXED:
- Disabled channel transparency when Lab Tech adds curves
- Processing panel updates now immediate (no manual refresh needed)
- Channel iteration bug causing incorrect references
- Smart Curve undo functionality integration

v1.6 (2025-01-30) - Global AI Curve Generation with Batch Undo:
ADDED:
- generate_global_custom_curve: Apply numeric key points to multiple channels simultaneously
- generate_global_custom_curve: Apply custom curve key points to multiple channels simultaneously
- Comprehensive batch undo system: Single undo action reverts all channels affected by global curve operations
- Channel filter support: Target 'all' printer channels or 'enabled' channels only
- Automatic percentage adjustment: Intelligently adjusts channel percentages based on curve range requirements
- Synchronized UI updates: Real-time graph updates and state synchronization across all affected channels

IMPROVED:
- Batch operation timing: 1.5-second flag duration prevents debounced handler conflicts with undo system
- Event handling during batch operations: Maintains UI/internal state consistency while preventing individual undo actions
- Error handling: Robust error management maintains batch flag state integrity
- User experience: Global curve generation provides immediate visual feedback with proper undo support

TECHNICAL:
- CurveHistory.isBatchOperation flag prevents individual undo action creation during batch operations  
- Debounced input handler coordination ensures proper batch undo action recording
- _applyCurveToChannel enhanced with batch-aware event dispatching
- Full integration with existing single-channel curve generation and undo systems

v1.5 (2025-08-29) - Adobe Photoshop .acv Curve File Support:
ADDED:
- Adobe Photoshop .acv file format support: Complete binary format parser for curve presets
- Cubic spline interpolation: Smooth curve generation matching Photoshop's behavior between control points  
- ACV format detection: Automatic binary vs text file handling in parseLinearizationFile()
- RGB composite curve extraction: Uses first curve from multi-curve .acv files for linearization
- Binary data parsing: DataView-based parser supporting Adobe's int16 big-endian format specification
- File input support: .acv files accepted in both global and per-channel linearization inputs
- UI integration: Updated tooltips and file format descriptions to include .acv curve file support
IMPROVED:
- File format documentation: Comprehensive .acv technical specifications in internal documentation
- Linearization workflow: Seamless integration with existing .cube and .txt file processing pipeline

v1.4.1 (2025-08-29) - Smoothing Algorithm Refinements & .quad File Improvements:
ADDED:
- Smoothing Splines algorithm: Mathematical curve smoothing with automatic lambda parameter selection
- Visual curve comparison: Original curve overlay (gray dashed line) shows smoothing effects on all channels
- Simplified curve algorithms: Focused on Uniform Sampling and Smoothing Splines
- Accurate .quad file maximum detection: Uses actual curve maximum instead of endpoint value
REFINED:
- Streamlined algorithm selection: Focused on reliable smoothing methods
- Simplified interpolation options: Hidden Cubic Spline and Catmull-Rom from UI to reduce complexity
- Default algorithm changed: Uniform Sampling now default with Smoothing Splines as advanced option
- UI cleanup: Removed monotonicity preservation option (PCHIP handles this appropriately)
IMPROVED:
- Curve visualization: Original vs smoothed comparison works with multiple channels simultaneously
- Algorithm focus: Concentrated on reliable, predictable smoothing methods for production use
- .quad file scaling: Proper scaling based on actual maximum value for non-monotonic curves

v1.4 (2025-08-29) - 3D LUT Support & Per-Channel LAB Data:
ADDED:
- 3D LUT neutral axis extraction: Automatic processing of 3D .cube files via trilinear interpolation
- Per-channel LAB data support: Individual LAB measurement .txt file loading per ink channel
- Dual format support: Per-channel linearization now accepts both .cube and .txt files
- Individual channel precision: Apply LAB corrections to specific inks for fine-tuned control
- 3D LUT format detection: Automatic routing between 1D and 3D LUT parsers
FIXED:
- Linear interpolation now properly handles non-evenly spaced control points
- LAB data now uses wedgie-style inversion to a linear target; optional smoothing can be applied after inversion
- LAB data uses selected interpolation immediately upon loading; smoothing is optional
- Curve simplification algorithm coordinate handling improved
- Curve simplification data type mismatch resolved for LAB measurement data
ENHANCED:
- Enhanced curve simplification methods for better performance
- Sample data now bundled in application (LAB measurements and Gamma 2.2 curve)
- UI layout reorganized into compact two-column design for better space utilization
- Sample data buttons now include download functionality for external use
- Consistent dropdown styling applied across all UI elements
TECHNICAL:
- 3D LUT neutral axis extraction uses trilinear interpolation with coordinate system normalization
- Per-channel LAB processing reuses proven parseLinearizationFile() architecture
- Removed explicit .txt file blocking from per-channel linearization function
- 3D LUT processing preserves existing 1D LUT pipeline without modifications
- Smoothing path is unified: interpolation/smoothing apply to samples from any source (LAB/Manual/ACV/LUT)
- Linear interpolation uses interval search for non-evenly spaced lutX coordinates
- Smoothing algorithms preserve curve characteristics while reducing data points
- Control points generated from original measurements, not pre-interpolated 256-point curves
================================================================================
v1.3 (2025-08-28) - Linearization Correction Fix:
FIXED:
- LAB measurement linearization correction algorithm now matches industry standard
- Manual L* data entry linearization correction algorithm now matches industry standard  
- .cube file linearization corrected to use original samples directly
- Wedgie-style inversion applied to measurement data (LAB .txt files and Manual L* entry)
- Removed erroneous inverse mapping logic from .cube file parsing

TECHNICAL:
- LAB measurement & Manual L* Entry: Applied horizontal and vertical flip transformations
- .cube files: Use original samples without any coordinate transformation
- Different file types require different coordinate system treatments
- Added comprehensive documentation explaining why different treatments are necessary

VALIDATION:
- Empirically validated against industry standard tools using LAB-Data-Data.txt
- All linearization methods now produce correct industry-standard behavior

v1.2 (2025-01-27) - Major Feature Release:
ADDED:
- Complete .quad file loading with curve preservation
- Layered processing system (base curves + linearization)
- Enhanced file validation and error handling
- Info popup with version information
- Compact UI controls and improved UX

CHANGED:
- Merged P700/P900 into single "P700-P900" option (identical 10-channel config)
- Interpolation controls now properly disabled for loaded .quad files
- Apply-to-all functions respect disabled channel checkboxes
- Enhanced scrollbar styling for file preview (24px, bright white, 60px min)

RESTORED:
- ACV file support (Photoshop curve files) - full binary format parsing for RGB composite curves
REMOVED:
- Smoothing intensity controls (pure interpolation preferred)

TECHNICAL:
- Loaded .quad data stored in loadedQuadData global variable
- make256() function uses Math.max() to find actual curve maximum for proper scaling
- hasAnyLinearization() determines when interpolation controls are relevant
- updateInterpolationControls() manages UI state and visual feedback
- Non-monotonic curve detection: Automatic maximum value identification across all input levels

v1.1 (Previous):
- Catmull-Rom spline interpolation with tension parameter
- Channel memory system for disabled channels
- Cube file inverse mapping corrections
- Tension controls for spline customization

v1.0 (Initial):
- Basic linear ramp generation
- Printer configuration support
- File download functionality
- Chart visualization

================================================================================
IMPLEMENTATION SPECIFICATIONS
================================================================================

CURVE DATA PROCESSING:
- Linear ramp generation: Mathematical progression 0→endValue across 256 steps
- Loaded curve scaling: Proportional adjustment based on actual maximum value (not endpoint)
- Non-monotonic curve support: Proper handling of curves where maximum occurs before 100% input
- Linearization application: Lookup table transformation methodology
- Value constraints: 0-65535 range compliance (QuadToneRIP specification)

INTERPOLATION PROCESSING:
- Application scope: Sparse control point linearization data only
- Processing method: apply1DLUT() function implementation
- Mapping algorithm: Forward input value → LUT lookup → output value
- Algorithm impact: Method selection affects sparse data expansion characteristics

SMOOTHING (DATA POINT REDUCTION):
- Implementation: CurveSimplification object with multiple algorithm support
- Control interface: Horizontal slider (0-90%) with visible simplification method dropdown
- Available methods: Smoothing Splines (mathematical smoothing, default) and Uniform Sampling (even distribution)
- LAB data support: Both methods now work with LAB measurement data (previously uniform-only)
- Method switching: Real-time algorithm selection affects both .cube files and LAB measurement data
- Uniform sampling: Preserves start/end points, reduces intermediate points with even spacing
- Smoothing Splines: Mathematical algorithm with automatic parameter selection for optimal smoothing
- Coordinate system handling: Maintains dual transformation for LAB data, preserves .cube coordinate relationships
- Processing pipeline: originalDataPoints → method selection → smoothing → sparse control points → interpolation → 256-point curve
- Data object integrity: LAB data objects with getSmoothingControlPoints() method now properly preserved through processing chain
- Path detection: apply1DLUT() correctly identifies LAB objects vs arrays to enable proper smoothing method application
- Control point generation: LAB data creates inverse mapping with dual transformation applied to control points
- File type support: LAB data (.txt) files, manual L* entry, 1DLUT (.cube) files, built-in sample data
- Algorithm switching: Real-time method selection with immediate preview update
- Sample data integration: LAB measurement measurement sample (21 points) and Gamma 2.2 curve sample (11 points)
- Coordinate preservation: Algorithms maintain proper spacing for .cube data to prevent interpolation artifacts
- Notification system: Non-intrusive overlay notification at top of graph when smoothing is active

CHANNEL STATE ARCHITECTURE:
- Channel properties: Percentage value, end value, enable/disable state
- Value synchronization: Percentage-end value computational relationship maintained
- Disabled channel handling: Checkbox unchecked, values = 0, previous state stored
- Memory management: channelPreviousValues object maintains restoration data

UI STATE CONTROL:
- Interpolation control state: Determined by hasAnyLinearization() function
- File information display: Activated for loaded .quad file datasets
- User feedback system: Status message communication protocol
- Interface documentation: Tooltip-based control functionality explanation
- Layout organization: Two-column interpolation panel (method selection left, smoothing controls right)
- Dropdown standardization: Unified .standard-dropdown CSS class for consistent styling
- Notification overlay: Fixed-position smoothing notification prevents layout shifts

FILENAME GENERATION ALGORITHM:
- Automatic generation: PrinterModel_Ch1Value_Ch2Value... pattern
- User override capability: Manual editing with userEdited flag
- Loaded file handling: originalname_copy default naming convention
- Filesystem compatibility: Character sanitization processing

================================================================================
TESTING NOTES
================================================================================

KEY TEST SCENARIOS:
1. Load .quad file → verify curve preservation and limit scaling
2. Load .quad + add linearization → verify layered processing
3. Enable/disable channels → verify apply-to-all skips disabled
4. Switch printers → verify channel count and layout changes
5. File validation → verify error handling for corrupted/invalid files
6. LAB data smoothing → verify no curve flipping, all interpolation methods functional
7. .cube file smoothing → verify coordinate system preservation and algorithm accuracy
8. Smoothing + interpolation → verify Linear/Cubic/Catmull-Rom/PCHIP compatibility
9. UI layout responsiveness → verify two-column interpolation panel and overlay notifications
10. Sample data integration → verify LAB measurement and Gamma 2.2 curve samples load correctly

EDGE CASES:
- Empty .quad files or corrupted data
- Linearization files with invalid ranges
- Channel limit changes on loaded curves
- Printer switching with loaded data
- File size limits and validation

================================================================================
LINEARIZATION CORRECTION PROCESSING
================================================================================

COORDINATE SYSTEM ANALYSIS: Correction curve implementation requires coordinate transformation distinct from mathematical intuition.

COLOR MUSE DATA PROCESSING:
- Input format: GRAY% (0-100) → LAB_L* (measured lightness values)
- Mathematical interpretation: GRAY% input produces LAB_L* output
- Industry standard implementation: Coordinate transformation required

ALGORITHM IMPLEMENTATION BY FILE TYPE:

COLOR MUSE (.txt) & MANUAL L* ENTRY PROCESSING:
1. Density value conversion: L* inversion (high L* = light = low density)
2. Density mapping generation: targetDensity (GRAY%) → actualDensity (L*)
3. Correction curve computation: Input determination for target density
4. Dual transformation application:
   - Horizontal flip: flippedInputPos = 1.0 - inputPos (coordinate mirror)
   - Vertical flip: verticallyFlipped = 1.0 - originalSample (value inversion)

CUBE FILE (.cube) PROCESSING:
1. 1D LUT sample extraction from file structure
2. Dual transformation application for coordinate system alignment:
   - Horizontal flip: Coordinate position reversal (ink-RGB relationship)
   - Vertical flip: Value inversion (printing intensity compatibility)
3. Transformation requirement: Industry standard application compatibility

DUAL TRANSFORMATION NECESSITY:
- Implementation consistency: All linearization methods employ identical transformation
- .cube files: RGB→printing ink coordinate space conversion required
- LAB measurement data: Raw measurement coordinate system interpretation
- Manual L* data: Laboratory measurement coordinate interpretation identical
- Industry compatibility: Standard coordinate system differs from mathematical intuition
- Transformation absence: Incorrect curve topology and crossing point behavior
- Transformation presence: Industry-standard curve behavior achieved

CUBE FILE COORDINATE SYSTEM SPECIFICATION:
- .cube RGB system: index 0 = white (RGB 255), index end = black (RGB 0)
- Printing ink system: 0% ink = white paper, 100% ink = black
- Horizontal transformation: .cube end → 0% ink, .cube start → 100% ink
- Vertical transformation: .cube value inversion for ink limit implementation
- Implementation example: test-half.cube RGB 50% → 0% ink 50% limit, 100% ink 100% limit

VALIDATION METHODOLOGY:
- test-linear.cube: Straight diagonal output (null effect confirmation)
- test-half.cube: 0% ink 50% limit → 100% ink 100% limit progression
- test-gamma.cube: Characteristic gamma curve topology (60% crossing point)
- Industry validation: Photoshop RGB 255 → RGB 127 behavior replication

TECHNICAL FINDINGS:
1. Coordinate interpretation significance exceeds mathematical complexity
2. Industry standards override intuitive coordinate systems
3. Empirical validation against established tools required
4. Coordinate transformation priority over algorithm selection
5. Historical workflow conventions influence digital implementation

================================================================================
USER WORKFLOW PROCEDURES
================================================================================

OPERATIONAL SEQUENCE:
1. .quad file creation: Specify target ink configuration and initial ink limit values
2. Test target printing: Execute print using specified .quad file with initial ink limits
3. Measurement data acquisition: LAB measurement device measurement OR 1DLUT (.cube) file generation via EDN system (http://www.easydigitalnegatives.com/)
4. Data importation: LAB data (.txt) file, manual L* entry, or 1DLUT (.cube) application to initial ink configuration
5. Result verification: Curve graph preview and tonal shape validation
6. Optional adjustment: Channel limit modification (enable/disable inks, uniform percentage application)
7. File export: Corrected .quad file generation and QuadToneRIP integration
8. Validation procedure: Reprint execution with corrected .quad file, tonal reproduction target matching verification

WORKFLOW INTEGRATION:
- QuadToneRIP ecosystem compatibility maintained throughout process
- Iterative refinement capability through measurement-correction cycles
- Alternative measurement methodologies supported (LAB measurement, EDN system)
- Advanced user flexibility via optional adjustment procedures

================================================================================
FUTURE CONSIDERATIONS
================================================================================

POTENTIAL ENHANCEMENTS:
- Additional printer model support
- Batch processing capabilities  
- Curve comparison tools
- Export format options
- Advanced curve editing features

ARCHITECTURAL NOTES:
- Single HTML file approach for simplicity and portability
- Client-side processing (no server dependencies)
- Tailwind CSS for styling consistency
- Vanilla JavaScript for maximum compatibility

================================================================================
-->

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title id="pageTitle">quadGEN</title>
  <meta name="description" content="quadGEN - Generate Epson P700-P900/P600-P800 QuadToneRIP .quad files with 256-step ramps per channel." />
  <!-- Version History notes guidance: keep entries concise, direct, factual, and short. See AGENTS.md and CLAUDE.md. -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Always show number input arrows */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: inner-spin-button !important;
      opacity: 1 !important;
    }
    
    input[type="number"] {
      -moz-appearance: textfield;
    }
    
    input[type="number"]::-moz-number-spin-box {
      -moz-appearance: spin-textfield !important;
    }

    /* Slider toggle styles */
    .slider-toggle {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }

    .slider-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #10b981;
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #10b981;
    }

    input:checked + .slider:before {
      transform: translateX(20px);
    }

    input:disabled + .slider {
      background-color: #e5e5e5;
      cursor: not-allowed;
    }

    input:disabled + .slider:before {
      background-color: #f5f5f5;
    }


    /* Custom scrollbar styling for file preview */
    #previewFull::-webkit-scrollbar {
      width: 24px;
    }

    #previewFull::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 12px;
    }

    #previewFull::-webkit-scrollbar-thumb {
      background: #ffffff;
      border-radius: 12px;
      border: 3px solid #2d3748;
      min-height: 60px;
    }

    #previewFull::-webkit-scrollbar-thumb:hover {
      background: #f7fafc;
    }

    #previewFull::-webkit-scrollbar-thumb:active {
      background: #e2e8f0;
    }

    /* Match Lab Tech console scrollbar to .quad File Preview */
    #chatHistory::-webkit-scrollbar {
      width: 24px;
    }
    #chatHistory::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 12px;
    }
    #chatHistory::-webkit-scrollbar-thumb {
      background: #ffffff;
      border-radius: 12px;
      border: 3px solid #2d3748;
      min-height: 60px;
    }
    #chatHistory::-webkit-scrollbar-thumb:hover {
      background: #f7fafc;
    }
    #chatHistory::-webkit-scrollbar-thumb:active {
      background: #e2e8f0;
    }

    /* Instant tooltip for linearization buttons */
    .per-channel-btn, #globalLinearizationBtn {
      position: relative;
    }

    .per-channel-btn:hover::after, #globalLinearizationBtn:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #1f2937;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 1000;
      margin-bottom: 4px;
      pointer-events: none;
    }

    .per-channel-btn:hover::before, #globalLinearizationBtn:hover::before {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #1f2937;
      z-index: 1000;
      pointer-events: none;
    }

    /* Hide number input spinners */
    .lstar-input::-webkit-outer-spin-button,
    .lstar-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    .lstar-input[type=number] {
      -moz-appearance: textfield;
    }
    /* Hide number input spinners for target inputs as well */
    /* (Removed) .lstar-target-* styles – Manual L* no longer uses Target inputs */
    
    /* Standard dropdown styling */
    .standard-dropdown {
      width: 100%;
      padding: 0.25rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      line-height: 1.25;
      height: 32px;
      box-sizing: border-box;
      background-color: white;
      color: #374151;
    }

    /* Edit panel global disable (except main toggle button) */
    #editPanelBody.edit-panel-disabled {
      opacity: 0.6;
      pointer-events: none;
      filter: grayscale(10%);
    }
    
    .standard-dropdown:disabled {
      background-color: #f9fafb;
      color: #9ca3af;
      cursor: not-allowed;
    }
    
    .standard-dropdown option {
      font-size: 0.875rem;
      line-height: 1.25;
      color: #374151;
    }

    /* Use default system checkbox styling */
    input[type="checkbox"] { accent-color: #ffffff; }

    /* Nudge buttons styling */
    .nudge-btn {
      background-color: #475569; /* slate-600 */
      color: #ffffff;
      transition: transform 0.05s ease, background-color 0.1s ease;
      user-select: none;
    }
    /* Unified disabled look in Edit panel: match Redo disabled */
    #editPanelBody button:disabled,
    #editPanelBody .nudge-btn:disabled {
      background-color: #475569; /* slate-600 */
      color: #ffffff;
      opacity: 0.5;
      cursor: not-allowed;
    }
    #editPanelBody #editPointIndex.is-disabled {
      background-color: #475569; /* slate-600 */
      color: #ffffff;
      opacity: 0.5;
    }
    .nudge-btn:hover { background-color: #374151; /* gray-700 (darker gray) */ }
    .nudge-btn:active {
      background-color: #000000; /* black */
      transform: translateY(2px);
    }

    /* Global press effect for all buttons */
    button {
      transition: transform 0.05s ease;
    }
    button:active {
      transform: translateY(2px);
    }

    /* Ultra-Compact Channel Styles */
    .channel-row {
      transition: all 0.2s ease-in-out;
    }
    
    /* Hide disabled channels from table flow */
    .channel-row[data-compact="true"] {
      display: none;
    }

    /* Disabled state styling for Generate button */
    #generateFromLstar:disabled {
      background-color: #9ca3af; /* gray-400 */
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    /* Compact chip container */
    .disabled-channels-compact {
      background-color: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 8px 12px;
      margin: 8px 0;
      display: none; /* Hidden by default */
    }
    
    .disabled-channels-compact.show {
      display: block;
    }
    
    .disabled-channels-compact .compact-label {
      font-size: 11px;
      font-weight: 600;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 6px;
      display: block;
    }
    
    .disabled-channels-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    
    /* Individual disabled channel chips */
    .disabled-channel-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background-color: #ffffff;
      border-radius: 6px;
      padding: 3px 8px;
      font-size: 12px;
      color: #374151;
      cursor: pointer;
      transition: all 0.15s ease-in-out;
      user-select: none;
    }
    
    .disabled-channel-chip:hover {
      background-color: #f3f4f6;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .disabled-channel-chip.active {
      background-color: #dbeafe;
      color: #1d4ed8;
    }
    
    .disabled-channel-chip .channel-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
      display: inline-block;
    }
    
    .disabled-channel-chip .channel-checkbox {
      width: 12px;
      height: 12px;
      margin: 0;
      cursor: pointer;
      accent-color: #ffffff;
    }
    
    .disabled-channel-chip .channel-name {
      font-weight: 600;
      min-width: 20px;
      color: #374151;
      font-size: 12px;
    }

    /* Compact label styling */
    .disabled-channels-compact .compact-label::after {
      content: ':';
      margin-left: 2px;
    }

    /* Smooth transitions for showing/hiding */
    .disabled-channels-compact {
      transition: all 0.3s ease-in-out;
      transform-origin: top;
    }

    .disabled-channels-compact:not(.show) {
      max-height: 0;
      opacity: 0;
      margin: 0;
      padding: 0;
      border: none;
      overflow: hidden;
    }

    /* Make assistant links in chat clearly clickable */
    #chatHistory a {
      color: #93c5fd;           /* light blue for dark bg */
      text-decoration: underline;
      font-weight: 600;
    }
    #chatHistory a:hover {
      color: #bfdbfe;           /* lighter on hover */
      text-decoration: underline;
    }
    #chatHistory a[target="_blank"]::after {
      content: ' ↗';
      font-weight: 600;
      color: #9ca3af;           /* subtle arrow on dark bg */
    }
  </style>
</head>
<body class="min-h-screen bg-gray-50 px-2 md:px-4 py-3">
  <main class="mx-auto max-w-6xl">
    <section class="bg-white rounded-2xl shadow-lg px-4 md:px-6 py-5 md:py-6">
      <header class="mb-6">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 items-center mb-2">
          <div class="flex items-center gap-4 lg:col-span-3">
            <svg id="quadgenLogo" xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 160 160" role="img" aria-labelledby="quadgenTitle quadgenDesc">
              <title id="quadgenTitle">quadGEN icon (CMYK)</title>
              <desc id="quadgenDesc">Four CMYK bars with a rising Bezier-style curve and nodes, flat design.</desc>
              <!-- baseline -->
              <path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round"/>
              <!-- CMYK bars -->
              <rect id="cyanBar" x="20" y="90" width="20" height="40" rx="6" ry="6" fill="#00B5E2"/>
              <rect id="magentaBar" x="52" y="70" width="20" height="60" rx="6" ry="6" fill="#FF2A8A"/>
              <rect id="yellowBar" x="84" y="50" width="20" height="80" rx="6" ry="6" fill="#FFD400"/>
              <rect id="blackBar" x="116" y="22" width="20" height="110" rx="6" ry="6" fill="#1A1A1A"/>
              <!-- Bezier-like curve -->
              <path id="logoPath" d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18"
                    fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
              <!-- curve nodes -->
              <circle id="node1" cx="30" cy="88" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node2" cx="62" cy="68" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node3" cx="94" cy="48" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node4" cx="126" cy="18" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
            </svg>
            <div>
              <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">
                quadGEN
                <span id="appVersion" class="text-gray-400 text-lg"></span>
              </h1>
              <p class="text-gray-400 text-sm -mt-1">by <a href="https://www.davidmarshprints.com/" target="_blank" rel="noopener noreferrer" class="hover:text-gray-600 underline">David Marsh</a></p>
            </div>
            
            <!-- Compact printer selector -->
            <div class="flex items-center gap-2 bg-gray-50 rounded-lg border border-gray-200 px-3 py-2 flex-1 ml-4">
              <label for="printerSelect" class="text-sm font-medium text-gray-700">Printer:</label>
              <select id="printerSelect" class="standard-dropdown" style="width: 120px;">
                <option value="P700P900" selected>P700-P900</option>
                <option value="P5-7-9000">P5-7-9000</option>
                <option value="P800">P600-P800</option>
                <option value="P400">P400</option>
                <option value="x900">x900</option>
                <option value="3880-7880">3880-7880</option>
                <option value="x800-x890">x800-x890</option>
                <option value="P4-6-8000">P4-6-8000</option>
              </select>
              <p id="channelInfo" class="flex-1 text-xs text-gray-600 ml-1"></p>
              <button id="helpBtn" class="text-xs text-gray-400 hover:text-gray-600 bg-gray-100 hover:bg-gray-200 rounded px-2 py-1 transition-colors ml-auto font-bold" title="Help and quick start">
                Help
              </button>
              <button id="infoBtn" class="text-xs text-gray-400 hover:text-gray-600 bg-gray-100 hover:bg-gray-200 rounded px-2 py-1 transition-colors ml-2 font-bold" title="Version info">
                About
              </button>
            </div>
          </div>
          
        </div>
        <p id="printerDescription" class="text-gray-600 mt-1"></p>
      </header>

      <!-- Main Actions -->
      <div class="mb-4">
        <div class="flex items-center gap-2 bg-white border border-gray-200 rounded-xl p-4">
          <input type="file" id="quadFile" accept=".quad" class="hidden">
          <button id="undoBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-700 rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed" disabled title="No changes to undo">
            ↺ Undo
          </button>
          <button id="redoBtn" class="px-4 py-2 text-sm bg-slate-600 text-white hover:bg-slate-700 rounded transition-colors font-bold disabled:opacity-50 disabled:cursor-not-allowed" disabled title="No changes to redo">
            ↻ Redo
          </button>
          <button id="loadQuadBtn" class="px-4 py-2 text-sm bg-blue-600 hover:bg-blue-700 text-white rounded transition-colors font-bold">
            → Load .quad
          </button>
          <button id="downloadBtn" class="px-4 py-2 text-sm bg-black text-white hover:bg-black/90 rounded transition-colors font-bold">
            ↓ Download .quad
          </button>
          <input id="filenameInput" type="text" placeholder="P900_K33_C33_M33..." class="flex-1 ml-3 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
          <span class="text-sm text-gray-500">.quad</span>
        </div>
      </div>

      <!-- Ink Limits Graph and Linearization -->
      <div class="mb-4 grid grid-cols-1 lg:grid-cols-3 gap-4">
        <!-- Graph Section -->
        <div class="lg:col-span-2 space-y-4">
          <div class="bg-white border border-gray-200 rounded-xl p-2 relative">
            <div class="bg-gray-50 rounded-lg p-2">
              <canvas id="inkChart" width="950" height="700" class="w-full h-auto max-h-none"></canvas>
              
              <!-- Smoothing Note at bottom of canvas (with reserved space) -->
              <div class="text-xs text-center h-[12px] flex items-center justify-center">
                <span id="smoothingWarning" class="text-amber-800 opacity-0 invisible">
                  ℹ️ Note: Smoothing allows departure of curves from loaded data
                </span>
              </div>
            </div>
            <!-- Cursor tooltip for X,Y coordinates over the graph -->
            <div id="chartCursorTooltip" class="hidden absolute z-20 px-1.5 py-0.5 text-xs rounded bg-black text-white pointer-events-none shadow-md"></div>
            
            <!-- Status Display -->
            <div class="absolute top-4 left-4 right-4 z-10">
              <div class="bg-gray-50 rounded-lg px-3 py-2 text-center flex items-center justify-center">
                <span id="status" class="text-xs text-gray-600 font-medium transition-opacity duration-500 ease-in-out">&nbsp;</span>
              </div>
            </div>
            
            <!-- Interpolation Controls (moved inside graph container) -->
            <div class="mt-3">
              <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                <!-- Left Column: Interpolation Method -->
                <div class="space-y-2">
                  <div style="display: none;">
                    <h3 class="text-xs font-medium text-gray-700 mb-1">Interpolation Method</h3>
                    <select id="curveSmoothingMethod" class="standard-dropdown" disabled>
                      <option value="pchip" selected>PCHIP (monotonic)</option>
                      <option value="linear">Linear (none)</option>
                    </select>
                    <p id="interpolationDescription" class="text-xs text-gray-500 mt-2">Monotonic interpolation preserves data trends</p>
                  </div>
                  
                  <!-- Catmull-Rom Tension Control -->
                  <div id="catmullTensionContainer" style="display: none;">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Curve Tension</label>
                    <div class="flex items-center gap-2">
                      <span class="text-xs text-gray-500">Tight</span>
                      <input type="range" id="catmullTension" min="0" max="100" value="50" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" disabled>
                      <span class="text-xs text-gray-500">Loose</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Adjust how curvy the interpolation becomes</p>
                  </div>

                  
                </div>
                
                <!-- Right Column: Data Point Smoothing -->
                <div class="space-y-2">
                  <!-- (Removed) Smoothing Method dropdown -->
                  
                  <!-- Smoothing Slider (inline label) -->
                  <div class="flex items-center gap-2 mt-2 hidden">
                    <span class="text-xs text-gray-700 whitespace-nowrap">Smoothing: <span id="smoothingValue" class="text-xs text-gray-700">0%</span></span>
                    <input type="range" id="smoothingSlider" min="0" max="90" value="0" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" disabled>
                    <span class="text-xs text-gray-500">90%</span>
                  </div>

                  <!-- (Removed) Key-Point Simplifier Controls under graph -->
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Linearization Section -->
        <div class="lg:col-span-1 space-y-4">
          <!-- Global Linearization -->
          <div class="bg-white border border-gray-200 rounded-xl p-3">
            <div class="flex items-center justify-between mb-2">
              <div class="flex items-center gap-2">
                <h3 class="text-sm font-bold">🌐 Global Correction</h3>
                <label class="slider-toggle" title="Enable/disable global correction">
                  <input type="checkbox" id="globalLinearizationToggle" disabled>
                  <span class="slider"></span>
                </label>
              </div>
              <button id="globalCorrectionHelpBtn" class="text-xs text-gray-400 hover:text-gray-600 bg-gray-100 hover:bg-gray-200 rounded px-2 py-1 transition-colors font-bold" title="Global Correction Help" aria-label="Global Correction Help">?</button>
            </div>
            <p class="text-xs text-gray-600 mb-2">Apply a correction to modify all channels uniformly.</p>
            <div class="flex items-center gap-2 mb-1">
              <button id="globalLinearizationBtn" class="px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold" data-tooltip="Load LUT.cube, LABdata.txt, or .acv curve files">Load Data File</button>
              <input type="file" id="linearizationFile" accept=".cube,.txt,.acv" class="hidden">
              <button id="manualLstarBtn" class="px-3 py-2 text-xs bg-slate-600 hover:bg-slate-700 text-white rounded transition-colors font-bold">
                ✏️ Enter L* Values Manually
              </button>
            </div>
            <p id="globalLinearizationHint" class="text-xs text-gray-500 mb-1">LUT (.cube), LAB data (.txt), or curves (.acv)</p>
            
            <!-- Linearization Controls -->
          <div class="space-y-3">
              <!-- File Upload -->
              <div>
                <div id="globalLinearizationInfo" class="text-xs text-gray-600 mb-2 hidden">
                  <span id="globalLinearizationFilename" class="font-medium"></span>
                  <span id="globalLinearizationDetails" class="text-gray-500"></span>
                  <span id="deltaSummary" class="ml-2 inline-block align-middle hidden"></span>
                  <span class="ml-3 inline-flex items-center gap-1 align-middle hidden">
                    <label for="perChannelDeltaSelect" class="text-gray-600">Channel change:</label>
                    <select id="perChannelDeltaSelect" class="text-xs border border-gray-300 rounded px-1 py-0.5"></select>
                    <span id="perChannelDeltaSummary" class="ml-1"></span>
                  </span>
                  
                </div>
                <!-- Buttons moved above; keep info here only -->
              </div>
            </div>
            
            

            <!-- Sample Data moved to About window -->
          </div>

          <!-- Edit Curves Panel -->
          <div class="bg-white border border-gray-200 rounded-xl p-3">
            <div class="flex items-center justify-between mb-2">
              <button id="editModeToggleBtn" type="button" class="inline-flex text-sm font-bold px-3 py-2 rounded cursor-pointer relative z-10 text-white bg-slate-600 hover:bg-slate-700 border-0" aria-pressed="false" role="switch" aria-checked="false" title="Toggle edit mode">
                <span id="editModeLabel">⟐ Edit Mode: OFF</span>
              </button>
              <button id="editModeHelpBtn" class="text-xs text-gray-400 hover:text-gray-600 bg-gray-100 hover:bg-gray-200 rounded px-2 py-1 transition-colors font-bold" title="Edit Mode Help" aria-label="Edit Mode Help">?</button>
            </div>
            <div id="editPanelBody">

            <!-- Row: smoothing only (key points visibility follows Edit Mode) -->
            <div class="flex items-center gap-4 mb-3">
              <div class="flex items-center gap-2 flex-1">
                <span class="text-sm text-gray-700 whitespace-nowrap">Smoothing - <span id="editSmoothingValue">0%</span></span>
                <input type="range" id="editSmoothingSlider" min="0" max="90" value="0" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              </div>
            </div>

            <!-- Calculate points -->
            <div class="border border-gray-200 rounded-lg p-3 mb-3 relative">
              <div class="flex items-center justify-between mb-2">
                <span class="absolute top-0 left-2 -translate-y-1/2 bg-white px-2 text-xs text-gray-700 z-10">Calculate points</span>
                <button id="editRecomputeBtn" class="px-3 py-1.5 text-xs bg-green-600 hover:bg-green-700 text-white rounded transition-colors font-bold">↻ Recompute</button>
              </div>
              <div class="flex items-center gap-4">
                <label class="text-xs text-gray-700">Max error %
                  <input type="number" id="editMaxError" class="w-20 ml-1 px-2 py-1 text-xs border border-gray-300 rounded" min="0.05" max="5" step="0.05" value="0.25">
                </label>
                <label class="text-xs text-gray-700">Max points
                  <input type="number" id="editMaxPoints" class="w-16 ml-1 px-2 py-1 text-xs border border-gray-300 rounded" min="2" max="21" step="1" value="16">
                </label>
              </div>
            </div>

            <!-- Channel selection -->
            <div class="border border-gray-200 rounded-lg p-3 mb-3 relative">
              <span class="absolute top-0 left-2 -translate-y-1/2 bg-white px-2 text-xs text-gray-700 z-10">Channel</span>
              <div class="grid grid-cols-3 items-center">
                <label for="editChannelSelect" class="text-sm text-gray-700 justify-self-start invisible">Channel:</label>
                <div class="justify-self-center flex items-center gap-2">
                  <button id="editChannelPrev" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Previous channel" aria-label="Previous channel">◀</button>
                  <select id="editChannelSelect" class="standard-dropdown text-center" style="width:56px; padding-left:0.25rem; padding-right:0.25rem;"></select>
                  <button id="editChannelNext" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Next channel" aria-label="Next channel">▶</button>
                </div>
                <div></div>
              </div>
              <div class="mt-1 text-center"><span id="editChannelState" class="text-xs text-gray-500"></span></div>
            </div>

          <!-- Selected point tools -->
          <div class="border border-gray-200 rounded-lg p-3 relative">
              <span class="absolute top-0 left-2 -translate-y-1/2 bg-white px-2 text-xs text-gray-700 z-10">Selected point</span>
              <div class="flex items-center justify-between mb-2">
                <div class="flex items-center gap-3">
                  <div class="inline-flex items-center gap-2">
                    <button id="editPointLeft" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Previous point">◀</button>
                    <span id="editPointIndex" class="text-sm font-bold text-white bg-black min-w-[1.5rem] text-center px-2 py-0.5 rounded is-disabled">–</span>
                    <button id="editPointRight" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-700 rounded font-bold" title="Next point">▶</button>
                  </div>
                </div>
                <button id="editDeleteBtn" class="px-2 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded font-bold" title="Delete selected point">✖ Delete</button>
              </div>
              <div class="flex items-center justify-center gap-2">
                <button id="editNudgeYUp" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge Y up">△</button>
              </div>
              <div class="flex items-center justify-center gap-2 mt-1">
                <button id="editNudgeXNeg" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge X left">◁</button>
                <input id="editXYInput" class="w-24 text-center px-2 py-1 text-xs border border-gray-300 rounded" placeholder="X,Y" title="Edit point as 'X,Y' percent">
                <button id="editNudgeXPos" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge X right">▷</button>
              </div>
              <div class="flex items-center justify-center gap-2 mt-1">
                <button id="editNudgeYDown" class="px-2 py-1 text-xs rounded font-bold nudge-btn" title="Nudge Y down">▽</button>
              </div>
            <div id="editDisabledHint" class="text-xs text-gray-500 text-center mt-2 hidden">Channel is disabled (End=0). Enable in Channels to edit.</div>
          </div>
          <!-- Inline help moved to Edit Mode Help popup -->
            </div>
          </div>
      </div>
      </div>


      <!-- Quick Enable Chips -->
      <div id="disabledChannelsCompact" class="disabled-channels-compact mb-3">
        <div id="disabledChannelsRow" class="disabled-channels-row">
          <!-- Channel chips will be inserted here -->
        </div>
      </div>

      <!-- Channel table -->
      <div class="overflow-auto">
        <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden">
          <thead>
            <tr class="bg-gray-50 text-gray-700 text-xs">
              <th class="text-center px-1 py-2"></th>
              <th class="text-left px-1 py-2">Channel</th>
              <th class="text-left px-1 py-2" style="width: 140px;">Curve</th>
              <th class="text-left px-1 py-2">Percent (0–100)</th>
              <th class="text-left px-1 py-2">End (0–64,000)</th>
            </tr>
          </thead>
          <tbody id="rows">
          </tbody>
        </table>
      </div>

      <!-- Lab Tech (console-style, matches .quad File Preview framing) -->
      <div class="mt-3">
        <div class="border border-gray-200 rounded-xl overflow-hidden">
          <div class="bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700 flex items-center justify-between">
            <span><span id="labTechIcon" class="mr-1">💬</span>Lab Tech</span>
            <div class="flex items-center gap-3">
              <label class="flex items-center gap-1 text-xs text-gray-700 hidden" title="Show assistant status messages in chat">
                <input type="checkbox" id="aiShowStatusToggle" class="rounded border-gray-300" checked>
                <span>Show assistant status</span>
              </label>
              <button id="clearChatBtn" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 rounded px-2 py-0.5 font-bold focus:outline-none focus:ring-0">Clear</button>
            </div>
          </div>
          <div class="bg-black text-white font-mono p-2">
            <!-- Chat History -->
            <div id="chatHistory" class="overflow-y-auto text-xs leading-4 mb-2" style="height:224px;">
              <div class="text-gray-300 px-2 py-1 border border-gray-800 rounded mb-2">
                <strong class="text-gray-200">Try this:</strong> "Reduce all ink limits by 20%"<br>
                <strong class="text-gray-200">or:</strong> "generate a curve with points 0,0 25,20 75,85 100,100"<br>
                <strong class="text-gray-200">or:</strong> "apply a midtone lift"<br>
                <strong class="text-gray-200">or:</strong> "delete the point near 25%"<br>
                <strong class="text-gray-2 00">or:</strong> "delete point 2"
              </div>
            </div>
            <!-- Resizer for Lab Tech console -->
            <div id="labTechResizer" class="h-4 bg-gray-800/40 hover:bg-gray-700/60 cursor-row-resize mb-2 rounded relative" role="separator" aria-orientation="horizontal" title="Drag to resize">
              <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                <span class="inline-block w-10 h-[2px] bg-gray-400/80 rounded"></span>
                <span class="inline-block w-10 h-[2px] bg-gray-400/80 rounded ml-1"></span>
              </div>
            </div>
            <!-- Bottom input area -->
            <div class="flex items-center gap-2">
              <input type="text" id="aiInputCompact" placeholder="Ask Lab Tech… (Enter to send)" 
                     class="flex-1 min-w-0 rounded border border-gray-700 px-3 py-1 text-xs focus:outline-none focus:ring-2 focus:ring-white/10 focus:border-gray-500 bg-black text-white placeholder-gray-400">
              <button id="sendMessageBtnCompact" class="px-2 py-1 text-xs bg-green-600 hover:bg-green-700 text-white rounded font-bold focus:outline-none focus:ring-0" disabled>Send</button>
            </div>
          </div>
        </div>
      </div>

      

      <!-- Full Preview -->
      <div class="mt-5">
        <div class="border border-gray-200 rounded-xl overflow-hidden">
          <div class="bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700">📝 .quad File Preview</div>
          <!-- Attached notes input styled like preview -->
          <div class="bg-black text-white font-mono p-2 border-t border-gray-800">
            <textarea id="userNotes" placeholder="Notes (saved as # comments in the .quad file)" rows="3"
                      class="w-full bg-black text-white font-mono text-xs p-2 outline-none resize-y border border-gray-700 rounded-sm placeholder-gray-400"></textarea>
          </div>
          <pre id="previewFull" class="p-2 text-xs leading-4 overflow-auto bg-black text-white font-mono" style="max-height:224px;">–</pre>
          <div id="previewResizer" class="h-4 bg-gray-200 hover:bg-gray-300 cursor-row-resize relative" role="separator" aria-orientation="horizontal" title="Drag to resize">
            <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
              <span class="inline-block w-10 h-[2px] bg-gray-400 rounded"></span>
              <span class="inline-block w-10 h-[2px] bg-gray-400 rounded ml-1"></span>
            </div>
          </div>
        </div>
      </div>
    </section>
    
  <!-- Info Popup -->
  <div id="infoPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
      <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
        <button id="closeInfoBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
        
        <h2 id="infoPopupTitle" class="text-xl font-bold mb-4">quadGEN</h2>
        
        <div id="changelogContent" class="text-sm text-gray-700 space-y-4 max-h-[70vh] overflow-y-auto">
          <!-- Changelog will be dynamically populated from main documentation -->
        </div>
      </div>
    </div>
  </main>

  <!-- Manual L* Entry Modal -->
  <div id="lstarModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
    <div class="bg-white rounded-lg max-w-3xl w-full mx-4 max-h-[90vh] flex flex-col">
      <!-- Fixed Header -->
      <div class="p-6 pb-4 flex-shrink-0">
        <div class="flex justify-between items-center mb-2">
          <h3 class="text-lg font-semibold">Manual Luminosity (L*) Entry</h3>
          <button id="closeLstarModal" class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
        </div>
        <div class="hidden text-xs italic text-gray-700 mb-3 p-2 px-3 bg-gray-50 border border-gray-200 rounded">The L* component of the Lab color system represents perceived lightness, ranging from 0 (black) to 100 (white). Equal steps in L* correspond approximately to equal perceptual differences in light–dark appearance.</div>
        
        <div class="hidden mb-4 text-sm text-gray-600">
          <ul class="list-disc list-inside space-y-1">
            <li>Measure and enter L* values for each patch (e.g., using a device like the Color Muse 2).</li>
            <li>If your chart uses even steps (0, 5, 10 … 100%), leave <span class="font-medium">Patch %</span> as‑is.</li>
            <li>Edit <span class="font-medium">Patch %</span> for irregular spacing (more steps in the highlights / shadows).</li>
            <li>Target result is linear (L* 100 → 0) and linked to Patch %.</li>
            <li>Inspired by & compatible with data from the <a href="https://clayharmonblog.com/wedgie.html" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">Wedgie tool</a> by Clay Harmon.</li>
            <li>A good resource for target images is <a href="https://clayharmonblog.com/downloads" target="_blank" rel="noopener noreferrer" class="text-green-700 underline">clayharmonblog.com/downloads</a>.</li>
          </ul>
          
        </div>

        <div class="hidden flex items-center justify-center gap-6 mb-4 p-3 bg-gray-50 rounded border">
          <div class="flex gap-2">
            <button id="addLstarInputHeader" class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded font-bold">+ Add</button>
            <button id="removeLstarInputHeader" class="px-3 py-1 text-sm bg-red-100 hover:bg-red-200 text-red-700 rounded font-bold">- Remove</button>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600">Patches:</label>
            <input type="number" id="lstarCountInputHeader" min="5" max="50" value="5" class="w-16 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500">
          </div>
        </div>
      </div>

      <!-- Scrollable Content -->
      <div class="flex-1 overflow-y-auto overflow-x-auto px-6">
        <div class="text-xs italic text-gray-700 mb-3 p-2 px-3 bg-gray-50 border border-gray-200 rounded">The L* component of the Lab color system represents perceived lightness, ranging from 0 (black) to 100 (white). Equal steps in L* correspond approximately to equal perceptual differences in light–dark appearance.</div>

        <div class="mb-4 text-sm text-gray-600">
          <ul class="list-disc list-inside space-y-1">
            <li>Measure and enter L* values for each patch (e.g., using a device like the Color Muse 2).</li>
            <li>If your chart uses even steps (0, 5, 10 … 100%), leave <span class=\"font-medium\">Patch %</span> as‑is.</li>
            <li>Edit <span class=\"font-medium\">Patch %</span> for irregular spacing (more steps in the highlights / shadows).</li>
            <li>Target result is linear (L* 100 → 0) and linked to Patch %.</li>
            <li>Inspired by & compatible with data from the <a href=\"https://clayharmonblog.com/wedgie.html\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"text-green-700 underline\">Wedgie tool</a> by Clay Harmon.</li>
            <li>A good resource for target images is <a href=\"https://clayharmonblog.com/downloads\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"text-green-700 underline\">clayharmonblog.com/downloads</a>.</li>
          </ul>
        </div>

        <div class="flex items-center justify-center gap-6 mb-4 p-3 bg-gray-50 rounded border">
          <div class="flex gap-2">
            <button id="addLstarInput" class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded font-bold">+ Add</button>
            <button id="removeLstarInput" class="px-3 py-1 text-sm bg-red-100 hover:bg-red-200 text-red-700 rounded font-bold">- Remove</button>
          </div>
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600">Patches:</label>
            <input type="number" id="lstarCountInput" min="5" max="50" value="5" class="w-16 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500">
          </div>
        </div>
        <table class="w-auto mx-auto text-sm border border-gray-200 rounded overflow-hidden">
          <thead class="bg-gray-50 sticky top-0 z-10">
            <tr>
              <th class="px-2 py-2 w-8 text-center">#</th>
              <th class="px-2 py-2 w-24 text-center">Patch %</th>
              <th class="px-2 py-2 w-24 text-center">Target / Measured</th>
              <th class="px-2 py-2 w-24 text-center">L* (0–100)</th>
            </tr>
          </thead>
          <tbody id="lstarInputs" class="align-middle">
            <!-- Dynamic rows will be added here -->
          </tbody>
        </table>
        <div id="lstarValidation" class="text-sm text-red-600 mt-3 hidden"></div>
      </div>

      <!-- Fixed Footer -->
      <div class="p-6 pt-4 flex-shrink-0 border-t border-gray-200">
        <div class="flex justify-end gap-3">
          <button id="saveLstarTxt" class="px-4 py-2 bg-slate-600 hover:bg-slate-700 text-white rounded" title="Download entered Patch % and L* as a .txt file">Save as .txt</button>
          <button id="cancelLstar" class="px-4 py-2 text-gray-600 hover:text-gray-800 bg-gray-100 hover:bg-gray-200 rounded font-bold">Cancel</button>
          <button id="generateFromLstar" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded">Generate Correction</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Popup -->
  <div id="helpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
      <button id="closeHelpBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" aria-label="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
      <h2 class="text-xl font-bold mb-4">Help</h2>
      <div id="helpContent" class="text-sm text-gray-700 space-y-4 max-h-[70vh] overflow-y-auto"></div>
    </div>
  </div>

  <!-- Global Correction Help Popup -->
  <div id="globalCorrectionHelpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
      <button id="closeGlobalCorrectionHelpBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" aria-label="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
      <h2 class="text-xl font-bold mb-4">Global Correction Help</h2>
      <div class="text-sm text-gray-700 space-y-6 max-h-[70vh] overflow-y-auto">
        <div>
          <p class="font-medium text-lg mb-2">Overview</p>
          <p class="text-sm text-gray-600">Global corrections can be applied in two ways: directly via a curve/LUT file, or by computing a linearization from L* measurements. Both approaches update all channels uniformly.</p>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Working Assumptions</p>
          <ul class="list-disc list-inside text-sm text-gray-600">
            <li>Positive space: X=0% is white → X=100% is black; Y=0% = no ink (white), Y=100% = max ink (black).</li>
            <li>Endpoints anchored: Keep 0→0 and 100→100 fixed unless you have a specific reason to change them.</li>
            <li>Monotonic, smooth curves: Avoid kinks or flat spots, especially near endpoints.</li>
            <li>Digital negatives: Work in positive space; invert your image in the editor when making a digital negative.</li>
          </ul>
        </div>
        <div>
          <p class="text-xs text-gray-700 font-semibold">Applies Directly →</p>
          <ul class="list-disc list-inside text-xs text-gray-600 mb-1">
            <li>Photoshop Curves (.acv): Curve presets.</li>
            <li>LUT (.cube): 1D or 3D LUT.</li>
          </ul>
        </div>
        <div>
          <p class="text-xs text-gray-700 font-semibold">Calculates Linearization ↕</p>
          <ul class="list-disc list-inside text-xs text-gray-600 mb-1">
            <li>LAB Data (.txt): L* measurements.</li>
            <li>Manual L* Entry: L* measurements.</li>
          </ul>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Tonal Zones</p>
          <ul class="list-disc list-inside text-sm text-gray-600">
            <li><span class="font-medium">Highlights</span>: 0–25% (X)</li>
            <li><span class="font-medium">Midtones</span>: 25–75% (X)</li>
            <li><span class="font-medium">Shadows</span>: 75–100% (X)</li>
          </ul>
          <div class="text-xs text-gray-600 mt-2">Examples: Lighten shadows → reduce output in 75–95% and taper to 0 change by 100%. Lighten highlights → reduce output in 5–25% and taper to 0 by 0%.</div>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Workflow Summary</p>
          <ol class="list-decimal list-inside space-y-1 ml-2 text-sm">
            <li>Choose your printer and set ink limits for each channel.</li>
            <li>Export a test .quad and print a 0–100% step wedge.</li>
            <li>Measure the positive result (inkjet print or alt‑process print).</li>
            <li>Load data into quadGEN: LAB (.txt), EDN LUT (.cube/.acv), or Manual L*.</li>
            <li>Review the graph and adjust channel limits if needed.</li>
            <li>Export the corrected .quad and reprint to verify.</li>
          </ol>
          <div class="text-xs text-gray-600 ml-2 mt-2">Tip for digital negatives: work in positive space, then invert your image in your editor before printing the negative.</div>
        </div>
        <div>
          <p class="font-medium text-lg mb-2">Sample Data</p>
          <div class="flex gap-2">
            <div class="flex-1">
              <button id="helpLoadSampleLab" class="w-full px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded transition-colors font-bold">Load LAB-Data-sample.txt</button>
              <a id="helpDownloadSampleLab" href="#" class="block text-center text-xs text-blue-600 hover:text-blue-800 mt-1">↓ Download LAB-Data-sample.txt</a>
            </div>
            <div class="flex-1">
              <button id="helpLoadSampleCube" class="w-full px-2 py-1 text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 rounded transition-colors font-bold">Load Sample LUT.cube</button>
              <a id="helpDownloadSampleCube" href="#" class="block text-center text-xs text-purple-600 hover:text-purple-800 mt-1">↓ Download LUT_sample.cube</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Edit Mode Help Popup -->
  <div id="editModeHelpPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
    <div class="bg-white rounded-xl max-w-3xl w-full max-h-[90vh] p-6 relative">
      <button id="closeEditModeHelpBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors" aria-label="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
      <h2 class="text-xl font-bold mb-4">Edit Mode Help</h2>
      <div class="text-sm text-gray-700 space-y-4 max-h-[70vh] overflow-y-auto">
        <div>
          <p class="font-medium">Overview</p>
          <p class="text-sm text-gray-600">Edit Mode enables point-by-point curve editing on the selected channel. Other enabled channels dim for focus. Turn Edit Mode off to prevent accidental edits.</p>
        </div>
        <div>
          <p class="font-medium">How it works</p>
          <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
            <li>Selected channel draws on top; others dim to 50%.</li>
            <li>Only the selected channel shows key‑point markers and ordinal labels.</li>
            <li>Click the chart to insert a point at the curve under the cursor X.</li>
            <li>Type “X,Y” in the field and press Enter to move the selected point (0–100).</li>
            <li>Use ◀ ▶ to change the selected point; use ↑ ↓ or nudgers to adjust.</li>
            <li>Undo/Redo supports all edit actions.</li>
          </ul>
        </div>
        <div>
          <p class="font-medium">First time use</p>
          <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
            <li>On first enable, Smart key points are prepared from the current curves to avoid “jumping” on first edits.</li>
            <li>ACV sources seed from their anchors; disabled channels remain disabled.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Application version - update in one place
    const APP_VERSION = 'Beta v2.0';
    // Global debug logging toggle for non-AI logs
    var DEBUG_LOGS = false;
    // AI provider selection (code-level switch, no UI): 'anthropic' or 'openai'
    const AI_PROVIDER = 'anthropic';
    const WORKER_URL = 'https://sparkling-shape-8b5a.marshmonkey.workers.dev';
    const ANTHROPIC_MODEL = 'claude-sonnet-4-0';
    // Set OPENAI_MODEL to 'gpt-5' if you have access; 'gpt-4o' is a safe default
    const OPENAI_MODEL = 'gpt-5-mini';
    // Debug flag for AI logs
    const DEBUG_AI = false;
    // Temporary alias during terminology transition (AI → Smart)
    const DEBUG_SMART = DEBUG_AI;
    
    // Centralized version history - update in one place
    const VERSION_HISTORY = {
      'v2.0': {
        date: '2025-09-09',
        title: 'Edit Mode, Smart Curves, Robust History',
        sections: {
          ADDED: [
            'Edit Mode: gates all key‑point edits and overlay visibility; APIs respect mode state',
            'Undo/Redo: full history for insert/adjust/delete/recompute and Edit Mode toggles',
            'Smart Curve: renamed from “AI curve”; writes source tag “smart”, reads legacy “ai”; legacy AI function names remain as aliases',
            'Absolute coordinates: XY input and Up/Down nudges use absolute Y (post‑End); Left/Right adjust X (pre‑scale)',
            'Redo parity: redo restores Smart key points + interpolation and recomputes curves to match overlays',
            'Ink‑limit guard: blocks edits that would exceed End when End cannot be raised, with a clear status message'
          ]
        },
        aboutDialog: [
          { label: 'Edit Mode', desc: 'All key‑point edits require Edit Mode; overlays show only when ON' },
          { label: 'History', desc: 'Undo/Redo covers edits and Edit Mode toggles' },
          { label: 'Smart Curves', desc: '“AI curve” → “Smart Curve”; reads ai/smart, writes smart; APIs keep AI aliases' },
          { label: 'Absolute Y', desc: 'XY input and Up/Down use absolute Y; Left/Right nudges X' },
          { label: 'Redo Parity', desc: 'Redo restores key points + interpolation, then recomputes curves' },
          { label: 'Ink Guard', desc: 'Blocks edits that exceed End when End is effectively locked' }
        ]
      },
      'v1.9.0': {
        date: '2025-09-06',
        title: 'Gaussian LAB, Overlay Alignment, Preserved Smart Shape',
        sections: {
          CHANGED: [
            'LAB processing now uses Gaussian Weighted Correction (density‑independent); smoothing slider widens Gaussian influence radius',
            'LAB → Smart conversion preserves plotted shape using adaptive key‑point fit (defaults: 0.25% max error, 21 max points)',
            'Key‑point overlay and adapter overlays now align exactly with End‑scaled curves (absolute plotting)'
          ],
          FIXED: [
            'Removed localized “bubble” artifacts when applying LAB to dense .quad curves',
            'Pre‑conversion overlay markers now use interpolated Y (no nearest‑index drift)'
          ],
          DOCS: [
            'Added debug helper compareKeyPointsToPlot and updated CLAUDE.md with Gaussian LAB and conversion details'
          ]
        },
        aboutDialog: [
          { label: 'Gaussian LAB', desc: 'Density‑independent LAB correction; smoother results on dense .quad curves' },
          { label: 'Preserved Shape', desc: 'LAB → AI conversion fits points to the plotted curve' },
          { label: 'Overlay Accuracy', desc: 'Markers and labels align with End‑scaled curves' },
          { label: 'Simplifier Defaults', desc: 'Tighter default fit (0.25% / 21 points)' }
        ]
      },
      'v1.8.6': {
        date: '2025-09-05',
        title: 'LAB Wedgie Parity & Manual L* Simplification',
        sections: {
          ADDED: [
            'LAB .txt import now uses wedgie-style inversion to a linear target (parity with Manual L*)',
            'Documentation updated to reflect wedgie inversion for measurement data'
          ],
          CHANGED: [
            'Manual L* modal simplified: removed Target X%/L* and link; Measured-only table',
            'Unified processing: Target X% = Measured X%; Target L* = 100→0'
          ],
          FIXED: [
            'Original measured points overlay and format labels consistent across LAB and Manual L*',
            'Measurement intent marker applies to LAB formats regardless of suffix',
            'ACV overlay: “Show key points” displays original ACV anchor points (global and per‑channel); no 32‑point fallback. ACV/LUT/LAB overlays take precedence over Smart key points.',
            'ACV → Smart editing: When first editing key points with a global ACV loaded, editable Smart points are seeded from the ACV anchors (not a simplified set) to avoid unexpected point shifts.',
            'Overlay preference: When Smart key points exist for a channel, the overlay shows those Smart points; ACV/LUT/LAB overlays appear only when no Smart points are present.',
            'No double processing: Global linearization is not applied to channels that have Smart Curves, preventing unintended changes when editing Smart points.',
            'Exact Smart plotting: “Show key points” draws Smart points directly from stored values (pre‑scale) for precise alignment.'
          ],
          REMOVED: [
            'Gaussian LAB documentation references',
            'Manual L* Target L* inputs and link toggle'
          ]
        },
        aboutDialog: [
          { label: 'Wedgie Parity', desc: 'LAB .txt and Manual L* use the same inversion to a linear target' },
          { label: 'Simplified Manual L*', desc: 'Measured-only entry; target is implicit (linear 100→0)' },
          { label: 'Docs Updated', desc: 'Removed Gaussian references; clarified wedgie mapping' }
        ]
      },
      'v1.8.5': {
        date: '2025-09-04',
        title: 'Smart Key‑Point Deletion',
        sections: {
          ADDED: [
            'Smart key‑point deletion: delete by index or nearest to input % (endpoints blocked by default)'
          ]
        },
        aboutDialog: [
          { label: 'Point Deletion', desc: 'Delete key points by index or nearest input % (safe by default: endpoints blocked)' }
        ]
      },
      'v1.8.4': {
        date: '2025-09-04',
        title: 'Smart Key‑Point Labels and UI Polish',
        sections: {
          ADDED: [
            'Numbered labels above Smart key points with ink‑colored backgrounds and auto black/white text for readability',
            'Lab Tech sample: added “apply a midtone lift” example',
            'Smart key‑point deletion: delete by index or nearest to input % (endpoints blocked by default)'
          ],
          CHANGED: [
            'Graph axis titles now use %: “Input Level %” (X), “Output Ink Level %” (Y)',
            'Key‑point label positioning refined: shifts slightly right near 0% and left near 100% to reduce overlap',
            'Lab Tech sample updated to “generate a curve with points 0,0 25,20 75,85 100,100”'
          ],
          DOCS: [
            'Updated CLAUDE.md and AGENTS.md to reflect numeric key‑point workflow and insert/adjust commands'
          ]
        },
        aboutDialog: [
          { label: 'Key‑Point Labels', desc: 'Smart key points now show numbered labels with ink‑colored backgrounds and readable text' },
          { label: 'Axis Titles', desc: 'Graph uses “Input Level %” (X) and “Output Ink Level %” (Y)' },
          { label: 'Lab Tech Samples', desc: 'Focused natural language controls on curve generation' }
        ]
      },
      'v1.8.3': {
        date: '2025-09-03',
        title: 'Expanded Printer Support, OR/GR Inks, Ordered by Release',
        sections: {
          ADDED: [
            'New printers: P400 (K,C,M,Y,LC,LM), x800-x890 (K,C,M,Y,LC,LM,LK,LLK), x900 (K,C,M,Y,LC,LM,LK,LLK,OR,GR), P4-6-8000 (K,C,M,Y,LC,LM,LK,LLK), P5-7-9000 (K,C,M,Y,LC,LM,LK,LLK,OR,GR)',
            'Ink colors: OR (#FF7F00, Orange) and GR (#00A651, Green) supported in charts and swatches',
            'Smart key‑point overlays: squares + ordinal labels for Smart Curves (<21 points)',
            'Smart key‑point insert commands: insert point at X or between ordinals',
            'Undo/redo now restores Smart key points and interpolation meta along with curves'
          ],
          CHANGED: [
            'Printer dropdown, Lab Tech enums, and validation lists reordered newest→oldest based on Epson release eras',
            'Supported printers list in .quad import error updated to include new models',
            'Smart workflow: natural‑language preset curves deprecated; tool now computes numeric key points and applies them directly',
            'Graph axis titles: display shows “Input Level %” (X) and “Output Ink Level %” (Y)'
          ],
          FIXED: [
            'AI-generated curves now respect ink limit percentage; plots update on relative adjustments (e.g., “reduce by 20%”).'
          ],
          REMOVED: [
            'Legacy 860-1160-VM model removed from UI and internal registry'
          ]
        },
        aboutDialog: [
          { label: 'More Printers', desc: 'Added P400, x800-x890, x900, P4-6-8000, P5-7-9000' },
          { label: 'OR/GR Inks', desc: 'Added support for Orange and Green ink channels' },
          { label: 'Smart Curve Scaling', desc: 'Smart Curves now scale with ink limit changes (e.g., reduce by 20%).' },
          { label: 'Defaults', desc: 'Channels now default to 100%' }
        ]
      },
      'v1.8.2': {
        date: '2025-09-03',
        title: 'Unified Workflow Summary & Positive-only Cleanup',
        sections: {
          CHANGED: [
            'About: Consolidated Recommended + Quick Workflow into a single beginner-friendly Workflow Summary',
            'About: Removed the “(Positive‑Only)” label and the PCHIP requirement bullet to simplify guidance'
          ],
          DOCS: [
            'Clarified Positive-only operation in UI text and helper messages; EDN LUT/.acv use Positive mapping (reverse + invert) by default',
            'Removed user-facing references to toggling intent or mismatch warnings; older release notes retained for history'
          ]
        },
        aboutDialog: [
          { label: 'Workflow Summary', desc: 'Step-by-step beginner overview replaces separate Recommended/Quick sections' },
          { label: 'Simplified Wording', desc: 'Cleaned up language and removed extra qualifiers for clarity' },
          { label: 'Positive-only Operation', desc: 'Tool operates in printer-space with Positive mapping; invert images in your editor for digital negatives' }
        ]
      },
      'v1.8.1': {
        date: '2025-09-03',
        title: 'MIT License + Chart Orientation Aids',
        sections: {
          ADDED: [
            'MIT License for quadgen.html only: header comment added; About dialog blurb notes scope and holder',
            'Chart orientation aids: White→black gradient bars added under X-axis (left→right) and beside Y-axis (bottom→top)'
          ],
          CHANGED: [
            'Axis titles: X now “Input Level Percent”, Y now “Output Ink Level Percent”',
            'Axis label contrast: Force solid black text and adjust spacing to avoid overlap with gradients',
            'EDN mapping fixed to Positive semantics (reverse + invert) with no intent toggle'
          ],
          REMOVED: [
            'Negative Print Intent UI and intent mismatch warning banner; tool now operates in Positive intent only'
          ]
        },
        aboutDialog: [
          { label: 'MIT License (HTML only)', desc: 'Added MIT header in quadgen.html and brief notice in About; scope limited to this HTML file' },
          { label: 'Axis Gradients', desc: 'Added white→black bars under X and along Y for clear white/black orientation' },
          { label: 'Readable Labels', desc: 'Labels forced to black with spacing tweaks for clarity' },
          { label: 'Axis Titles', desc: 'Renamed to “Input Level Percent” (X) and “Output Ink Level Percent” (Y)' },
          { label: 'Positive-only Intent', desc: 'Removed Negative intent; EDN mapping uses Positive semantics by default' }
        ]
      },
      'v1.8': {
        date: '2025-09-02',
        title: 'Print Intent Mapping, ACV/LUT Parity, LAB Traceability',
        sections: {
          ADDED: [
            'Print Intent selector (Positive/Negative) applied to EDN-style corrections; live recompute on toggle',
            'LAB measurement intent traceability: UI shows “measured: Positive/Negative” and .quad comments include it',
            'LAB intent mismatch warning banner when current intent differs from recorded LAB measurement intent'
          ],
          FIXED: [
            'ACV/LUT parity: ACV path now uses same orientation as LUT (horizontal flip + vertical inversion for positive-domain EDN)',
            'Immediate graph update when toggling Print Intent with EDN corrections loaded',
            'LAB endpoints anchored to 0 and 1 to preserve full dynamic range',
            'Natural-language curve parser: Tonal regions flipped to match 0% = white, 100% = black ("shadows" now 75–100%)'
          ],
          REMOVED: [
            'Built-in process presets (cyanotype, palladium, etc.) and process triggers from AI routing',
            'Bookmarks/auto-citation experiment; the assistant no longer auto-injects sources'
          ]
        },
        aboutDialog: [
          { label: 'Print Intent Mapping', desc: 'EDN (.cube/.acv) mapped by intent (Positive: flip+invert; Negative: flip only) with live recompute' },
          { label: 'ACV/LUT Parity', desc: 'ACV orientation normalized to match LUT; midtones now align closely' },
          { label: 'LAB Traceability', desc: 'Recorded “measured: Positive/Negative” and added mismatch warning banner' },
          { label: 'LAB Endpoints Anchored', desc: 'Measurement curves now start at 0% and end at 100% to preserve range' },
          { label: 'Tonal Region Mapping', desc: 'Parser regions flipped; 0% is white and 100% is black. "Lift shadows" now affects 75–100% correctly.' },
          { label: 'Simplified AI Scope', desc: 'Removed process presets; assistant provides guidance to load EDN/LAB instead' }
        ]
      },
      'v1.7': {
        date: '2025-09-02',
        title: 'Wedgie Inversion & LAB Data Artifacts Fix',
        sections: {
          FIXED: [
            'LAB data curve artifacts: Replaced complex coordinate transformation with wedgie-style inversion to a linear target',
            'Dense-on-dense data processing: Eliminated curve spikes when applying LAB corrections to loaded .quad files and AI-generated curves',
            'Undo system gaps: Added proper state capture for all LAB data loading methods (sample data, file upload, pasted data)',
            'Algorithm mismatch: Sparse measurement data (21 points) now properly applied to dense curve data (256 points)'
          ],
          ENHANCED: [
            'LAB processing algorithm: Wedgie-style inversion to linear target; optional smoothing available separately',
            'Processing reliability: Eliminated need for ad-hoc smoothing by fixing the mapping at the source',
            'Mathematical accuracy: Replaced experimental coordinate transformation with direct inversion to target'
          ],
          REMOVED: [
            'RBF experimental method: Removed Radial Basis Functions option after confirming no advantage over the simplified inversion',
            'UI switching controls: Cleaned up method selection dropdown and event listeners for simplified interface'
          ]
        },
        aboutDialog: [
          { label: 'LAB Data Artifact Fix', desc: 'Eliminated curve spikes when applying measurement data to loaded .quad files using wedgie-style inversion' },
          { label: 'Unified Inversion', desc: 'Manual L* and LAB .txt now use the same inversion to a linear target' },
          { label: 'Dense Data Processing', desc: 'Proper handling of sparse corrections (21 points) applied to dense curves (256 points)' },
          { label: 'Undo System Completion', desc: 'Added state capture for all LAB data loading methods ensuring proper undo functionality' },
          { label: 'Algorithm Simplification', desc: 'Removed RBF experimental option after simplification to wedgie-style inversion' }
        ]
      },
      'v1.6': {
        date: '2025-08-31',
        title: 'Lab Tech Assistant & Processing Visibility',
        sections: {
          ADDED: [
            'Lab Tech AI assistant with 25 specialized functions for natural language control',
            'Processing detail panels showing Base Curves → Per-Channel → Global pipeline per channel',
            'Professional communication style with markdown formatting support',
            'Quick reference documentation with function locations'
          ],
          ENHANCED: [
            'AI curve generation with natural language descriptions ("palladium curve", "S-curve")',
            'Undo system integration for AI-generated curves',
            'Visual state restoration for disabled channels'
          ],
          FIXED: [
            'Disabled channel transparency when Lab Tech adds curves',
            'Processing panel updates now immediate (no manual refresh needed)',
            'Channel iteration bug causing incorrect references',
            'AI curve undo functionality integration'
          ]
        },
        aboutDialog: [
          { label: 'Lab Tech Assistant', desc: 'AI assistant with 25 specialized functions for natural language control of QuadGEN' },
          { label: 'Processing Visibility', desc: 'Expandable panels show Base Curves → Per-Channel → Global pipeline for each channel' },
          { label: 'Professional Communication', desc: 'Concise responses with markdown formatting and structured information' },
          { label: 'AI Curve Integration', desc: 'Natural language curve generation with full undo system integration' },
          { label: 'Visual Improvements', desc: 'Enhanced state restoration and immediate processing panel updates' }
        ]
      },
      'v1.5': {
        date: '2025-08-29',
        title: 'Adobe Photoshop .acv Curve File Support',
        sections: {
          ADDED: [
            'Adobe Photoshop .acv file format support: Complete binary format parser for curve presets',
            'Cubic spline interpolation: Smooth curve generation matching Photoshop\'s behavior between control points',
            'ACV format detection: Automatic binary vs text file handling in parseLinearizationFile()',
            'RGB composite curve extraction: Uses first curve from multi-curve .acv files for linearization',
            'Binary data parsing: DataView-based parser supporting Adobe\'s int16 big-endian format specification',
            'File input support: .acv files accepted in both global and per-channel linearization inputs',
            'UI integration: Updated tooltips and file format descriptions to include .acv curve file support'
          ],
          IMPROVED: [
            'File format documentation: Comprehensive .acv technical specifications in internal documentation',
            'Linearization workflow: Seamless integration with existing .cube and .txt file processing pipeline'
          ]
        },
        aboutDialog: [
          { label: 'ACV File Format', desc: 'Complete binary format parser for Adobe Photoshop curve presets' },
          { label: 'Cubic Spline Interpolation', desc: 'Smooth curve generation matching Photoshop\'s behavior between control points' },
          { label: 'RGB Composite Curves', desc: 'Automatic extraction of first curve from multi-curve .acv files' },
          { label: 'Binary Data Handling', desc: 'DataView-based parser supporting Adobe\'s int16 big-endian format specification' },
          { label: 'Seamless Integration', desc: '.acv files work in both global and per-channel linearization workflows' },
          { label: 'UI Updates', desc: 'Updated tooltips and file format descriptions for .acv curve file support' }
        ]
      },
      'v1.4.1': {
        date: '2025-08-29',
        title: 'Smoothing Algorithm Refinements & .quad File Improvements',
        sections: {
          ADDED: [
            'Smoothing Splines algorithm: Mathematical curve smoothing with automatic lambda parameter selection',
            'Visual curve comparison: Original curve overlay (gray dashed line) shows smoothing effects on all channels',
            'Simplified curve algorithms: Focused on Uniform Sampling and Smoothing Splines',
            'Accurate .quad file maximum detection: Uses actual curve maximum instead of endpoint value'
          ],
          REFINED: [
            'Streamlined algorithm selection: Focused on reliable smoothing methods',
            'Simplified interpolation options: Hidden Cubic Spline and Catmull-Rom from UI to reduce complexity',
            'Default algorithm changed: Uniform Sampling now default with Smoothing Splines as advanced option',
            'UI cleanup: Removed monotonicity preservation option (PCHIP handles this appropriately)'
          ],
          IMPROVED: [
            'Curve visualization: Original vs smoothed comparison works with multiple channels simultaneously',
            'Algorithm focus: Concentrated on reliable, predictable smoothing methods for production use',
            '.quad file scaling: Proper scaling based on actual maximum value for non-monotonic curves'
          ]
        },
        aboutDialog: [
          { label: 'Smoothing Splines', desc: 'Added mathematical smoothing algorithm with automatic parameter selection' },
          { label: 'Visual Curve Comparison', desc: 'Original curve overlay shows before/after smoothing effects on all channels' },
          { label: 'Accurate .quad File Handling', desc: 'Proper detection and scaling of ink limits based on actual curve maximum' },
          { label: 'Non-Monotonic Curve Support', desc: 'Correctly handles curves where peak ink density occurs before 100% input' },
          { label: 'Streamlined Algorithm Selection', desc: 'Focused on Uniform Sampling and Smoothing Splines for reliable results' },
          { label: 'Improved Interpolation Defaults', desc: 'PCHIP monotonic interpolation as primary method with Linear fallback' }
        ]
      }
    };
    
    // Functions to generate version history content
    // Removed unused generateInternalVersionHistory()
    
    function generateAboutDialogVersionHistory() {
      let content = '';
      for (const [version, data] of Object.entries(VERSION_HISTORY)) {
        const displayVersion = `Beta ${version}`;
        content += `
          <div class="mb-3">
            <p class="font-bold">${displayVersion}</p>
            <ul class="list-none ml-2 mt-1 text-sm leading-tight">`;
        
        for (const item of data.aboutDialog) {
          content += `
              <li>- ${item.desc}</li>`;
        }
        
        content += `
            </ul>
          </div>`;
      }
      return content;
    }
    
    const TOTAL = 64000;
    const N = 256;
    const DENOM = N - 1;

    /**
     * QuadGenActions - Centralized system for programmatic control of quadGEN
     * Provides methods for Lab Tech assistant to execute user actions
     */
    class QuadGenActions {
      constructor() {
        this.lastAction = null;
        this.lastActionTime = null;
      }

      /**
       * Resolve channel: if not provided, choose the first enabled channel
       * Enabled = percentage > 0 OR endValue > 0 OR enabled = true
       */
      _resolveChannel(preferredChannel = null) {
        const currentPrinter = getCurrentPrinter();
        if (preferredChannel && currentPrinter.channels.includes(preferredChannel)) {
          return preferredChannel;
        }
        const state = this.getCurrentState();
        if (!state.success) return currentPrinter.channels[0];
        const entries = Object.entries(state.data.channels || {});
        const firstEnabled = entries.find(([name, ch]) => ch && (ch.enabled || (ch.percentage || 0) > 0 || (ch.endValue || 0) > 0));
        if (firstEnabled) return firstEnabled[0];
        // Fallback: first printer channel
        return currentPrinter.channels[0];
      }

      /**
       * Set individual channel ink limit value
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {number} percentage - Ink limit percentage (0-100)
       * @returns {Object} Result with success status and message
       */
      setChannelValue(channelName, percentage) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (DEBUG_LOGS) console.log('🖨️ Current printer:', currentPrinter.name);
          if (DEBUG_LOGS) console.log('🎯 Requested channel:', channelName);
          
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Validate percentage
          const validatedPercentage = InputValidator.clampPercent(percentage);
          if (validatedPercentage !== percentage) {
            return {
              success: false,
              message: `Invalid percentage '${percentage}'. Must be between 0 and 100.`
            };
          }

          // Update the channel value
          const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
          if (!channelRow) {
            // List all channel rows for debugging
            const allRows = Array.from(document.querySelectorAll('tr[data-channel]'));
            
            return {
              success: false,
              message: `Channel row for '${channelName}' not found. Available channels: ${allRows.map(row => row.dataset.channel).join(', ')}`
            };
          }

          const channelElement = channelRow.querySelector('.percent-input');
          if (!channelElement) {
            return {
              success: false,
              message: `Percent input element not found for channel '${channelName}'`
            };
          }

          // Record the action before changing the value
          const oldValue = channelElement.value;
          CurveHistory.recordChannelAction(channelName, 'percentage', oldValue, validatedPercentage.toString());
          
          channelElement.value = validatedPercentage;
          
          // Trigger the input event to update the UI and recalculate
          channelElement.dispatchEvent(new Event('input', { bubbles: true }));

          this._recordAction('setChannelValue', { channelName, percentage: validatedPercentage });

          return {
            success: true,
            message: `Set ${channelName} channel to ${validatedPercentage}%`,
            details: { channel: channelName, value: validatedPercentage }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting channel value: ${error.message}`
          };
        }
      }

      /**
       * Set ink limit end value for a specific channel
       * @param {string} channelName - The channel name (K, C, M, Y, etc.)
       * @param {number} endValue - Ink limit end value (0-64000)
       * @returns {Object} Result with success status and message
       */
      setChannelEndValue(channelName, endValue) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Validate end value
          const validatedEndValue = InputValidator.clampEnd(endValue);
          if (validatedEndValue !== endValue) {
            return {
              success: false,
              message: `Invalid end value '${endValue}'. Must be between 0 and 64000.`
            };
          }

          // Find the channel row
          const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          const endElement = channelRow.querySelector('.end-input');
          if (!endElement) {
            return {
              success: false,
              message: `End value input element not found for channel '${channelName}'`
            };
          }

          // Record the action before changing the value
          const oldValue = endElement.value;
          CurveHistory.recordChannelAction(channelName, 'end', oldValue, validatedEndValue.toString());
          
          endElement.value = validatedEndValue;
          
          // Trigger the input event to update the UI and recalculate percentage
          endElement.dispatchEvent(new Event('input', { bubbles: true }));

          this._recordAction('setChannelEndValue', { channelName, endValue: validatedEndValue });

          return {
            success: true,
            message: `Set ${channelName} channel end value to ${validatedEndValue}`,
            details: { channel: channelName, endValue: validatedEndValue }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting channel end value: ${error.message}`
          };
        }
      }

      /**
       * Apply same percentage to all enabled channels
       * @param {number} percentage - Ink limit percentage (0-100)
       * @returns {Object} Result with success status and message
       */
      applyToAllChannels(percentage) {
        try {
          const validatedPercentage = InputValidator.clampPercent(percentage);
          if (validatedPercentage !== percentage) {
            return {
              success: false,
              message: `Invalid percentage '${percentage}'. Must be between 0 and 100.`
            };
          }

          const currentPrinter = getCurrentPrinter();
          const results = [];
          const channelActions = [];
          let appliedCount = 0;

          // First pass: collect current values and prepare batch action
          for (const channelName of currentPrinter.channels) {
            // Check if channel is enabled
            const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
            if (channelRow) {
              const checkbox = channelRow._virtualCheckbox;
              if (checkbox && checkbox.checked) {
                const channelElement = channelRow.querySelector('.percent-input');
                if (channelElement) {
                  const oldValue = channelElement.value;
                  
                  // Record this individual channel change for the batch
                  channelActions.push({
                    channelName: channelName,
                    type: 'percentage',
                    oldValue: oldValue,
                    newValue: validatedPercentage.toString()
                  });
                  
                  results.push(channelName);
                  appliedCount++;
                }
              }
            }
          }

          // Second pass: apply all changes and record as batch
          if (channelActions.length > 0) {
            // Set flag to prevent individual action recording during batch operation
            CurveHistory.isBatchOperation = true;
            
            for (const channelAction of channelActions) {
              const channelRow = document.querySelector(`tr[data-channel="${channelAction.channelName}"]`);
              if (channelRow) {
                const channelElement = channelRow.querySelector('.percent-input');
                if (channelElement) {
                  
                  // Set value and manually trigger UI updates without dispatching input event
                  channelElement.value = validatedPercentage;
                  
                  // Manually perform the same UI updates as the input handler, but without recording actions
                  const p = InputValidator.validateInput(channelElement, InputValidator.clampPercent);
                  const endVal = InputValidator.computeEndFromPercent(p);
                  const endInput = channelRow.querySelector('.end-input');
                  if (endInput) endInput.value = String(endVal);
                  
                  // Update UI display
                  if (channelRow.refreshDisplayFn) channelRow.refreshDisplayFn();
                }
              }
            }
            
            // Update compact channels list and graphs after all changes
            setTimeout(() => updateCompactChannelsList(), 50);
            debouncedPreviewUpdate();
            
            // Clear flag and record the batch action
            CurveHistory.isBatchOperation = false;
            CurveHistory.recordBatchAction(
              `Apply ${validatedPercentage}% to ${appliedCount} channels`,
              channelActions
            );
          }

          this._recordAction('applyToAllChannels', { percentage: validatedPercentage, appliedChannels: results });

          return {
            success: true,
            message: `Applied ${validatedPercentage}% to ${appliedCount} enabled channels: ${results.join(', ')}`,
            details: { percentage: validatedPercentage, channels: results }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error applying to all channels: ${error.message}`
          };
        }
      }

      /**
       * Apply same end value to all enabled channels
       * @param {number} endValue - Ink limit end value (0-64000)
       * @returns {Object} Result with success status and message
       */
      applyEndToAllChannels(endValue) {
        try {
          const validatedEndValue = InputValidator.clampEnd(endValue);
          if (validatedEndValue !== endValue) {
            return {
              success: false,
              message: `Invalid end value '${endValue}'. Must be between 0 and 64000.`
            };
          }

          const currentPrinter = getCurrentPrinter();
          const results = [];
          const channelActions = [];
          let appliedCount = 0;

          // First pass: collect current values and prepare batch action
          for (const channelName of currentPrinter.channels) {
            // Check if channel is enabled
            const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
            if (channelRow) {
              const checkbox = channelRow._virtualCheckbox;
              if (checkbox && checkbox.checked) {
                const channelElement = channelRow.querySelector('.end-input');
                if (channelElement) {
                  const oldValue = channelElement.value;
                  
                  // Record this individual channel change for the batch
                  channelActions.push({
                    channelName: channelName,
                    type: 'end',
                    oldValue: oldValue,
                    newValue: validatedEndValue.toString()
                  });
                  
                  results.push(channelName);
                  appliedCount++;
                }
              }
            }
          }

          // Second pass: apply all changes and record as batch
          if (channelActions.length > 0) {
            // Set flag to prevent individual action recording during batch operation
            CurveHistory.isBatchOperation = true;
            
            for (const channelAction of channelActions) {
              const channelRow = document.querySelector(`tr[data-channel="${channelAction.channelName}"]`);
              if (channelRow) {
                const channelElement = channelRow.querySelector('.end-input');
                if (channelElement) {
                  
                  // Set value and manually trigger UI updates without dispatching input event
                  channelElement.value = validatedEndValue;
                  
                  // Manually perform the same UI updates as the input handler, but without recording actions
                  const e = InputValidator.validateInput(channelElement, InputValidator.clampEnd);
                  const p = InputValidator.computePercentFromEnd(e);
                  const percentInput = channelRow.querySelector('.percent-input');
                  if (percentInput) percentInput.value = p.toFixed(1);
                  
                  // Update UI display
                  if (channelRow.refreshDisplayFn) channelRow.refreshDisplayFn();
                }
              }
            }
            
            // Update compact channels list and graphs after all changes
            setTimeout(() => updateCompactChannelsList(), 50);
            debouncedPreviewUpdate();
            
            // Clear flag and record the batch action
            CurveHistory.isBatchOperation = false;
            CurveHistory.recordBatchAction(
              `Apply end value ${validatedEndValue} to ${appliedCount} channels`,
              channelActions
            );
          }

          this._recordAction('applyEndToAllChannels', { endValue: validatedEndValue, appliedChannels: results });

          return {
            success: true,
            message: `Applied end value ${validatedEndValue} to ${appliedCount} enabled channels: ${results.join(', ')}`,
            details: { endValue: validatedEndValue, channels: results }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error applying end value to all channels: ${error.message}`
          };
        }
      }

      /**
       * Enable or disable a specific channel
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {boolean} enabled - Whether to enable (true) or disable (false)
       * @returns {Object} Result with success status and message
       */
      enableDisableChannel(channelName, enabled) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Find and update the channel checkbox
          const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          const checkbox = channelRow._virtualCheckbox;
          if (!checkbox) {
            return {
              success: false,
              message: `Channel checkbox for '${channelName}' not found`
            };
          }

          // Only trigger change event if the state is actually changing
          if (checkbox.checked !== enabled) {
            checkbox.checked = enabled;
            // Trigger the change event to update the UI
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }

          this._recordAction('enableDisableChannel', { channelName, enabled });

          const action = enabled ? 'enabled' : 'disabled';
          return {
            success: true,
            message: `${channelName} channel ${action}`,
            details: { channel: channelName, enabled }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error ${enabled ? 'enabling' : 'disabling'} channel: ${error.message}`
          };
        }
      }

      /**
       * Get current state of all channels
       * @returns {Object} Current app state with channel values and settings
       */
      getCurrentState() {
        try {
          const currentPrinter = getCurrentPrinter();
          const channels = {};

          for (const channelName of currentPrinter.channels) {
            const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
            
            if (channelRow) {
              const percentElement = channelRow.querySelector('.percent-input');
              const enabledElement = channelRow._virtualCheckbox;
              const endElement = channelRow.querySelector('.end-input');

              channels[channelName] = {
                percentage: percentElement ? parseFloat(percentElement.value) : 0,
                enabled: enabledElement ? enabledElement.checked : false,
                endValue: endElement ? parseInt(endElement.value) : 0
              };
            } else {
              // Channel row not found, set defaults
              channels[channelName] = {
                percentage: 0,
                enabled: false,
                endValue: 0
              };
            }
          }

          const state = {
            printer: currentPrinter.name,
            channels: channels,
            filename: elements.filenameInput ? elements.filenameInput.value : '',
            printIntent: elements.printIntent ? elements.printIntent.value : 'positive',
            version: APP_VERSION
          };

          return {
            success: true,
            message: 'Current state retrieved successfully',
            data: state
          };

        } catch (error) {
          return {
            success: false,
            message: `Error getting current state: ${error.message}`
          };
        }
      }

      /**
       * Open file picker for global linearization
       * @returns {Object} Result with success status and message
       */
      openGlobalLinearizationFilePicker() {
        try {
          const fileInput = document.getElementById('linearizationFile');
          if (!fileInput) {
            return {
              success: false,
              message: 'Global linearization file input not found'
            };
          }

          // Trigger the file picker
          fileInput.click();

          return {
            success: true,
            message: 'File picker opened for global linearization. Please select a .cube, .txt, or .acv file.',
            details: { action: 'file_picker_opened', type: 'global' }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error opening global linearization file picker: ${error.message}`
          };
        }
      }

      /**
       * Open file picker for per-channel linearization
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @returns {Object} Result with success status and message
       */
      openPerChannelLinearizationFilePicker(channelName) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          const fileInput = document.getElementById(`perChannel_${channelName}`);
          if (!fileInput) {
            return {
              success: false,
              message: `Per-channel file input for '${channelName}' not found`
            };
          }

          // Trigger the file picker
          fileInput.click();

          return {
            success: true,
            message: `File picker opened for ${channelName} channel linearization. Please select a .cube, .txt, or .acv file.`,
            details: { action: 'file_picker_opened', type: 'per_channel', channel: channelName }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error opening per-channel linearization file picker: ${error.message}`
          };
        }
      }

      /**
       * Load sample LAB data file
       * @returns {Object} Result with success status and message
       */
      loadSampleLabFile() {
        try {
          const downloadLink = document.getElementById('downloadSampleLabData');
          if (!downloadLink) {
            return {
              success: false,
              message: 'Sample LAB data download link not found'
            };
          }

          // Trigger the download/load of sample file
          downloadLink.click();

          return {
            success: true,
            message: 'Loading sample LAB measurement data file...',
            details: { action: 'sample_file_loaded', type: 'lab_data' }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error loading sample LAB data file: ${error.message}`
          };
        }
      }

      /**
       * Load LAB data from pasted text content
       * @param {string} labData - LAB measurement data (standard format)
       * @param {boolean} isGlobal - Whether to apply globally (true) or to specific channel (false)
       * @param {string} channelName - Channel name if isGlobal is false
       * @returns {Object} Result with success status and message
       */
      loadLabData(labData, isGlobal = true, channelName = null) {
        try {
          // Capture state before loading LAB data for proper undo functionality
          CurveHistory.captureState('Before loading pasted LAB data');
          
          // Validate channel if per-channel loading
          if (!isGlobal) {
            const currentPrinter = getCurrentPrinter();
            if (!channelName || !currentPrinter.channels.includes(channelName)) {
              return {
                success: false,
                message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
              };
            }
          }

          // Parse the LAB data using the existing parser
          let parseResult;
          try {
            parseResult = parseLabData(labData, isGlobal ? 'pasted_global_lab_data.txt' : `pasted_${channelName}_lab_data.txt`);
          } catch (error) {
            return {
              success: false,
              message: `Failed to parse LAB data: ${error.message || error}`
            };
          }

          if (!parseResult || !parseResult.samples || parseResult.samples.length === 0) {
            return {
              success: false,
              message: 'No valid LAB data points found. Expected format: GRAY_PERCENT LAB_L [LAB_A LAB_B]'
            };
          }

          // Apply the linearization data
          if (isGlobal) {
            // Set global linearization data (use the same variables as file loading)
            linearizationData = parseResult;
            linearizationApplied = true;
            
            // Update UI
            const globalToggle = document.getElementById('globalLinearizationToggle');
            if (globalToggle) {
              globalToggle.disabled = false;
              globalToggle.checked = true;
              globalToggle.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Note: No auto-smoothing; wedgie inversion produces the base curve. Smoothing is optional via slider.

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            return {
              success: true,
              message: `Loaded global LAB data with ${parseResult.samples.length} measurement points. Global linearization enabled.`,
              details: { 
                type: 'global_lab_data', 
                points: parseResult.samples.length,
                range: `${parseResult.domainMin * 100}% to ${parseResult.domainMax * 100}%`
              }
            };

          } else {
            // Set per-channel linearization data (use the same variables as file loading)
            perChannelLinearization[channelName] = parseResult;
            perChannelEnabled[channelName] = true;

            // Update UI toggle for this channel
            const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
            if (channelRow) {
              const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
                perChannelToggle.checked = true;
                perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }

            // Note: No auto-smoothing; wedgie inversion produces the base curve. Smoothing is optional via slider.

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            return {
              success: true,
              message: `Loaded LAB data for ${channelName} channel with ${parseResult.samples.length} measurement points. Channel linearization enabled.`,
              details: { 
                type: 'per_channel_lab_data',
                channel: channelName, 
                points: parseResult.samples.length,
                range: `${parseResult.domainMin * 100}% to ${parseResult.domainMax * 100}%`
              }
            };
          }

        } catch (error) {
          return {
            success: false,
            message: `Error loading LAB data: ${error.message}`
          };
        }
      }

      /**
       * Load sample LUT cube file
       * @returns {Object} Result with success status and message
       */
      loadSampleCubeFile() {
        try {
          const downloadLink = document.getElementById('downloadSampleCube');
          if (!downloadLink) {
            return {
              success: false,
              message: 'Sample cube download link not found'
            };
          }

          // Trigger the download/load of sample file
          downloadLink.click();

          return {
            success: true,
            message: 'Loading sample LUT cube file...',
            details: { action: 'sample_file_loaded', type: 'cube' }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error loading sample cube file: ${error.message}`
          };
        }
      }

      /**
       * Load cube data from pasted text content
       * @param {string} cubeData - Cube file data (1D or 3D LUT format)
       * @param {boolean} isGlobal - Whether to apply globally (true) or to specific channel (false)
       * @param {string} channelName - Channel name if isGlobal is false
       * @returns {Object} Result with success status and message
       */
      loadCubeData(cubeData, isGlobal = true, channelName = null) {
        try {
          // Validate channel if per-channel loading
          if (!isGlobal) {
            const currentPrinter = getCurrentPrinter();
            if (!channelName || !currentPrinter.channels.includes(channelName)) {
              return {
                success: false,
                message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
              };
            }
          }

          // Parse the cube data using the existing parser
          let parseResult;
          try {
            parseResult = parseCube1D(cubeData); // This will route to parseCube3D if needed
          } catch (error) {
            return {
              success: false,
              message: `Failed to parse cube data: ${error.message || error}`
            };
          }

          if (!parseResult || !parseResult.samples || parseResult.samples.length === 0) {
            return {
              success: false,
              message: 'No valid cube data found. Expected .cube format with DOMAIN_MIN/MAX and LUT data.'
            };
          }

          // Apply the linearization data
          if (isGlobal) {
            // Set global linearization data (use the same variables as file loading)
            linearizationData = parseResult;
            linearizationApplied = true;
            
            // Update UI
            const globalToggle = document.getElementById('globalLinearizationToggle');
            if (globalToggle) {
              globalToggle.disabled = false;
              globalToggle.checked = true;
              globalToggle.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            const cubeType = parseResult.format || 'cube';
            return {
              success: true,
              message: `Loaded global cube data (${cubeType}) with ${parseResult.samples.length} points. Global linearization enabled.`,
              details: { 
                type: 'global_cube_data', 
                format: cubeType,
                points: parseResult.samples.length,
                range: `${parseResult.domainMin} to ${parseResult.domainMax}`
              }
            };

          } else {
            // Set per-channel linearization data (use the same variables as file loading)
            perChannelLinearization[channelName] = parseResult;
            perChannelEnabled[channelName] = true;

            // Update UI toggle for this channel
            const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
            if (channelRow) {
              const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
                perChannelToggle.checked = true;
                perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));
              }
            }

            // Regenerate curves with the new linearization data
            if (typeof updatePreview === 'function') {
              updatePreview();
            }

            const cubeType = parseResult.format || 'cube';
            return {
              success: true,
              message: `Loaded cube data (${cubeType}) for ${channelName} channel with ${parseResult.samples.length} points. Channel linearization enabled.`,
              details: { 
                type: 'per_channel_cube_data',
                channel: channelName,
                format: cubeType,
                points: parseResult.samples.length,
                range: `${parseResult.domainMin} to ${parseResult.domainMax}`
              }
            };
          }

        } catch (error) {
          return {
            success: false,
            message: `Error loading cube data: ${error.message}`
          };
        }
      }

      /**
       * Copy curve from one channel to another
       * @param {string} sourceChannel - Channel to copy from
       * @param {string} targetChannel - Channel to copy to
       * @returns {Object} Result with success status and message
       */
      copyCurveToChannel(sourceChannel, targetChannel) {
        try {
          // Validate channels
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(sourceChannel)) {
            return {
              success: false,
              message: `Source channel '${sourceChannel}' not found. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }
          if (!currentPrinter.channels.includes(targetChannel)) {
            return {
              success: false,
              message: `Target channel '${targetChannel}' not found. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Check if source channel has a custom curve
          if (!loadedQuadData?.curves?.[sourceChannel]) {
            return {
              success: false,
              message: `No custom curve found for ${sourceChannel} channel. Generate or load a curve first.`
            };
          }

          // Copy the curve
          const sourceCurve = [...loadedQuadData.curves[sourceChannel]];
          
          // Apply the copied curve to target channel
          const result = this._applyCurveToChannel(targetChannel, sourceCurve);
          
          if (!result.success) {
            return result;
          }

          // Record action
          this._recordAction('copyCurveToChannel', { sourceChannel, targetChannel });
          updatePreview();
          // Refresh Edit Curves channel dropdown now that printer/channels are set
          try { if (typeof edit_populateChannelSelect === 'function') edit_populateChannelSelect(); } catch {}

          return {
            success: true,
            message: `Successfully copied curve from ${sourceChannel} to ${targetChannel} channel`,
            details: {
              source: sourceChannel,
              target: targetChannel,
              curveMaxValue: Math.max(...sourceCurve)
            }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error copying curve: ${error.message}`
          };
        }
      }

      /**
       * Generate and download the .quad file
       * @returns {Object} Result with success status and message
       */
      generateAndDownloadQuadFile() {
        try {
          // Generate the .quad file content using the existing buildFile function
          const quadContent = buildFile();
          
          if (!quadContent || quadContent.length === 0) {
            return {
              success: false,
              message: 'Failed to generate .quad file content. Check that channels are properly configured.'
            };
          }

          // Get the filename
          const filenameInput = document.getElementById('filenameInput');
          let filename;
          const customName = filenameInput ? filenameInput.value.trim() : '';
          
          if (customName) {
            // Remove .quad extension if user added it, then sanitize
            const cleanName = customName.replace(/\.quad$/, '');
            filename = `${sanitizeFilename(cleanName)}.quad`;
          } else {
            // Use auto-generated filename
            filename = `${generateFilename()}.quad`;
          }

          // Create download link and trigger download
          const blob = new Blob([quadContent], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.style.display = 'none';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          return {
            success: true,
            message: `Generated and downloaded '${filename}' successfully`,
            details: { 
              filename: filename,
              size: quadContent.length,
              channels: Object.keys(getCurrentPrinter().channels).length
            }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error generating .quad file: ${error.message}`
          };
        }
      }

      /**
       * Set the filename for the .quad file
       * @param {string} filename - Desired filename (without extension)
       * @returns {Object} Result with success status and message
       */
      setFilename(filename) {
        try {
          const filenameInput = document.getElementById('filenameInput');
          if (!filenameInput) {
            return {
              success: false,
              message: 'Filename input not found'
            };
          }

          // Sanitize filename - remove invalid characters
          const sanitized = filename
            .replace(/[<>:"/\\|?*]/g, '')  // Remove invalid file system characters
            .replace(/\s+/g, '_')          // Replace spaces with underscores
            .trim();

          if (!sanitized) {
            return {
              success: false,
              message: 'Filename cannot be empty after sanitization'
            };
          }

          // Set the filename
          filenameInput.value = sanitized;
          filenameInput.dataset.userEdited = 'true'; // Mark as user-edited to prevent auto-generation
          filenameInput.dispatchEvent(new Event('input', { bubbles: true }));

          return {
            success: true,
            message: `Filename set to '${sanitized}.quad'`,
            details: { filename: sanitized }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting filename: ${error.message}`
          };
        }
      }

      /**
       * Toggle global linearization
       * @param {boolean} enabled - Whether to enable global linearization
       * @returns {Object} Result with success status and message
       */
      setGlobalLinearization(enabled) {
        try {
          const globalToggle = document.getElementById('globalLinearizationToggle');
          if (!globalToggle) {
            return {
              success: false,
              message: 'Global linearization toggle not found'
            };
          }

          // Check if linearization file is loaded
          if (enabled && globalToggle.disabled) {
            return {
              success: false,
              message: 'Cannot enable global linearization - no linearization file loaded. Load a .cube, .txt, or .acv file first.'
            };
          }

          globalToggle.checked = enabled;
          globalToggle.dispatchEvent(new Event('change', { bubbles: true }));

          return {
            success: true,
            message: `Global linearization ${enabled ? 'enabled' : 'disabled'}`,
            details: { globalLinearization: enabled }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting global linearization: ${error.message}`
          };
        }
      }

      /**
       * Toggle per-channel linearization
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {boolean} enabled - Whether to enable linearization for this channel
       * @returns {Object} Result with success status and message
       */
      setPerChannelLinearization(channelName, enabled) {
        try {
          // Validate channel name
          const currentPrinter = getCurrentPrinter();
          if (!currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Find the channel row and toggle
          const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
          if (!perChannelToggle) {
            return {
              success: false,
              message: `Per-channel linearization toggle for '${channelName}' not found`
            };
          }

          // Check if linearization file is loaded for this channel
          if (enabled && perChannelToggle.disabled) {
            return {
              success: false,
              message: `Cannot enable linearization for ${channelName} - no linearization file loaded for this channel. Load a .cube, .txt, or .acv file first.`
            };
          }

          perChannelToggle.checked = enabled;
          perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));

          return {
            success: true,
            message: `${channelName} channel linearization ${enabled ? 'enabled' : 'disabled'}`,
            details: { channel: channelName, linearization: enabled }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting per-channel linearization: ${error.message}`
          };
        }
      }

      /**
       * Set interpolation method
       * @param {string} method - Interpolation method (pchip or linear)
       * @returns {Object} Result with success status and message
       */
      setInterpolationMethod(method) {
        try {
          const interpolationSelect = document.getElementById('curveSmoothingMethod');
          if (!interpolationSelect) {
            return {
              success: false,
              message: 'Interpolation selector not found'
            };
          }

          // Validate method
          const validMethods = ['pchip', 'linear'];
          if (!validMethods.includes(method)) {
            return {
              success: false,
              message: `Invalid interpolation method '${method}'. Available methods: PCHIP (monotonic), Linear (none)`
            };
          }

          // Set the interpolation method
          interpolationSelect.value = method;
          interpolationSelect.dispatchEvent(new Event('change', { bubbles: true }));

          const methodName = method === 'pchip' ? 'PCHIP (monotonic)' : 'Linear (none)';
          return {
            success: true,
            message: `Set interpolation method to ${methodName}`,
            details: { method: methodName }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting interpolation method: ${error.message}`
          };
        }
      }

      /**
       * Set data point smoothing percentage
       * @param {number} percentage - Smoothing percentage (0-90)
       * @returns {Object} Result with success status and message
       */
      setSmoothingPercentage(percentage) {
        try {
          const smoothingSlider = document.getElementById('smoothingSlider');
          const smoothingValue = document.getElementById('smoothingValue');
          
          if (!smoothingSlider) {
            return {
              success: false,
              message: 'Smoothing slider not found'
            };
          }

          // Validate percentage
          const clampedValue = Math.max(0, Math.min(90, percentage));
          if (clampedValue !== percentage) {
            return {
              success: false,
              message: `Invalid smoothing percentage '${percentage}'. Must be between 0 and 90.`
            };
          }

          // Set the smoothing value
          smoothingSlider.value = clampedValue;
          if (smoothingValue) {
            smoothingValue.textContent = `${clampedValue}%`;
          }
          smoothingSlider.dispatchEvent(new Event('input', { bubbles: true }));

          return {
            success: true,
            message: `Set data point smoothing to ${clampedValue}%`,
            details: { smoothing: clampedValue }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error setting smoothing percentage: ${error.message}`
          };
        }
      }

      /**
       * Change the active printer
       * @param {string} printerName - Printer name (P600-P800 or P700P900)
       * @returns {Object} Result with success status and message
       */
      changePrinter(printerName) {
        try {
          const printerSelect = document.getElementById('printerSelect');
          if (!printerSelect) {
            return {
              success: false,
              message: 'Printer selector not found'
            };
          }

          // Validate printer name
          const validPrinters = ['P700P900', 'P5-7-9000', 'P800', 'P400', 'x900', '3880-7880', 'x800-x890', 'P4-6-8000'];
          if (!validPrinters.includes(printerName)) {
            return {
              success: false,
              message: `Invalid printer '${printerName}'. Available printers: ${validPrinters.join(', ')}`
            };
          }

          // Change the printer
          printerSelect.value = printerName;
          
          // Trigger the change event to update the UI
          printerSelect.dispatchEvent(new Event('change', { bubbles: true }));

          return {
            success: true,
            message: `Switched to ${printerName} printer`,
            details: { printer: printerName }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error changing printer: ${error.message}`
          };
        }
      }

      /**
       * Perform multiple channel enable/disable operations
       * @param {Array} operations - Array of {channelName, enabled} objects
       * @returns {Object} Result with success status and message
       */
      batchChannelOperations(operations) {
        try {
          const results = [];
          const errors = [];
          const channelActions = [];

          // Set flag to prevent individual action recording during batch operation
          CurveHistory.isBatchOperation = true;
          
          // First pass: collect current values and prepare batch action
          for (const operation of operations) {
            const channelRow = document.querySelector(`tr[data-channel="${operation.channelName}"]`);
            if (channelRow) {
              const checkbox = channelRow._virtualCheckbox;
              if (checkbox) {
                const oldValue = checkbox.checked;
                
                // Only record if there's an actual change
                if (oldValue !== operation.enabled) {
                  channelActions.push({
                    channelName: operation.channelName,
                    type: 'enable',
                    oldValue: oldValue,
                    newValue: operation.enabled
                  });
                }
              }
            }
          }

          // Second pass: apply all changes
          for (const operation of operations) {
            const result = this.enableDisableChannel(operation.channelName, operation.enabled);
            if (result.success) {
              results.push(result.message);
            } else {
              errors.push(result.message);
            }
          }
          
          // Clear flag and record the batch action
          CurveHistory.isBatchOperation = false;
          
          if (channelActions.length > 0) {
            const enabledCount = channelActions.filter(a => a.newValue).length;
            const disabledCount = channelActions.filter(a => !a.newValue).length;
            let description = '';
            if (enabledCount > 0 && disabledCount > 0) {
              description = `Batch enable ${enabledCount} and disable ${disabledCount} channels`;
            } else if (enabledCount > 0) {
              description = `Batch enable ${enabledCount} channels`;
            } else {
              description = `Batch disable ${disabledCount} channels`;
            }
            
            CurveHistory.recordBatchAction(description, channelActions);
          }

          if (errors.length > 0) {
            return {
              success: false,
              message: `Some operations failed: ${errors.join(', ')}. Successful: ${results.join(', ')}`
            };
          }

          return {
            success: true,
            message: `All operations completed: ${results.join(', ')}`,
            details: { operationCount: operations.length, results }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error performing batch operations: ${error.message}`
          };
        }
      }

      /**
       * Record the last action for potential undo functionality
       * @private
       */
      _recordAction(actionType, params) {
        this.lastAction = {
          type: actionType,
          params: params,
          timestamp: Date.now()
        };
        this.lastActionTime = new Date().toLocaleTimeString();
      }

      /**
       * Get information about the last action performed
       * @returns {Object|null} Last action details or null if no actions
       */
      getLastAction() {
        return this.lastAction;
      }

      /**
       * Generate a custom curve from natural language description
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {string} description - Natural language curve description
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @returns {Object} Result with success status and message
       */
      generateCurveFromDescription(channelName, description, interpolationType = 'smooth') {
        return {
          success: false,
          message: 'DEPRECATED: Natural-language curve generation is disabled. Compute numeric key points and call setAIKeyPoints.'
        };
      }

      /**
       * Generate a custom curve from key points for a specific channel
       * @param {string} channelName - Channel name (K, C, M, Y, etc.)
       * @param {Array} keyPoints - Array of {input: number, output: number} objects (0-100 range)
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @returns {Object} Result with success status and message
       */
      generateCustomCurve(channelName, keyPoints, interpolationType = 'smooth') {
        try {
          // Validate channel
          const currentPrinter = getCurrentPrinter();
          if (!channelName || !currentPrinter.channels.includes(channelName)) {
            return {
              success: false,
              message: `Invalid channel '${channelName}'. Available channels: ${currentPrinter.channels.join(', ')}`
            };
          }

          // Validate key points
          if (!Array.isArray(keyPoints) || keyPoints.length < 2) {
            return {
              success: false,
              message: 'At least 2 key points required for curve generation'
            };
          }

          // Validate and normalize key points
          const normalizedPoints = keyPoints.map((point, index) => {
            if (!point || typeof point.input !== 'number' || typeof point.output !== 'number') {
              throw new Error(`Invalid key point at index ${index}: must have 'input' and 'output' properties`);
            }
            return {
              input: Math.max(0, Math.min(100, point.input)),
              output: Math.max(0, Math.min(100, point.output))
            };
          });

          // Sort by input value
          normalizedPoints.sort((a, b) => a.input - b.input);

          // Ensure we have start and end points
          if (normalizedPoints[0].input !== 0) {
            normalizedPoints.unshift({ input: 0, output: 0 });
          }
          if (normalizedPoints[normalizedPoints.length - 1].input !== 100) {
            normalizedPoints.push({ input: 100, output: normalizedPoints[normalizedPoints.length - 1].output });
          }

          // Generate 256-point curve
          if (DEBUG_LOGS) console.log('Generating curve with key points:', normalizedPoints, 'interpolation:', interpolationType);
          const curve = this._interpolateCurve(normalizedPoints, interpolationType);

          // Apply curve to channel with key-point history extras
          const oldKP = window.loadedQuadData?.keyPoints?.[channelName] ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null;
          const oldInterp = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth';
          const newInterp = (interpolationType === 'linear' ? 'linear' : 'smooth');
          const extras = {
            oldKeyPoints: oldKP,
            newKeyPoints: normalizedPoints.map(p => ({ input: p.input, output: p.output })),
            oldInterpolation: oldInterp,
            newInterpolation: newInterp
          };
          CurveHistory.recordKeyPointsChange(channelName, extras.oldKeyPoints, extras.newKeyPoints, extras.oldInterpolation, extras.newInterpolation);
          const result = this._applyCurveToChannel(channelName, curve, extras);
          
          if (!result.success) {
            return result;
          }
          // Persist Smart key points for overlay display (store normalized 0-100 inputs/outputs)
          try {
            ControlPoints.persist(channelName, normalizedPoints, interpolationType);
          } catch (e) {
          if (DEBUG_LOGS) console.warn('Could not persist Smart key points for overlay:', e);
          }

          // Record action and trigger update
          this._recordAction('generateCustomCurve', { channelName, keyPoints: normalizedPoints, interpolationType });
          updatePreview();

          return {
            success: true,
            message: `Generated custom ${interpolationType} curve for ${channelName} channel with ${keyPoints.length} key points`,
            details: {
              channelName,
              interpolationType,
              keyPointsCount: normalizedPoints.length,
              keyPoints: normalizedPoints.slice(0, 5) // summarize first up to 5 points
            }
          };

        } catch (error) {
          return {
            success: false,
            message: `Error generating custom curve: ${error.message}`
          };
        }
      }

      /**
       * Generate curves from natural language description for multiple channels
       * @param {string} description - Natural language curve description
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @param {string|Array} channelFilter - 'all', 'enabled', or array of channel names
       * @returns {Object} Result with success status and message
       */
      generateGlobalCurveFromDescription(description, interpolationType = 'smooth', channelFilter = 'enabled') {
        return {
          success: false,
          message: 'DEPRECATED: Natural-language curve generation is disabled. Compute numeric key points and call generateGlobalCustomCurve or setAIKeyPoints.'
        };
      }

      /**
       * Generate custom curves from key points for multiple channels
       * @param {Array} keyPoints - Array of {input: number, output: number} objects (0-100 range)
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @param {string|Array} channelFilter - 'all', 'enabled', or array of channel names
       * @returns {Object} Result with success status and message
       */
      generateGlobalCustomCurve(keyPoints, interpolationType = 'smooth', channelFilter = 'enabled') {
        try {
          // Validate key points
          if (!Array.isArray(keyPoints) || keyPoints.length < 2) {
            return {
              success: false,
              message: 'At least 2 key points required for curve generation'
            };
          }

          // Determine target channels based on filter
          const currentPrinter = getCurrentPrinter();
          let targetChannels = [];
          
          if (channelFilter === 'all') {
            targetChannels = [...currentPrinter.channels];
          } else if (channelFilter === 'enabled') {
            // Find enabled channels
            targetChannels = currentPrinter.channels.filter(channelName => {
              const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
              if (!channelRow) return false;
              const checkbox = channelRow._virtualCheckbox;
              return checkbox && checkbox.checked;
            });
          } else if (Array.isArray(channelFilter)) {
            // Validate specified channels exist
            targetChannels = channelFilter.filter(channelName => 
              currentPrinter.channels.includes(channelName)
            );
          } else {
            return {
              success: false,
              message: `Invalid channel filter '${channelFilter}'. Use 'all', 'enabled', or channel array.`
            };
          }

          if (targetChannels.length === 0) {
            return {
              success: false,
              message: channelFilter === 'enabled' ? 
                'No enabled channels found. Enable at least one channel first.' :
                'No valid channels found for the specified filter.'
            };
          }

          // Validate and normalize key points
          const normalizedPoints = keyPoints.map((point, index) => {
            if (!point || typeof point.input !== 'number' || typeof point.output !== 'number') {
              throw new Error(`Invalid key point at index ${index}: must have 'input' and 'output' properties`);
            }
            return {
              input: Math.max(0, Math.min(100, point.input)),
              output: Math.max(0, Math.min(100, point.output))
            };
          });

          // Sort by input value
          normalizedPoints.sort((a, b) => a.input - b.input);

          // Ensure we have start and end points
          if (normalizedPoints[0].input !== 0) {
            normalizedPoints.unshift({ input: 0, output: 0 });
          }
          if (normalizedPoints[normalizedPoints.length - 1].input !== 100) {
            normalizedPoints.push({ input: 100, output: normalizedPoints[normalizedPoints.length - 1].output });
          }

          // Generate 256-point curve
          if (DEBUG_LOGS) console.log('Generating global curve with key points:', normalizedPoints, 'interpolation:', interpolationType, 'channels:', targetChannels);
          const curve = this._interpolateCurve(normalizedPoints, interpolationType);

          // Set flag to prevent individual action recording during batch operation
          CurveHistory.isBatchOperation = true;
          const channelActions = [];
          const results = [];
          const errors = [];

          // Apply curve to each target channel
          for (const channelName of targetChannels) {
            try {
              // Capture old state before changing anything
              const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
              if (!channelRow) {
                errors.push(`${channelName}: channel row not found`);
                continue;
              }
              
              const percentInput = channelRow.querySelector('.percent-input');
              const checkbox = channelRow._virtualCheckbox;
              
              const oldCurveData = window.loadedQuadData?.curves?.[channelName] ? 
                [...window.loadedQuadData.curves[channelName]] : null;
              const oldPercentage = percentInput ? percentInput.value : '0';
              const oldEnabled = checkbox ? checkbox.checked : false;
              const oldSource = window.loadedQuadData?.sources?.[channelName] || null;
              
              // Apply curve to channel
              const result = this._applyCurveToChannel(channelName, curve);
              
              if (result.success) {
                // Persist the same AI key points for each affected channel
                try {
                  ControlPoints.persist(channelName, normalizedPoints, interpolationType);
                } catch (e) {
                  if (DEBUG_LOGS) console.warn('Could not persist Smart key points for overlay (global):', channelName, e);
                }
                // Mark contributing linearization as edited for display
                markLinearizationEdited(channelName);
                // For global curve generation, we only need to record the curve changes
                // The curve undo will automatically restore the channel to its previous state
                channelActions.push({
                  channelName: channelName,
                  type: 'curve',
                  oldValue: oldCurveData,
                  newValue: [...curve],
                  oldKeyPoints: (window.loadedQuadData?.keyPoints?.[channelName]) ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null,
                  newKeyPoints: normalizedPoints.map(p => ({ input: p.input, output: p.output })),
                  oldInterpolation: window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth',
                  newInterpolation: interpolationType,
                  oldSource: oldSource,
                  newSource: 'smart'
                });
                
                results.push(`${channelName}: curve applied`);
              } else {
                errors.push(`${channelName}: ${result.message}`);
              }
            } catch (error) {
              errors.push(`${channelName}: ${error.message}`);
            }
          }

          // Record the batch action first, then clear flag after debounced handlers have time to execute
          if (DEBUG_LOGS) console.log('🔄 Recording batch action and scheduling flag clear');
          
          if (channelActions.length > 0) {
            const curveType = normalizedPoints.length <= 3 ? 'simple' : 'complex';
            const batchDescription = `Generate global ${interpolationType} ${curveType} curve for ${channelActions.length} channels`;
            CurveHistory.recordBatchAction(batchDescription, channelActions);
            if (DEBUG_LOGS) console.log('✅ Batch action recorded successfully');
            
            // Clear batch flag after debounced handlers have time to execute (1.5 seconds)
            setTimeout(() => {
              if (DEBUG_LOGS) console.log('🔄 Clearing batch operation flag after timeout');
              CurveHistory.isBatchOperation = false;
            }, 1500);
          } else {
            if (DEBUG_LOGS) console.log('⚠️ No channel actions to record');
            // Clear flag immediately if no actions
            CurveHistory.isBatchOperation = false;
          }

          // Record action for internal tracking
          this._recordAction('generateGlobalCustomCurve', { 
            keyPoints: normalizedPoints, 
            interpolationType, 
            channelFilter,
            affectedChannels: targetChannels 
          });

          // CRITICAL: Trigger graph redraw for all affected channels
          updatePreview();
          
          // Additional deferred update to ensure all DOM changes are processed
          setTimeout(() => {
              
            // Force refresh each affected channel's display
            for (const channelName of targetChannels) {
              const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
              if (channelRow && channelRow.refreshDisplayFn) {
                channelRow.refreshDisplayFn();
              }
            }
            
            updatePreview();
          }, 100);

          // Return results
          if (errors.length > 0 && results.length === 0) {
            return {
              success: false,
              message: `All curve generations failed: ${errors.join(', ')}`
            };
          } else if (errors.length > 0) {
            return {
              success: true,
              message: `Partial success: ${results.length} curves generated, ${errors.length} failed. Successful: ${results.join(', ')}. Failed: ${errors.join(', ')}`,
              details: { 
                successCount: results.length, 
                errorCount: errors.length,
                affectedChannels: channelActions.map(a => a.channelName)
              }
            };
          } else {
            return {
              success: true,
              message: `Generated global ${interpolationType} curve for ${channelActions.length} channels: ${channelActions.map(a => a.channelName).join(', ')}`,
              details: { 
                affectedChannels: channelActions.map(a => a.channelName),
                keyPoints: keyPoints.length,
                interpolationType
              }
            };
          }

        } catch (error) {
          // Clear flag in case of error
          setTimeout(() => {
            CurveHistory.isBatchOperation = false;
          }, 1500);
          return {
            success: false,
            message: `Error generating global custom curve: ${error.message}`
          };
        }
      }

      /**
       * Generate global linearization curve from natural language description
       * @param {string} description - Natural language curve description
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @param {number} pointCount - Number of curve points to generate (default 256)
       * @returns {Object} Result with success status and message
       */
      generateGlobalLinearizationFromDescription(description, interpolationType = 'smooth', pointCount = 256) {
        return { success: false, message: 'DEPRECATED: Natural-language global linearization is disabled. Compute numeric key points and use generate_global_custom_curve or setAIKeyPoints per channel.' };
      }

      /**
       * Interpolate curve from key points to 256 data points
       * @param {Array} keyPoints - Sorted array of {input, output} points (0-100 range)
       * @param {string} interpolationType - 'linear' or 'smooth'
       * @returns {Array} 256-point curve array scaled to TOTAL
       * @private
       */
      _interpolateCurve(keyPoints, interpolationType) {
        const curve = new Array(N);
        
        for (let i = 0; i < N; i++) {
          const inputPercent = (i / DENOM) * 100; // Convert index to 0-100 range
          let outputPercent;

          // Find surrounding key points
          let leftPoint = null;
          let rightPoint = null;

          for (let j = 0; j < keyPoints.length - 1; j++) {
            if (inputPercent >= keyPoints[j].input && inputPercent <= keyPoints[j + 1].input) {
              leftPoint = keyPoints[j];
              rightPoint = keyPoints[j + 1];
              break;
            }
          }

          if (!leftPoint || !rightPoint) {
            // Fallback: clamp to nearest point
            if (inputPercent <= keyPoints[0].input) {
              outputPercent = keyPoints[0].output;
            } else {
              outputPercent = keyPoints[keyPoints.length - 1].output;
            }
          } else if (interpolationType === 'linear' || leftPoint.input === rightPoint.input) {
            // Linear interpolation
            const t = leftPoint.input === rightPoint.input ? 0 : 
                     (inputPercent - leftPoint.input) / (rightPoint.input - leftPoint.input);
            outputPercent = leftPoint.output + t * (rightPoint.output - leftPoint.output);
          } else {
            // Use PCHIP interpolation for smooth, monotonic curves (from working v1.5)
            const x = keyPoints.map(p => p.input);
            const y = keyPoints.map(p => p.output);
            outputPercent = this._pchipInterpolate(x, y, inputPercent);
          }

          // Convert to TOTAL scale and clamp
          if (isNaN(outputPercent)) {
            console.error('❌ NaN outputPercent at index', i, 'inputPercent:', inputPercent, 'interpolationType:', interpolationType);
            console.error('❌ Left/Right points:', { leftPoint, rightPoint });
          }
          curve[i] = Math.round(Math.max(0, Math.min(TOTAL, (outputPercent / 100) * TOTAL)));
          if (isNaN(curve[i])) {
            console.error('❌ NaN in final curve at index', i, 'outputPercent:', outputPercent, 'TOTAL:', TOTAL);
          }
        }

        return curve;
      }


      /**
       * Parse photography curve description into key points
       * @param {string} description - Natural language curve description
       * @returns {Object} Result with success status and keyPoints array
       * @private
       */
      /**
       * ⚠️  CRITICAL: DO NOT REPLACE THIS INTERPOLATION METHOD ⚠️
       * PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) interpolation
       * 
       * THIS IS THE ONLY APPROVED METHOD FOR SMOOTH INTERPOLATION
       * - VERIFIED WORKING in v1.5 for natural language curve generation
       * - Avoids horizontal flattening (smoothstep problem)
       * - Avoids sharp corners (linear problem)  
       * - Avoids overshooting (spline problem)
       * - DO NOT replace with Catmull-Rom, smoothstep, cosine, or other methods
       * 
       * @param {number[]} x - Input values (sorted ascending)
       * @param {number[]} y - Output values corresponding to x
       * @param {number} xi - Input value to interpolate at
       * @returns {number} Interpolated output value
       */
      _pchipInterpolate(x, y, xi) {
        // Development reminder about this critical method
        if (this._pchipWarningShown !== true) {
          console.warn('🚨 PCHIP INTERPOLATION IN USE: This is the ONLY approved smooth interpolation method. DO NOT replace with other methods.');
          this._pchipWarningShown = true;
        }
        
        const n = x.length;
        
        // Handle edge cases
        if (n < 2) return y[0] || 0;
        if (xi <= x[0]) return y[0];
        if (xi >= x[n - 1]) return y[n - 1];
        
        // Find the interval containing xi
        let i = 0;
        for (i = 0; i < n - 1; i++) {
          if (xi >= x[i] && xi <= x[i + 1]) break;
        }
        
        // Calculate slopes (derivatives) at each point
        const slopes = new Array(n);
        const h = new Array(n - 1);
        const delta = new Array(n - 1);
        
        // Calculate intervals and finite differences
        for (let j = 0; j < n - 1; j++) {
          h[j] = x[j + 1] - x[j];
          delta[j] = (y[j + 1] - y[j]) / h[j];
        }
        
        // Calculate slopes using PCHIP method
        slopes[0] = delta[0]; // First point - use forward difference
        slopes[n - 1] = delta[n - 2]; // Last point - use backward difference
        
        for (let j = 1; j < n - 1; j++) {
          // Interior points - use monotonic slope calculation
          if (delta[j - 1] * delta[j] <= 0) {
            slopes[j] = 0; // Local extremum
          } else {
            // Weighted average of neighboring slopes
            const w1 = 2 * h[j] + h[j - 1];
            const w2 = h[j] + 2 * h[j - 1];
            slopes[j] = (w1 + w2) / (w1 / delta[j - 1] + w2 / delta[j]);
          }
        }
        
        // Perform cubic Hermite interpolation
        const x0 = x[i];
        const x1 = x[i + 1];
        const y0 = y[i];
        const y1 = y[i + 1];
        const m0 = slopes[i];
        const m1 = slopes[i + 1];
        
        const t = (xi - x0) / (x1 - x0);
        const t2 = t * t;
        const t3 = t2 * t;
        
        const h00 = 2 * t3 - 3 * t2 + 1;
        const h10 = t3 - 2 * t2 + t;
        const h01 = -2 * t3 + 3 * t2;
        const h11 = t3 - t2;
        
        return h00 * y0 + h10 * (x1 - x0) * m0 + h01 * y1 + h11 * (x1 - x0) * m1;
      }

      _parsePhotographyCurveDescription(description) {
        return { success: false, message: 'DEPRECATED: Natural-language curve parsing is disabled. Compute numeric key points and use setAIKeyPoints.' };
      }

      /**
       * Apply a curve to a specific channel by setting it as loaded curve data
       * @param {string} channelName - Channel name
       * @param {Array} curve - 256-point curve array
       * @returns {Object} Result object
       * @private
       */
      _applyCurveToChannel(channelName, curve, historyExtras = null) {
        try {
          // Find the channel row
          const channelRow = document.querySelector(`tr[data-channel="${channelName}"]`);
          if (!channelRow) {
            return {
              success: false,
              message: `Channel row for '${channelName}' not found`
            };
          }

          // Initialize loadedQuadData if it doesn't exist (ensure global scope)
          if (!window.loadedQuadData) {
            window.loadedQuadData = { curves: {}, sources: {} };
          }
          if (!window.loadedQuadData.curves) {
            window.loadedQuadData.curves = {};
          }
          if (!window.loadedQuadData.sources) {
            window.loadedQuadData.sources = {};
          }

          // Capture old curve data before changing it
          const oldCurveData = window.loadedQuadData.curves[channelName] ? 
            [...window.loadedQuadData.curves[channelName]] : null;
          
          // Record the curve change action (only if not during batch operation or restore)
          if (!CurveHistory.isBatchOperation && !CurveHistory.isRestoring) {
            // Prefer explicit extras; otherwise consume pending key-point change recorded earlier
            let extras = historyExtras;
            if (!extras) {
              const pending = CurveHistory._pendingKeyPoints?.[channelName];
              if (pending) {
                extras = { ...pending };
                delete CurveHistory._pendingKeyPoints[channelName];
              } else {
                const existingKP = window.loadedQuadData?.keyPoints?.[channelName];
                if (existingKP) {
                  extras = { oldKeyPoints: existingKP.map(p => ({ input: p.input, output: p.output })) };
                }
              }
            }
            // Attach source transition metadata for accurate undo/redo labeling
            if (!extras || typeof extras !== 'object') extras = {};
            const oldSource = window.loadedQuadData?.sources?.[channelName] || null;
            extras.oldSource = oldSource;
            extras.newSource = 'smart';
            CurveHistory.recordChannelAction(channelName, 'curve', oldCurveData, [...curve], extras);
          } else {
          if (DEBUG_LOGS) console.log(`⏭️ Skipping individual curve action for ${channelName} (in batch mode)`);
          }

          // Store the curve in the global loadedQuadData and mark as Smart source
          window.loadedQuadData.curves[channelName] = [...curve];
          window.loadedQuadData.sources[channelName] = 'smart';
          console.log(`DEBUG: Stored Smart curve for ${channelName}:`, {
            curveLength: curve.length,
            firstFew: curve.slice(0, 5),
            lastFew: curve.slice(-5),
            maxValue: Math.max(...curve),
            loadedQuadDataExists: !!window.loadedQuadData,
            curvesExists: !!window.loadedQuadData?.curves
          });
          
          // Keep any existing per-channel linearization metadata so the UI can still display the source filename.
          // Just ensure it is disabled to avoid double-processing while a Smart Curve is active.
          if (perChannelLinearization[channelName]) {
            perChannelEnabled[channelName] = false;
          }
          
          // Update UI for Smart Curve (different from file-loaded linearization)
          const perChannelToggle = channelRow.querySelector('.per-channel-toggle');
          const perChannelBtn = channelRow.querySelector('.per-channel-btn');
          
          // For Smart Curves, disable the per-channel linearization toggle since the curve is applied directly
          if (perChannelToggle) {
            perChannelToggle.disabled = true;
            perChannelToggle.checked = false;
            perChannelToggle.dispatchEvent(new Event('change', { bubbles: true }));
          }
          
          if (perChannelBtn) {
            const base = perChannelFilenames[channelName] || 'unknown file';
            const edited = !!(perChannelLinearization[channelName] && perChannelLinearization[channelName].edited);
            const disp = getEditedDisplayName(base, edited);
            const tip = perChannelLinearization[channelName]
              ? `Loaded: ${disp} (disabled; Smart Curve applied)`
              : `Smart Curve: ${curve.length} point curve (applied directly)`;
            perChannelBtn.setAttribute('data-tooltip', tip);
          }
          
          // Update interpolation controls since we now have linearization data
          if (typeof updateInterpolationControls === 'function') {
            updateInterpolationControls();
          }
          

          // Preserve existing scaling: only adjust percentage automatically if channel is currently disabled
          const currentEndValue = parseInt(channelRow.querySelector('.end-input').value) || 0;
          const percentInput = channelRow.querySelector('.percent-input');
          const endInput = channelRow.querySelector('.end-input');
          const checkbox = channelRow._virtualCheckbox;
          
          if (!CurveHistory.isRestoring && percentInput && endInput && currentEndValue === 0) {
            // Channel is disabled: set a reasonable starting percentage based on curve amplitude
            const maxCurveValue = Math.max(...curve);
            const suggestedPercent = Math.max(20, Math.min(100, Math.round((maxCurveValue / TOTAL) * 100)));
            
            percentInput.value = suggestedPercent;
            percentInput.dispatchEvent(new Event('input', { bubbles: true }));
            
            // Enable the channel checkbox if it was disabled
            if (checkbox && !checkbox.checked) {
              checkbox.checked = true;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
            
            // Force visual state refresh to ensure disabled channel transparency is removed
            const refreshDisplayFn = channelRow.refreshDisplayFn;
            if (refreshDisplayFn) {
              setTimeout(() => { refreshDisplayFn(); }, 10);
            }
          }

          // Force preview update after all DOM changes are complete
          if (typeof updatePreview === 'function') {
            updatePreview();
          }
          
          // Update processing detail for this channel
          if (typeof updateProcessingDetail === 'function') {
            updateProcessingDetail(channelName);
          }
          
          return {
            success: true,
            message: `Applied custom curve to ${channelName} channel`
          };

        } catch (error) {
          return {
            success: false,
            message: `Error applying curve to channel: ${error.message}`
          };
        }
      }

      /**
       * Get stored Smart key points for a channel (deep copy)
       */
      getAIKeyPoints(channelName) {
        try {
          channelName = this._resolveChannel(channelName);
          const { points: kp, interpolation: interp } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const suggestion = `No Smart key points yet for ${channelName}. They will be created automatically on first edit. Example: adjust_smart_key_point_by_index(ordinal=2, outputPercent=90) or insert_smart_key_point_at(inputPercent=50, outputPercent=50).`;
            return {
              success: true,
              channelName,
              keyPoints: [],
              interpolationType: (interp || 'smooth'),
              created: false,
              canAutoCreateOnEdit: true,
              message: suggestion,
              nextActions: [
                { name: 'adjust_smart_key_point_by_index', params: { ordinal: 2, outputPercent: 90 } },
                { name: 'insert_smart_key_point_at', params: { inputPercent: 50, outputPercent: 50 } }
              ]
            };
          }
          const list = kp.map(p => `${Math.round(p.input)},${Math.round(p.output)}`).join(' ');
          const msg = `Key points (${channelName}): ${list}`;
          return { success: true, channelName, keyPoints: kp.map(p => ({ input: p.input, output: p.output })), interpolationType: interp, message: msg };
        } catch (e) {
          return { success: false, message: `Error getting Smart key points: ${e.message}` };
        }
      }

      /**
       * Set Smart key points for a channel and apply the resulting curve
       */
      setAIKeyPoints(channelName, points, interpolationType = 'smooth') {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          if (!Array.isArray(points) || points.length < 2) {
            return { success: false, message: 'At least 2 key points are required' };
          }
          // Normalize and clamp via ControlPoints
          const norm = ControlPoints.normalize(points);
          // Interpolate to 256-point curve
          const curve = this._interpolateCurve(norm, interpolationType === 'linear' ? 'linear' : 'smooth');
          // Record key-point change for history linkage and apply curve
          const oldKP = window.loadedQuadData?.keyPoints?.[channelName] ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null;
          const oldInterp = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth';
          const extras = {
            oldKeyPoints: oldKP,
            newKeyPoints: norm.map(p => ({ input: p.input, output: p.output })),
            oldInterpolation: oldInterp,
            newInterpolation: (interpolationType === 'linear' ? 'linear' : 'smooth')
          };
          CurveHistory.recordKeyPointsChange(channelName, extras.oldKeyPoints, extras.newKeyPoints, extras.oldInterpolation, extras.newInterpolation);
          // Persist Smart key points BEFORE applying curve so downstream UI reflects latest counts
          ControlPoints.persist(channelName, norm, interpolationType);
          const applied = this._applyCurveToChannel(channelName, curve, extras);
          if (!applied.success) return applied;
          // Mark any contributing linearization as edited for display
          markLinearizationEdited(channelName);
          updatePreview();
          // Ensure processing panel reflects latest key-point count (in case panel was already open)
          if (typeof updateProcessingDetail === 'function') {
            updateProcessingDetail(channelName);
          }
          this._recordAction('setAIKeyPoints', { channelName, points: norm, interpolationType });
          return { success: true, message: `Updated Smart key points for ${channelName} (${norm.length} points)`, details: { keyPoints: norm } };
        } catch (e) {
          return { success: false, message: `Error setting Smart key points: ${e.message}` };
        }
      }

      /**
       * Extract adaptive Smart key points from the current curve (prefers loaded .quad curve if available)
       * and apply them to a channel. Useful for turning dense .quad data into an editable sparse set.
       */
      simplifyAIKeyPointsFromCurve(channelName, options = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          const row = document.querySelector(`tr[data-channel="${channelName}"]`);
          const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input').value) : TOTAL;
          // Prefer raw loaded .quad curve if present; otherwise use displayed curve
          let values = (window.loadedQuadData?.curves?.[channelName] && Array.isArray(window.loadedQuadData.curves[channelName]))
            ? window.loadedQuadData.curves[channelName]
            : make256(endVal, channelName, true);
          const maxErrorPercent = Math.max(0.05, Math.min(5, options.maxErrorPercent || KP_SIMPLIFY.maxErrorPercent || 1.0));
      const maxPoints = Math.max(2, Math.min(21, options.maxPoints || KP_SIMPLIFY.maxPoints || 21));
          const keyPoints = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent, maxPoints });
          return this.setAIKeyPoints(channelName, keyPoints, 'smooth');
        } catch (e) {
          return { success: false, message: `Error simplifying Smart key points: ${e.message}` };
        }
      }

      /**
       * Set AI key points for multiple channels as a single batch action
       * entries: [{ channelName, keyPoints, interpolationType }]
       */
      setAIKeyPointsBatch(entries = []) {
        try {
          if (!Array.isArray(entries) || entries.length === 0) {
            return { success: false, message: 'entries must be a non-empty array' };
          }

          // Begin batch
          CurveHistory.isBatchOperation = true;
          const channelActions = [];
          const results = [];
          const errors = [];

          for (const entry of entries) {
            try {
              let { channelName, keyPoints, interpolationType } = entry || {};
              channelName = this._resolveChannel(channelName);
              if (!Array.isArray(keyPoints) || keyPoints.length < 2) {
                errors.push(`${channelName}: at least 2 key points required`);
                continue;
              }
              const norm = ControlPoints.normalize(keyPoints);
              const interp = (interpolationType === 'linear' ? 'linear' : 'smooth');

              // Capture old state
              const oldCurveData = window.loadedQuadData?.curves?.[channelName] ?
                [...window.loadedQuadData.curves[channelName]] : null;
              const oldKP = window.loadedQuadData?.keyPoints?.[channelName] ? window.loadedQuadData.keyPoints[channelName].map(p => ({ input: p.input, output: p.output })) : null;
              const oldInterp = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth';
              const oldSource = window.loadedQuadData?.sources?.[channelName] || null;

              // Generate curve and persist key points before applying (so UI counts are up to date)
              const curve = this._interpolateCurve(norm, interp);
              try { ControlPoints.persist(channelName, norm, interp); } catch (e) { console.warn('Persist KP (batch) failed:', channelName, e); }

              const extras = { oldKeyPoints: oldKP, newKeyPoints: norm.map(p => ({ input: p.input, output: p.output })), oldInterpolation: oldInterp, newInterpolation: interp };
              const applied = this._applyCurveToChannel(channelName, curve, extras);
              if (!applied.success) { errors.push(`${channelName}: ${applied.message}`); continue; }

              markLinearizationEdited(channelName);

              channelActions.push({
                channelName,
                type: 'curve',
                oldValue: oldCurveData,
                newValue: [...curve],
                oldKeyPoints: oldKP,
                newKeyPoints: norm.map(p => ({ input: p.input, output: p.output })),
                oldInterpolation: oldInterp,
                newInterpolation: interp,
                oldSource: oldSource,
                newSource: 'smart'
              });
              results.push(`${channelName}: ${norm.length} key points`);

            } catch (err) {
              errors.push(`${entry?.channelName || 'unknown'}: ${err.message}`);
            }
          }

          // Record batch action and clear flag after debounce window
          if (channelActions.length > 0) {
            const batchDescription = `Batch set Smart key points for ${channelActions.length} channel(s)`;
            CurveHistory.recordBatchAction(batchDescription, channelActions);
            setTimeout(() => { CurveHistory.isBatchOperation = false; }, 1500);
          } else {
            CurveHistory.isBatchOperation = false;
          }

          // Refresh UI
          updatePreview();
          try {
            const current = getCurrentPrinter();
            current.channels.forEach((name) => { if (typeof updateProcessingDetail === 'function') updateProcessingDetail(name); });
          } catch {}

          if (errors.length > 0 && results.length === 0) {
            return { success: false, message: `All operations failed: ${errors.join('; ')}` };
          }
          if (errors.length > 0) {
            return { success: true, message: `Partial success. ${results.length} updated, ${errors.length} failed. ${errors.join('; ')}`, details: { updated: results, errors } };
          }
          return { success: true, message: `Updated Smart key points for ${results.length} channel(s).`, details: { updated: results } };

        } catch (e) {
          CurveHistory.isBatchOperation = false;
          return { success: false, message: `Batch set Smart key points failed: ${e.message}` };
        }
      }

      /**
       * Adjust a single Smart key point by ordinal (1-based, endpoints included)
       * Supports absolute or delta changes to input (X) and output (Y)
       */
      adjustAIKeyPointByIndex(channelName, ordinal, params = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          if (typeof ordinal !== 'number' || ordinal < 1 || ordinal > kp.length) {
            return { success: false, message: `Invalid ordinal ${ordinal}. Valid range: 1..${kp.length}` };
          }
          const gap = ControlPolicy.minGap;
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          const idx = ordinal - 1;
          let target = points[idx];
          // Compute new values
          let newInput = target.input;
          let newOutput = target.output;
          if (typeof params.inputPercent === 'number') newInput = params.inputPercent;
          if (typeof params.deltaInput === 'number') newInput = newInput + params.deltaInput;
          if (typeof params.deltaOutput === 'number') newOutput = newOutput + params.deltaOutput;
          // If an absolute output is provided, convert to pre-scale; may require End increase
          if (typeof params.outputPercent === 'number') {
            try {
              const row = document.querySelector(`tr[data-channel="${channelName}"]`);
              const endEl = row?.querySelector('.end-input');
              const pctEl = row?.querySelector('.percent-input');
              let endVal = InputValidator.clampEnd(endEl?.value || 0);
              const endLocked = !!(row?.hasAttribute('data-user-disabled') || endEl?.disabled || pctEl?.disabled);
              const oldScale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              const desiredAbs = Math.max(0, Math.min(100, params.outputPercent));
              let scale = (InputValidator.computePercentFromEnd(endVal)) / 100; // fraction of TOTAL
              if (scale <= 0 && desiredAbs > 0) {
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                // Channel effectively at 0%; raise End to minimally satisfy desiredAbs at pre-scale 100
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                }
                endVal = neededEnd;
                scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              }
              const pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
              if (pre > 100 + 1e-6) {
                // Need to increase End so pre-scale stays within [0,100]
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                if (neededEnd > endVal && endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  // Recompute scale
                  scale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                }
              }
              // Final pre-scale target under current/new scale
              newOutput = Math.max(0, Math.min(100, (scale > 0) ? (desiredAbs / scale) : desiredAbs));
              // If End increased (scale > oldScale), scale all other points down to keep their absolute outputs constant
              if (scale > oldScale + 1e-6) {
                const factor = oldScale / scale;
                for (let j = 0; j < points.length; j++) {
                  if (j === idx) continue;
                  points[j].output = ControlPolicy.clampY(points[j].output * factor);
                }
              }
            } catch (e) {
              console.warn('Absolute-to-prescale conversion failed:', e);
              newOutput = Math.max(0, Math.min(100, params.outputPercent));
            }
          }
          // Clamp output after conversions
          newOutput = Math.max(0, Math.min(100, newOutput));
          // Bounds for input to maintain order
          const prevX = idx > 0 ? points[idx - 1].input : 0;
          const nextX = idx < points.length - 1 ? points[idx + 1].input : 100;
          const minX = idx === 0 ? 0 : prevX + gap;
          const maxX = idx === points.length - 1 ? 100 : nextX - gap;
          newInput = Math.max(minX, Math.min(maxX, newInput));

          // Endpoint edits: interpret requested output as absolute axis % (0-100) and
          // convert to pre-scale percent so final (after End scaling) hits the requested value.
          if (idx === points.length - 1 && typeof params.outputPercent === 'number') {
            try {
              const row = document.querySelector(`tr[data-channel="${channelName}"]`);
              const endInput = row?.querySelector('.end-input');
              if (endInput) {
                const endVal = InputValidator.clampEnd(endInput.value);
                const endPercentOfTotal = InputValidator.computePercentFromEnd(endVal); // 0..100 of TOTAL
                const scale = Math.max(0, endPercentOfTotal) / 100; // fraction of TOTAL
                if (scale > 0) {
                  // We need pre-scale output so that (pre * scale) = requestedAbsolute
                  const desiredAbs = Math.max(0, Math.min(100, params.outputPercent));
                  newOutput = Math.max(0, Math.min(100, desiredAbs / scale));
                } else {
                  // End=0, keep as-is but clamp
                  newOutput = Math.max(0, Math.min(100, params.outputPercent));
                }
              }
            } catch (e) {
              console.warn('Endpoint absolute conversion failed:', e);
              newOutput = Math.max(0, Math.min(100, params.outputPercent));
            }
          }
          // Apply and re-set
          const preScaleEndpointPercent = (idx === points.length - 1 && typeof params.outputPercent === 'number')
            ? (function(){
                try {
                  const row = document.querySelector(`tr[data-channel="${channelName}"]`);
                  const endVal = InputValidator.clampEnd(row?.querySelector('.end-input')?.value || 0);
                  const endPct = InputValidator.computePercentFromEnd(endVal);
                  const scale = Math.max(0, endPct) / 100;
                  const desiredAbs = Math.max(0, Math.min(100, params.outputPercent));
                  if (scale > 0) return Math.max(0, Math.min(100, desiredAbs / scale));
                  return desiredAbs; // End=0 edge case
                } catch { return newOutput; }
              })()
            : null;

          points[idx] = { input: newInput, output: newOutput };
          const res = this.setAIKeyPoints(channelName, points, interpType);
          try {
            if (res && res.success && preScaleEndpointPercent !== null && window.loadedQuadData?.curves?.[channelName]) {
              const enforced = Math.round((Math.max(0, Math.min(100, preScaleEndpointPercent)) / 100) * TOTAL);
              const arr = window.loadedQuadData.curves[channelName];
              if (Array.isArray(arr) && arr.length === 256) {
                arr[arr.length - 1] = enforced;
              }
              if (typeof updatePreview === 'function') updatePreview();
              if (typeof updateProcessingDetail === 'function') updateProcessingDetail(channelName);
            }
          } catch (e) { console.warn('Endpoint enforcement failed:', e); }
          return res;
        } catch (e) {
          return { success: false, message: `Error adjusting Smart key point: ${e.message}` };
        }
      }

      /**
       * Insert a new AI key point at a specific input (X). If output (Y) omitted, sample current AI curve at X.
       */
      insertAIKeyPointAt(channelName, inputPercent, outputPercent = null) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          let x = typeof inputPercent === 'number' ? inputPercent : null;
          if (x === null || isNaN(x)) {
            return { success: false, message: 'inputPercent is required and must be a number (0-100).' };
          }
          x = Math.max(0, Math.min(100, x));
          // Prevent inserting directly on top of an existing X (within duplicateTolerance)
          const dupIdx0 = ControlPoints.nearestIndex(kp, x, ControlPolicy.duplicateTolerance);
          if (dupIdx0 !== null) {
            const existing = kp[dupIdx0];
            return { success: false, message: `A key point already exists at ${existing.input.toFixed(3)}%.` };
          }
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          // Ensure sorted by input
          points.sort((a, b) => a.input - b.input);
          const gap = ControlPolicy.minGap;
          // Find neighbors
          let insertIndex = 0;
          while (insertIndex < points.length && points[insertIndex].input < x) insertIndex++;
          const left = insertIndex > 0 ? points[insertIndex - 1] : null;
          const right = insertIndex < points.length ? points[insertIndex] : null;
          // Enforce spacing
          const leftBound = left ? left.input + gap : 0;
          const rightBound = right ? right.input - gap : 100;
          if (left && right && (right.input - left.input) <= 2 * gap) {
            return { success: false, message: `Not enough space to insert between ${left.input}% and ${right.input}%.` };
          }
          x = Math.max(leftBound, Math.min(rightBound, x));
          // Determine Y (treat provided outputPercent as ABSOLUTE; convert to pre-scale and raise End if needed)
          let y;
          if (typeof outputPercent === 'number') {
            try {
              const row = document.querySelector(`tr[data-channel="${channelName}"]`);
              const endEl = row?.querySelector('.end-input');
              const pctEl = row?.querySelector('.percent-input');
              let endVal = InputValidator.clampEnd(endEl?.value || 0);
              const oldScale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              const desiredAbs = Math.max(0, Math.min(100, outputPercent));
              let scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              if (scale <= 0 && desiredAbs > 0) {
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                }
                endVal = neededEnd;
                scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              }
              const pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
              if (pre > 100 + 1e-6) {
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (neededEnd > endVal && endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  // Recompute scale
                  const newScale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                  // Scale existing points down so their absolute outputs remain unchanged
                  const factor = (oldScale > 0) ? (oldScale / newScale) : 0;
                  for (let j = 0; j < points.length; j++) {
                    points[j].output = ControlPolicy.clampY(points[j].output * factor);
                  }
                  scale = newScale;
                  endVal = neededEnd;
                }
              }
              y = Math.max(0, Math.min(100, (scale > 0) ? (desiredAbs / scale) : desiredAbs));
            } catch (e) {
              console.warn('Insert absolute-to-prescale conversion failed:', e);
              y = ControlPolicy.clampY(outputPercent);
            }
          } else {
            y = ControlPoints.sampleY(points, interpType, x);
          }
          // Insert and persist
          points.splice(insertIndex, 0, { input: x, output: y });
          return this.setAIKeyPoints(channelName, points, interpType);
        } catch (e) {
          return { success: false, message: `Error inserting Smart key point: ${e.message}` };
        }
      }

      /**
       * Insert a new AI key point between two adjacent ordinals. If output omitted, sample current AI curve at midpoint.
       */
      insertAIKeyPointBetween(channelName, leftOrdinal, rightOrdinal, outputPercent = null) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          const n = kp.length;
          if (typeof leftOrdinal !== 'number' || typeof rightOrdinal !== 'number') {
            return { success: false, message: 'leftOrdinal and rightOrdinal must be numbers.' };
          }
          if (leftOrdinal < 1 || rightOrdinal < 1 || leftOrdinal > n || rightOrdinal > n) {
            return { success: false, message: `Ordinals must be within 1..${n}.` };
          }
          if (rightOrdinal !== leftOrdinal + 1) {
            return { success: false, message: 'Ordinals must be adjacent (rightOrdinal = leftOrdinal + 1).' };
          }
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          // Ensure sorted by input
          points.sort((a, b) => a.input - b.input);
          const left = points[leftOrdinal - 1];
          const right = points[rightOrdinal - 1];
          const gap = ControlPolicy.minGap;
          if ((right.input - left.input) <= 2 * gap) {
            return { success: false, message: `Not enough space to insert between ${left.input}% and ${right.input}%.` };
          }
          // Midpoint X by default
          let x = (left.input + right.input) / 2;
          // Prevent inserting on top of an existing X within tolerance
          const dupIdx1 = ControlPoints.nearestIndex(kp, x, ControlPolicy.duplicateTolerance);
          if (dupIdx1 !== null) {
            const existing = kp[dupIdx1];
            return { success: false, message: `A key point already exists at ${existing.input.toFixed(3)}%.` };
          }
          x = Math.max(left.input + gap, Math.min(right.input - gap, x));
          // Determine Y (treat provided outputPercent as ABSOLUTE; convert to pre-scale and raise End if needed)
          let y;
          if (typeof outputPercent === 'number') {
            try {
              const row = document.querySelector(`tr[data-channel="${channelName}"]`);
              const endEl = row?.querySelector('.end-input');
              const pctEl = row?.querySelector('.percent-input');
              let endVal = InputValidator.clampEnd(endEl?.value || 0);
              const endLocked = !!(row?.hasAttribute('data-user-disabled') || endEl?.disabled || pctEl?.disabled);
              const oldScale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              const desiredAbs = Math.max(0, Math.min(100, outputPercent));
              let scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              if (scale <= 0 && desiredAbs > 0) {
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                }
                endVal = neededEnd;
                scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              }
              const pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
              if (pre > 100 + 1e-6) {
                const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                if (endLocked) {
                  showStatus(`${channelName} edit blocked: exceeds ink limit (${InputValidator.computePercentFromEnd(endVal).toFixed(1)}%).`);
                  return { success: false, message: 'Edit blocked: exceeds ink limit' };
                }
                if (neededEnd > endVal && endEl && pctEl) {
                  endEl.value = String(neededEnd);
                  pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                  endEl.dispatchEvent(new Event('input', { bubbles: true }));
                  pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                  console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  const newScale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                  const factor = (oldScale > 0) ? (oldScale / newScale) : 0;
                  for (let j = 0; j < points.length; j++) {
                    points[j].output = ControlPolicy.clampY(points[j].output * factor);
                  }
                  scale = newScale;
                  endVal = neededEnd;
                }
              }
              y = Math.max(0, Math.min(100, (scale > 0) ? (desiredAbs / scale) : desiredAbs));
            } catch (e) {
              console.warn('Insert-between absolute-to-prescale conversion failed:', e);
              y = ControlPolicy.clampY(outputPercent);
            }
          } else {
            y = ControlPoints.sampleY(points, interpType, x);
          }
          // Insert and persist
          points.splice(leftOrdinal, 0, { input: x, output: y });
          return this.setAIKeyPoints(channelName, points, interpType);
        } catch (e) {
          return { success: false, message: `Error inserting Smart key point: ${e.message}` };
        }
      }

      /**
       * Delete an AI key point by ordinal (1-based). Endpoints blocked by default.
       */
      deleteAIKeyPointByIndex(channelName, ordinal, options = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interp } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interp } = ControlPoints.get(channelName));
          }
          if (typeof ordinal !== 'number' || ordinal < 1 || ordinal > kp.length) {
            return { success: false, message: `Invalid ordinal ${ordinal}. Valid range: 1..${kp.length}` };
          }
          const allowEndpoint = options.allowEndpoint === true;
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          const idx = ordinal - 1;
          const isEndpoint = (idx === 0 || idx === points.length - 1);
          if (isEndpoint && !allowEndpoint) {
            return { success: false, message: 'Endpoint deletion is blocked by default. Set allowEndpoint=true to remove endpoints.' };
          }
          if (points.length - 1 < 2) {
            return { success: false, message: 'Cannot delete: at least 2 key points are required.' };
          }
          points.splice(idx, 1);
          return this.setAIKeyPoints(channelName, points, interp);
        } catch (e) {
          return { success: false, message: `Error deleting Smart key point: ${e.message}` };
        }
      }

      /**
       * Delete the Smart key point nearest to a given input percentage within a tolerance. Endpoints blocked by default.
       */
      deleteAIKeyPointNearInput(channelName, inputPercent, options = {}) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          let { points: kp, interpolation: interp } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interp } = ControlPoints.get(channelName));
          }
          if (typeof inputPercent !== 'number' || isNaN(inputPercent)) {
            return { success: false, message: 'inputPercent must be a number (0-100).' };
          }
          const x = ControlPolicy.clampX(inputPercent);
          const tolerance = typeof options.tolerance === 'number' ? Math.max(0, options.tolerance) : ControlPolicy.defaultTolerance;
          const allowEndpoint = options.allowEndpoint === true;
          const points = kp.map(p => ({ input: p.input, output: p.output }));
          const nearest = ControlPoints.nearestIndex(points, x, tolerance);
          if (nearest === null) {
            return { success: false, message: `No key point found within ±${tolerance}% of ${x}%.` };
          }
          const isEndpoint = (nearest === 0 || nearest === points.length - 1);
          if (isEndpoint && !allowEndpoint) {
            return { success: false, message: 'Nearest point is an endpoint; endpoint deletion is blocked by default.' };
          }
          if (points.length - 1 < 2) {
            return { success: false, message: 'Cannot delete: at least 2 key points are required.' };
          }
          // Create reduced set excluding selected index
          const reduced = kp.filter((_, i) => i !== nearest).map(p => ({ input: p.input, output: p.output }));
          return this.setAIKeyPoints(channelName, reduced, interp);
        } catch (e) {
          return { success: false, message: `Error deleting Smart key point: ${e.message}` };
        }
      }

      /**
       * Insert multiple Smart key points in a single batch action for one channel
       * inserts: [{ inputPercent, outputPercent? }]
       */
      insertAIKeyPointsBatch(channelName, inserts = []) {
        if (!window.EDIT_MODE_ENABLED) {
          return { success: false, message: 'Edit mode is off — enable Edit Curves to edit.' };
        }
        try {
          channelName = this._resolveChannel(channelName);
          if (!Array.isArray(inserts) || inserts.length === 0) {
            return { success: false, message: 'inserts must be a non-empty array' };
          }
          let { points: kp, interpolation: interpType } = ControlPoints.get(channelName);
          if (!kp || kp.length < 2) {
            const ensured = ensureEditableKeyPointsForChannel(channelName, 'smooth');
            if (!ensured.success) return { success: false, message: ensured.message || `No Smart key points stored for ${channelName}.` };
            ({ points: kp, interpolation: interpType } = ControlPoints.get(channelName));
          }
          let points = kp.map(p => ({ input: p.input, output: p.output }));
          const gap = ControlPolicy.minGap;
          // Cache channel End UI refs for efficient updates
          const row = document.querySelector(`tr[data-channel="${channelName}"]`);
          const endEl = row?.querySelector('.end-input');
          const pctEl = row?.querySelector('.percent-input');
          let endVal = InputValidator.clampEnd(endEl?.value || 0);
          let scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
          // Sort inserts by input to produce deterministic results
          const sorted = inserts.map(p => ({
            input: ControlPolicy.clampX(Number(p.inputPercent)),
            output: typeof p.outputPercent === 'number' ? ControlPolicy.clampY(Number(p.outputPercent)) : null
          })).sort((a, b) => a.input - b.input);
          for (const ins of sorted) {
            // Skip if attempting to insert on top of an existing X within tolerance
            const dupIdx = ControlPoints.nearestIndex(points, ins.input, ControlPolicy.duplicateTolerance);
            if (dupIdx !== null) {
              continue; // silently skip duplicates in batch
            }
            // Sample output if not provided
            let y = ins.output;
            if (y === null || typeof y !== 'number' || isNaN(y)) {
              // Ensure points are sorted for sampling
              points.sort((a, b) => a.input - b.input);
              y = ControlPoints.sampleY(points, interpType, ins.input);
            } else {
              // Treat provided output as ABSOLUTE; convert to pre-scale and raise End if needed
              try {
                const desiredAbs = Math.max(0, Math.min(100, y));
                const oldScale = scale;
                if (scale <= 0 && desiredAbs > 0) {
                  const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                  if (endEl && pctEl) {
                    endEl.value = String(neededEnd);
                    pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                    endEl.dispatchEvent(new Event('input', { bubbles: true }));
                    pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                    if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                    showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                  }
                  endVal = neededEnd;
                  scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
                }
                let pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
                if (pre > 100 + 1e-6) {
                  const neededEnd = Math.round((desiredAbs / 100) * TOTAL);
                  if (neededEnd > endVal && endEl && pctEl) {
                    endEl.value = String(neededEnd);
                    pctEl.value = InputValidator.computePercentFromEnd(neededEnd).toFixed(1);
                    endEl.dispatchEvent(new Event('input', { bubbles: true }));
                    pctEl.dispatchEvent(new Event('input', { bubbles: true }));
                    if (DEBUG_LOGS) console.log(`[INK] ${channelName} channel ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                    showStatus(`${channelName} ink limit changed to ${InputValidator.computePercentFromEnd(neededEnd).toFixed(1)}%`);
                    const newScale = (InputValidator.computePercentFromEnd(neededEnd)) / 100;
                    const factor = (oldScale > 0) ? (oldScale / newScale) : 0;
                    for (let j = 0; j < points.length; j++) {
                      points[j].output = ControlPolicy.clampY(points[j].output * factor);
                    }
                    scale = newScale;
                    endVal = neededEnd;
                  }
                  // recompute pre with latest scale
                  pre = (scale > 0) ? (desiredAbs / scale) : desiredAbs;
                }
                y = Math.max(0, Math.min(100, pre));
              } catch (e) {
                console.warn('Batch insert absolute-to-prescale conversion failed:', e);
                y = ControlPolicy.clampY(y);
              }
            }
            // Constrain X within neighbor gap
            points.sort((a, b) => a.input - b.input);
            let x = ins.input;
            for (let i = 0; i < points.length - 1; i++) {
              if (x >= points[i].input && x <= points[i + 1].input) {
                x = Math.max(points[i].input + gap, Math.min(points[i + 1].input - gap, x));
                break;
              }
            }
            points.push({ input: x, output: y });
            points = ControlPoints.normalize(points);
          }
          // Apply once to create a single undoable action
          return this.setAIKeyPoints(channelName, points, interpType);
        } catch (e) {
          return { success: false, message: `Error in batch insert: ${e.message}` };
        }
      }

      // === Smart Curve aliases (non-breaking rename: AI → Smart) ===
      getSmartKeyPoints(channelName) { return this.getAIKeyPoints(channelName); }
      setSmartKeyPoints(channelName, keyPoints, interpolationType = 'smooth') { return this.setAIKeyPoints(channelName, keyPoints, interpolationType); }
      setSmartKeyPointsBatch(entries = []) { return this.setAIKeyPointsBatch(entries); }
      simplifySmartKeyPointsFromCurve(channelName, options = {}) { return this.simplifyAIKeyPointsFromCurve(channelName, options); }
      adjustSmartKeyPointByIndex(channelName, ordinal, params = {}) { return this.adjustAIKeyPointByIndex(channelName, ordinal, params); }
      insertSmartKeyPointAt(channelName, inputPercent, outputPercent = null) { return this.insertAIKeyPointAt(channelName, inputPercent, outputPercent); }
      insertSmartKeyPointBetween(channelName, leftOrdinal, rightOrdinal, outputPercent = null) { return this.insertAIKeyPointBetween(channelName, leftOrdinal, rightOrdinal, outputPercent); }
      insertSmartKeyPointsBatch(channelName, inserts = []) { return this.insertAIKeyPointsBatch(channelName, inserts); }
      deleteSmartKeyPointByIndex(channelName, ordinal, options = {}) { return this.deleteAIKeyPointByIndex(channelName, ordinal, options); }
      deleteSmartKeyPointNearInput(channelName, inputPercent, options = {}) { return this.deleteAIKeyPointNearInput(channelName, inputPercent, options); }
    }

    /**
     * Get current printer configuration
     * @returns {Object} Current printer object with name and channels
     */
    function getCurrentPrinter() {
      const printerSelect = document.getElementById('printerSelect');
      if (!printerSelect) {
        return PRINTERS.P700P900; // Default fallback
      }
      return PRINTERS[printerSelect.value] || PRINTERS.P700P900;
    }

    // Create singleton instance
    const quadGenActions = new QuadGenActions();

    // Debug utilities for validating overlay vs. plotted curve
    const DebugUtils = {
      /**
       * Compare Smart key points (as drawn) against the plotted curve values used in the chart.
       * Logs a table with expected (from make256) vs actual (pre‑scale × End%) and delta in %.
       * @param {string} channelName - channel to inspect (default resolves to first enabled if omitted)
       * @param {object} options - { thresholdPercent?: number }
       * @returns {Array} rows with idx, X%, expected%, actual%, delta%
       */
      compareKeyPointsToPlot(channelName = null, options = {}) {
        try {
          // Resolve channel
          const currentPrinter = getCurrentPrinter();
          let ch = channelName;
          if (!ch || !currentPrinter.channels.includes(ch)) {
            // choose first enabled channel
            const rows = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
            const enabled = rows.find(tr => InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0) > 0);
            ch = enabled ? enabled.getAttribute('data-channel') : (currentPrinter.channels[0] || 'K');
          }

          const row = document.querySelector(`tr[data-channel="${ch}"]`);
          if (!row) throw new Error(`Channel row not found for ${ch}`);
          const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
          if (endVal <= 0) throw new Error(`${ch} channel is disabled (End=0)`);

          // Gather Smart key points
          const kp = ControlPoints.get(ch).points;
          if (!Array.isArray(kp) || kp.length < 2) throw new Error(`No Smart key points for ${ch}`);

          // Build plotted values (same path as chart)
          const values = make256(endVal, ch, true); // 256 integers 0..endVal (after processing)
          const endPct = InputValidator.computePercentFromEnd(endVal);
          const endScale = Math.max(0, endPct) / 100; // fraction of TOTAL for overlay mapping

          function expectedAt(xp) {
            const N = values.length;
            const t = Math.max(0, Math.min(1, xp / 100)) * (N - 1);
            const i0 = Math.floor(t);
            const i1 = Math.min(N - 1, Math.ceil(t));
            const a = t - i0;
            const v = (1 - a) * values[i0] + a * values[i1]; // absolute (0..End)
            return endVal > 0 ? (v / endVal) * 100 : 0; // percent of End (chart percent)
          }

          // Compute rows
          const rows = kp.map((p, i) => {
            const xp = Math.max(0, Math.min(100, Number(p.input || 0)));
            const pre = Math.max(0, Math.min(100, Number(p.output || 0)));
            const actual = Math.max(0, Math.min(100, pre * endScale)); // overlay absolute percent
            const expected = expectedAt(xp);
            const delta = actual - expected;
            return {
              idx: i + 1,
              X_percent: +xp.toFixed(3),
              expected_percent: +expected.toFixed(3),
              actual_percent: +actual.toFixed(3),
              delta_percent: +delta.toFixed(3)
            };
          });

          const threshold = typeof options.thresholdPercent === 'number' ? Math.max(0, options.thresholdPercent) : 0.25;
          const maxAbsDelta = rows.reduce((m, r) => Math.max(m, Math.abs(r.delta_percent)), 0);
          console.table(rows);
          if (maxAbsDelta > threshold) {
            console.warn(`[DEBUG] Max delta ${maxAbsDelta.toFixed(3)}% exceeds threshold ${threshold}% on ${ch}.`);
          } else {
            console.log(`[DEBUG] All deltas within ±${threshold}% on ${ch}. Max |delta|=${maxAbsDelta.toFixed(3)}%`);
          }
          return rows;
        } catch (e) {
          console.warn('compareKeyPointsToPlot error:', e.message || e);
          return [];
        }
      }
    };

    // Expose debug helpers
    window.quadGenDebug = DebugUtils;

    /**
     * Claude Sonnet 4 API function definitions for quadGEN operations
     */
    const CLAUDE_FUNCTIONS = [
      {
        name: "set_edit_mode",
        description: "Enable or disable Edit Mode for key‑point editing and overlays.",
        parameters: {
          type: "object",
          properties: {
            enabled: { type: "boolean", description: "true to enable Edit Mode; false to disable" }
          },
          required: ["enabled"]
        }
      },
      {
        name: "explain_lab_linearization",
        description: "Return a concise explanation of quadGEN's LAB linearization and plotting semantics for user-facing help.",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "set_channel_value",
        description: "Set the ink limit percentage for a specific channel",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            percentage: {
              type: "number",
              description: "Ink limit percentage (0-100)",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["channelName", "percentage"]
        }
      },
      {
        name: "set_channel_end_value",
        description: "Set the ink limit end value for a specific channel (0-64000 range)",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            endValue: {
              type: "number",
              description: "Ink limit end value (0-64000). Common values: 21000=33%, 32000=50%, 64000=100%",
              minimum: 0,
              maximum: 64000
            }
          },
          required: ["channelName", "endValue"]
        }
      },
      {
        name: "apply_to_all_channels",
        description: "Apply the same ink limit percentage to all enabled channels",
        parameters: {
          type: "object",
          properties: {
            percentage: {
              type: "number",
              description: "Ink limit percentage to apply to all enabled channels (0-100)",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["percentage"]
        }
      },
      {
        name: "apply_end_to_all_channels",
        description: "Apply the same ink limit end value to all enabled channels",
        parameters: {
          type: "object",
          properties: {
            endValue: {
              type: "number",
              description: "Ink limit end value to apply to all enabled channels (0-64000)",
              minimum: 0,
              maximum: 64000
            }
          },
          required: ["endValue"]
        }
      },
      {
        name: "enable_disable_channel",
        description: "Enable or disable a specific ink channel",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            enabled: {
              type: "boolean",
              description: "Whether to enable (true) or disable (false) the channel"
            }
          },
          required: ["channelName", "enabled"]
        }
      },
      {
        name: "batch_channel_operations",
        description: "Perform multiple channel enable/disable operations in a single call",
        parameters: {
          type: "object",
          properties: {
            operations: {
              type: "array",
              description: "Array of channel operations to perform",
              items: {
                type: "object",
                properties: {
                  channelName: {
                    type: "string",
                    description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  enabled: {
                    type: "boolean",
                    description: "Whether to enable (true) or disable (false) the channel"
                  }
                },
                required: ["channelName", "enabled"]
              }
            }
          },
          required: ["operations"]
        }
      },
      {
        name: "open_global_linearization_file_picker",
        description: "Open file picker dialog to load global linearization file (.cube, .txt, or .acv)",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "open_per_channel_linearization_file_picker",
        description: "Open file picker dialog to load linearization file for a specific channel",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name to load linearization for",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["channelName"]
        }
      },
      {
        name: "load_sample_lab_file",
        description: "Load the sample LAB measurement data file for testing",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "load_sample_cube_file",
        description: "Load the sample LUT cube file for testing",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "load_lab_data_global",
        description: "Load LAB measurement data from pasted text for global linearization",
        parameters: {
          type: "object",
          properties: {
            labData: {
              type: "string",
              description: "LAB measurement data in standard format (GRAY_PERCENT LAB_L [LAB_A LAB_B])"
            }
          },
          required: ["labData"]
        }
      },
      {
        name: "load_lab_data_per_channel",
        description: "Load LAB measurement data from pasted text for specific channel linearization",
        parameters: {
          type: "object",
          properties: {
            labData: {
              type: "string",
              description: "LAB measurement data in standard format (GRAY_PERCENT LAB_L [LAB_A LAB_B])"
            },
            channelName: {
              type: "string",
              description: "Channel name to apply the LAB data to",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["labData", "channelName"]
        }
      },
      {
        name: "load_cube_data_global",
        description: "Load .cube (LUT) file data from pasted text for global linearization",
        parameters: {
          type: "object",
          properties: {
            cubeData: {
              type: "string",
              description: ".cube file data in standard LUT format (supports 1D and 3D LUTs)"
            }
          },
          required: ["cubeData"]
        }
      },
      {
        name: "load_cube_data_per_channel",
        description: "Load .cube (LUT) file data from pasted text for specific channel linearization",
        parameters: {
          type: "object",
          properties: {
            cubeData: {
              type: "string",
              description: ".cube file data in standard LUT format (supports 1D and 3D LUTs)"
            },
            channelName: {
              type: "string",
              description: "Channel name to apply the cube data to",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["cubeData", "channelName"]
        }
      },
      {
        name: "generate_and_download_quad_file",
        description: "Generate, save, export, or download the .quad file with current settings",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "set_filename",
        description: "Set the filename for the .quad file (without extension)",
        parameters: {
          type: "object",
          properties: {
            filename: {
              type: "string",
              description: "Desired filename without extension (will be sanitized automatically)"
            }
          },
          required: ["filename"]
        }
      },
      {
        name: "set_global_linearization",
        description: "Enable or disable global linearization (requires linearization file to be loaded)",
        parameters: {
          type: "object",
          properties: {
            enabled: {
              type: "boolean",
              description: "Whether to enable (true) or disable (false) global linearization"
            }
          },
          required: ["enabled"]
        }
      },
      {
        name: "set_per_channel_linearization",
        description: "Enable or disable linearization for a specific channel (requires linearization file to be loaded for that channel)",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name (K, C, M, Y, LC, LM, LK, LLK, V, MK)",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            enabled: {
              type: "boolean",
              description: "Whether to enable (true) or disable (false) linearization for this channel"
            }
          },
          required: ["channelName", "enabled"]
        }
      },
      {
        name: "set_interpolation_method",
        description: "Set the interpolation method for curve generation",
        parameters: {
          type: "object",
          properties: {
            method: {
              type: "string",
              description: "Interpolation method to use",
              enum: ["pchip", "linear"]
            }
          },
          required: ["method"]
        }
      },
      {
        name: "set_smoothing_percentage",
        description: "Set the data point smoothing percentage (0-90%)",
        parameters: {
          type: "object",
          properties: {
            percentage: {
              type: "number",
              description: "Smoothing percentage (0=none, 90=maximum)",
              minimum: 0,
              maximum: 90
            }
          },
          required: ["percentage"]
        }
      },
      {
        name: "change_printer",
        description: "Switch between supported printer models",
        parameters: {
          type: "object",
          properties: {
            printerName: {
              type: "string",
              description: "Printer model to switch to",
              enum: ["P700P900", "P5-7-9000", "P800", "P400", "x900", "3880-7880", "x800-x890", "P4-6-8000"]
            }
          },
          required: ["printerName"]
        }
      },
      {
        name: "generate_custom_curve", 
        description: "Generate a curve from explicit numerical key points (single channel). Prefer set_ai_key_points for AI-driven curves.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel name to generate curve for",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            keyPoints: {
              type: "array",
              description: "Array of curve control points with input/output values (0-100 range)",
              items: {
                type: "object",
                properties: {
                  input: {
                    type: "number",
                    description: "Input position (0-100%)",
                    minimum: 0,
                    maximum: 100
                  },
                  output: {
                    type: "number", 
                    description: "Output value (0-100%)",
                    minimum: 0,
                    maximum: 100
                  }
                },
                required: ["input", "output"]
              },
              minItems: 2
            },
            interpolationType: {
              type: "string",
              description: "Interpolation method between points",
              enum: ["linear", "smooth"],
              default: "smooth"
            }
          },
          required: ["channelName", "keyPoints"]
        }
      },
      {
        name: "get_ai_key_points",
        description: "Get stored AI key points (endpoints included). If channelName is omitted, uses the first enabled channel. If none exist yet, returns an empty list with suggestions; edit calls will auto‑create.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: []
        }
      },
      {
        name: "get_smart_key_points",
        description: "Get stored Smart key points (endpoints included). If channelName is omitted, uses the first enabled channel. If none exist yet, returns an empty list with suggestions; edit calls will auto‑create.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: []
        }
      },
      {
        name: "set_ai_key_points",
        description: "Replace AI key points and reapply the curve. If channelName is omitted, uses the first enabled channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            keyPoints: {
              type: "array",
              description: "Array of {input, output} in 0-100%",
              items: {
                type: "object",
                properties: {
                  input: { type: "number", minimum: 0, maximum: 100 },
                  output: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["input", "output"]
              },
              minItems: 2
            },
            interpolationType: {
              type: "string",
              enum: ["linear", "smooth"],
              default: "smooth"
            }
          },
          required: ["keyPoints"]
        }
      },
      {
        name: "set_smart_key_points",
        description: "Replace Smart key points and reapply the curve. If channelName is omitted, uses the first enabled channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            keyPoints: {
              type: "array",
              description: "Array of {input, output} in 0-100%",
              items: {
                type: "object",
                properties: {
                  input: { type: "number", minimum: 0, maximum: 100 },
                  output: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["input", "output"]
              },
              minItems: 2
            },
            interpolationType: {
              type: "string",
              enum: ["linear", "smooth"],
              default: "smooth"
            }
          },
          required: ["keyPoints"]
        }
      },
      {
        name: "set_ai_key_points_batch",
        description: "Replace AI key points for multiple channels and reapply curves as a single batch action.",
        parameters: {
          type: "object",
          properties: {
            entries: {
              type: "array",
              description: "List of per-channel key points updates",
              items: {
                type: "object",
                properties: {
                  channelName: {
                    type: "string",
                    description: "Channel to update",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  keyPoints: {
                    type: "array",
                    description: "Array of {input, output} in 0-100%",
                    items: {
                      type: "object",
                      properties: {
                        input: { type: "number", minimum: 0, maximum: 100 },
                        output: { type: "number", minimum: 0, maximum: 100 }
                      },
                      required: ["input", "output"]
                    },
                    minItems: 2
                  },
                  interpolationType: {
                    type: "string",
                    enum: ["linear", "smooth"],
                    default: "smooth"
                  }
                },
                required: ["channelName", "keyPoints"]
              },
              minItems: 1
            }
          },
          required: ["entries"]
        }
      },
      {
        name: "set_smart_key_points_batch",
        description: "Replace Smart key points for multiple channels and reapply curves as a single batch action.",
        parameters: {
          type: "object",
          properties: {
            entries: {
              type: "array",
              description: "List of per-channel key points updates",
              items: {
                type: "object",
                properties: {
                  channelName: {
                    type: "string",
                    description: "Channel to update",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  keyPoints: {
                    type: "array",
                    description: "Array of {input, output} in 0-100%",
                    items: {
                      type: "object",
                      properties: {
                        input: { type: "number", minimum: 0, maximum: 100 },
                        output: { type: "number", minimum: 0, maximum: 100 }
                      },
                      required: ["input", "output"]
                    },
                    minItems: 2
                  },
                  interpolationType: {
                    type: "string",
                    enum: ["linear", "smooth"],
                    default: "smooth"
                  }
                },
                required: ["channelName", "keyPoints"]
              },
              minItems: 1
            }
          },
          required: ["entries"]
        }
      },
      {
        name: "simplify_ai_key_points_from_curve",
        description: "Extract adaptive key points from the current curve (prefers loaded .quad) and apply them to a channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to simplify",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            maxErrorPercent: {
              type: "number",
              description: "Max allowed deviation in % (0.05–5). Default 1.0",
              minimum: 0.05,
              maximum: 5
            },
            maxPoints: {
              type: "integer",
              description: "Upper bound on points (2–20). Default 16",
              minimum: 2,
              maximum: 20
            }
          },
          required: ["channelName"]
        }
      },
      {
        name: "simplify_smart_key_points_from_curve",
        description: "Extract adaptive Smart key points from the current curve (prefers loaded .quad) and apply them to a channel.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to simplify",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            maxErrorPercent: {
              type: "number",
              description: "Max allowed deviation in % (0.05–5). Default 1.0",
              minimum: 0.05,
              maximum: 5
            },
            maxPoints: {
              type: "integer",
              description: "Upper bound on points (2–20). Default 16",
              minimum: 2,
              maximum: 20
            }
          },
          required: ["channelName"]
        }
      },
      {
        name: "adjust_ai_key_point_by_index",
        description: "Adjust a single AI key point by ordinal (1‑based, endpoints included). If channelName is omitted, uses the first enabled channel. If no AI key points exist yet, quadGEN will silently create them from the current curve/data and then apply the edit.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point (including endpoints)",
              minimum: 1
            },
            inputPercent: {
              type: "number",
              description: "Absolute new input (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Absolute new output (Y) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            deltaInput: {
              type: "number",
              description: "Delta to add to input (X) in percentage points"
            },
            deltaOutput: {
              type: "number",
              description: "Delta to add to output (Y) in percentage points"
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "adjust_smart_key_point_by_index",
        description: "Adjust a single Smart key point by ordinal (1‑based, endpoints included). If channelName is omitted, uses the first enabled channel. If no Smart key points exist yet, quadGEN will create them from the current curve/data and then apply the edit.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point (including endpoints)",
              minimum: 1
            },
            inputPercent: {
              type: "number",
              description: "Absolute new input (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Absolute new output (Y) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            deltaInput: {
              type: "number",
              description: "Delta to add to input (X) in percentage points"
            },
            deltaOutput: {
              type: "number",
              description: "Delta to add to output (Y) in percentage points"
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "insert_ai_key_point_at",
        description: "Insert a new AI key point at a given input (X). If output is omitted, sample current AI curve at X. If no AI key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current AI curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "insert_smart_key_point_at",
        description: "Insert a new Smart key point at a given input (X). If output is omitted, sample current Smart curve at X. If no Smart key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current Smart curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "insert_ai_key_point_between",
        description: "Insert a new AI key point between two adjacent ordinals. If output is omitted, sample at the midpoint. If no AI key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            leftOrdinal: {
              type: "integer",
              description: "Left ordinal (1-based)",
              minimum: 1
            },
            rightOrdinal: {
              type: "integer",
              description: "Right ordinal (must be leftOrdinal+1)",
              minimum: 2
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current AI curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["leftOrdinal", "rightOrdinal"]
        }
      },
      {
        name: "insert_smart_key_point_between",
        description: "Insert a new Smart key point between two adjacent ordinals. If output is omitted, sample at the midpoint. If no Smart key points exist yet, they will be created from the current curve/data.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            leftOrdinal: {
              type: "integer",
              description: "Left ordinal (1-based)",
              minimum: 1
            },
            rightOrdinal: {
              type: "integer",
              description: "Right ordinal (must be leftOrdinal+1)",
              minimum: 2
            },
            outputPercent: {
              type: "number",
              description: "Optional output (Y) in % (0-100) — if omitted, sampled from current Smart curve",
              minimum: 0,
              maximum: 100
            }
          },
          required: ["leftOrdinal", "rightOrdinal"]
        }
      },
      {
        name: "insert_ai_key_points_batch",
        description: "Insert multiple AI key points for a single channel in one batch (single undoable action).",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to update",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inserts: {
              type: "array",
              description: "List of points to insert",
              items: {
                type: "object",
                properties: {
                  inputPercent: { type: "number", minimum: 0, maximum: 100 },
                  outputPercent: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["inputPercent"]
              },
              minItems: 1
            }
          },
          required: ["channelName", "inserts"]
        }
      },
      {
        name: "insert_smart_key_points_batch",
        description: "Insert multiple Smart key points for a single channel in one batch (single undoable action).",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Channel to update",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inserts: {
              type: "array",
              description: "List of points to insert",
              items: {
                type: "object",
                properties: {
                  inputPercent: { type: "number", minimum: 0, maximum: 100 },
                  outputPercent: { type: "number", minimum: 0, maximum: 100 }
                },
                required: ["inputPercent"]
              },
              minItems: 1
            }
          },
          required: ["channelName", "inserts"]
        }
      },
      {
        name: "delete_ai_key_point_by_index",
        description: "Delete a single AI key point by ordinal (1‑based). Endpoints blocked by default. If no AI key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point to delete",
              minimum: 1
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "delete_smart_key_point_by_index",
        description: "Delete a single Smart key point by ordinal (1‑based). Endpoints blocked by default. If no Smart key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            ordinal: {
              type: "integer",
              description: "1-based index of the key point to delete",
              minimum: 1
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["ordinal"]
        }
      },
      {
        name: "delete_ai_key_point_near_input",
        description: "Delete the AI key point nearest to a given input % within a tolerance. Endpoints blocked by default. If no AI key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Target input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            tolerance: {
              type: "number",
              description: "Maximum distance in % to consider a match (default 1.0)"
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "delete_smart_key_point_near_input",
        description: "Delete the Smart key point nearest to a given input % within a tolerance. Endpoints blocked by default. If no Smart key points exist yet, they will be created from the current curve/data first.",
        parameters: {
          type: "object",
          properties: {
            channelName: {
              type: "string",
              description: "Optional channel name. If omitted, the first enabled channel is used.",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            inputPercent: {
              type: "number",
              description: "Target input position (X) in % (0-100)",
              minimum: 0,
              maximum: 100
            },
            tolerance: {
              type: "number",
              description: "Maximum distance in % to consider a match (default 1.0)"
            },
            allowEndpoint: {
              type: "boolean",
              description: "Whether to allow deletion of endpoints (defaults to false)",
              default: false
            }
          },
          required: ["inputPercent"]
        }
      },
      {
        name: "copy_curve_to_channel",
        description: "Copy a custom curve from one channel to another channel",
        parameters: {
          type: "object",
          properties: {
            sourceChannel: {
              type: "string",
              description: "Channel to copy the curve from",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            },
            targetChannel: {
              type: "string",
              description: "Channel to copy the curve to",
              enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
            }
          },
          required: ["sourceChannel", "targetChannel"]
        }
      },
      
      {
        name: "generate_global_custom_curve",
        description: "Generate curves from explicit numerical key points for multiple channels simultaneously. Creates single batch undo action.",
        parameters: {
          type: "object",
          properties: {
            keyPoints: {
              type: "array",
              description: "Array of curve control points with input/output values (0-100 range)",
              items: {
                type: "object",
                properties: {
                  input: {
                    type: "number",
                    description: "Input value (0-100)"
                  },
                  output: {
                    type: "number", 
                    description: "Output value (0-100)"
                  }
                },
                required: ["input", "output"]
              }
            },
            interpolationType: {
              type: "string",
              description: "Interpolation method between points",
              enum: ["linear", "smooth"],
              default: "smooth"
            },
            channelFilter: {
              oneOf: [
                {
                  type: "string",
                  enum: ["all", "enabled"],
                  description: "Predefined channel filters"
                },
                {
                  type: "array",
                  items: {
                    type: "string",
                    enum: ["K", "C", "M", "Y", "LC", "LM", "LK", "LLK", "V", "MK"]
                  },
                  description: "Array of specific channel names"
                }
              ],
              description: "Which channels to apply to: 'all' (all printer channels), 'enabled' (only enabled channels), or array of specific channels like ['LK', 'MK']",
              default: "enabled"
            }
          },
          required: ["keyPoints"]
        }
      },
      
      {
        name: "get_current_state",
        description: "Get the current state of all channels and app settings",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "undo_last_change",
        description: "Revert to the previous state (undo the last change made to curves or channel settings)",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "get_history_summary",
        description: "Get a summary of recent changes and undo history for reference",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      },
      {
        name: "get_quad_file_content",
        description: "Return the current generated .quad file content as text (based on current settings)",
        parameters: {
          type: "object",
          properties: {},
          required: []
        }
      }
    ];

    /**
     * Lab Tech integration for quadGEN
     * Handles API communication and function execution
     */
    class LabTech {
      constructor() {
        this.conversationHistory = [];
        this.isProcessing = false;
        this.requestCount = 0;
        this.requestTimes = [];
        this.maxRequestsPerMinute = 10;
        this.maxRequestsPerHour = 100;
        // Recent system notices buffer (not sent until user chats)
        this.systemContextBuffer = [];
        this.systemContextMaxLines = 8;
        this.systemContextMaxChars = 800;
      }

      addSystemContext(message) {
        try {
          const line = String(message || '').trim();
          if (!line) return;
          this.systemContextBuffer.push(line);
          // Trim by lines
          if (this.systemContextBuffer.length > this.systemContextMaxLines) {
            this.systemContextBuffer = this.systemContextBuffer.slice(-this.systemContextMaxLines);
          }
          // Trim by chars
          let txt = this.systemContextBuffer.join('\n');
          if (txt.length > this.systemContextMaxChars) {
            txt = txt.slice(txt.length - this.systemContextMaxChars);
            this.systemContextBuffer = txt.split('\n').slice(-this.systemContextMaxLines);
          }
        } catch {}
      }

      getSystemContext() {
        try {
          if (!this.systemContextBuffer || this.systemContextBuffer.length === 0) return '';
          return this.systemContextBuffer.join('\n');
        } catch { return ''; }
      }

      // (Tool gating removed - always include tools for assistant)

      /**
       * Check if user is within rate limits
       * @returns {Object} Rate limit status
       */
      checkRateLimit() {
        const now = Date.now();
        const oneMinuteAgo = now - 60 * 1000;
        const oneHourAgo = now - 60 * 60 * 1000;
        
        // Clean old entries
        this.requestTimes = this.requestTimes.filter(time => time > oneHourAgo);
        
        const requestsLastMinute = this.requestTimes.filter(time => time > oneMinuteAgo).length;
        const requestsLastHour = this.requestTimes.length;
        
        if (requestsLastMinute >= this.maxRequestsPerMinute) {
          return {
            allowed: false,
            reason: `Rate limit: Max ${this.maxRequestsPerMinute} requests per minute. Please wait.`
          };
        }
        
        if (requestsLastHour >= this.maxRequestsPerHour) {
          return {
            allowed: false,
            reason: `Rate limit: Max ${this.maxRequestsPerHour} requests per hour. Please try later.`
          };
        }
        
        return { allowed: true };
      }

      /**
       * Record a new request
       */
      recordRequest() {
        this.requestTimes.push(Date.now());
        this.requestCount++;
      }

      /**
       * Get usage statistics
       * @returns {Object} Usage stats
       */
      getUsageStats() {
        const now = Date.now();
        const oneHourAgo = now - 60 * 60 * 1000;
        const requestsLastHour = this.requestTimes.filter(time => time > oneHourAgo).length;
        
        return {
          totalRequests: this.requestCount,
          requestsLastHour,
          remainingHourly: Math.max(0, this.maxRequestsPerHour - requestsLastHour)
        };
      }

      /**
       * Estimate token usage for a request (rough approximation)
       * @param {string} userMessage - User's message
       * @returns {number} Estimated token count
       */
      estimateTokens(userMessage) {
        // Rough token estimation: ~4 characters per token
        const systemMessageTokens = 400; // System message is ~400 tokens
        const functionDefinitionTokens = 800; // 17 functions * ~50 tokens each
        const appStateTokens = 200; // Current app state context
        const conversationHistoryTokens = 500; // 10 messages * ~50 tokens each
        const userMessageTokens = Math.ceil(userMessage.length / 4);
        
        return systemMessageTokens + functionDefinitionTokens + appStateTokens + conversationHistoryTokens + userMessageTokens;
      }

      /**
       * Check if token usage seems high and warn user
       * @param {string} userMessage - User's message
       * @returns {Object} Warning info
       */
      checkTokenUsage(userMessage) {
        const estimatedTokens = this.estimateTokens(userMessage);
        
        if (estimatedTokens > 2000) {
          return {
            shouldWarn: true,
            message: `This request will use approximately ${estimatedTokens} tokens. Consider shorter messages to reduce costs.`,
            estimatedTokens
          };
        }
        
        return { shouldWarn: false, estimatedTokens };
      }

      /**
       * Determine whether to apply curve as global linearization or per-channel curves
       * @param {string} userPrompt - The user's natural language request
       * @returns {string} 'global' for global linearization, 'per_channel' for individual channels
       */
      determineApplicationMethod(userPrompt) {
        // Feature flag for easy enable/disable
        const ENABLE_AI_GLOBAL_LINEARIZATION = true;
        
        
        if (!ENABLE_AI_GLOBAL_LINEARIZATION) {
          return 'per_channel';
        }

        // Global linearization indicators
        const globalIndicators = [
          // System-wide language
          /\b(entire system|whole print|overall|globally|system-wide)\b/i,
          // Direct global language
          /\b(global)\b.*\b(curve|correction|adjustment|linearization|compensation)\b/i,
          /\b(apply|add|create)\b.*\b(global)\b/i,
          // Process/paper simulation language
          // Process-specific triggers removed to avoid generating image-space style presets in printer-space
          // Paper/process characteristics
          /\b(paper|process|tonality|characteristics|simulation)\b.*\b(curve|adjustment|correction)\b/i,
          /\b(matte paper|glossy paper|textured paper)\b/i,
          // Global effect language
          /\b(simulate|create|add|apply)\b.*\b(paper|process|print|system)\b/i,
          /\b(compensat|correct|adjust)\b.*\b(paper|printer|system|print)\b/i,
          // Universal/system-wide effects
          /\b(universal|system-wide|across.all|for.everything)\b/i
        ];
        
        // Per-channel curve indicators  
        const perChannelIndicators = [
          // Channel-specific language
          /\b(all channels|each channel|every channel|individual channels?)\b/i,
          /\b(K.*C.*M|cyan.*magenta|ink.*channel|channel.*control)\b/i,
          // Selective control language
          /\b(selective|separate|independent|individual|per.channel)\b/i,
          /\b(color.*balanc|channel.*specific)\b/i
        ];

        // Check for explicit global indicators
        const matchedGlobalPattern = globalIndicators.find(pattern => pattern.test(userPrompt));
        if (matchedGlobalPattern) {
          if (DEBUG_AI || DEBUG_LOGS) console.log('🌐 AI Decision: Using GLOBAL LINEARIZATION based on pattern:', matchedGlobalPattern);
          if (DEBUG_AI || DEBUG_LOGS) console.log('🌐 Matched text in prompt:', userPrompt.match(matchedGlobalPattern));
          return 'global';
        }
        
        // Check for explicit per-channel indicators
        const matchedChannelPattern = perChannelIndicators.find(pattern => pattern.test(userPrompt));
        if (matchedChannelPattern) {
          return 'per_channel';
        }
        
        // Default to per-channel (existing behavior)
        return 'per_channel';
      }

      /**
       * Execute a function call returned by Claude
       * @param {Object} functionCall - Function call object from Claude
       * @returns {Object} Function execution result
       */
      executeFunctionCall(functionCall, userMessage = '') {
        const { name, parameters } = functionCall;

        switch (name) {
          case 'set_edit_mode': {
            try {
              const on = parameters && parameters.enabled === true;
              setEditMode(on, { recordHistory: true });
              return { success: true, message: `Edit Mode ${on ? 'enabled' : 'disabled'}` };
            } catch (e) {
              return { success: false, message: `Error toggling Edit Mode: ${e.message}` };
            }
          }
          case 'explain_lab_linearization': {
            const blurb = [
              "quadGEN plots ink mapping: Y = output ink level vs X = input ink level; Y=X means no correction.",
              "Too dark at input X → reduce ink → curve dips below the diagonal; too light → add ink → curve rises above.",
              "Other tools may mirror X (curves view) or plot luminance instead of ink, so features can appear at 1−X or on the opposite side of the diagonal."
            ].join(' ');
            return { success: true, message: blurb };
          }
          case 'set_channel_value':
            return quadGenActions.setChannelValue(parameters.channelName, parameters.percentage);
          
          case 'set_channel_end_value':
            return quadGenActions.setChannelEndValue(parameters.channelName, parameters.endValue);
          
          case 'apply_to_all_channels':
            return quadGenActions.applyToAllChannels(parameters.percentage);
          
          case 'apply_end_to_all_channels':
            return quadGenActions.applyEndToAllChannels(parameters.endValue);
          
          case 'enable_disable_channel':
            return quadGenActions.enableDisableChannel(parameters.channelName, parameters.enabled);
          
          case 'batch_channel_operations':
            return quadGenActions.batchChannelOperations(parameters.operations);
          
          case 'open_global_linearization_file_picker':
            return quadGenActions.openGlobalLinearizationFilePicker();
          
          case 'open_per_channel_linearization_file_picker':
            return quadGenActions.openPerChannelLinearizationFilePicker(parameters.channelName);
          
          case 'load_sample_lab_file':
            return quadGenActions.loadSampleLabFile();
          
          case 'load_sample_cube_file':
            return quadGenActions.loadSampleCubeFile();
          
          case 'load_lab_data_global':
            return quadGenActions.loadLabData(parameters.labData, true);
          
          case 'load_lab_data_per_channel':
            return quadGenActions.loadLabData(parameters.labData, false, parameters.channelName);
          
          case 'load_cube_data_global':
            return quadGenActions.loadCubeData(parameters.cubeData, true);
          
          case 'load_cube_data_per_channel':
            return quadGenActions.loadCubeData(parameters.cubeData, false, parameters.channelName);
          
          case 'generate_and_download_quad_file':
            return quadGenActions.generateAndDownloadQuadFile();
          
          case 'set_filename':
            return quadGenActions.setFilename(parameters.filename);
          
          case 'set_global_linearization':
            return quadGenActions.setGlobalLinearization(parameters.enabled);
          
          case 'set_per_channel_linearization':
            return quadGenActions.setPerChannelLinearization(parameters.channelName, parameters.enabled);
          
          case 'set_interpolation_method':
            return quadGenActions.setInterpolationMethod(parameters.method);
          
          case 'set_smoothing_percentage':
            return quadGenActions.setSmoothingPercentage(parameters.percentage);
          
          case 'change_printer':
            return quadGenActions.changePrinter(parameters.printerName);
          
          case 'generate_custom_curve':
            return quadGenActions.generateCustomCurve(
              parameters.channelName, 
              parameters.keyPoints, 
              parameters.interpolationType || 'smooth'
            );
          
          
          
          case 'generate_global_custom_curve':
            return quadGenActions.generateGlobalCustomCurve(
              parameters.keyPoints,
              parameters.interpolationType || 'smooth',
              parameters.channelFilter || 'enabled'
            );
          
          case 'get_current_state':
            return quadGenActions.getCurrentState();
          
          case 'undo_last_change':
            return CurveHistory.undo();
          
          case 'get_history_summary':
            return CurveHistory.getHistorySummary();
          
          case 'get_quad_file_content':
            try {
              const content = buildFile();
              return { success: true, message: 'Generated current .quad content', content };
            } catch (e) {
              return { success: false, message: `Error generating .quad content: ${e.message}` };
            }
          
          case 'copy_curve_to_channel':
            return quadGenActions.copyCurveToChannel(parameters.sourceChannel, parameters.targetChannel);
          case 'get_ai_key_points':
            return quadGenActions.getAIKeyPoints(parameters.channelName);
          case 'get_smart_key_points':
            return quadGenActions.getSmartKeyPoints(parameters.channelName);
          case 'set_ai_key_points':
            return quadGenActions.setAIKeyPoints(parameters.channelName, parameters.keyPoints, parameters.interpolationType);
          case 'set_smart_key_points':
            return quadGenActions.setSmartKeyPoints(parameters.channelName, parameters.keyPoints, parameters.interpolationType);
          case 'set_ai_key_points_batch':
            return quadGenActions.setAIKeyPointsBatch(parameters.entries);
          case 'set_smart_key_points_batch':
            return quadGenActions.setSmartKeyPointsBatch(parameters.entries);
          case 'simplify_ai_key_points_from_curve':
            return quadGenActions.simplifyAIKeyPointsFromCurve(parameters.channelName, { maxErrorPercent: parameters.maxErrorPercent, maxPoints: parameters.maxPoints });
          case 'simplify_smart_key_points_from_curve':
            return quadGenActions.simplifySmartKeyPointsFromCurve(parameters.channelName, { maxErrorPercent: parameters.maxErrorPercent, maxPoints: parameters.maxPoints });
          case 'adjust_ai_key_point_by_index':
            return quadGenActions.adjustAIKeyPointByIndex(parameters.channelName, parameters.ordinal, {
              inputPercent: parameters.inputPercent,
              outputPercent: parameters.outputPercent,
              deltaInput: parameters.deltaInput,
              deltaOutput: parameters.deltaOutput
            });
          case 'adjust_smart_key_point_by_index':
            return quadGenActions.adjustSmartKeyPointByIndex(parameters.channelName, parameters.ordinal, {
              inputPercent: parameters.inputPercent,
              outputPercent: parameters.outputPercent,
              deltaInput: parameters.deltaInput,
              deltaOutput: parameters.deltaOutput
            });
          case 'insert_ai_key_point_at':
            return quadGenActions.insertAIKeyPointAt(parameters.channelName, parameters.inputPercent, parameters.outputPercent);
          case 'insert_smart_key_point_at':
            return quadGenActions.insertSmartKeyPointAt(parameters.channelName, parameters.inputPercent, parameters.outputPercent);
          case 'insert_ai_key_point_between':
            return quadGenActions.insertAIKeyPointBetween(parameters.channelName, parameters.leftOrdinal, parameters.rightOrdinal, parameters.outputPercent);
          case 'insert_smart_key_point_between':
            return quadGenActions.insertSmartKeyPointBetween(parameters.channelName, parameters.leftOrdinal, parameters.rightOrdinal, parameters.outputPercent);
          case 'insert_ai_key_points_batch':
            return quadGenActions.insertAIKeyPointsBatch(parameters.channelName, parameters.inserts);
          case 'insert_smart_key_points_batch':
            return quadGenActions.insertSmartKeyPointsBatch(parameters.channelName, parameters.inserts);
          case 'delete_ai_key_point_by_index':
            return quadGenActions.deleteAIKeyPointByIndex(parameters.channelName, parameters.ordinal, { allowEndpoint: parameters.allowEndpoint });
          case 'delete_smart_key_point_by_index':
            return quadGenActions.deleteSmartKeyPointByIndex(parameters.channelName, parameters.ordinal, { allowEndpoint: parameters.allowEndpoint });
          case 'delete_ai_key_point_near_input':
            return quadGenActions.deleteAIKeyPointNearInput(parameters.channelName, parameters.inputPercent, { tolerance: parameters.tolerance, allowEndpoint: parameters.allowEndpoint });
          case 'delete_smart_key_point_near_input':
            return quadGenActions.deleteSmartKeyPointNearInput(parameters.channelName, parameters.inputPercent, { tolerance: parameters.tolerance, allowEndpoint: parameters.allowEndpoint });
          
          default:
            return {
              success: false,
              message: `Unknown function: ${name}`
            };
        }
      }

      /**
       * Send message to Claude and handle response
       * @param {string} userMessage - User's message
       * @returns {Promise<Object>} Response object with message and any actions performed
       */
      async sendMessage(userMessage) {
        // Check rate limits first
        const rateLimitCheck = this.checkRateLimit();
        if (!rateLimitCheck.allowed) {
          return {
            success: false,
            message: rateLimitCheck.reason,
            response: rateLimitCheck.reason
          };
        }

        if (this.isProcessing) {
          return {
            success: false,
            message: 'Already processing a request. Please wait.',
            response: 'I\'m still processing your previous request. Please wait a moment.'
          };
        }

        try {
          this.isProcessing = true;
          this.recordRequest();

          // Get current app state for context
          const currentState = quadGenActions.getCurrentState();
          const contextMessage = currentState.success 
            ? `Current QuadGEN state: ${JSON.stringify(currentState.data, null, 2)}`
            : 'Unable to retrieve current state';

          // No bookmarks or reference injection

          // Prepare system message separately (append recent system notices if any)
          const baseSystemMessage = `You are Lab Tech, the specialized digital darkroom assistant for QuadGEN. You control QuadToneRIP .quad file generation for Epson printers. Always refer to yourself as "Lab Tech" when speaking to users. Adopt the persona of a knowledgeable lab technician who's expert in digital printmaking and alternative photographic processes.

COMMUNICATION STYLE: Be professional, concise, and direct in all responses. Provide clear, actionable guidance without unnecessary elaboration. Do NOT use greetings, pleasantries, self-descriptive language ("I'm here to help", "As Lab Tech", etc.), exclamation points, or conversational endings ("Let me know if you have questions", "Does this help", etc.). Simply provide the requested information and stop. Use formatting to improve readability:
- Use bullet points for lists (- item or * item)
- Use **bold** for emphasis on key terms
- Use line breaks to separate different topics or steps
- Use numbered lists (1. 2. 3.) for sequential instructions

🚨 CRITICAL CHANNEL SELECTION RULE 🚨
SIMPLE RULE: If user doesn't specify a channel, use the FIRST ENABLED channel from the provided state.
ENABLED = percentage > 0 OR endValue > 0 OR enabled = true (check ALL three fields)
- DO NOT analyze what channel would be "most appropriate" 
- DO NOT enable different channels
- DO NOT make assumptions based on curve names
- JUST use the first enabled channel you find in the current state JSON
- If NO channels are enabled, then ask which channel to use

Current state provided with each request. Make multiple function calls in one response for complex requests.

INK COLORS:
K=Black(Photo/Matte), C=Cyan, M=Magenta, Y=Yellow, LC=Light Cyan, LM=Light Magenta, LK=Gray/Light Black, LLK=Light Gray, V=Violet, MK=Matte Black

PRINTERS:
P600-P800 (8 channels, K switchable), P700-P900 (10 channels, MK+V dedicated)

.QUAD ESSENTIALS:
• 256-step linearization curves mapping input density to ink output
• Higher % = more ink = darker output | 0% = disabled channel
• Multiple active channels blend to create neutral or tinted prints
• Linearization files (.cube/.txt/.acv) compensate for paper/ink characteristics
• Users can PASTE LAB measurement data or .cube LUT file data directly into chat for instant linearization
• Positive-only workflow: quadGEN operates in printer-space. EDN LUT/.acv are mapped for Positive orientation (reverse + invert). Work in positive space; invert your image when printing a digital negative. Measurement linearization unchanged.
• Curve creation: Compute explicit numeric key points yourself based on the user’s intent (e.g., gentle S-curve, lift shadows) and apply them with set_ai_key_points. Do NOT rely on built-in presets or pre-defined curves.
• You may interpret photography terms (lift/drop shadows/midtones/highlights, crush/blow, peak/bump, gentle arc, roll off, S-curve), but YOU must choose the actual numerical key points.
• Alt-process terms: palladium/pt-pd curve, cyanotype density, salt print range, gum curve, zone system, block shadows, boost shadows, preserve highlights, contact printing density, UV blocking, exposure scale (ES)
• Global curve generation: Apply same numeric key points to multiple channels with a single undo action
  - Prefer generate_global_custom_curve when the user mentions multiple channels (e.g., 'LK and MK', or 'C, M, Y').
  - Single batch undo reverts all affected channels simultaneously
  - Do NOT use generate_curve_from_description or generate_global_curve_from_description (deprecated)
• To save/download: "download the quad file", "generate quad file", "export quad"
• Generated files work with QuadToneRIP print driver for precise ink control

TONAL MODEL (POSITIVE SPACE):
• Assume a positive working space. X=0% is white, X=100% is black. Y=0% is no ink (white), Y=100% is max ink (black). More output (%) = darker print.
• Endpoints policy: Keep 0→0 and 100→100 anchored by default. Do not move endpoints unless the user explicitly asks. Maintain monotonicity and smoothness; avoid kinks near endpoints.
• Zones by input (X): Highlights 0–25%, Midtones 25–75%, Shadows 75–100%.
• Common requests (interpretation):
  - Lighten shadows: decrease output in 75–95% and taper to 0 change by 100%.
  - Darken shadows: increase output in 75–95% and taper to 0 change by 100%.
  - Lighten highlights: decrease output in 5–25% and taper to 0 change by 0%.
  - Darken highlights: increase output in 5–25% and taper to 0 change by 0%.
  - Increase midtone contrast: gentle S around 50% with endpoints unchanged.
• Guardrail: If the user mentions digital negatives/inversion, briefly confirm orientation or provide both interpretations without changing the positive-space assumption unless requested.

CONFIRMATION & EFFECT SUMMARY:
• After any successful curve/key‑point change (set/adjust/insert/delete/generate global), end with ONE concise effect line.
• Format: Effect: <zone/change> <±peak>% → <expected outcome>; <endpoints note>
  - Examples: Effect: Midtone lift −6% @ 50% → lighter midtones; 0/100 fixed.
             Effect: Shadow boost +5% (75–95%) → darker shadows; endpoints anchored.
• Keep ≤120 characters. Do NOT repeat the points preview or the “Action:” line shown by the app.

KEY‑POINT EDITING DEFAULTS:
• “point N” ALWAYS refers to the AI key‑point ordinal N (1‑based, endpoints included) on the selected channel
• If channel is not specified, apply the CRITICAL CHANNEL SELECTION RULE (first enabled channel). Only ask which channel if none are enabled
• Silent conversion: If no AI key points exist yet, call the edit/insert/delete function anyway — quadGEN will convert from any loaded ACV/LUT/LAB or from the currently displayed curve on the first edit. Do NOT ask the user to generate a curve first
• Disambiguation: If the user mentions “point N … %”, interpret as a key‑point change, not a channel ink limit. Example: “set point 5 to 90%” ⇒ adjust_ai_key_point_by_index(ordinal=5, outputPercent=90)
• Use insert_ai_key_point_at / insert_ai_key_point_between and delete_ai_key_point_* similarly; endpoints are included in indexing and deletions of endpoints are blocked unless allowEndpoint=true
• Edit Mode control: If making edits and Edit Mode is off, call set_edit_mode(enabled=true) before performing the edit. You may turn it off if the user asks (set_edit_mode(enabled=false)).

RULES:
• Only engage with requests about: app functionality, printing, photography, historical/alternative processes, digital negatives/positives
• Politely decline unrelated topics - stay focused on quadGEN and printing
• NEVER change settings when user asks general questions (what, why, how, which, etc.)
• ONLY make changes when user explicitly commands it (set, change, enable, disable, apply, etc.)
• For general questions, provide advice/information WITHOUT making changes
• If unclear whether user wants changes, ASK before acting
• Confirm all actions taken
• Standard: K/MK=100%, colors=30-45% | Light: LC/LM/LK/LLK=60-80% | Rich black: K/MK+LK+LLK
• batch_channel_operations for multiple enable/disable same action (creates single batch undo)
• apply_to_all_channels for same percentage across enabled channels (creates single batch undo)
• apply_end_to_all_channels for same end value across enabled channels (creates single batch undo)
• Multiple set_channel_value calls for different percentages (individual undos)
• Multiple set_channel_end_value calls for different end values (individual undos)
• Ask clarification if ambiguous
• Process curve requests (cyanotype, palladium, etc.): Do NOT generate a preset. Briefly explain image-space vs printer-space and ask the user to load EDN (.cube/.acv) or LAB (.txt).

VALUE INTERPRETATION:
• Percentages (0-100%) and end values (0-64000) are equivalent representations
• 0% = 0, 33% = 21120, 50% = 32000, 100% = 64000
• Use set_channel_value for percentage requests ("set to 50%")
• Use set_channel_end_value for end value requests ("set to 32000")

UNDO/REDO BEHAVIOR:
• Batch operations (batch_channel_operations, apply_to_all_channels, apply_end_to_all_channels) create single undoable actions
• Individual channel changes (set_channel_value, set_channel_end_value, enable_disable_channel) create individual undos
• Users can undo entire batch operations with one button press
• Only actual state changes are recorded (enabling already-enabled channels creates no undo action)

CHANNEL SELECTION RULES - KEEP IT SIMPLE:
• Step 1: Look at provided state JSON, find channels with percentage > 0 OR endValue > 0 OR enabled = true
• Step 2: If user didn't specify a channel, use the FIRST enabled channel - that's it!
• Step 3: If NO channels enabled, ask which channel to use
• DO NOT overthink, DO NOT analyze "appropriateness", DO NOT enable new channels
• Curve names describe TONAL CHARACTERISTICS, not which ink to use` + (this.getSystemContext() ? ("\n\nRecent system notices:\n" + this.getSystemContext()) : '');
          const systemMessage = baseSystemMessage;


          // Prepare the API request messages
          const messages = [
            {
              role: 'user',
              content: `${contextMessage}\n\nUser request: ${userMessage}`
            }
          ];

          // Add conversation history (last 10 messages to avoid token limits)
          const recentHistory = this.conversationHistory.slice(-10);
          messages.splice(-1, 0, ...recentHistory);

          // Provider request helper with parsing and error propagation
          const requestProvider = async (provider) => {
            // Build provider-specific payload
            let payload;
            if (provider === 'openai') {
              const openaiMessages = [
                { role: 'system', content: systemMessage },
                ...recentHistory,
                messages[messages.length - 1]
              ];
              const openaiTools = CLAUDE_FUNCTIONS.map(func => ({
                type: 'function',
                function: {
                  name: func.name,
                  description: func.description,
                  parameters: func.parameters
                }
              }));
              payload = {
                provider: 'openai',
                model: OPENAI_MODEL,
                messages: openaiMessages,
                tools: openaiTools
                // Note: some models only support default temperature; omit to use default
              };
            } else {
              payload = {
                provider: 'anthropic',
                model: ANTHROPIC_MODEL,
                max_tokens: 1000,
                system: systemMessage,
                messages: messages,
                tools: CLAUDE_FUNCTIONS.map(func => ({
                  name: func.name,
                  description: func.description,
                  input_schema: func.parameters
                }))
              };
            }

            // Retry wrapper for transient errors (429/5xx/529)
            const maxAttempts = 3;
            let response, respText, data;
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              response = await fetch(WORKER_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              });

              respText = await response.text();
              try { data = JSON.parse(respText); } catch { data = {}; }

              if (response.ok) break;

              const status = response.status;
              const retryAfterHeader = response.headers.get('Retry-After');
              const retryAfter = retryAfterHeader ? parseInt(retryAfterHeader, 10) * 1000 : null;
              const isRetryable = status === 429 || status === 529 || (status >= 500 && status <= 504);
              if (attempt < maxAttempts && isRetryable) {
                const backoff = retryAfter ?? attempt * 600; // ms
                if (DEBUG_AI || DEBUG_LOGS) console.warn(`Transient AI error ${status}; retrying in ${backoff}ms (attempt ${attempt}/${maxAttempts - 1})`);
                await new Promise(r => setTimeout(r, backoff));
                continue;
              }

              const errMsg = data?.error?.message || data?.error || response.statusText || 'Unknown error';
              const error = new Error(`API Error: ${status} - ${errMsg}`);
              error.status = status;
              error.provider = provider;
              error.data = data;
              throw error;
            }

            // One-time model/provider debug line
            if (!this._modelLogged) {
              const servedModel = data.model || (provider === 'openai' ? OPENAI_MODEL : ANTHROPIC_MODEL);
              const servedProvider = response.headers.get('X-Model-Provider') || provider;
              const connectMsg = `AI connected → provider: ${servedProvider}, model: ${servedModel}`;
              if (DEBUG_AI || DEBUG_LOGS) console.log(connectMsg);
              try { if (shouldShowAssistantStatus() && typeof addChatMessage === 'function') addChatMessage('system', connectMsg); } catch {}
              this._modelLogged = true;
            }

            // Mark AI as connected (successful response)
            aiConnected = true;
            refreshLabTechIcon();

            // Extract rate limit headers
            const rateLimitHeaders = {};
            ['x-ratelimit-limit', 'x-ratelimit-remaining', 'x-ratelimit-reset'].forEach(header => {
              const value = response.headers.get(header);
              if (value) rateLimitHeaders[header] = value;
            });

            // Process function calls and text
            const functionResults = [];
            let assistantMessage = '';
            if (provider === 'openai') {
              const choice = data.choices?.[0] || {};
              const msg = choice.message || {};
              // Robust text extraction for OpenAI variants
              if (typeof msg.content === 'string') {
                assistantMessage = msg.content;
              } else if (Array.isArray(msg.content)) {
                assistantMessage = msg.content.map(c => (typeof c === 'string' ? c : (c?.text ?? ''))).join('');
              } else if (typeof choice.text === 'string') {
                assistantMessage = choice.text; // Some responses include .text
              } else if (Array.isArray(data.output_text)) {
                assistantMessage = data.output_text.join('\n'); // Responses API style
              } else if (typeof data.output_text === 'string') {
                assistantMessage = data.output_text;
              }
              const toolCalls = msg.tool_calls || choice.tool_calls || [];
            for (const call of toolCalls) {
              if (call.type === 'function' && call.function?.name) {
                let args = {};
                try { args = JSON.parse(call.function.arguments || '{}'); } catch {}
                  if (DEBUG_AI || DEBUG_LOGS) console.log('🔧 Function call (OpenAI):', call.function.name, args);
                  const result = this.executeFunctionCall({ name: call.function.name, parameters: args }, userMessage);
                  functionResults.push({ function: call.function.name, parameters: args, result });
              }
            }
            } else {
              for (const content of data.content || []) {
                if (content.type === 'text') {
                  assistantMessage += content.text;
                } else if (content.type === 'tool_use') {
                  if (DEBUG_AI || DEBUG_LOGS) console.log('🔧 Function call (Anthropic):', content.name, content.input);
                  const result = this.executeFunctionCall({ name: content.name, parameters: content.input }, userMessage);
                  functionResults.push({ function: content.name, parameters: content.input, result });
                }
              }
            }

            return { assistantMessage, functionResults, rateLimitHeaders, provider };
          };

          // No fallback: strictly use the configured provider
          let result = await requestProvider(AI_PROVIDER);

          const { assistantMessage, functionResults, rateLimitHeaders } = result;
          let finalMessage = assistantMessage || '';

          // If the model didn't produce a narrative, synthesize a concise action summary for AI key point updates
          try {
            const hasSetAI = (functionResults || []).some(fr => fr.function === 'set_ai_key_points');
            if ((!finalMessage || finalMessage.trim().length === 0) && hasSetAI) {
              const parts = [];
              // Helper to build a one-line effect summary from key points
              const buildEffectSummary = (keyPoints) => {
                try {
                  if (!Array.isArray(keyPoints) || keyPoints.length < 2) return '';
                  // Determine peak absolute delta and its zone
                  let peak = { x: 50, d: 0 };
                  for (const p of keyPoints) {
                    const x = typeof p.input === 'number' ? p.input : Number(p.input);
                    const y = typeof p.output === 'number' ? p.output : Number(p.output);
                    if (!isFinite(x) || !isFinite(y)) continue;
                    const d = y - x; // positive = more ink (darken), negative = less ink (lighten)
                    if (Math.abs(d) > Math.abs(peak.d)) peak = { x, d };
                  }
                  if (!isFinite(peak.d)) return '';
                  const zone = (peak.x < 25) ? 'Highlight' : (peak.x > 75 ? 'Shadow' : 'Midtone');
                  const action = peak.d < 0 ? (zone === 'Shadow' ? 'lift' : 'lift') : (zone === 'Shadow' ? 'boost' : 'boost');
                  const outcome = peak.d < 0 ? (zone === 'Shadow' ? 'lighter shadows' : zone === 'Highlight' ? 'lighter highlights' : 'lighter midtones')
                                             : (zone === 'Shadow' ? 'darker shadows' : zone === 'Highlight' ? 'darker highlights' : 'darker midtones');
                  // Endpoints note
                  const first = keyPoints[0];
                  const last = keyPoints[keyPoints.length - 1];
                  const endpointsFixed = first && last && Math.round(first.input) === 0 && Math.round(first.output) === 0 && Math.round(last.input) === 100 && Math.round(last.output) === 100;
                  const endpointsNote = endpointsFixed ? '0/100 fixed' : 'endpoints anchored';
                  const peakPct = Math.round(Math.abs(peak.d));
                  const at = Math.round(peak.x);
                  return `Effect: ${zone.toLowerCase()} ${action} ${peakPct}% @ ${at}% → ${outcome}; ${endpointsNote}.`;
                } catch { return ''; }
              };

              let lastKP = null;
              for (const fr of functionResults) {
                if (fr.function === 'set_ai_key_points') {
                  const res = fr.result || {};
                  const d = res.details;
                  const msg = res.message || '';
                  const safeMsg = msg || 'Applied AI key points.';
                  if (d && Array.isArray(d.keyPoints)) {
                    const kpPreview = d.keyPoints.map(p => `${Math.round(p.input)}→${Math.round(p.output)}`).join(', ');
                    parts.push(`Action: ${safeMsg}\n- Preview: ${kpPreview}`);
                    lastKP = d.keyPoints;
                  } else {
                    parts.push(`Action: ${safeMsg}`);
                  }
                }
              }
              if (parts.length > 0) {
                const effect = buildEffectSummary(lastKP);
                if (effect) parts.push(effect);
                finalMessage = parts.join('\n\n');
              }
            }

            // Always format get_ai_key_points results (either fill or append)
            const getAIResults = (functionResults || []).filter(fr => fr.function === 'get_ai_key_points');
            if (getAIResults.length > 0) {
              const lines = [];
              for (const fr of getAIResults) {
                const res = fr.result || {};
                if (res.success && Array.isArray(res.keyPoints)) {
                  const ch = res.channelName || fr.parameters?.channelName || 'channel';
                  const list = res.keyPoints.map(p => `${Math.round(p.input)},${Math.round(p.output)}`).join(' ');
                  lines.push(`Key points (${ch}): ${list}`);
                } else if (res.message) {
                  lines.push(res.message);
                }
              }
              if (lines.length > 0) {
                if (!finalMessage || finalMessage.trim().length === 0) {
                  finalMessage = lines.join('\n');
                } else {
                  finalMessage += `\n${lines.join('\n')}`;
                }
              }
            }
          } catch (e) {
            if (DEBUG_AI || DEBUG_LOGS) console.warn('Failed to synthesize action summary:', e.message);
          }

          // No auto-citations; references removed (trust the model)
          
          if (DEBUG_AI || DEBUG_LOGS) console.log('📝 Total function calls processed:', functionResults.length);

          // Update conversation history
          this.conversationHistory.push(
            { role: 'user', content: userMessage },
            { role: 'assistant', content: finalMessage || 'I performed the requested actions.' }
          );

          return {
            success: true,
            message: 'Request processed successfully',
            response: finalMessage || 'Actions completed successfully.',
            functionResults: functionResults,
            actionsPerformed: functionResults.length > 0,
            rateLimitHeaders: rateLimitHeaders
          };

        } catch (error) {
          console.error('AI API Error:', error);
          // Mark AI as disconnected on error
          aiConnected = false;
          refreshLabTechIcon();
          return {
            success: false,
            message: `Error communicating with AI provider: ${error.message}`,
            response: `Sorry, I encountered an error: ${error.message}`
          };
        } finally {
          this.isProcessing = false;
        }
      }

      /**
       * Clear conversation history
       */
      clearHistory() {
        this.conversationHistory = [];
      }

      /**
       * Get processing status
       * @returns {boolean} Whether the assistant is currently processing
       */
      isProcessingRequest() {
        return this.isProcessing;
      }

      /**
       * Test the proxy connection
       * @returns {Promise<Object>} Connection test result
       */
      async testConnection() {
        try {
          const response = await fetch('http://localhost:8080/v1/messages', {
            method: 'OPTIONS'
          });
          return {
            success: response.ok,
            message: response.ok ? 'Proxy server is running' : 'Proxy server error'
          };
        } catch (error) {
          return {
            success: false,
            message: 'Proxy server not accessible. Please run: node cors-proxy.js'
          };
        }
      }

      /**
       * Validate API key by making a test request
       * @param {string} testApiKey - API key to validate
       * @returns {Promise<Object>} Validation result
       */
      async validateApiKey(testApiKey) {
        // Basic validation - let the API validate the format
        if (!testApiKey || typeof testApiKey !== 'string' || testApiKey.trim().length === 0) {
          return {
            success: false,
            message: 'Please enter a valid API key'
          };
        }

        try {
          
          const response = await fetch('http://localhost:8080/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': testApiKey,
              'anthropic-version': '2023-06-01'
            },
            body: JSON.stringify({
              model: 'claude-sonnet-4-0',
              max_tokens: 10,
              messages: [
                {
                  role: 'user',
                  content: 'Test'
                }
              ]
            })
          });

          if (DEBUG_AI || DEBUG_LOGS) console.log('📡 API Response:', {
            status: response.status,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers.entries())
          });

          if (response.ok) {
            if (DEBUG_AI || DEBUG_LOGS) console.log('✅ API key validation successful');
            return {
              success: true,
              message: 'API key is valid'
            };
          } else {
            const errorData = await response.json().catch(() => ({}));
            if (DEBUG_AI || DEBUG_LOGS) console.log('❌ API Error Response:', errorData);
            
            let errorMessage = 'Authentication failed';
            
            if (response.status === 401) {
              errorMessage = errorData.error?.message || 'Invalid API key. Please check your key from console.anthropic.com';
            } else if (response.status === 429) {
              // Server-side rate limit from Cloudflare Worker
              const retryAfter = errorData.retryAfter || response.headers.get('Retry-After');
              errorMessage = errorData.message || 'Rate limit exceeded. Please try again later.';
              if (retryAfter) {
                errorMessage += ` (Wait ${retryAfter} seconds)`;
              }
            } else if (response.status >= 500) {
              errorMessage = 'Claude Sonnet 4 API server error. Please try again later.';
            } else if (errorData.error?.message) {
              errorMessage = errorData.error.message;
            }
            
            return {
              success: false,
              message: `${errorMessage} (Status: ${response.status})`,
              statusCode: response.status,
              rawError: errorData
            };
          }
        } catch (error) {
          console.error('🚨 Validation network error:', error);
          return {
            success: false,
            message: `Validation error: ${error.message}`
          };
        }
      }
    }

    // Create singleton instance
    const claudeAssistant = new LabTech();

    const PRINTERS = {
      P400: { name: "Epson P400", channels: ["K","C","M","Y","LC","LM"] },
      P800: { name: "Epson P600-P800", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "3880-7880": { name: "Epson 3880-7880", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "x800-x890": { name: "Epson x800-x890", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "x900": { name: "Epson x900", channels: ["K","C","M","Y","LC","LM","LK","LLK","OR","GR"] },
      "P4-6-8000": { name: "Epson P4-6-8000", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      "P5-7-9000": { name: "Epson P5-7-9000", channels: ["K","C","M","Y","LC","LM","LK","LLK","OR","GR"] },
      P700P900: { name: "Epson P700-P900", channels: ["K","C","M","Y","LC","LM","LK","LLK","V","MK"] },
      
    };

    const INK_COLORS = {
      K: "#111111",
      C: "#00AEEF",
      M: "#EC008C",
      Y: "#FFF200",
      LC: "#8FD3FF",
      LM: "#FF9AD5",
      LK: "#777777",
      LLK: "#BBBBBB",
      OR: "#FF7F00",
      GR: "#00A651",
      V: "#7F00FF",
      MK: "#000000"
    };


    // Cache DOM elements
  const elements = {
      rows: document.getElementById('rows'),
      printerSelect: document.getElementById('printerSelect'),
      channelInfo: document.getElementById('channelInfo'),
      printerDescription: document.getElementById('printerDescription'),
      downloadBtn: document.getElementById('downloadBtn'),
      previewFull: document.getElementById('previewFull'),
      status: document.getElementById('status'),
      inkChart: document.getElementById('inkChart'),
      chartCursorTooltip: document.getElementById('chartCursorTooltip'),
      filenameInput: document.getElementById('filenameInput'),
      linearizationFile: document.getElementById('linearizationFile'),
      globalLinearizationBtn: document.getElementById('globalLinearizationBtn'),
      globalLinearizationHint: document.getElementById('globalLinearizationHint'),
      globalLinearizationToggle: document.getElementById('globalLinearizationToggle'),
      curveSmoothingMethod: document.getElementById('curveSmoothingMethod'),
      catmullTension: document.getElementById('catmullTension'),
      catmullTensionContainer: document.getElementById('catmullTensionContainer'),
      smoothingSlider: document.getElementById('smoothingSlider'),
      smoothingValue: document.getElementById('smoothingValue'),
      smoothingWarning: document.getElementById('smoothingWarning'),
      // Simplifier controls removed; handled in Edit Curves panel
      kpSimplifierContainer: document.getElementById('kpSimplifierContainer'),
      userNotes: document.getElementById('userNotes'),
      notesToggle: document.getElementById('notesToggle'),
      quadFile: document.getElementById('quadFile'),
      loadQuadBtn: document.getElementById('loadQuadBtn'),
      manualLstarBtn: document.getElementById('manualLstarBtn'),
      lstarModal: document.getElementById('lstarModal'),
      closeLstarModal: document.getElementById('closeLstarModal'),
      lstarInputs: document.getElementById('lstarInputs'),
      addLstarInput: document.getElementById('addLstarInput'),
      removeLstarInput: document.getElementById('removeLstarInput'),
      lstarCountInput: document.getElementById('lstarCountInput'),
      lstarValidation: document.getElementById('lstarValidation'),
      cancelLstar: document.getElementById('cancelLstar'),
      saveLstarTxt: document.getElementById('saveLstarTxt'),
      generateFromLstar: document.getElementById('generateFromLstar'),
      notesContent: document.getElementById('notesContent'),
      notesChevron: document.getElementById('notesChevron'),
      helpBtn: document.getElementById('helpBtn'),
      infoBtn: document.getElementById('infoBtn'),
      infoPopup: document.getElementById('infoPopup'),
      closeInfoBtn: document.getElementById('closeInfoBtn'),
      deltaSummary: document.getElementById('deltaSummary'),
      perChannelDeltaSelect: document.getElementById('perChannelDeltaSelect'),
      perChannelDeltaSummary: document.getElementById('perChannelDeltaSummary'),
      helpPopup: document.getElementById('helpPopup'),
      closeHelpBtn: document.getElementById('closeHelpBtn'),
      helpContent: document.getElementById('helpContent'),
      globalCorrectionHelpBtn: document.getElementById('globalCorrectionHelpBtn'),
      globalCorrectionHelpPopup: document.getElementById('globalCorrectionHelpPopup'),
      closeGlobalCorrectionHelpBtn: document.getElementById('closeGlobalCorrectionHelpBtn'),
      editModeHelpBtn: document.getElementById('editModeHelpBtn'),
      editModeHelpPopup: document.getElementById('editModeHelpPopup'),
      closeEditModeHelpBtn: document.getElementById('closeEditModeHelpBtn'),
      interpolationDescription: document.getElementById('interpolationDescription'),
      globalLinearizationInfo: document.getElementById('globalLinearizationInfo'),
      aiLabelToggle: document.getElementById('aiLabelToggle'),
      globalLinearizationFilename: document.getElementById('globalLinearizationFilename'),
      globalLinearizationDetails: document.getElementById('globalLinearizationDetails'),
      
      loadSampleLabData: document.getElementById('loadSampleLabData'),
      loadSampleCube: document.getElementById('loadSampleCube'),
      pageTitle: document.getElementById('pageTitle'),
      appVersion: document.getElementById('appVersion'),
      infoPopupTitle: document.getElementById('infoPopupTitle'),
      // Edit Curves panel
      editSmoothingSlider: document.getElementById('editSmoothingSlider'),
      editSmoothingValue: document.getElementById('editSmoothingValue'),
      editChannelSelect: document.getElementById('editChannelSelect'),
      editChannelPrev: document.getElementById('editChannelPrev'),
      editChannelNext: document.getElementById('editChannelNext'),
      editChannelState: document.getElementById('editChannelState'),
      editMaxError: document.getElementById('editMaxError'),
      editMaxPoints: document.getElementById('editMaxPoints'),
      editRecomputeBtn: document.getElementById('editRecomputeBtn'),
      editPanelBody: document.getElementById('editPanelBody'),
      editPointLeft: document.getElementById('editPointLeft'),
      editPointRight: document.getElementById('editPointRight'),
      editPointIndex: document.getElementById('editPointIndex'),
      editNudgeXNeg: document.getElementById('editNudgeXNeg'),
      editNudgeXPos: document.getElementById('editNudgeXPos'),
      editNudgeYUp: document.getElementById('editNudgeYUp'),
      editNudgeYDown: document.getElementById('editNudgeYDown'),
      editXYInput: document.getElementById('editXYInput'),
      editDeleteBtn: document.getElementById('editDeleteBtn'),
      editDisabledHint: document.getElementById('editDisabledHint'),
      // Lab Tech elements
      aiToggle: document.getElementById('aiToggle'),
      aiChevron: document.getElementById('aiChevron'),
      aiContent: document.getElementById('aiContent'),
      aiCompactBar: document.getElementById('aiCompactBar'),
      aiStatus: document.getElementById('aiStatus'), // Will be null - kept for compatibility
      aiStatusIcon: document.getElementById('aiStatusIcon'), // Will be null - kept for compatibility
      // usageCounter: document.getElementById('usageCounter'), // Disabled
      chatHistory: document.getElementById('chatHistory'),
      aiInput: document.getElementById('aiInput'),
      aiInputCompact: document.getElementById('aiInputCompact'),
      sendMessageBtn: document.getElementById('sendMessageBtn'),
      sendMessageBtnCompact: document.getElementById('sendMessageBtnCompact'),
      clearChatBtn: document.getElementById('clearChatBtn'),
      labTechIcon: document.getElementById('labTechIcon'),
  };

  // No display orientation or Y semantics toggles in stable layout

    // Global defaults for key‑point simplifier
    let KP_SIMPLIFY = { maxErrorPercent: 0.25, maxPoints: 21 };
    // Maximum count at which we directly seed source points into AI key points
    // (Above this, we recompute/simplify to an edit‑friendly subset.)
    const DIRECT_SEED_MAX_POINTS = 25;

    // clampSimplifierSettings removed; simplifier is managed by Edit Curves panel

    // Internal state: track whether we auto-toggled overlays off due to multi-channel selection
    let overlayAutoToggledOff = false;
    // Lab Tech: command history for Up/Down navigation
    let aiCommandHistory = [];
    let aiHistoryIndex = 0; // points to next insertion (history.length). Up/Down move within [0..length]
    // Lab Tech: AI connection indicator
    let aiConnected = null; // null = unknown/pending (💬), true = connected (⚡), false = disconnected (🚫)

    function refreshLabTechIcon() {
      try {
        if (!elements.labTechIcon) return;
        elements.labTechIcon.textContent = (aiConnected === true) ? '⚡' : (aiConnected === false ? '🚫' : '💬');
      } catch {}
    }

    // Helper to prefix edited filenames for display
    function getEditedDisplayName(name, edited) {
      if (!name) return '';
      return edited ? `✦Edited✦ ${name}` : name;
    }

    // Helper to describe base/editable point counts for linearization datasets
    function getBasePointCountLabel(data) {
      if (!data) return '';
      const fmt = (data.format || '').toUpperCase();
      // Normalize all types to a compact "N points" label
      if (fmt === 'ACV' && Array.isArray(data.controlPointsTransformed)) {
        return `${data.controlPointsTransformed.length} points`;
      }
      if ((fmt.includes('LAB') || fmt.includes('MANUAL')) && Array.isArray(data.originalData)) {
        return `${data.originalData.length} points`;
      }
      if (Array.isArray(data.originalSamples)) return `${data.originalSamples.length} points`;
      if (Array.isArray(data.samples)) return `${data.samples.length} points`;
      return '';
    }

    function refreshGlobalLinearizationDisplay() {
      if (!elements.globalLinearizationBtn || !elements.globalLinearizationFilename) return;
      if (linearizationData) {
        const base = linearizationData.filename || 'unknown file';
        const disp = getEditedDisplayName(base, !!linearizationData.edited);
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${disp}`);
        elements.globalLinearizationFilename.textContent = disp;
      }
    }

    function refreshPerChannelLinearizationDisplay(channelName) {
      const tr = document.querySelector(`tr[data-channel="${channelName}"]`);
      if (!tr) return;
      const perChannelBtn = tr.querySelector('.per-channel-btn');
      if (perChannelBtn) {
        const base = perChannelFilenames[channelName] || 'unknown file';
        const edited = !!(perChannelLinearization[channelName] && perChannelLinearization[channelName].edited);
        const disp = getEditedDisplayName(base, edited);
        perChannelBtn.setAttribute('data-tooltip', `Loaded: ${disp}`);
      }
    }

    function refreshOpenProcessingPanels() {
      // Always-visible labels: refresh all channel rows
      const rows = document.querySelectorAll('tr[data-channel]');
      rows.forEach(tr => {
        const channelName = tr.getAttribute('data-channel');
        if (channelName) updateProcessingDetailForce(channelName);
      });
    }

    function markLinearizationEdited(channelName) {
      let changed = false;
      if (linearizationData) { linearizationData.edited = true; changed = true; }
      if (perChannelLinearization[channelName]) { perChannelLinearization[channelName].edited = true; changed = true; }
      if (changed) {
        refreshGlobalLinearizationDisplay();
        if (channelName) refreshPerChannelLinearizationDisplay(channelName);
        // When the global dataset is flagged, refresh all open processing panels
        if (linearizationData && linearizationData.edited) refreshOpenProcessingPanels();
      }
    }

    // Initialize dynamic version numbers
    function initializeVersionNumbers() {
      elements.pageTitle.textContent = `quadGEN ${APP_VERSION}`;
      elements.appVersion.textContent = APP_VERSION;
      elements.infoPopupTitle.textContent = `quadGEN ${APP_VERSION}`;
    }

    // Initialize version numbers when DOM is ready
    initializeVersionNumbers();

    // (Removed) IndustryReferences bookmarks system — reverted to trusting the model

    // Sample data constants
    const SAMPLE_DATA = {
      colorMuse: `GRAY\tLAB_L\tLAB_A\tLAB_B
0\t97.15\t0.00\t0.00
5\t97.14\t0.00\t0.00
10\t95.90\t0.00\t0.00
15\t93.30\t0.00\t0.00
20\t90.06\t0.00\t0.00
25\t85.89\t0.00\t0.00
30\t79.22\t0.00\t0.00
35\t71.65\t0.00\t0.00
40\t64.43\t0.00\t0.00
45\t58.21\t0.00\t0.00
50\t52.13\t0.00\t0.00
55\t46.63\t0.00\t0.00
60\t41.83\t0.00\t0.00
65\t38.50\t0.00\t0.00
70\t35.63\t0.00\t0.00
75\t31.53\t0.00\t0.00
80\t29.94\t0.00\t0.00
85\t27.34\t0.00\t0.00
90\t25.91\t0.00\t0.00
95\t24.17\t0.00\t0.00
100\t21.33\t0.00\t0.00`,

      gammaCube: `# Test LUT - Gamma 2.2 curve
TITLE "Test Gamma 2.2"
LUT_1D_SIZE 11
DOMAIN_MIN 0.0 0.0 0.0
DOMAIN_MAX 1.0 1.0 1.0

# Gamma 2.2 curve: output = input^2.2
0.0 0.0 0.0
0.01 0.01 0.01
0.05 0.05 0.05
0.13 0.13 0.13
0.24 0.24 0.24
0.41 0.41 0.41
0.61 0.61 0.61
0.78 0.78 0.78
0.90 0.90 0.90
0.97 0.97 0.97
1.0 1.0 1.0`
    };

    // Input validation utilities
    class InputValidator {
      static clampPercent(p) { 
        const num = parseFloat(p);
        return isNaN(num) ? 0 : Math.min(100, Math.max(0, num)); 
      }
      
      static clampEnd(e) { 
        const num = parseInt(e);
        return isNaN(num) ? 0 : Math.min(64000, Math.max(0, num)); 
      }
      
      static computeEndFromPercent(p) { 
        return Math.round((TOTAL * p) / 100); 
      }
      
      static computePercentFromEnd(e) { 
        return (e / TOTAL) * 100; 
      }

      static validateInput(input, validator) {
        const originalValue = input.value;
        const validatedValue = validator(originalValue);
        const isValid = validatedValue.toString() === originalValue || Math.abs(parseFloat(originalValue) - validatedValue) < 0.01;
        
        input.classList.toggle('border-red-300', !isValid);
        input.classList.toggle('border-gray-300', isValid);
        
        if (!isValid) {
          input.value = validatedValue.toString();
        }
        
        return validatedValue;
      }
    }

    // ===== Edit Curves panel logic =====
    // Global edit mode toggle (off by default)
    window.EDIT_MODE_ENABLED = false;
    const EDIT = { selectedChannel: null, selectedOrdinal: 1 };

    function isEditModeEnabled(){ return window.EDIT_MODE_ENABLED === true; }
    function setEditMode(on, opts = {}){
      const options = opts || {};
      const prev = isEditModeEnabled();
      window.EDIT_MODE_ENABLED = !!on;
      // Update toggle button visuals
      try {
        const btn = document.getElementById('editModeToggleBtn');
        const label = document.getElementById('editModeLabel');
        if (btn){
          btn.setAttribute('aria-pressed', String(!!on));
          btn.setAttribute('aria-checked', String(!!on));
          // Reset color classes
          btn.classList.remove(
            'bg-slate-600','hover:bg-slate-700',
            'bg-black','hover:bg-gray-900',
            'bg-orange-600','hover:bg-orange-700',
            'bg-rose-800','hover:bg-rose-900',
            'border','border-blue-200'
          );
          // Always ensure white bold text and no border
          btn.classList.add('text-white','font-bold','border-0');
          if (on) {
            // Black style when ON
            btn.classList.add('bg-black','hover:bg-gray-900');
          } else {
            // Slate style when OFF
            btn.classList.add('bg-slate-600','hover:bg-slate-700');
          }
        }
        if (label){ label.textContent = on ? '◈ Edit Mode: ON' : '⟐ Edit Mode: OFF'; }
      } catch {}
      // On first enable of Edit Mode, silently pre-create AI key points for all channels that need them
      try {
        if (on && !window.__EDIT_MODE_PRIMED) {
          const current = getCurrentPrinter();
          const channels = (current && current.channels) ? current.channels.slice() : [];
          const entries = [];
          const persistOnly = [];
          channels.forEach((ch) => {
            try {
              const existing = ControlPoints.get(ch)?.points;
              if (existing && existing.length >= 2) return; // already has AI points
              // ACV sources (per-channel or global): seed directly from anchors without simplification
              try {
                const per = perChannelLinearization[ch];
                const perFmt = (per?.format || '').toUpperCase();
                const hasPerACVAnchors = perFmt === 'ACV' && Array.isArray(per?.controlPointsTransformed) && per.controlPointsTransformed.length >= 2;
                if (hasPerACVAnchors) {
                  const anchors = per.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
                  if (anchors.length >= 2) {
                    const row = document.querySelector(`tr[data-channel="${ch}"]`);
                    const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                    if (endVal === 0) persistOnly.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    return;
                  }
                }
                const hasPerLAB = (perFmt.includes('LAB') || perFmt.includes('MANUAL')) && Array.isArray(per?.originalData) && per.originalData.length > 0;
                if (hasPerLAB) {
                  const row = document.querySelector(`tr[data-channel="${ch}"]`);
                  const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
                  const values = make256(endVal, ch, true);
                  let kps;
                  if (per.originalData.length <= DIRECT_SEED_MAX_POINTS) {
                    const Nvals = values.length - 1;
                    kps = per.originalData.map(d => {
                      const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                      const t = (x / 100) * Nvals;
                      const i0 = Math.floor(t);
                      const i1 = Math.min(Nvals, Math.ceil(t));
                      const a = t - i0;
                      const v = (1 - a) * values[i0] + a * values[i1];
                      const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                      return { input: x, output: outPct };
                    });
                  } else {
                    kps = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
                  }
                  if (Array.isArray(kps) && kps.length >= 2) {
                    const row2 = document.querySelector(`tr[data-channel="${ch}"]`);
                    const e2 = row2 ? InputValidator.clampEnd(row2.querySelector('.end-input')?.value || 0) : 0;
                    if (e2 === 0) persistOnly.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    return;
                  }
                }
                const glbFmt = (linearizationData?.format || '').toUpperCase();
                const hasGlobalACVAnchors = glbFmt === 'ACV' && Array.isArray(linearizationData?.controlPointsTransformed) && linearizationData.controlPointsTransformed.length >= 2;
                if (hasGlobalACVAnchors) {
                  const anchors = linearizationData.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
                  if (anchors.length >= 2) {
                    const row = document.querySelector(`tr[data-channel="${ch}"]`);
                    const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                    if (endVal === 0) persistOnly.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: anchors, interpolationType: 'smooth' });
                    return;
                  }
                }
                const hasGlobalLAB = (glbFmt.includes('LAB') || glbFmt.includes('MANUAL')) && Array.isArray(linearizationData?.originalData) && linearizationData.originalData.length > 0;
                if (hasGlobalLAB) {
                  const row = document.querySelector(`tr[data-channel="${ch}"]`);
                  const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
                  const values = make256(endVal, ch, true);
                  let kps;
                  if (linearizationData.originalData.length <= DIRECT_SEED_MAX_POINTS) {
                    const Nvals = values.length - 1;
                    kps = linearizationData.originalData.map(d => {
                      const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                      const t = (x / 100) * Nvals;
                      const i0 = Math.floor(t);
                      const i1 = Math.min(Nvals, Math.ceil(t));
                      const a = t - i0;
                      const v = (1 - a) * values[i0] + a * values[i1];
                      const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                      return { input: x, output: outPct };
                    });
                  } else {
                    kps = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
                  }
                  if (Array.isArray(kps) && kps.length >= 2) {
                    const row2 = document.querySelector(`tr[data-channel="${ch}"]`);
                    const e2 = row2 ? InputValidator.clampEnd(row2.querySelector('.end-input')?.value || 0) : 0;
                    if (e2 === 0) persistOnly.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    else entries.push({ channelName: ch, keyPoints: kps, interpolationType: 'smooth' });
                    return;
                  }
                }
              } catch {}
              // Prefer raw loaded .quad curve if present; otherwise use displayed curve
              let values = (window.loadedQuadData?.curves?.[ch] && Array.isArray(window.loadedQuadData.curves[ch]))
                ? window.loadedQuadData.curves[ch]
                : (function(){
                    const row = document.querySelector(`tr[data-channel="${ch}"]`);
                    const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
                    return make256(endVal, ch, true);
                  })();
              if (!Array.isArray(values) || values.length < 2) return;
              const keyPoints = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
              if (Array.isArray(keyPoints) && keyPoints.length >= 2) {
                const row = document.querySelector(`tr[data-channel="${ch}"]`);
                const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
                if (endVal === 0) persistOnly.push({ channelName: ch, keyPoints, interpolationType: 'smooth' });
                else entries.push({ channelName: ch, keyPoints, interpolationType: 'smooth' });
              }
            } catch {}
          });
          if (entries.length > 0) {
            try { quadGenActions.setSmartKeyPointsBatch(entries); } catch {}
          }
          // Persist-only for disabled channels (no curve apply; no enable)
          if (persistOnly.length > 0) {
            try { persistOnly.forEach(e => { ControlPoints.persist(e.channelName, e.keyPoints, e.interpolationType || 'smooth'); }); } catch {}
          }
          window.__EDIT_MODE_PRIMED = true;
        }
      } catch {}
      // Enable/disable panel controls and refresh chart overlays
      try {
        if (on) {
          edit_refreshState();
        } else {
          edit_setControlsEnabled(false);
        }
        if (typeof updateInterpolationControls === 'function') updateInterpolationControls();
        if (typeof updateInkChart === 'function') updateInkChart();
      } catch {}
      // Record UI history for edit mode toggle (only when state actually changes)
      try {
        if (prev !== !!on) {
          const shouldRecord = options.recordHistory === true; // explicit opt-in at call sites
          if (shouldRecord && typeof CurveHistory !== 'undefined' && CurveHistory && !CurveHistory.isRestoring && typeof CurveHistory.recordUIAction === 'function') {
            const desc = `Edit Mode: ${prev ? 'On' : 'Off'} → ${on ? 'On' : 'Off'}`;
            CurveHistory.recordUIAction('editMode', prev, !!on, desc);
          }
        }
      } catch {}
    }

    function edit_isChannelEnabled(ch){
      try {
        const row = document.querySelector(`tr[data-channel="${ch}"]`);
        const endVal = InputValidator.clampEnd(row?.querySelector('.end-input')?.value || 0);
        return endVal > 0;
      } catch { return false; }
    }

    function edit_populateChannelSelect(){
      if (!elements.editChannelSelect) return;
      const sel = elements.editChannelSelect;
      const rows = Array.from(elements.rows?.children || []).filter(tr => tr.id !== 'noChannelsRow');
      const enabled = rows
        .filter(tr => (InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0)) > 0)
        .map(tr => tr.getAttribute('data-channel'))
        .filter(Boolean);
      const prev = sel.value;
      const prevChannel = EDIT.selectedChannel || prev;
      const prevOrdinal = EDIT.selectedOrdinal || 1;
      sel.innerHTML = '';
      if (enabled.length === 0) {
        const opt = document.createElement('option');
        opt.value = ''; opt.textContent = 'No channels enabled';
        opt.disabled = true; opt.selected = true;
        sel.appendChild(opt);
        EDIT.selectedChannel = null;
        edit_setControlsEnabled(false);
        if (elements.editChannelState) elements.editChannelState.textContent = '';
        return;
      }
      enabled.forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch; opt.textContent = ch;
        sel.appendChild(opt);
      });
      // Prefer previously selected if still enabled; else first enabled
      let desired = (prev && enabled.includes(prev)) ? prev
                  : (prevChannel && enabled.includes(prevChannel)) ? prevChannel
                  : enabled[0];
      if (desired) sel.value = desired;
      const changed = EDIT.selectedChannel !== desired;
      EDIT.selectedChannel = desired;
      EDIT.selectedOrdinal = changed ? 1 : prevOrdinal;
      edit_refreshState();
    }

    function edit_refreshState(){
      const ch = EDIT.selectedChannel;
      if (!ch){
        edit_setControlsEnabled(false);
        if (elements.editChannelState) elements.editChannelState.textContent = '';
        return;
      }
      // Respect global edit mode toggle
      if (!isEditModeEnabled()){
        edit_setControlsEnabled(false);
        if (elements.editChannelState) elements.editChannelState.textContent = '';
        return;
      }
      const isEnabled = edit_isChannelEnabled(ch);
      if (elements.editChannelState) elements.editChannelState.textContent = isEnabled ? '' : '(disabled)';
      // Allow editing even when channel End=0; just show hint
      edit_setControlsEnabled(true);
      if (elements.editDisabledHint){ elements.editDisabledHint.classList.toggle('hidden', isEnabled); }
      // Disable specific controls to reflect channel disabled state visually
      try {
        const disable = !isEnabled;
        const setDisabled = (el, on) => { if (el) el.disabled = !!on; };
        setDisabled(elements.editPointLeft, disable);
        setDisabled(elements.editPointRight, disable);
        setDisabled(elements.editNudgeXNeg, disable);
        setDisabled(elements.editNudgeXPos, disable);
        setDisabled(elements.editNudgeYUp, disable);
        setDisabled(elements.editNudgeYDown, disable);
        setDisabled(elements.editDeleteBtn, disable);
        setDisabled(elements.editRecomputeBtn, disable);
        if (elements.editXYInput) elements.editXYInput.disabled = disable;
        if (elements.editPointIndex) elements.editPointIndex.classList.toggle('is-disabled', disable);
      } catch {}
      // Ensure AI key points exist so we can meaningfully edit/cycle
      try {
        const pts = ControlPoints.get(ch)?.points || [];
        if (!pts || pts.length < 2) {
          const ensured = ensureEditableKeyPointsForChannel(ch, 'smooth');
          if (!ensured?.success) { console.warn('Ensure KP failed:', ensured?.message); }
        }
      } catch (e) { console.warn('Edit panel ensure KP error:', e); }
      edit_refreshPointIndex();
      edit_syncShowPointsAndSmoothing();
    }

    function edit_setControlsEnabled(on){
      // Apply a single disabling class to the entire panel body
      if (elements.editPanelBody){
        elements.editPanelBody.classList.toggle('edit-panel-disabled', !on);
      }
      // Hint should not show while Edit Mode is off, even if controls are disabled
      if (elements.editDisabledHint){
        const hideHint = !!on || !isEditModeEnabled();
        elements.editDisabledHint.classList.toggle('hidden', hideHint);
      }
      // Ensure Recompute is explicitly disabled when Edit Mode is OFF
      try {
        if (elements.editRecomputeBtn) elements.editRecomputeBtn.disabled = !on;
        if (elements.editDeleteBtn) elements.editDeleteBtn.disabled = !on;
        if (elements.editPointIndex) elements.editPointIndex.classList.toggle('is-disabled', !on);
      } catch {}
    }

    function edit_refreshPointIndex(){
      try {
        const ch = EDIT.selectedChannel; if (!ch) return;
        const kp = ControlPoints.get(ch)?.points || [];
        const n = Math.max(2, kp.length || 0);
        if (EDIT.selectedOrdinal < 1) EDIT.selectedOrdinal = 1;
        if (EDIT.selectedOrdinal > n) EDIT.selectedOrdinal = n;
        if (elements.editPointIndex) elements.editPointIndex.textContent = String(EDIT.selectedOrdinal);
        if (elements.editXYInput && kp.length>=2){
          const p = kp[EDIT.selectedOrdinal - 1];
          if (p) {
            let yAbs = p.output;
            try {
              const row = document.querySelector(`tr[data-channel="${ch}"]`);
              const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
              const scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
              yAbs = Math.max(0, Math.min(100, (scale > 0) ? (p.output * scale) : 0));
            } catch {}
            const xDisp = Math.round(p.input*100)/100;
            const yDisp = Math.round(yAbs*100)/100;
            elements.editXYInput.value = `${xDisp},${yDisp}`;
          }
        }
        // Re-render chart overlays so the selected point highlight updates immediately
        if (typeof updateInkChart === 'function') { updateInkChart(); }
      } catch {}
    }

    function edit_cyclePoint(dir){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      const kp = ControlPoints.get(ch)?.points || [];
      const n = Math.max(2, kp.length || 0);
      EDIT.selectedOrdinal = ((EDIT.selectedOrdinal - 1 + dir + n) % n) + 1;
      edit_refreshPointIndex();
    }

    function edit_getStepFromEvent(e){
      if (e && e.shiftKey) return 5; if (e && e.altKey) return 0.1; return 1;
    }

    function edit_nudge(deltaX, deltaY, evt){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      if (!edit_isChannelEnabled(ch)) { showStatus('Channel disabled – enable in Channels to edit'); return; }
      const step = edit_getStepFromEvent(evt);
      const params = {};
      if (deltaX) params.deltaInput = deltaX * step;
      if (deltaY) {
        try {
          const kp = ControlPoints.get(ch)?.points || [];
          const p = kp[EDIT.selectedOrdinal - 1];
          const row = document.querySelector(`tr[data-channel="${ch}"]`);
          const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
          const scale = (InputValidator.computePercentFromEnd(endVal)) / 100;
          const curAbs = Math.max(0, Math.min(100, (scale > 0 && p) ? (p.output * scale) : 0));
          const nextAbs = Math.max(0, Math.min(100, curAbs + deltaY * step));
          params.outputPercent = nextAbs;
        } catch {}
      }
      const res = quadGenActions.adjustSmartKeyPointByIndex(ch, EDIT.selectedOrdinal, params);
      if (!res?.success){ showStatus(res?.message || 'Edit failed'); return; }
      updateProcessingDetail(ch);
      updatePreview();
      edit_refreshPointIndex();
    }

    function edit_commitXY(){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      try {
        const ch = EDIT.selectedChannel; if (!ch) return;
        const el = elements.editXYInput; if (!el) return;
        const raw = String(el.value || '').trim();
        const parts = raw.split(',');
        if (parts.length !== 2) {
          el.classList.add('border-red-300');
          showStatus('Invalid format. Use X,Y (e.g., 25.5, 72.3)');
          setTimeout(()=> el.classList.remove('border-red-300'), 1500);
          return;
        }
        const parseNum = (s) => {
          const t = String(s).replace(/%/g, '').trim();
          const n = parseFloat(t);
          return isNaN(n) ? null : n;
        };
        let x = parseNum(parts[0]);
        let y = parseNum(parts[1]);
        if (x === null || y === null) {
          el.classList.add('border-red-300');
          showStatus('Invalid numbers. X and Y must be 0–100');
          setTimeout(()=> el.classList.remove('border-red-300'), 1500);
          return;
        }
        x = Math.max(0, Math.min(100, x));
        y = Math.max(0, Math.min(100, y));
      const res = quadGenActions.adjustSmartKeyPointByIndex(ch, EDIT.selectedOrdinal, { inputPercent: x, outputPercent: y });
        if (!res?.success){
          el.classList.add('border-red-300');
          showStatus(res?.message || 'Edit failed');
          setTimeout(()=> el.classList.remove('border-red-300'), 1500);
          return;
        }
        updateProcessingDetail(ch);
        updatePreview();
        edit_refreshPointIndex();
        el.classList.remove('border-red-300');
      } catch (e) { console.warn('edit_commitXY error:', e); }
    }

    function edit_recompute(){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      if (!edit_isChannelEnabled(ch)) { showStatus('Channel disabled – enable in Channels to recompute'); return; }
      const maxError = Math.max(0.05, Math.min(5, parseFloat(elements.editMaxError?.value || '0.25')));
      const maxPts = Math.max(2, Math.min(21, parseInt(elements.editMaxPoints?.value || '16', 10)));
      const res = quadGenActions.simplifySmartKeyPointsFromCurve(ch, { maxErrorPercent: maxError, maxPoints: maxPts });
      if (!res?.success){ showStatus(res?.message || 'Recompute failed'); return; }
      showStatus(`Recomputed ${ch} key points (${maxPts} max, ${maxError}% max error)`);
      EDIT.selectedOrdinal = Math.min(EDIT.selectedOrdinal, (ControlPoints.get(ch)?.points?.length || 1));
      edit_refreshPointIndex();
    }

    function edit_delete(){
      if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
      const ch = EDIT.selectedChannel; if (!ch) return;
      if (!edit_isChannelEnabled(ch)) { showStatus('Channel disabled – enable in Channels to edit'); return; }
      try {
        const kp = ControlPoints.get(ch)?.points || [];
        const n = kp.length || 0;
        if (n <= 2) { showStatus('At least 2 points required — cannot delete.'); return; }
        if (EDIT.selectedOrdinal === 1 || EDIT.selectedOrdinal === n) {
          showStatus('Endpoint deletion is blocked.');
          return;
        }
      const res = quadGenActions.deleteSmartKeyPointByIndex(ch, EDIT.selectedOrdinal, { allowEndpoint: false });
        if (!res?.success){ showStatus(res?.message || 'Delete failed'); return; }
        // After delete, clamp ordinal and refresh
        const n2 = (ControlPoints.get(ch)?.points?.length || (n-1));
        EDIT.selectedOrdinal = Math.max(1, Math.min(EDIT.selectedOrdinal, n2));
        updateProcessingDetail(ch);
        updatePreview();
        edit_refreshPointIndex();
        showStatus(`Deleted point on ${ch}`);
      } catch (e) { showStatus(`Delete failed: ${e.message}`); }
    }

    function edit_syncShowPointsAndSmoothing(){
      // Mirror smoothing
      if (elements.smoothingSlider && elements.editSmoothingSlider){
        elements.editSmoothingSlider.value = String(elements.smoothingSlider.value);
        if (elements.editSmoothingValue) elements.editSmoothingValue.textContent = `${elements.smoothingSlider.value}%`;
        // Disable the edit smoothing slider whenever the main smoothing is disabled (no linearization active)
        elements.editSmoothingSlider.disabled = !!elements.smoothingSlider.disabled;
        elements.editSmoothingSlider.classList.toggle('opacity-60', !!elements.smoothingSlider.disabled);
      }
    }

    function initEditPanel(){
      // Channel select
      if (elements.editChannelSelect){
        elements.editChannelSelect.addEventListener('change', () => {
          if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
          EDIT.selectedChannel = elements.editChannelSelect.value || null;
          EDIT.selectedOrdinal = 1;
          edit_refreshState();
        });
      }
      // Channel cycle buttons
      function edit_cycleChannel(dir){
        if (!isEditModeEnabled()) { showStatus('Edit mode is off'); return; }
        const sel = elements.editChannelSelect; if (!sel || sel.options.length === 0) return;
        const idx = sel.selectedIndex;
        const n = sel.options.length;
        const next = ((idx + dir) % n + n) % n; // wrap-around
        sel.selectedIndex = next;
        EDIT.selectedChannel = sel.value || null;
        EDIT.selectedOrdinal = 1;
        edit_refreshState();
      }
      if (elements.editChannelPrev){ elements.editChannelPrev.addEventListener('click', ()=> edit_cycleChannel(-1)); }
      if (elements.editChannelNext){ elements.editChannelNext.addEventListener('click', ()=> edit_cycleChannel(+1)); }
      // Recompute
      if (elements.editRecomputeBtn){ elements.editRecomputeBtn.addEventListener('click', edit_recompute); }
      // Point navigation
      if (elements.editPointLeft){ elements.editPointLeft.addEventListener('click', ()=> edit_cyclePoint(-1)); }
      if (elements.editPointRight){ elements.editPointRight.addEventListener('click', ()=> edit_cyclePoint(1)); }
      if (elements.editNudgeYUp){ elements.editNudgeYUp.addEventListener('click', (e)=> edit_nudge(0, +1, e)); }
      if (elements.editNudgeYDown){ elements.editNudgeYDown.addEventListener('click', (e)=> edit_nudge(0, -1, e)); }
      if (elements.editNudgeXNeg){ elements.editNudgeXNeg.addEventListener('click', (e)=> edit_nudge(-1, 0, e)); }
      if (elements.editNudgeXPos){ elements.editNudgeXPos.addEventListener('click', (e)=> edit_nudge(+1, 0, e)); }
      if (elements.editXYInput){ elements.editXYInput.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ edit_commitXY(); } }); }
      if (elements.editDeleteBtn){ elements.editDeleteBtn.addEventListener('click', edit_delete); }
      // No key-point visibility checkbox; visibility follows Edit Mode
      // Mirror Smoothing
      if (elements.editSmoothingSlider){
        elements.editSmoothingSlider.addEventListener('input', (e)=>{
          const v = Math.round(parseFloat(e.target.value||'0'));
          if (elements.editSmoothingValue) elements.editSmoothingValue.textContent = `${v}%`;
          if (elements.smoothingSlider){ elements.smoothingSlider.value = String(v); elements.smoothingSlider.dispatchEvent(new Event('input', {bubbles:true})); }
        });
      }
      if (elements.smoothingSlider){ elements.smoothingSlider.addEventListener('input', ()=> edit_syncShowPointsAndSmoothing()); }
      // Initial population
      edit_populateChannelSelect();
      // Wire edit mode toggle
      const toggleBtn = document.getElementById('editModeToggleBtn');
      if (toggleBtn){
        toggleBtn.addEventListener('click', () => setEditMode(!isEditModeEnabled(), { recordHistory: true }));
      }
      // Start with edit mode disabled by default (no history)
      setEditMode(false, { recordHistory: false });
      // Re-populate when channel enable states change
      if (elements.rows){
        elements.rows.addEventListener('input', (e)=>{
          const t = e.target;
          if (t && (t.classList?.contains('end-input') || t.classList?.contains('percent-input'))){
            setTimeout(()=>{ try { edit_populateChannelSelect(); } catch {} }, 0);
          }
        });
        elements.rows.addEventListener('channelsChanged', ()=>{
          setTimeout(()=>{ try { edit_populateChannelSelect(); } catch {} }, 0);
        });
      }
    }

    // Initialize Edit Curves panel now that dependencies are defined
    try { initEditPanel(); } catch(e) { console.warn('Edit panel init failed:', e); }

    // Debounce function to prevent excessive updates
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Normalize legacy 'ai' source tags to 'smart'
    function normalizeSmartSourcesInLoadedData() {
      try {
        if (!window.loadedQuadData || !window.loadedQuadData.sources) return;
        const src = window.loadedQuadData.sources;
        Object.keys(src).forEach((ch) => {
          if (src[ch] === 'ai') src[ch] = 'smart';
        });
      } catch {}
    }

    // Helper: treat both historical 'ai' and new 'smart' as Smart Curve source
    function isSmartCurveSourceTag(tag) {
      return tag === 'smart' || tag === 'ai';
    }

    function isSmartCurve(channelName) {
      try {
        const tag = window.loadedQuadData?.sources?.[channelName];
        return isSmartCurveSourceTag(tag);
      } catch {
        return false;
      }
    }

    // Toggle: whether to show assistant status messages in chat
    function shouldShowAssistantStatus() {
      try {
        const el = document.getElementById('aiShowStatusToggle');
        return !el || !!el.checked; // default to true if toggle missing
      } catch { return true; }
    }
    // Back-compat wrapper
    function shouldShowAIStatus() { return shouldShowAssistantStatus(); }

    // Helper: graph-only status filter and simple chat de-duplication
    let __lastStatusChat = { text: '', ts: 0 };
    function isGraphStatusMessage(msg) {
      const graphKeys = ['Preview updated', 'Error updating preview'];
      return graphKeys.some(k => msg.includes(k));
    }

    function showStatus(message) {
      const isGraph = isGraphStatusMessage(message);
      if (isGraph) {
        elements.status.textContent = message;
        elements.status.style.opacity = '1';
      } else {
        // Route non-graph messages to Lab Tech chat (avoid duplicates)
        try {
          if (shouldShowAssistantStatus() && typeof addChatMessage === 'function') {
            const now = Date.now();
            if (__lastStatusChat.text !== message || now - __lastStatusChat.ts > 1000) {
              addChatMessage('system', message);
              __lastStatusChat = { text: message, ts: now };
            }
          }
        } catch {}
      }
      setTimeout(() => {
        if (elements.status.textContent === message) {
          elements.status.style.opacity = '0';
          setTimeout(() => {
            if (elements.status.style.opacity === '0') {
              elements.status.innerHTML = "&nbsp;";
              elements.status.style.opacity = '1';
            }
          }, 500); // Wait for fade transition to complete
        }
      }, 6000);
    }
    
    function animateLogoBars() {
      const cyanBar = document.getElementById('cyanBar');
      const magentaBar = document.getElementById('magentaBar');
      const yellowBar = document.getElementById('yellowBar');
      const blackBar = document.getElementById('blackBar');
      const logoPath = document.getElementById('logoPath');
      const node1 = document.getElementById('node1');
      const node2 = document.getElementById('node2');
      const node3 = document.getElementById('node3');
      const node4 = document.getElementById('node4');
      
      if (!cyanBar || !magentaBar || !yellowBar || !blackBar) return;
      
      // Original values
      const originalHeights = { cyan: 40, magenta: 60, yellow: 80, black: 110 };
      const originalYs = { cyan: 90, magenta: 70, yellow: 50, black: 22 };
      
      let animationStep = 0;
      const maxSteps = 32; // Number of back-and-forth movements
      
      function animateStep() {
        if (animationStep >= maxSteps) {
          // Final return to original state
          cyanBar.setAttribute('height', originalHeights.cyan);
          cyanBar.setAttribute('y', originalYs.cyan);
          magentaBar.setAttribute('height', originalHeights.magenta);
          magentaBar.setAttribute('y', originalYs.magenta);
          yellowBar.setAttribute('height', originalHeights.yellow);
          yellowBar.setAttribute('y', originalYs.yellow);
          blackBar.setAttribute('height', originalHeights.black);
          blackBar.setAttribute('y', originalYs.black);
          logoPath.setAttribute('d', 'M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 32, 126 22');
          node1.setAttribute('cy', '88');
          node2.setAttribute('cy', '68');
          node3.setAttribute('cy', '48');
          node4.setAttribute('cy', '18');
          return;
        }
        
        // Generate oscillating variations that get smaller over time
        const damping = 1 - (animationStep / maxSteps) * 0.7; // Reduce intensity over time
        const frequency = Math.sin(animationStep * 0.8) * damping; // Oscillating pattern
        
        const cyanVariation = originalHeights.cyan + frequency * 12;
        const magentaVariation = originalHeights.magenta + frequency * 15;
        const yellowVariation = originalHeights.yellow + frequency * 18;
        const blackVariation = originalHeights.black + frequency * 25;
        
        // Update bar heights and positions
        cyanBar.setAttribute('height', Math.max(5, cyanVariation));
        cyanBar.setAttribute('y', 132 - Math.max(5, cyanVariation));
        
        magentaBar.setAttribute('height', Math.max(5, magentaVariation));
        magentaBar.setAttribute('y', 132 - Math.max(5, magentaVariation));
        
        yellowBar.setAttribute('height', Math.max(5, yellowVariation));
        yellowBar.setAttribute('y', 132 - Math.max(5, yellowVariation));
        
        blackBar.setAttribute('height', Math.max(5, blackVariation));
        blackBar.setAttribute('y', 132 - Math.max(5, blackVariation));
        
        // Update curve and nodes to match bar heights
        const newCyanY = 132 - Math.max(5, cyanVariation) + 2;
        const newMagentaY = 132 - Math.max(5, magentaVariation) + 2;
        const newYellowY = 132 - Math.max(5, yellowVariation) + 2;
        const newBlackY = 132 - Math.max(5, blackVariation) + 2;
        
        // Update curve path
        const newPath = `M30 ${newCyanY} C 44 ${newCyanY-4}, 50 ${newMagentaY+4}, 62 ${newMagentaY} S 86 ${newYellowY+2}, 94 ${newYellowY} S 118 ${newBlackY+10}, 126 ${newBlackY}`;
        logoPath.setAttribute('d', newPath);
        
        // Update node positions
        node1.setAttribute('cy', newCyanY);
        node2.setAttribute('cy', newMagentaY);
        node3.setAttribute('cy', newYellowY);
        node4.setAttribute('cy', newBlackY);
        
        animationStep++;
        setTimeout(animateStep, 100); // 100ms between each step
      }
      
      animateStep(); // Start the animation sequence
    }
    

    function updateProcessingDetailForce(channelName) {
      // Always-visible single-line label updater
      const processingLabel = document.querySelector(`tr[data-channel="${channelName}"] .processing-label`);
      if (!processingLabel) return;

      const segmentsApplied = [];

      // Consolidated display: if a Smart Curve is active and there is a loaded per‑channel source that is disabled,
      // show a single line with the source filename and the current Smart key‑point count.
      const hasSmartCurve = !!(window.loadedQuadData && window.loadedQuadData.curves && window.loadedQuadData.curves[channelName] && isSmartCurve(channelName));
      const per = perChannelLinearization[channelName];
      const perIsDisabled = !!(per && !perChannelEnabled[channelName]);
      if (hasSmartCurve && per && perIsDisabled) {
        const baseName = (perChannelFilenames && perChannelFilenames[channelName]) || per.filename || 'unknown file';
        const dispName = getEditedDisplayName(baseName, !!per.edited);
        const smartPts = ControlPoints.get(channelName).points;
        const smartCount = Array.isArray(smartPts) ? smartPts.length : null;
        const countLabel = smartCount ? `${smartCount} key points` : getBasePointCountLabel(per);
        const text = `${dispName} (${countLabel})`;
        processingLabel.textContent = text;
        processingLabel.setAttribute('title', text);
        return; // Do not list separate Smart/per‑channel lines
      }

      // Base curve segment (Smart vs loaded .quad)
      if (window.loadedQuadData && window.loadedQuadData.curves && window.loadedQuadData.curves[channelName]) {
        const isSmart = isSmartCurve(channelName);
        if (isSmart) {
          const kp = ControlPoints.get(channelName).points;
          const kpLabel = Array.isArray(kp) ? ` (${kp.length} key points)` : '';
          segmentsApplied.push(`Smart Curve${kpLabel}`);
        } else {
          const baseFile = window.loadedQuadData.filename || 'loaded .quad';
          segmentsApplied.push(`${baseFile}`);
        }
      }

      // Per-channel linearization segment (show even if disabled)
      if (perChannelLinearization[channelName]) {
        const data = perChannelLinearization[channelName];
        const format = data.format || 'curve data';
        const baseName = (perChannelFilenames && perChannelFilenames[channelName]) || data.filename || 'unknown file';
        const dispName = getEditedDisplayName(baseName, !!data.edited);
        const applied = !!perChannelEnabled[channelName];
        const countLabel = getBasePointCountLabel(data);
        if (applied) {
          segmentsApplied.push(`channel: ${format} • ${dispName} (${countLabel})`);
        }
      }

      // Global linearization segment (show even if disabled)
      if (linearizationData && Array.isArray(linearizationData.samples)) {
        const format = linearizationData.format || 'linearization';
        const baseName = linearizationData.filename || 'unknown file';
        const dispName = getEditedDisplayName(baseName, !!linearizationData.edited);
        const countLabel = getBasePointCountLabel(linearizationData);
        if (linearizationApplied) {
          segmentsApplied.push(`Global: ${format} • ${dispName} (${countLabel})`);
        }
      }

      // Build display text; show each applied segment on a new line.
      if (segmentsApplied.length === 0) {
        processingLabel.textContent = '→ Linear ramp';
        processingLabel.setAttribute('title', 'Linear ramp');
      } else {
        // Preserve clean tooltip without decoration
        const tooltip = segmentsApplied.join(' | ');
        // Add a downward arrow to the first line if multiple segments
        if (segmentsApplied.length > 1) {
          segmentsApplied[0] = `${segmentsApplied[0]} \u21B4`;
        }
        const html = segmentsApplied.map(s => `<span>${s}</span>`).join('<br>');
        processingLabel.innerHTML = html;
        processingLabel.setAttribute('title', tooltip);
      }
    }

    function updateProcessingDetail(channelName) {
      // Panels are always visible now; delegate to force updater
      updateProcessingDetailForce(channelName);
    }

    function updatePreview() {
      requestAnimationFrame(() => {
        try {
          const fileText = buildFile();
          elements.previewFull.textContent = fileText;
          updateInkChart();
          updateFilename(); // Update filename when preview updates
          // Delta UI disabled; summaries are posted to Lab Tech chat instead
          showStatus("Preview updated");
        } catch (error) {
      console.error('Preview update error:', error);
          showStatus("Error updating preview");
        }
      });
    }

    function populatePerChannelDeltaSelect() {
      const sel = elements.perChannelDeltaSelect;
      if (!sel) return;
      const channels = getCurrentPrinter().channels || [];
      const current = sel.value;
      sel.innerHTML = '';
      channels.forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch; opt.textContent = ch;
        sel.appendChild(opt);
      });
      // Prefer previously selected, else first enabled, else first channel
      let desired = current && channels.includes(current) ? current : null;
      if (!desired) {
        const rows = Array.from(elements.rows?.children || []).filter(tr => tr.id !== 'noChannelsRow');
        const enabledRow = rows.find(tr => (InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0)) > 0);
        desired = enabledRow ? enabledRow.getAttribute('data-channel') : (channels[0] || '');
      }
      if (desired) sel.value = desired;
    }

    // Deprecated UI summary (hidden). Kept for reference; use chat summaries instead.
    function updatePerChannelDeltaSummary() {
      const out = elements.perChannelDeltaSummary;
      const sel = elements.perChannelDeltaSelect;
      if (!out || !sel) return;
      const ch = sel.value;
      if (!ch) { out.textContent = ''; return; }
      try {
        // Find end value for channel
        const row = document.querySelector(`tr[data-channel="${ch}"]`);
        if (!row) { out.textContent=''; return; }
        const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
        if (endVal <= 0) { out.textContent = '(disabled)'; return; }
        // Build before/after plotted values with/without global linearization
        const before = make256(endVal, ch, false); // integers 0..endVal
        const after  = make256(endVal, ch, true);  // integers 0..endVal
        if (!Array.isArray(before) || before.length < 2 || !Array.isArray(after) || after.length !== before.length) { out.textContent=''; return; }
        const N = after.length;
        // Compute absolute change as percent of full scale (TOTAL)
        let minChange=Infinity, maxChange=-Infinity, minIdx=0, maxIdx=0;
        for (let i=0;i<N;i++) {
          const dAbs = ((after[i] - before[i]) / TOTAL) * 100; // absolute ink % of full scale
          if (dAbs < minChange){ minChange=dAbs; minIdx=i; }
          if (dAbs > maxChange){ maxChange=dAbs; maxIdx=i; }
        }
        const fmtPct = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
        const kind = (v)=> v>0 ? 'add ink' : (v<0 ? 'reduce ink' : 'no change');
        const maxLabel = `${fmtPct(maxChange)} (${kind(maxChange)}) @ ${(maxIdx/(N-1)*100).toFixed(1)}%`;
        const minLabel = `${fmtPct(minChange)} (${kind(minChange)}) @ ${(minIdx/(N-1)*100).toFixed(1)}%`;
        out.textContent = `${ch}: ${maxLabel}, ${minLabel}`;
        out.title = 'Absolute change vs original plotted curve (percent of full scale)';
      } catch (e) { out.textContent=''; }
    }

    // Compute and display delta vs linear when LAB global linearization is active
    // Deprecated UI summary (hidden). Kept for reference; use chat summaries instead.
    function updateDeltaSummary() {
      const el = elements.deltaSummary;
      if (!el) return;
      if (!linearizationData || !linearizationApplied) { el.textContent = ''; return; }
      const fmt = String(linearizationData.format || '').toUpperCase();
      // Show delta for LAB files and Manual L* generated corrections
      if (!(fmt.includes('LAB') || fmt.includes('MANUAL'))) { el.textContent = ''; return; }
      try {
        const smoothingPercent = parseFloat(elements.smoothingSlider?.value || '0') || 0;
        // Build normalized mapping 0..1 using current interpolation and smoothing
        let samples, lutX;
        if (typeof linearizationData.getSmoothingControlPoints === 'function') {
          const cp = linearizationData.getSmoothingControlPoints(smoothingPercent);
          samples = cp?.samples || linearizationData.samples;
          lutX = cp?.xCoords || null;
        } else {
          samples = linearizationData.samples;
          lutX = null;
        }
        if (!Array.isArray(samples) || samples.length < 2) { el.textContent=''; return; }
        const K = samples.length;
        if (!lutX) {
          lutX = new Array(K);
          for (let i=0;i<K;i++) lutX[i] = i/(K-1);
        }
        // Choose interpolation type similarly to global apply
        const interpType = getGlobalLinearizationInterpolationType(linearizationData, elements.curveSmoothingMethod.value);
        let interp;
        if (interpType === 'pchip') interp = createPCHIPSpline(lutX, samples);
        else if (interpType === 'cubic') interp = createCubicSpline(lutX, samples);
        else if (interpType === 'catmull') interp = createCatmullRomSpline(lutX, samples, (elements.catmullTension?.value||50)/100);
        else {
          interp = (t)=>{
            if (t<=lutX[0]) return samples[0];
            if (t>=lutX[K-1]) return samples[K-1];
            let i0=0; for(let i=0;i<K-1;i++){ if (t>=lutX[i] && t<=lutX[i+1]) { i0=i; break; } }
            const i1=Math.min(i0+1,K-1);
            const x0=lutX[i0], x1=lutX[i1];
            const y0=samples[i0], y1=samples[i1];
            const a = x1===x0?0:(t-x0)/(x1-x0);
            return (1-a)*y0 + a*y1;
          };
        }
        // Evaluate 256 mapping and compute delta vs linear
        const N = 256;
        let minDelta=Infinity, maxDelta=-Infinity, minIdx=0, maxIdx=0;
        for (let i=0;i<N;i++){
          const x = i/(N-1);
          const y = interp(x);
          const d = (y - x) * 100; // percent points
          if (d < minDelta){ minDelta = d; minIdx = i; }
          if (d > maxDelta){ maxDelta = d; maxIdx = i; }
        }
        // Zero crossing (first sign change)
        let zeroAt = null;
        for (let i=1;i<N;i++){
          const prev = (interp((i-1)/(N-1)) - (i-1)/(N-1));
          const curr = (interp(i/(N-1)) - i/(N-1));
          if (prev===0){ zeroAt = (i-1)/(N-1); break; }
          if ((prev<0 && curr>0) || (prev>0 && curr<0)){
            const t = Math.abs(curr - prev) > 1e-12 ? (-prev)/(curr - prev) : 0;
            zeroAt = ((i-1) + t)/(N-1);
            break;
          }
        }
        const fmtPct = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
        const kind = (v)=> v>0 ? 'add ink' : (v<0 ? 'reduce ink' : 'no change');
        const maxLabel = `${fmtPct(maxDelta)} (${kind(maxDelta)}) @ ${(maxIdx/(N-1)*100).toFixed(1)}%`;
        const minLabel = `${fmtPct(minDelta)} (${kind(minDelta)}) @ ${(minIdx/(N-1)*100).toFixed(1)}%`;
        const zeroLabel = zeroAt!=null ? `, zero ≈ ${(zeroAt*100).toFixed(1)}%` : '';
        el.textContent = `Δ vs linear: ${maxLabel}, ${minLabel}${zeroLabel}`;
        el.title = 'Delta computed from current LAB mapping and interpolation';
      } catch (e) {
        try { elements.deltaSummary.textContent=''; } catch {}
      }
    }

    // Build a one-line global delta summary for Lab Tech chat
    function buildGlobalDeltaSummaryText() {
      try {
        if (!linearizationData || !linearizationApplied) return '';
        const fmt = String(linearizationData.format || '').toUpperCase();
        if (!(fmt.includes('LAB') || fmt.includes('MANUAL'))) return '';
        const smoothingPercent = parseFloat(elements.smoothingSlider?.value || '0') || 0;
        let samples, lutX;
        if (typeof linearizationData.getSmoothingControlPoints === 'function') {
          const cp = linearizationData.getSmoothingControlPoints(smoothingPercent);
          samples = cp?.samples || linearizationData.samples;
          lutX = cp?.xCoords || null;
        } else {
          samples = linearizationData.samples;
          lutX = null;
        }
        if (!Array.isArray(samples) || samples.length < 2) return '';
        const K = samples.length;
        if (!lutX) { lutX = Array.from({length: K}, (_, i) => i/(K-1)); }
        const interpType = getGlobalLinearizationInterpolationType(linearizationData, elements.curveSmoothingMethod.value);
        let interp;
        if (interpType === 'pchip') interp = createPCHIPSpline(lutX, samples);
        else if (interpType === 'cubic') interp = createCubicSpline(lutX, samples);
        else if (interpType === 'catmull') interp = createCatmullRomSpline(lutX, samples, (elements.catmullTension?.value||50)/100);
        else interp = (t)=>{
          if (t<=lutX[0]) return samples[0];
          if (t>=lutX[K-1]) return samples[K-1];
          let i0=0; for(let i=0;i<K-1;i++){ if (t>=lutX[i] && t<=lutX[i+1]) { i0=i; break; } }
          const i1=Math.min(i0+1,K-1);
          const x0=lutX[i0], x1=lutX[i1];
          const y0=samples[i0], y1=samples[i1];
          const a = x1===x0?0:(t-x0)/(x1-x0);
          return (1-a)*y0 + a*y1;
        };
        const N = 256;
        let minDelta=Infinity, maxDelta=-Infinity, minIdx=0, maxIdx=0;
        for (let i=0;i<N;i++){
          const x = i/(N-1);
          const y = interp(x);
          const d = (y - x) * 100; // percent points
          if (d < minDelta){ minDelta = d; minIdx = i; }
          if (d > maxDelta){ maxDelta = d; maxIdx = i; }
        }
        // zero crossing
        let zeroAt = null;
        for (let i=1;i<N;i++){
          const prev = (interp((i-1)/(N-1)) - (i-1)/(N-1));
          const curr = (interp(i/(N-1)) - i/(N-1));
          if (prev===0){ zeroAt=(i-1)/(N-1); break; }
          if ((prev<0 && curr>0) || (prev>0 && curr<0)){
            const t = Math.abs(curr - prev) > 1e-12 ? (-prev)/(curr - prev) : 0;
            zeroAt = ((i-1) + t)/(N-1);
            break;
          }
        }
        const fmtPct = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
        const kind = (v)=> v>0 ? 'add ink' : (v<0 ? 'reduce ink' : 'no change');
        const maxLabel = `${fmtPct(maxDelta)} (${kind(maxDelta)}) @ ${(maxIdx/(N-1)*100).toFixed(1)}%`;
        const minLabel = `${fmtPct(minDelta)} (${kind(minDelta)}) @ ${(minIdx/(N-1)*100).toFixed(1)}%`;
        const zeroLabel = zeroAt!=null ? `, zero ≈ ${(zeroAt*100).toFixed(1)}%` : '';
        return `Δ vs linear: ${maxLabel}, ${minLabel}${zeroLabel}`;
      } catch { return ''; }
    }

    function buildPerChannelChangeSummaryAllChannelsText() {
      try {
        if (!linearizationData || !linearizationApplied) return '';
        const channels = getCurrentPrinter().channels || [];
        const parts = [];
        channels.forEach(ch => {
          const row = document.querySelector(`tr[data-channel="${ch}"]`);
          if (!row) return;
          const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
          if (endVal <= 0) return;
          const before = make256(endVal, ch, false);
          const after  = make256(endVal, ch, true);
          if (!Array.isArray(before) || !Array.isArray(after) || before.length !== after.length) return;
          let minChange=Infinity, maxChange=-Infinity;
          const N = after.length;
          for (let i=0;i<N;i++){
            const dAbs = ((after[i] - before[i]) / TOTAL) * 100;
            if (dAbs < minChange){ minChange=dAbs; }
            if (dAbs > maxChange){ maxChange=dAbs; }
          }
          const fmtShort = (v)=> (v>=0?'+':'') + v.toFixed(1) + '%';
          parts.push(`${ch}:${fmtShort(maxChange)}/${fmtShort(minChange)}`);
        });
        if (parts.length === 0) return '';
        return `Channel changes (max/min vs original): ${parts.join('; ')}`;
      } catch { return ''; }
    }

    function postGlobalDeltaChatSummary() {
      try {
        const line1 = buildGlobalDeltaSummaryText();
        const line2 = buildPerChannelChangeSummaryAllChannelsText();
        if (line1) addChatMessage('system', line1);
        if (line2) addChatMessage('system', line2);
      } catch {}
    }

    // Graph semantics: ink mapping (output vs input). Y=X = no correction; dips (Y<X) lighten; humps (Y>X) darken.
    // See docs/LAB_LINEARIZATION_WORKFLOW.md for plotting conventions and cross-tool comparisons.
  function updateInkChart() {
      // Stable mapping: X left→right (0→100), Y bottom→top (0→100)
      if (DEBUG_LOGS) console.log('DEBUG: Global linearization state:', {
        hasLinearizationData: !!linearizationData,
        linearizationApplied: linearizationApplied,
        samplesCount: linearizationData?.samples?.length || 0,
        hasAnyLinearization: hasAnyLinearization()
      });
      
      if (elements.rows.children.length === 0) return;
      
      const canvas = elements.inkChart;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Set up coordinate system
      const padding = 60;
      const leftPadding = padding - 6; // Shift chart 6px left
      const rightPadding = padding + 6; // Maintain total width
      const chartWidth = width - leftPadding - rightPadding;
      const chartHeight = height - 2 * padding;

      // Determine how many ink channels are currently enabled (selected)
      const activeEnabledCount = Array.from(elements.rows.children).reduce((count, row) => {
        if (row.id === 'noChannelsRow') return count;
        const input = row.querySelector('.end-input');
        if (!input) return count;
        const endVal = InputValidator.clampEnd(input.value);
        return count + (endVal > 0 ? 1 : 0);
      }, 0);
      
      // Auto-toggle off overlays when multiple channels are enabled, but allow users to re-enable them
      if (elements.aiLabelToggle) {
        if (activeEnabledCount > 1) {
          if (elements.aiLabelToggle.checked && !overlayAutoToggledOff) {
            elements.aiLabelToggle.checked = false;
            overlayAutoToggledOff = true;
          }
        } else {
          // Reset guard when back to single/no channels
          overlayAutoToggledOff = false;
        }
      }
      
      // No additional status messaging; overlays are user-togglable via the toggle
      
      // Check conditions for showing original curve overlay
      const smoothingPercent = parseFloat(elements.smoothingSlider.value) || 0;
      const shouldShowOriginal = smoothingPercent > 0;
      
      // Draw grid
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      
      // Vertical grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Horizontal grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const y = padding + (i * chartHeight / 10);
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(leftPadding + chartWidth, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(leftPadding, padding);
      ctx.lineTo(leftPadding, height - padding);
      ctx.lineTo(leftPadding + chartWidth, height - padding);
      ctx.stroke();
      
      // Draw axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      
      // Ink-level orientation helper: vertical white↕black gradient beside Y-axis
      // White at 0% (bottom), Black at 100% (top)
      (function drawInkLevelGradient() {
        const gradientWidth = 10; // slim vertical strip for orientation
        // Place outside chart area, just to the left of the Y-axis line
        const gradientX = leftPadding - gradientWidth - 1;
        const grad = ctx.createLinearGradient(0, padding, 0, height - padding);
        grad.addColorStop(0, '#000000'); // top = 100% ink = black
        grad.addColorStop(1, '#ffffff'); // bottom = 0% ink = white
        ctx.fillStyle = grad;
        ctx.fillRect(gradientX, padding, gradientWidth, chartHeight);
        // subtle border for visibility
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 1;
        ctx.strokeRect(gradientX, padding, gradientWidth, chartHeight);
      })();

      // Input-level orientation helper: white→black gradient under X-axis
      // White at 0% (left), Black at 100% (right)
      (function drawInputLevelGradient() {
        const gradientHeight = 10; // small strip for orientation
        // Position so the strip touches the axis line
        const gradientY = height - padding + 1; // flush with axis bottom
        const grad = ctx.createLinearGradient(leftPadding, 0, leftPadding + chartWidth, 0);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#000000');
        ctx.fillStyle = grad;
        ctx.fillRect(leftPadding, gradientY, chartWidth, gradientHeight);
        // subtle border for visibility on light backgrounds
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 1;
        ctx.strokeRect(leftPadding, gradientY, chartWidth, gradientHeight);
      })();
      
      // Ensure text labels are solid black regardless of prior fills
      ctx.fillStyle = '#000000';
      
      // X-axis labels (0% to 100%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        const value = i * 10;
        // Make 0 and 100 bold
        if (value === 0 || value === 100) {
          ctx.font = 'bold 12px system-ui';
        } else {
          ctx.font = '12px system-ui';
        }
        // Nudge labels slightly lower to avoid overlapping the gradient strip
        ctx.fillText(`${value}`, x, height - padding + 28);
      }
      
      // Y-axis labels (0% to 100%)
      ctx.textAlign = 'right';
      ctx.fillStyle = '#000000';
      // Nudge labels left to account for the vertical gradient width (10px) + 1px gap + ~1px margin
      // Nudge slightly more to the right for spacing
      const yAxisLabelX = leftPadding - (10 /* gradient */ + 1 /* gap */ + 10 /* original offset */ + 1 /* margin */) + 4;
      for (let i = 0; i <= 10; i++) {
        const y = height - padding - (i * chartHeight / 10);
        const value = i * 10;
        // Make 0 and 100 bold
        if (value === 0 || value === 100) {
          ctx.font = 'bold 12px system-ui';
        } else {
          ctx.font = '12px system-ui';
        }
        ctx.fillText(`${value}`, yAxisLabelX, y + 4);
      }
      
      // Axis titles
      ctx.textAlign = 'center';
      ctx.font = '14px system-ui';
      ctx.fillStyle = '#000000';
      ctx.fillText('Input Level %', width / 2, height - 10);
      
      ctx.save();
      // Shift Y-axis title left; clamp to keep it inside canvas
      const yAxisTitleBaseX = 15;
      const yAxisTitleShift = (10 /* gradient */ + 1 /* gap */ + 1 /* margin */);
      // Nudge a bit further left while keeping it inside canvas
      const yAxisTitleX = Math.max(11, yAxisTitleBaseX - yAxisTitleShift);
      ctx.translate(yAxisTitleX, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillStyle = '#000000';
      ctx.fillText('Output Ink Level %', 0, 0);
      ctx.restore();

      // Update chart cursor tooltip mapping and listeners
      setupChartCursorTooltip({ leftPadding, chartWidth, padding, chartHeight, width, height });
      
      // Draw curves and collect label info
      const labels = [];
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      
      // Build draw order; in Edit Mode draw the selected channel last (on top)
      const isEdit = isEditModeEnabled();
      const selectedName = (isEdit && EDIT && EDIT.selectedChannel) ? String(EDIT.selectedChannel) : null;
      const drawRows = Array.from(elements.rows.children)
        .filter(row => row.id !== 'noChannelsRow')
        .sort((a, b) => {
          try {
            if (!selectedName) return 0;
            const aName = a.querySelector('td span span:nth-child(2)')?.textContent?.trim();
            const bName = b.querySelector('td span span:nth-child(2)')?.textContent?.trim();
            const aSel = (aName === selectedName) ? 1 : 0;
            const bSel = (bName === selectedName) ? 1 : 0;
            return aSel - bSel; // selected (1) sorts after non-selected (0)
          } catch { return 0; }
        });
      
      drawRows.forEach((row, index) => {
        // Skip the placeholder row
        if (row.id === 'noChannelsRow') return;
        
        const channelName = row.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(row.querySelector('.end-input').value);
        
        if (endVal === 0) return; // Skip disabled channels
        
        const percent = InputValidator.computePercentFromEnd(endVal);
        const inkColor = INK_COLORS[channelName] || '#000000';
        
        // Generate the 256 values with linearization
        const values = make256(endVal, channelName, true);
        const maxValue = TOTAL; // 64000
        
        if (DEBUG_LOGS) console.log('DEBUG: Chart values for', channelName, {
          valuesCount: values.length,
          valuesMin: Math.min(...values),
          valuesMax: Math.max(...values),
          maxValue: maxValue,
          endVal: endVal,
          hasInvalidValues: values.some(v => isNaN(v) || !isFinite(v) || v < 0),
          firstFewValues: values.slice(0, 10),
          lastFewValues: values.slice(-5)
        });
        
        
        // Draw a faded linear reference line (always for Smart/edited curves; also for active linearization)
        const isAICurve = isSmartCurve(channelName);
        const showLinearRef = hasLinearization || isAICurve;
        if (showLinearRef) {
          // Generate linear values without linearization for comparison
          // Use a pure linear ramp from 0→End to avoid Smart/per-channel/global influences
          const linearValues = (() => {
            const Nvals = 256;
            const arr = new Array(Nvals);
            for (let i = 0; i < Nvals; i++) arr[i] = Math.round((i / (Nvals - 1)) * endVal);
            return arr;
          })();
          
          // Draw faded linear reference line
          ctx.strokeStyle = inkColor;
          // Dim further when Edit Mode is on and this is not the selected channel
          const isEdit = isEditModeEnabled();
          const isSelectedChannel = isEdit && EDIT && EDIT.selectedChannel === channelName;
          ctx.globalAlpha = (isEdit && !isSelectedChannel) ? 0.125 : 0.25;
          ctx.lineWidth = 1;
          ctx.setLineDash([2, 2]); // Dotted line
          ctx.beginPath();
          
          for (let i = 0; i < linearValues.length; i++) {
            const x = leftPadding + (i / (linearValues.length - 1)) * chartWidth;
            const valuePercent = (linearValues[i] / maxValue) * 100;
            const y = height - padding - (valuePercent / 100) * chartHeight;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
          ctx.setLineDash([]); // Reset line dash
          ctx.globalAlpha = 1.0; // Reset opacity
        }
        
        // Draw original curve (before smoothing) if conditions are met
        if (shouldShowOriginal && hasLinearization) {
          // Generate the original curve without smoothing by temporarily storing and overriding smoothing
          const currentSmoothing = elements.smoothingSlider.value;
          elements.smoothingSlider.value = '0';
          const originalValues = make256(endVal, channelName, true);
          elements.smoothingSlider.value = currentSmoothing; // Restore original smoothing
          
          // Draw original curve as gray dashed line
          ctx.strokeStyle = '#9CA3AF'; // Gray-400
          ctx.globalAlpha = 0.8;
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 2]); // Dashed line
          ctx.beginPath();
          
          for (let i = 0; i < originalValues.length; i++) {
            const x = leftPadding + (i / (originalValues.length - 1)) * chartWidth;
            const valuePercent = (originalValues[i] / maxValue) * 100;
            const y = height - padding - (valuePercent / 100) * chartHeight;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
          ctx.setLineDash([]); // Reset line dash
          ctx.globalAlpha = 1.0; // Reset opacity
        }
        
        // Draw the actual linearized curve (dim unselected channels in Edit Mode)
      const isSelectedChannel = isEdit && EDIT && EDIT.selectedChannel === channelName;
      const dimUnselected = isEdit && !isSelectedChannel;
      ctx.strokeStyle = inkColor;
      ctx.globalAlpha = dimUnselected ? 0.5 : 1.0;
      ctx.lineWidth = 2;
      ctx.beginPath();
        
        // Plot the curve
        for (let i = 0; i < values.length; i++) {
          const x = leftPadding + (i / (values.length - 1)) * chartWidth;
          const valuePercent = (values[i] / maxValue) * 100;
          const y = height - padding - (valuePercent / 100) * chartHeight;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
      ctx.stroke();
      ctx.globalAlpha = 1.0; // reset
        
        // Lightweight overlay: key points visibility follows Edit Mode
        // Prefer explicit AI key points when available; otherwise show adapter overlays (ACV/LUT/LAB)
        const aiPts = window.loadedQuadData?.keyPoints?.[channelName];
        const hasAIKeyPoints = Array.isArray(aiPts) && aiPts.length > 0;
        if (hasAIKeyPoints && isEdit) {
          const showAIlabels = !!isSelectedChannel; // hide ordinal labels on unselected channels
          const showMarkers = !!isSelectedChannel; // hide point boxes on unselected channels
          ctx.save();
          if (dimUnselected) ctx.globalAlpha = 0.5;
          renderAIKeyPointOverlay(ctx, channelName, values, maxValue, { leftPadding, chartWidth, padding, height }, inkColor, { showLabels: showAIlabels, drawMarkers: showMarkers });
          ctx.restore();
        } else if (isEdit) {
          // Only show adapter overlays (LAB/LUT/ACV) in Edit Mode
          const sets = getAdapterOverlayXPositions(channelName);
          const showOverlayLabels = !!isSelectedChannel; // show labels only for selected channel
          ctx.save();
          if (dimUnselected) ctx.globalAlpha = 0.5;
          sets.forEach(set => {
            renderXPositionsOverlay(ctx, set.xPercents, values, maxValue, { leftPadding, chartWidth, padding, height }, inkColor, showOverlayLabels);
          });
          ctx.restore();
        }
        
        // Store label info for later positioning
        const actualEndValue = values[values.length - 1];
        const actualEndPercent = (actualEndValue / maxValue) * 100;
        const endY = height - padding - (actualEndPercent / 100) * chartHeight;
        
        labels.push({
          channelName,
          percent: Math.round(percent),
          inkColor,
          endY
        });
      });
      
      // Draw labels with collision avoidance
      if (labels.length > 0) {
        labels.sort((a, b) => a.endY - b.endY); // Sort by Y position
        
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        
        const minSpacing = 20; // Minimum spacing between labels
        const endX = leftPadding + chartWidth; // Position labels at the right edge of chart
        
        // Adjust label positions to avoid overlaps
        for (let i = 0; i < labels.length; i++) {
          let labelY = labels[i].endY + 4;
          
          // Check for overlap with previous label
          if (i > 0) {
            const prevLabelY = labels[i-1].adjustedY || (labels[i-1].endY + 4);
            if (labelY - prevLabelY < minSpacing) {
              labelY = prevLabelY + minSpacing;
            }
          }
          
          // Store adjusted position
          labels[i].adjustedY = labelY;
          
          // Draw the label with background for better readability
          const labelText = `${labels[i].channelName} (${labels[i].percent}%)`;
          const textMetrics = ctx.measureText(labelText);
          const textWidth = textMetrics.width;
          const textHeight = 18; // Background height for 12px text with padding
          
          // Draw solid white background
          ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
          ctx.fillRect(endX, labelY - textHeight + 2, textWidth + 4, textHeight + 2);
          
          // Calculate centered text position within the background
          const textCenterY = labelY - (textHeight / 2) + 2 + (textHeight / 2);
          
          // Draw text shadow first
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillText(labelText, endX + 3, textCenterY + 1);
          
          // Draw the text
          ctx.fillStyle = labels[i].inkColor;
        ctx.fillText(labelText, endX + 2, textCenterY);
      }
    }

    // After drawing right-edge ink limit labels, re-render selected channel's ordinal labels on top
    try {
      const isEditTop = isEditModeEnabled();
      const selCh = isEditTop && EDIT && EDIT.selectedChannel ? String(EDIT.selectedChannel) : null;
      if (isEditTop && selCh) {
        const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
        if (row) {
          const endVal = InputValidator.clampEnd(row.querySelector('.end-input').value);
          if (endVal > 0) {
            const values = make256(endVal, selCh, true);
            const inkColor = INK_COLORS[selCh] || '#000000';
            ctx.save();
            // Ensure full opacity for topmost labels
            ctx.globalAlpha = 1.0;
            renderAIKeyPointOverlay(ctx, selCh, values, TOTAL, { leftPadding, chartWidth, padding, height }, inkColor, { showLabels: true, drawMarkers: false });
            ctx.restore();
          }
        }
      }
    } catch {}
      
      // Animate logo bars when chart is redrawn
      animateLogoBars();
    }

    // Cursor tooltip over the chart: show X,Y in percent (locks to selected channel in Edit Mode)
    let CHART_CURSOR_MAP = null;
    function setupChartCursorTooltip(map){
      CHART_CURSOR_MAP = map;
      const canvas = elements.inkChart;
      const tip = elements.chartCursorTooltip;
      if (!canvas || !tip) return;
      if (!canvas._cursorTooltipBound){
        const container = canvas.closest('.relative') || canvas.parentElement || document.body;
        const onMove = (e)=>{
          if (!CHART_CURSOR_MAP) return;
          // Re-render chart to clear prior cursor marker overlay
          try { updateInkChart(); } catch {}
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;
          const cx = (e.clientX - rect.left) * scaleX;
          const cy = (e.clientY - rect.top) * scaleY;
          const { leftPadding, chartWidth, padding, chartHeight, width, height } = CHART_CURSOR_MAP;
          let xPct = ((cx - leftPadding) / chartWidth) * 100;
          let yPctRaw = ((height - padding - cy) / chartHeight) * 100;
          let yPct = yPctRaw;
          xPct = Math.max(0, Math.min(100, xPct));
          yPctRaw = Math.max(0, Math.min(100, yPctRaw));
          yPct = Math.max(0, Math.min(100, yPct));
          let drawX = cx;
          let drawY = height - padding - (yPct / 100) * chartHeight;

          // If Edit Mode is ON and a selected channel exists and is enabled, lock Y to that channel's plot
          try {
            if (isEditModeEnabled() && EDIT && EDIT.selectedChannel) {
              const selCh = EDIT.selectedChannel;
              const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
              if (row) {
                const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
                if (endVal > 0) {
                  // Build plotted values with linearization and sample at the cursor X
                  const values = make256(endVal, selCh, true);
                  const t = Math.max(0, Math.min(1, (xPct/100))) * (values.length - 1);
                  const i0 = Math.floor(t);
                  const i1 = Math.min(values.length - 1, i0 + 1);
                  const a = t - i0;
                  const v = (1 - a) * values[i0] + a * values[i1];
                  const vPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                  yPct = vPct; // lock tooltip Y to curve value
                  drawY = height - padding - (vPct / 100) * chartHeight;
                  // Draw a bolded circle at (drawX, drawY) using channel color
                  const ctx = canvas.getContext('2d');
                  if (ctx) {
                    const inkColor = INK_COLORS[selCh] || '#000000';
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(Math.max(leftPadding, Math.min(leftPadding + chartWidth, drawX)), drawY, 5, 0, Math.PI * 2);
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = inkColor;
                    ctx.stroke();
                    ctx.restore();
                  }
                }
              }
            }
          } catch {}

          const canInsert = (function(){
            try {
              if (!isEditModeEnabled() || !EDIT || !EDIT.selectedChannel) return false;
              const selCh = EDIT.selectedChannel;
              const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
              if (!row) return false;
              const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
              return endVal > 0;
            } catch { return false; }
          })();
          tip.innerHTML = `${xPct.toFixed(1)}, ${yPct.toFixed(1)}${canInsert ? '<br>click to add point' : ''}`;
          const contRect = container.getBoundingClientRect();
          const left = e.clientX - contRect.left + 12;
          const top = e.clientY - contRect.top - 24;
          tip.style.left = `${left}px`;
          tip.style.top = `${top}px`;
          tip.classList.remove('hidden');
        };
        const onLeave = ()=>{ tip.classList.add('hidden'); try { updateInkChart(); } catch {} };
        const onClick = (e)=>{
          try {
            if (!isEditModeEnabled() || !EDIT || !EDIT.selectedChannel) return;
            const selCh = EDIT.selectedChannel;
            // Ensure enabled
            const row = Array.from(elements.rows.children).find(tr => tr.getAttribute('data-channel') === selCh);
            if (!row) return;
            const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
            if (endVal <= 0) return;
            // Compute raw cursor X,Y in percent (not curve-locked)
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const cx = (e.clientX - rect.left) * scaleX;
            const cy = (e.clientY - rect.top) * scaleY;
            const { leftPadding, chartWidth, padding, chartHeight, height } = CHART_CURSOR_MAP;
            let xPct = ((cx - leftPadding) / chartWidth) * 100;
            // Lock Y to the selected channel's plotted curve at this X
            // Sample current plotted values with linearization and compute absolute percent
            const values = make256(endVal, selCh, true);
            const t = Math.max(0, Math.min(1, (xPct/100))) * (values.length - 1);
            const i0 = Math.floor(t);
            const i1 = Math.min(values.length - 1, i0 + 1);
            const a = t - i0;
            const v = (1 - a) * values[i0] + a * values[i1];
            let yPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
            xPct = Math.max(0, Math.min(100, xPct));
            yPct = Math.max(0, Math.min(100, yPct));
            const res = quadGenActions.insertSmartKeyPointAt(selCh, xPct, yPct);
            if (res && res.success) {
              // Set selection to the newly inserted point (nearest to xPct)
              try {
                const kp = ControlPoints.get(selCh)?.points || [];
                const idx = ControlPoints.nearestIndex(kp, xPct, 100); // large tolerance to find nearest
                if (idx !== null && typeof idx === 'number') {
                  EDIT.selectedOrdinal = idx + 1;
                  edit_refreshPointIndex();
                }
              } catch {}
              updateProcessingDetail(selCh);
              updatePreview();
            } else if (res && !res.success && res.message) {
              showStatus(res.message);
            }
          } catch (err) { console.warn('Click-to-insert failed:', err); }
        };
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseenter', onMove);
        canvas.addEventListener('mouseleave', onLeave);
        canvas.addEventListener('click', onClick);
        canvas._cursorTooltipBound = true;
      }
    }

    // Overlay renderer for AI key points
    function renderAIKeyPointOverlay(ctx, channelName, values, maxValue, geom, inkColor, options = {}) {
      if (!isEditModeEnabled()) return; // Hide key-point overlay when edit mode is off
      const { leftPadding, chartWidth, padding, height } = geom;
      const showLabels = options.showLabels !== false;
      const drawMarkers = options.drawMarkers !== false; // allow hiding square markers
      try {
        // Prefer explicit AI key points if available
        const aiPoints = window.loadedQuadData?.keyPoints?.[channelName];
        let points = Array.isArray(aiPoints) ? aiPoints.slice() : [];

        // Determine current End scaling so pre-scale key-point outputs map to absolute Y on the chart
        let scale = 1.0;
        try {
          const row = document.querySelector(`tr[data-channel="${channelName}"]`);
          const endVal = InputValidator.clampEnd(row?.querySelector('.end-input')?.value || 0);
          const endPct = InputValidator.computePercentFromEnd(endVal);
          scale = Math.max(0, endPct) / 100; // fraction of TOTAL
        } catch {}

        // Fallback: if no explicit points, derive marker positions from current curve
        if (!points || points.length === 0) {
          // Detect linear ramp from provided values; if linear, collapse to 2 markers at 0 and 100
          let useTwo = false;
          const last = values[values.length - 1];
          if (last > 0) {
            const N = values.length - 1;
            const samples = [0, Math.floor(N*0.25), Math.floor(N*0.5), Math.floor(N*0.75), N];
            const EPS = 0.005;
            useTwo = samples.every((idx) => {
              const expected = (idx / N);
              const actual = (values[idx] / last);
              return Math.abs(actual - expected) <= EPS;
            });
          }
          if (useTwo) {
            points = [{ input: 0 }, { input: 100 }];
          } else {
            const target = 16; // compact set to keep overlay readable
            points = [];
            for (let i = 0; i < target; i++) {
              const x = (i / (target - 1)) * 100;
              points.push({ input: x });
            }
          }
        }

        // Guard against excessive points (allow up to 32 so 21‑point LUTs still render after conversion)
        const MAX_LABEL_POINTS = 32;
        if (!Array.isArray(points) || points.length === 0 || points.length > MAX_LABEL_POINTS) return;

        const boxSize = 6;
        const sortedPoints = [...points].sort((a, b) => (a.input || 0) - (b.input || 0));
        ctx.save();
        ctx.strokeStyle = inkColor;
        ctx.lineWidth = 1.5;
        const defaultFont = 'bold 12px system-ui';
        ctx.font = defaultFont;
        ctx.textBaseline = 'bottom';
        ctx.textAlign = 'center';

        const isSelectedChannel = (typeof EDIT !== 'undefined' && EDIT && EDIT.selectedChannel === channelName);
        const selectedOrdinal = isSelectedChannel ? (EDIT.selectedOrdinal || 1) : -1;

        sortedPoints.forEach((pt, i) => {
          const xNorm = Math.max(0, Math.min(1, (pt.input || 0) / 100));
          const x = leftPadding + xNorm * chartWidth;
          // Convert pre‑scale stored output (0..100) to absolute chart percent using current End scale
          const pre = Math.max(0, Math.min(100, Number(pt.output || 0)));
          const valuePercent = Math.max(0, Math.min(100, pre * scale));
          const y = height - padding - (valuePercent / 100) * (height - 2 * padding);
          const hx = boxSize / 2;
          const hy = boxSize / 2;
          // Square marker (highlight current selected ordinal)
          const isSelected = isSelectedChannel && (i + 1 === selectedOrdinal);
          const bx = Math.round(x - hx) + 0.5;
          const by = Math.round(y - hy) + 0.5;
          if (drawMarkers) {
          if (isSelected) {
            ctx.save();
            ctx.lineWidth = 3;
            ctx.strokeStyle = inkColor;
            ctx.strokeRect(bx - 2, by - 2, boxSize + 4, boxSize + 4);
            ctx.restore();
            ctx.fillStyle = 'rgba(255,255,255,1)';
          } else {
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
          }
          ctx.fillRect(bx, by, boxSize, boxSize);
          ctx.strokeRect(bx, by, boxSize, boxSize);
          }

          if (!showLabels) return;
          // Label positioning
          let labelX = x;
          let labelY = y - hy - 3;
          if (valuePercent <= 5) labelX += 8;
          if (valuePercent >= 95) labelX -= 8;
          const minY = padding + 8;
          const maxY = height - padding - 2;
          if (labelY < minY) labelY = minY;
          if (labelY > maxY) labelY = maxY;

          const num = String(i + 1);
          // Enlarge and bold the selected label number
          const labelFontSize = isSelected ? 24 : 12; // double size for selected
          ctx.font = `bold ${labelFontSize}px system-ui`;
          const metrics = ctx.measureText(num);
          const bgPadX = isSelected ? 6 : 4;
          const bgW = Math.ceil(metrics.width) + bgPadX * 2;
          const bgH = Math.round(labelFontSize * 1.33);
          const bgX = Math.round(labelX - bgW / 2) + 0.5;
          const bgY = Math.round(labelY - bgH + 1) + 0.5;

          // Colored background uses channel ink color (selected and unselected)
          ctx.fillStyle = inkColor;
          ctx.fillRect(bgX, bgY, bgW, bgH);
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(bgX, bgY, bgW, bgH);

          // Dynamic text color for readability
          let r = 0, g = 0, b = 0;
          const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i.exec(inkColor);
          if (m) {
            r = parseInt(m[1], 16);
            g = parseInt(m[2], 16);
            b = parseInt(m[3], 16);
          }
          const yiq = (r * 299 + g * 587 + b * 114) / 1000;
          ctx.fillStyle = (yiq >= 140 ? '#000000' : '#FFFFFF');
          ctx.fillText(num, Math.round(labelX) + 0.5, Math.round(labelY) + 0.5);
          // Reset font to default for next iterations
          ctx.font = defaultFont;
        });
        ctx.restore();
      } catch (e) {
        if (DEBUG_LOGS) console.warn('Smart key point overlay failed:', e);
      }
    }

    // Generic overlay for data-type adapters using only X positions (percent)
    function renderXPositionsOverlay(ctx, xPercents, values, maxValue, geom, color, showLabels = true) {
      if (!Array.isArray(xPercents) || xPercents.length === 0) return;
      const { leftPadding, chartWidth, padding, height } = geom;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      ctx.font = 'bold 12px system-ui';
      ctx.textBaseline = 'bottom';
      ctx.textAlign = 'center';
      const boxSize = 6;
      const hx = boxSize / 2;
      const hy = boxSize / 2;
      xPercents.forEach((xp, i) => {
        const xNorm = Math.max(0, Math.min(1, (xp || 0) / 100));
        const x = leftPadding + xNorm * chartWidth;
        // Interpolate Y from plotted values for precise alignment
        const t = xNorm * (values.length - 1); // model t (do not flip for interpolation)
        const i0 = Math.floor(t);
        const i1 = Math.min(values.length - 1, Math.ceil(t));
        const a = t - i0;
        const v = (1 - a) * values[i0] + a * values[i1];
        const valuePercent = (v / maxValue) * 100;
        const y = height - padding - (valuePercent / 100) * (height - 2 * padding);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(Math.round(x - hx) + 0.5, Math.round(y - hy) + 0.5, boxSize, boxSize);
        ctx.strokeRect(Math.round(x - hx) + 0.5, Math.round(y - hy) + 0.5, boxSize, boxSize);

        if (showLabels) {
          let labelX = x;
          let labelY = y - hy - 3;
          if (valuePercent <= 5) labelX += 8;
          if (valuePercent >= 95) labelX -= 8;
          const minY = padding + 8;
          const maxY = height - padding - 2;
          if (labelY < minY) labelY = minY;
          if (labelY > maxY) labelY = maxY;

          const num = String(i + 1);
          const metrics = ctx.measureText(num);
          const bgPadX = 4;
          const bgW = Math.ceil(metrics.width) + bgPadX * 2;
          const bgH = 16;
          const bgX = Math.round(labelX - bgW / 2) + 0.5;
          const bgY = Math.round(labelY - bgH + 1) + 0.5;

          // Colored background same as AI (use channel ink color)
          ctx.fillStyle = color;
          ctx.fillRect(bgX, bgY, bgW, bgH);
          ctx.strokeStyle = 'rgba(0,0,0,0.2)';
          ctx.lineWidth = 1;
          ctx.strokeRect(bgX, bgY, bgW, bgH);

          // Choose text color (black/white) based on background luminance
          let r = 0, g = 0, b = 0;
          const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})/i.exec(color);
          if (m) {
            r = parseInt(m[1], 16);
            g = parseInt(m[2], 16);
            b = parseInt(m[3], 16);
          }
          const yiq = (r * 299 + g * 587 + b * 114) / 1000;
          ctx.fillStyle = yiq >= 140 ? '#000000' : '#FFFFFF';
          ctx.fillText(num, Math.round(labelX) + 0.5, Math.round(labelY) + 0.5);
        }
      });
      ctx.restore();
    }

    // Collect overlay point sets from loaded data for a given channel
    function getAdapterOverlayXPositions(channelName) {
      const sets = [];

      // Per-channel linearization overlay
      const per = perChannelLinearization[channelName];
      if (per && Array.isArray(per.samples)) {
        const format = per.format || '';
        const fmtLower = String(format).toLowerCase();
        if (format === 'ACV' && Array.isArray(per.controlPointsTransformed) && per.controlPointsTransformed.length > 0) {
          // Use ACV anchor points if available
          const xs = per.controlPointsTransformed.map(p => p.input);
          sets.push({ id: 'acv-per', label: 'ACV (per)', color: '#374151', xPercents: xs });
        } else if (!fmtLower.includes('lab')) {
          // Use original sample positions when K <= 32; otherwise downsample to 32 using index selection
          const K = per.samples.length;
          const target = Math.min(32, K);
          const xs = [];
          for (let i = 0; i < target; i++) {
            const idx = Math.round(i * (K - 1) / (target - 1));
            xs.push((idx / (K - 1)) * 100);
          }
          sets.push({ id: 'lin-per', label: `${format||'LIN'} (per)`, color: '#7C3AED', xPercents: xs });
        }
      }

      // Global linearization overlay (applies to all channels)
      if (linearizationData && Array.isArray(linearizationData.samples)) {
        const format = linearizationData.format || '';
        const fmtLower = String(format).toLowerCase();
        if (format === 'ACV' && Array.isArray(linearizationData.controlPointsTransformed) && linearizationData.controlPointsTransformed.length > 0) {
          // For ACV loaded globally, use the original ACV anchor points (transformed)
          const xs = linearizationData.controlPointsTransformed.map(p => p.input);
          sets.push({ id: 'acv-global', label: 'ACV (global)', color: '#374151', xPercents: xs });
        } else if (!fmtLower.includes('lab')) {
          // Generic non-LAB data: use original sample positions when K <= 32; else downsample to 32
          const K = linearizationData.samples.length;
          const target = Math.min(32, K);
          const xs = [];
          for (let i = 0; i < target; i++) {
            const idx = Math.round(i * (K - 1) / (target - 1));
            xs.push((idx / (K - 1)) * 100);
          }
          sets.push({ id: 'lin-global', label: `${format||'LIN'} (global)`, color: '#059669', xPercents: xs });
        }
      }

      // LAB original measured points overlay (global or per-channel if used there)
      const addLabOriginal = (data, scopeLabel) => {
        if (data && Array.isArray(data.originalData) && data.originalData.length > 0) {
          const xs = data.originalData.map(d => Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0))));
          if (xs.length > 0) sets.push({ id: `lab-${scopeLabel}`, label: `LAB (${scopeLabel})`, color: '#F59E0B', xPercents: xs });
        }
      };
      if (linearizationData && (linearizationData.format||'').includes('LAB')) addLabOriginal(linearizationData, 'global');
      if (perChannelLinearization[channelName] && (perChannelLinearization[channelName].format||'').includes('LAB')) addLabOriginal(perChannelLinearization[channelName], 'per');

      return sets;
    }

    // Generate filename based on current settings
    function generateFilename() {
      const p = PRINTERS[elements.printerSelect.value];
      // Extract just the printer model (remove "Epson " prefix)
      const printerModel = p.name.replace(/^Epson\s+/, '').replace(/\s+/g, '');
      let parts = [printerModel]; // Start with printer model
      
      // Add active channels with their percentages
      Array.from(elements.rows.children).forEach((tr) => {
        // Skip the placeholder row
        if (tr.id === 'noChannelsRow') return;
        
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        
        if (endVal > 0) {
          const percent = Math.round(InputValidator.computePercentFromEnd(endVal));
          parts.push(name + percent);
        }
      });
      
      // Add CORRECTED suffix if any linearization is applied
      const hasLinearization = (linearizationData && linearizationApplied) || 
                                Object.keys(perChannelLinearization).some(ch => perChannelEnabled[ch]);
      if (hasLinearization) {
        parts.push('CORRECTED');
      }
      
      return parts.join('_');
    }

    // Toggle listeners
    if (elements.aiLabelToggle) {
      elements.aiLabelToggle.addEventListener('change', () => {
        // Key-Point Simplifier UI is deprecated under-graph; no visibility toggling
        updateInkChart();
      });
    }

    // Update filename input with current settings
    function updateFilename() {
      if (!elements.filenameInput.dataset.userEdited) {
        elements.filenameInput.value = generateFilename();
        // Trigger validation styling
        elements.filenameInput.dispatchEvent(new Event('input'));
      }
    }
    function sanitizeFilename(filename) {
      // Remove or replace invalid characters for Windows and Mac
      // Invalid: \ / : * ? " < > |
      return filename
        .replace(/[\\/:*?"<>|]/g, '_')  // Replace invalid chars with underscore
        .replace(/\s+/g, '_')          // Replace spaces with underscores
        .replace(/_{2,}/g, '_')        // Replace multiple underscores with single
        .replace(/^_+|_+$/g, '')       // Trim underscores from start/end
        .substring(0, 200);            // Limit length to 200 chars
    }

    // ---- Linearization utilities ----
    const clamp01 = (x) => Math.max(0, Math.min(1, x));

    // Linearization data storage
    let linearizationData = null;
    let linearizationApplied = false;
    let loadedQuadData = null; // Stores complete curve data from loaded .quad files
    
    // Clear loaded quad data
    function clearLoadedQuadData() {
      window.loadedQuadData = null;
      // Update interpolation controls since loaded data is no longer available
      updateInterpolationControls();
    }

    // Clear all processing-related data (global + per-channel) and reset related UI
    function clearAllProcessingData() {
      try {
        // 1) Clear global linearization
        linearizationData = null;
        linearizationApplied = false;
        if (elements.globalLinearizationBtn) {
          elements.globalLinearizationBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
        }
        if (elements.globalLinearizationToggle) {
          elements.globalLinearizationToggle.disabled = true;
          elements.globalLinearizationToggle.checked = false;
        }
        if (elements.globalLinearizationInfo) {
          elements.globalLinearizationInfo.classList.add('hidden');
        }

        // 2) Clear per-channel linearization
        perChannelLinearization = {};
        perChannelEnabled = {};
        perChannelFilenames = {};
        // Reset per-channel UI if rows currently exist
        if (elements.rows) {
          Array.from(elements.rows.children).forEach(tr => {
            if (tr.id === 'noChannelsRow') return;
            const perBtn = tr.querySelector('.per-channel-btn');
            const perToggle = tr.querySelector('.per-channel-toggle');
            if (perBtn) perBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
            if (perToggle) { perToggle.disabled = true; perToggle.checked = false; }
            const ch = tr.getAttribute('data-channel');
            if (ch && typeof updateProcessingDetailForce === 'function') updateProcessingDetailForce(ch);
          });
        }

        // 3) Clear AI key points/meta and any prior curves in loaded data (will be replaced on load)
        if (!window.loadedQuadData) window.loadedQuadData = {};
        delete window.loadedQuadData.keyPoints;
        delete window.loadedQuadData.keyPointsMeta;
        delete window.loadedQuadData.sources;
        delete window.loadedQuadData.curves;
        delete window.loadedQuadData.channels;

        // 4) Update interpolation controls and hide overlay note
        updateInterpolationControls();
        // No overlay status messaging to reset

        // 5) Reset undo/redo history so user starts fresh
        if (typeof CurveHistory !== 'undefined' && CurveHistory && typeof CurveHistory.clear === 'function') {
          CurveHistory.clear();
        }
      } catch (e) {
        console.warn('clearAllProcessingData encountered an issue:', e);
      }
    }
    
    // Check if any linearization is available that would benefit from interpolation
    function hasAnyLinearization() {
      // Active when a global correction is applied, or at least one per-channel correction is enabled
      const hasGlobal = !!(linearizationData && linearizationApplied);
      const hasAnyPerEnabled = Object.keys(perChannelLinearization).some(ch => perChannelEnabled[ch]);
      return hasGlobal || hasAnyPerEnabled;
      // Note: Loaded .quad data alone doesn't need interpolation since it already has 256 points
    }
    
    // Update interpolation description based on selected method
    function updateInterpolationDescription() {
      const method = elements.curveSmoothingMethod.value;
      const hasLinearization = hasAnyLinearization();
      const hasLoadedQuad = loadedQuadData && loadedQuadData.curves;
      
      // Always hide description - controls are self-explanatory
      elements.interpolationDescription.style.display = 'none';
    }
    
    // Update interpolation controls based on linearization availability
    function updateInterpolationControls() {
      const hasLinearization = hasAnyLinearization();
      elements.curveSmoothingMethod.disabled = !hasLinearization;
      elements.catmullTension.disabled = !hasLinearization;
      elements.smoothingSlider.disabled = (!hasLinearization) || (!isEditModeEnabled());
      if (elements.simplificationMethod) elements.simplificationMethod.disabled = !hasLinearization;
      
      // Update visual styling for disabled state
      if (!hasLinearization) {
        elements.curveSmoothingMethod.className = 'standard-dropdown';
      } else {
        elements.curveSmoothingMethod.className = 'standard-dropdown';
      }
      
      // Show/hide tension control for Catmull-Rom
      const method = elements.curveSmoothingMethod.value;
      const showTension = hasLinearization && method === 'catmull';
      elements.catmullTensionContainer.style.display = showTension ? 'block' : 'none';
      
      // Update smoothing warning visibility
      const smoothingPercent = parseFloat(elements.smoothingSlider.value) || 0;
      const showWarning = hasLinearization && smoothingPercent > 0;
      if (showWarning) {
        elements.smoothingWarning.classList.remove('opacity-0', 'invisible');
      } else {
        elements.smoothingWarning.classList.add('opacity-0', 'invisible');
      }
      
      // Update description
      updateInterpolationDescription();
    }
    
    // Get selected simplification method
    function getSelectedSimplificationMethod() {
      return elements.simplificationMethod ? (elements.simplificationMethod.value || 'smoothing-splines') : 'smoothing-splines';
    }
    
    // Per-channel linearization storage
    let perChannelLinearization = {};
    let perChannelEnabled = {};
    let perChannelFilenames = {};
    
    // Channel previous values storage (for restore after enable)
    let channelPreviousValues = {};

    // Curve history system for undo functionality
    const CurveHistory = {
      actionHistory: [], // Array of individual actions
      legacyHistory: [], // For non-channel operations (curves, etc.)
      redoHistory: [],
      maxHistorySize: 20, // Keep last 20 actions
      isRestoring: false, // Flag to prevent state capture during restore
      isBatchOperation: false, // Flag to prevent individual recording during batch operations
      _pendingKeyPoints: {}, // Pending key-point extras keyed by channel
      
      // Record pending key point change for the next curve action on this channel
      recordKeyPointsChange(channelName, oldKeyPoints, newKeyPoints, oldInterpolation, newInterpolation) {
        try {
          this._pendingKeyPoints[channelName] = {
            oldKeyPoints: Array.isArray(oldKeyPoints) ? oldKeyPoints.map(p => ({ input: p.input, output: p.output })) : undefined,
            newKeyPoints: Array.isArray(newKeyPoints) ? newKeyPoints.map(p => ({ input: p.input, output: p.output })) : undefined,
            oldInterpolation,
            newInterpolation
          };
        } catch (e) {
          console.warn('recordKeyPointsChange failed:', e);
        }
      },
      
      /**
       * Record individual channel action
       */
      recordChannelAction(channelName, actionType, oldValue, newValue, extras = null) {
        // Don't record actions during restore operations
        if (this.isRestoring) {
          return;
        }
        
        const action = {
          timestamp: Date.now(),
          type: actionType, // 'enable', 'disable', 'percentage', 'end'
          channelName: channelName,
          oldValue: oldValue,
          newValue: newValue,
          description: `${actionType} ${channelName}: ${oldValue} → ${newValue}`
        };
        if (extras && typeof extras === 'object') {
          Object.assign(action, extras);
        }

        // Create concise, user-friendly descriptions
        if (actionType === 'curve') {
          const kpCount = Array.isArray(action.newKeyPoints) ? action.newKeyPoints.length : undefined;
          const interp = action.newInterpolation || action.oldInterpolation || undefined;
          const parts = [`curve ${channelName}`];
          if (kpCount !== undefined) parts.push(`(${kpCount} key points${interp ? `, ${interp}` : ''})`);
          else if (Array.isArray(newValue)) parts.push(`(${newValue.length} pts)`);
          action.description = parts.join(' ');
        } else {
          // Avoid dumping large arrays/objects in tooltip for other actions
          const summarize = (v) => {
            if (Array.isArray(v)) return `${v.length} items`;
            if (v && typeof v === 'object') return 'updated';
            return String(v);
          };
          action.description = `${actionType} ${channelName}: ${summarize(oldValue)} → ${summarize(newValue)}`;
        }
        
        
        this.actionHistory.push(action);
        
        // Clear redo history when new action is performed
        this.redoHistory = [];
        
        // Maintain history size limit
        if (this.actionHistory.length > this.maxHistorySize) {
          this.actionHistory.shift();
        }
        
        // Update button states
        this.updateUndoButton();
        this.updateRedoButton();
        
      },

      /**
       * Record a UI-level action (non-channel), e.g., toggling Edit Mode
       * @param {string} uiType - e.g., 'editMode'
       * @param {any} oldValue
       * @param {any} newValue
       * @param {string} description - human-friendly description
       */
      recordUIAction(uiType, oldValue, newValue, description) {
        if (this.isRestoring) return;
        const action = {
          timestamp: Date.now(),
          type: 'ui',
          uiType,
          oldValue,
          newValue,
          description: description || `${uiType}: ${String(oldValue)} → ${String(newValue)}`
        };
        this.actionHistory.push(action);
        // Clear redo history when new action is performed
        this.redoHistory = [];
        // Maintain size limit
        if (this.actionHistory.length > this.maxHistorySize) this.actionHistory.shift();
        // Update buttons
        this.updateUndoButton();
        this.updateRedoButton();
      },

      /**
       * Record batch action (multiple channels affected by single command)
       */
      recordBatchAction(description, channelActions) {
        // Don't record actions during restore operations
        if (this.isRestoring) {
          return;
        }
        
        const batchAction = {
          timestamp: Date.now(),
          type: 'batch',
          description: description,
          channelActions: channelActions // Array of individual channel actions
        };
        
        this.actionHistory.push(batchAction);
        
        // Clear redo history when new action is performed
        this.redoHistory = [];
        
        // Maintain history size limit
        if (this.actionHistory.length > this.maxHistorySize) {
          this.actionHistory.shift();
        }
        
        // Update button states
        this.updateUndoButton();
        this.updateRedoButton();
      },

      /**
       * Legacy method for non-channel actions (curve modifications, etc.)
       */
      captureState(actionDescription = 'Curve modification') {
        // Don't capture state during restore operations
        if (this.isRestoring) {
          return;
        }
        const state = {
          timestamp: Date.now(),
          action: actionDescription,
          channels: {}
        };
        
        // Capture current state of all visible channels
        Array.from(elements.rows.children).forEach(tr => {
          // Skip the placeholder row
          if (tr.id === 'noChannelsRow') return;
          
          const channelName = tr.dataset.channel;
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          const checkbox = tr._virtualCheckbox;
          
          state.channels[channelName] = {
            percentage: parseFloat(percentInput.value) || 0,
            endValue: parseFloat(endInput.value) || 0,
            enabled: checkbox.checked,
            // Capture any loaded curve data for this channel
            curveData: window.loadedQuadData?.curves?.[channelName] ? [...window.loadedQuadData.curves[channelName]] : null
          };
        });
        
        // Capture global linearization state
        state.globalLinearization = {
          enabled: elements.globalLinearizationToggle?.checked || false,
          filename: elements.globalLinearizationFilename?.textContent || '',
          data: linearizationData ? {...linearizationData} : null,
          applied: linearizationApplied
        };
        
        // Capture per-channel linearization state
        state.perChannelLinearization = JSON.parse(JSON.stringify(perChannelLinearization));
        state.perChannelEnabled = JSON.parse(JSON.stringify(perChannelEnabled));
        
        // Add to legacy history (remove oldest if at max size)
        this.legacyHistory.push(state);
        if (this.legacyHistory.length > this.maxHistorySize) {
          this.legacyHistory.shift();
        }
        
        // Clear redo history when new action is taken
        this.redoHistory = [];
        
        // Update button states
        this.updateUndoButton();
        this.updateRedoButton();
        
      },
      
      /**
       * Undo the last action (either individual channel or legacy global action)
       */
      undo() {
        // Check if we have any actions to undo
        if (this.actionHistory.length === 0 && this.legacyHistory.length === 0) {
          return { success: false, message: 'No actions to undo' };
        }
        
        try {
          // Determine which history has the most recent action
          let useChannelHistory = false;
          if (this.actionHistory.length > 0 && this.legacyHistory.length === 0) {
            useChannelHistory = true;
          } else if (this.actionHistory.length === 0 && this.legacyHistory.length > 0) {
            useChannelHistory = false;
          } else if (this.actionHistory.length > 0 && this.legacyHistory.length > 0) {
            // Both have actions, compare timestamps
            const lastChannel = this.actionHistory[this.actionHistory.length - 1];
            const lastLegacy = this.legacyHistory[this.legacyHistory.length - 1];
            useChannelHistory = lastChannel.timestamp > lastLegacy.timestamp;
          }
          
          let message;
          if (useChannelHistory) {
            // Handle individual channel action
            const lastAction = this.actionHistory.pop();
      if (DEBUG_LOGS) console.log('🔥 UNDO: Processing channel action:', lastAction);
            this.redoHistory.push(lastAction);
            
            this.undoSingleAction(lastAction);
            message = `Undid: ${lastAction.description}`;
          } else {
            // Handle legacy global action
            const lastState = this.legacyHistory.pop();
      if (DEBUG_LOGS) console.log('🔥 UNDO: Processing legacy action:', lastState.action);
            
            // Check if this is an "After" state from dual-state capture
            if (lastState.action.startsWith('After: AI Global Linearization')) {
              if (DEBUG_LOGS) console.log('🔥 UNDO: Found "After" state, looking for matching "Before" state');
              // This is the "After" state, we need to find and use the "Before" state instead
              const beforeStateName = lastState.action.replace('After:', 'Before:');
              
              // Find the matching "Before" state in the history
              const beforeStateIndex = this.legacyHistory.findIndex(state => state.action === beforeStateName);
              if (beforeStateIndex !== -1) {
                // Remove the "Before" state from history and use it for undo
                const beforeState = this.legacyHistory.splice(beforeStateIndex, 1)[0];
                if (DEBUG_LOGS) console.log('🔥 UNDO: Using "Before" state for undo:', beforeState.action);
                
                // Push the "After" state to redo (so redo will restore the Smart‑generated state)
                this.redoHistory.push(lastState);
                
                // Restore the "Before" state (empty/previous state)
                this.restoreState(beforeState);
                message = `Undid: ${lastState.action}`;
              } else {
                if (DEBUG_LOGS) console.log('🔥 UNDO: Could not find matching "Before" state, using fallback');
                this.redoHistory.push(lastState);
                this.restoreState(lastState);
                message = `Undid: ${lastState.action}`;
              }
            } else {
              // Normal legacy action
              this.redoHistory.push(lastState);
              this.restoreState(lastState);
              message = `Undid: ${lastState.action}`;
            }
          }
          
          // Limit redo history size
          if (this.redoHistory.length > this.maxHistorySize) {
            this.redoHistory.shift();
          }
          
          try { normalizeSmartSourcesInLoadedData(); } catch {}
          this.updateUndoButton();
          this.updateRedoButton();
          
          return { success: true, message };
          
        } catch (error) {
          console.error('❌ Error during undo:', error);
          return { success: false, message: `Undo failed: ${error.message}` };
        }
      },

      /**
       * Undo a single action by reversing it
       */
      undoSingleAction(action) {
        this.isRestoring = true;

        // Handle UI actions (no channel row)
        if (action.type === 'ui') {
          try {
            if (action.uiType === 'editMode') {
              // Restore previous edit mode state without recording
              if (typeof setEditMode === 'function') setEditMode(!!action.oldValue, { recordHistory: false });
            }
          } finally {
            this.isRestoring = false;
          }
          return;
        }
        
        // Handle batch actions differently - they don't have a single channelName
        if (action.type === 'batch') {
          // Reverse batch: undo all channel actions in reverse order
          for (let i = action.channelActions.length - 1; i >= 0; i--) {
            const channelAction = action.channelActions[i];
            const channelTr = document.querySelector(`tr[data-channel="${channelAction.channelName}"]`);
            if (channelTr) {
              this.undoIndividualAction(channelTr, channelAction);
            }
          }
          
          // Update compact channels list and graphs
          setTimeout(() => updateCompactChannelsList(), 50);
          debouncedPreviewUpdate();
          // Refresh processing panels for affected channels
          action.channelActions.forEach(a => {
            if (typeof updateProcessingDetail === 'function') updateProcessingDetail(a.channelName);
          });
          
          this.isRestoring = false;
          return;
        }
        
        // Handle individual channel actions
        const tr = document.querySelector(`tr[data-channel="${action.channelName}"]`);
        if (!tr) {
          console.error(`Channel row for ${action.channelName} not found`);
          return;
        }
        
        switch (action.type) {
          case 'enable':
            // Reverse: disable the channel (same logic as handleCheckboxChange)
            const checkbox = tr._virtualCheckbox;
            const percentInput = tr.querySelector('.percent-input');
            const endInput = tr.querySelector('.end-input');
            
            if (checkbox) {
              checkbox.checked = false;
              
              // Store current values and set to 0 (same as normal disable logic)
              const currentPercentVal = InputValidator.clampPercent(percentInput.value);
              const currentEndVal = InputValidator.clampEnd(endInput.value);
              
              channelPreviousValues[action.channelName] = {
                percent: currentPercentVal,
                endValue: currentEndVal
              };
              
              percentInput.value = '0';
              endInput.value = '0';
              tr.setAttribute('data-user-disabled', 'true');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'disable':
            // Reverse: enable the channel (same logic as handleCheckboxChange)
            const enableCheckbox = tr._virtualCheckbox;
            const enablePercentInput = tr.querySelector('.percent-input');
            const enableEndInput = tr.querySelector('.end-input');
            
            if (enableCheckbox) {
              enableCheckbox.checked = true;
              
              // Restore previous values or default to 100% (same as normal enable logic)
              const previousValues = channelPreviousValues[action.channelName];
              
              if (previousValues && previousValues.percent > 0) {
                // Restore previous values
                enablePercentInput.value = previousValues.percent.toString();
                enableEndInput.value = previousValues.endValue.toString();
              } else {
                // Default to 100% if no previous value stored
                enablePercentInput.value = '100';
                enableEndInput.value = String(InputValidator.computeEndFromPercent(100));
              }
              
              tr.removeAttribute('data-user-disabled');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'percentage':
            // Reverse: restore old percentage value
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            // Reverse: restore old end value
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Reverse: restore old curve data
            if (action.oldValue === null) {
              // Remove curve data if it didn't exist before
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              // Also remove any stored AI key points/meta
              if (window.loadedQuadData?.keyPoints?.[action.channelName]) {
                delete window.loadedQuadData.keyPoints[action.channelName];
              }
              if (window.loadedQuadData?.keyPointsMeta?.[action.channelName]) {
                delete window.loadedQuadData.keyPointsMeta[action.channelName];
              }
              // Clear AI source tag since curve removed
              if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
            } else {
              // Restore old curve data
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[action.channelName] = [...action.oldValue];

              // Restore old AI key points/meta if provided
              if (action.oldKeyPoints && Array.isArray(action.oldKeyPoints)) {
                if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                window.loadedQuadData.keyPoints[action.channelName] = action.oldKeyPoints.map(p => ({ input: p.input, output: p.output }));
              }
              if (action.oldInterpolation) {
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                window.loadedQuadData.keyPointsMeta[action.channelName] = { interpolationType: action.oldInterpolation };
              }
              // Restore previous source tag if available; otherwise clear AI tag
              if (action.oldSource !== undefined) {
                if (!window.loadedQuadData.sources) window.loadedQuadData.sources = {};
                if (action.oldSource === null) delete window.loadedQuadData.sources[action.channelName];
                else window.loadedQuadData.sources[action.channelName] = action.oldSource;
              } else if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
              
              // Disable per-channel linearization when restoring Smart Curve (keep metadata for UI display)
              if (perChannelLinearization[action.channelName]) {
                perChannelEnabled[action.channelName] = false;
              }
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }
            }
            break;
        }
        
        // Update compact channels list and graphs
        setTimeout(() => updateCompactChannelsList(), 50);
        debouncedPreviewUpdate();
        // Refresh processing panel for this channel
        if (typeof updateProcessingDetail === 'function') updateProcessingDetail(action.channelName);
        
        this.isRestoring = false;
      },

      /**
       * Helper method to undo individual action (used by both single and batch undo)
       */
      undoIndividualAction(tr, action) {
        if (DEBUG_LOGS) console.log(`🔙 Undoing individual action:`, action);
        switch (action.type) {
          case 'enable':
            // Reverse: restore old enabled state
            const checkbox = tr._virtualCheckbox;
            if (checkbox) {
              checkbox.checked = action.oldValue;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
            break;
            
          case 'percentage':
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.oldValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Reverse: restore old curve data
            if (action.oldValue === null) {
              // Remove curve data if it didn't exist before
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              // Also remove any stored AI key points/meta
              if (window.loadedQuadData?.keyPoints?.[action.channelName]) {
                delete window.loadedQuadData.keyPoints[action.channelName];
              }
              if (window.loadedQuadData?.keyPointsMeta?.[action.channelName]) {
                delete window.loadedQuadData.keyPointsMeta[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
            } else {
              // Restore old curve data
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[action.channelName] = [...action.oldValue];
              
              // Disable per-channel linearization when restoring Smart Curve (keep metadata for UI display)
              if (perChannelLinearization[action.channelName]) {
                perChannelEnabled[action.channelName] = false;
              }
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }

              // Restore old AI key points/meta if provided
              if (action.oldKeyPoints && Array.isArray(action.oldKeyPoints)) {
                if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                window.loadedQuadData.keyPoints[action.channelName] = action.oldKeyPoints.map(p => ({ input: p.input, output: p.output }));
              }
              if (action.oldInterpolation) {
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                window.loadedQuadData.keyPointsMeta[action.channelName] = { interpolationType: action.oldInterpolation };
              }
              // Restore previous source tag if available; otherwise clear AI tag
              if (action.oldSource !== undefined) {
                if (!window.loadedQuadData.sources) window.loadedQuadData.sources = {};
                if (action.oldSource === null) delete window.loadedQuadData.sources[action.channelName];
                else window.loadedQuadData.sources[action.channelName] = action.oldSource;
              } else if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
            }
            
            // CRITICAL: Update graph display for curve changes
            if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            break;
        }
      },
      
      /**
       * Helper method to redo individual action (used by both single and batch redo)
       */
      redoIndividualAction(tr, action) {
        switch (action.type) {
          case 'enable':
            // Re-apply: restore new enabled state
            const checkbox = tr._virtualCheckbox;
            if (checkbox) {
              checkbox.checked = action.newValue;
              checkbox.dispatchEvent(new Event('change', { bubbles: true }));
            }
            break;
            
          case 'percentage':
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Re-apply: restore new curve data
            if (action.newValue === null) {
              // Remove curve data
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
              // Clear source tag when removing curve
              if (window.loadedQuadData?.sources?.[action.channelName] !== undefined) {
                delete window.loadedQuadData.sources[action.channelName];
              }
            } else {
              // Prefer recomputing curve from newKeyPoints to guarantee overlay/curve parity
              try {
                if (action.newKeyPoints && Array.isArray(action.newKeyPoints)) {
                  if (!window.loadedQuadData) window.loadedQuadData = {};
                  if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                  if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                  window.loadedQuadData.keyPoints[action.channelName] = action.newKeyPoints.map(p => ({ input: p.input, output: p.output }));
                  if (action.newInterpolation) {
                    window.loadedQuadData.keyPointsMeta[action.channelName] = { interpolationType: action.newInterpolation };
                  }
                  // Recompute curve from key points and apply via internal path (no history during restore)
                  const interp = (action.newInterpolation === 'linear' ? 'linear' : 'smooth');
                  const computed = quadGenActions._interpolateCurve(action.newKeyPoints, interp);
                  // Ensure curves storage exists
                  if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                  window.loadedQuadData.curves[action.channelName] = [...computed];
                } else {
                  // Fallback: restore provided curve array
                  if (!window.loadedQuadData) window.loadedQuadData = { curves: {} };
                  if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                  window.loadedQuadData.curves[action.channelName] = [...action.newValue];
                }
              } catch (e) {
                console.warn('Redo recompute from key points failed; using stored curve:', e);
                if (!window.loadedQuadData) window.loadedQuadData = { curves: {} };
                if (!window.loadedQuadData.curves) window.loadedQuadData.curves = {};
                window.loadedQuadData.curves[action.channelName] = [...action.newValue];
              }
              
              // Disable per-channel linearization when restoring Smart Curve (keep metadata for UI display)
              if (perChannelLinearization[action.channelName]) {
                perChannelEnabled[action.channelName] = false;
              }
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }
              // Apply new source if provided (usually 'smart')
              if (action.newSource !== undefined) {
                if (!window.loadedQuadData.sources) window.loadedQuadData.sources = {};
                if (action.newSource === null) delete window.loadedQuadData.sources[action.channelName];
                else window.loadedQuadData.sources[action.channelName] = action.newSource;
              } else {
                if (!window.loadedQuadData.sources) window.loadedQuadData.sources = {};
                window.loadedQuadData.sources[action.channelName] = 'smart';
              }
            }

            // CRITICAL: Update graph display for curve changes
            if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            break;
        }
      },
      
      /**
       * Redo the next state
       */
      /**
       * Redo the next action (either individual channel or legacy global action)
       */
      redo() {
        if (this.redoHistory.length === 0) {
          return { success: false, message: 'No actions to redo' };
        }
        
        try {
          // Get the next action from redo history
          const nextAction = this.redoHistory.pop();
          if (DEBUG_LOGS) console.log('🔄 REDO: Processing action:', nextAction);
          if (DEBUG_LOGS) console.log('🔄 REDO: Action properties:', {
            hasChannelName: nextAction.channelName !== undefined,
            hasType: nextAction.type !== undefined,
            hasAction: nextAction.action !== undefined,
            hasChannels: nextAction.channels !== undefined,
            hasDescription: nextAction.description !== undefined
          });
          
          let message;
          if (nextAction.channelName !== undefined || nextAction.type !== undefined) {
            // This is a channel action - has channelName or action type
            this.actionHistory.push(nextAction);
            this.redoSingleAction(nextAction);
            message = `Redid: ${nextAction.description}`;
          } else if (nextAction.action !== undefined && nextAction.channels !== undefined) {
            // This is a legacy state action - has action description and channels object
            this.legacyHistory.push(nextAction);
            this.restoreState(nextAction);
            message = `Redid: ${nextAction.action}`;
          } else {
            // Fallback - treat as channel action
            this.actionHistory.push(nextAction);
            this.redoSingleAction(nextAction);
            message = `Redid: ${nextAction.description || 'Unknown action'}`;
          }
          
          try { normalizeSmartSourcesInLoadedData(); } catch {}
          this.updateUndoButton();
          this.updateRedoButton();
          
          return { success: true, message };
          
        } catch (error) {
          console.error('❌ Error during redo:', error);
          return { success: false, message: `Redo failed: ${error.message}` };
        }
      },

      /**
       * Redo a single action by re-applying it
       */
      redoSingleAction(action) {
        this.isRestoring = true;

        // Handle UI actions (no channel row)
        if (action.type === 'ui') {
          try {
            if (action.uiType === 'editMode') {
              // Re-apply new edit mode state without recording
              if (typeof setEditMode === 'function') setEditMode(!!action.newValue, { recordHistory: false });
            }
          } finally {
            this.isRestoring = false;
          }
          return;
        }

        // Handle batch actions differently - they don't have a single channelName
        if (action.type === 'batch') {
          // Re-apply batch: redo all channel actions in original order
          for (let i = 0; i < action.channelActions.length; i++) {
            const channelAction = action.channelActions[i];
            const channelTr = document.querySelector(`tr[data-channel="${channelAction.channelName}"]`);
            if (channelTr) {
              this.redoIndividualAction(channelTr, channelAction);
            }
          }
          
          // Update compact channels list and graphs
          setTimeout(() => updateCompactChannelsList(), 50);
          debouncedPreviewUpdate();
          // Refresh processing panels for affected channels
          action.channelActions.forEach(a => {
            if (typeof updateProcessingDetail === 'function') updateProcessingDetail(a.channelName);
          });
          
          this.isRestoring = false;
          return;
        }
        
        // Handle individual channel actions
        const tr = document.querySelector(`tr[data-channel="${action.channelName}"]`);
        if (!tr) {
          console.error(`Channel row for ${action.channelName} not found`);
          return;
        }
        
        switch (action.type) {
          case 'enable':
            // Re-apply: enable the channel (same logic as handleCheckboxChange)
            const checkbox = tr._virtualCheckbox;
            const enablePercentInput = tr.querySelector('.percent-input');
            const enableEndInput = tr.querySelector('.end-input');
            
            if (checkbox) {
              checkbox.checked = true;
              
              // Restore previous values or default to 100% (same as normal enable logic)
              const previousValues = channelPreviousValues[action.channelName];
              
              if (previousValues && previousValues.percent > 0) {
                // Restore previous values
                enablePercentInput.value = previousValues.percent.toString();
                enableEndInput.value = previousValues.endValue.toString();
              } else {
                // Default to 100% if no previous value stored
                enablePercentInput.value = '100';
                enableEndInput.value = String(InputValidator.computeEndFromPercent(100));
              }
              
              tr.removeAttribute('data-user-disabled');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'disable':
            // Re-apply: disable the channel (same logic as handleCheckboxChange)
            const disableCheckbox = tr._virtualCheckbox;
            const disablePercentInput = tr.querySelector('.percent-input');
            const disableEndInput = tr.querySelector('.end-input');
            
            if (disableCheckbox) {
              disableCheckbox.checked = false;
              
              // Store current values and set to 0 (same as normal disable logic)
              const currentPercentVal = InputValidator.clampPercent(disablePercentInput.value);
              const currentEndVal = InputValidator.clampEnd(disableEndInput.value);
              
              channelPreviousValues[action.channelName] = {
                percent: currentPercentVal,
                endValue: currentEndVal
              };
              
              disablePercentInput.value = '0';
              disableEndInput.value = '0';
              tr.setAttribute('data-user-disabled', 'true');
              
              // Call refresh function to handle compact display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'percentage':
            // Re-apply: restore new percentage value
            const percentageInput = tr.querySelector('.percent-input');
            if (percentageInput) {
              percentageInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const p = InputValidator.validateInput(percentageInput, InputValidator.clampPercent);
              const endVal = InputValidator.computeEndFromPercent(p);
              const endInput = tr.querySelector('.end-input');
              if (endInput) endInput.value = String(endVal);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'end':
            // Re-apply: restore new end value
            const endValueInput = tr.querySelector('.end-input');
            if (endValueInput) {
              endValueInput.value = action.newValue;
              
              // Recalculate dependent values and update UI
              const e = InputValidator.validateInput(endValueInput, InputValidator.clampEnd);
              const p = InputValidator.computePercentFromEnd(e);
              const percentageInput = tr.querySelector('.percent-input');
              if (percentageInput) percentageInput.value = p.toFixed(1);
              
              // Update UI display
              if (tr.refreshDisplayFn) tr.refreshDisplayFn();
            }
            break;
            
          case 'curve':
            // Re-apply: restore new curve data
            if (action.newValue === null) {
              // Remove curve data
              if (window.loadedQuadData?.curves?.[action.channelName]) {
                delete window.loadedQuadData.curves[action.channelName];
              }
              // Remove AI key points/meta as well
              if (window.loadedQuadData?.keyPoints?.[action.channelName]) {
                delete window.loadedQuadData.keyPoints[action.channelName];
              }
              if (window.loadedQuadData?.keyPointsMeta?.[action.channelName]) {
                delete window.loadedQuadData.keyPointsMeta[action.channelName];
              }
              
              // Re-enable per-channel linearization UI when removing Smart Curve
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = false;
              }
            } else {
              // Restore new curve data
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[action.channelName] = [...action.newValue];
              
              // Disable per-channel linearization when restoring Smart Curve
              if (perChannelLinearization[action.channelName]) {
                delete perChannelLinearization[action.channelName];
              }
              perChannelEnabled[action.channelName] = false;
              
              const perChannelToggle = tr.querySelector('.per-channel-toggle');
              if (perChannelToggle) {
                perChannelToggle.disabled = true;
                perChannelToggle.checked = false;
              }

              // Restore new AI key points/meta if provided
              if (action.newKeyPoints && Array.isArray(action.newKeyPoints)) {
                if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
                window.loadedQuadData.keyPoints[action.channelName] = action.newKeyPoints.map(p => ({ input: p.input, output: p.output }));
              }
              if (action.newInterpolation) {
                if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
                window.loadedQuadData.keyPointsMeta[action.channelName] = { interpolationType: action.newInterpolation };
              }
            }
            break;
        }
        
        // Update compact channels list and graphs
        setTimeout(() => updateCompactChannelsList(), 50);
        debouncedPreviewUpdate();
        // Refresh processing panel for this channel
        if (typeof updateProcessingDetail === 'function') updateProcessingDetail(action.channelName);
        
        this.isRestoring = false;
      },
      
      /**
       * Restore a specific state
       */
      restoreState(state) {
        // Set flag to prevent capturing state during restore
        this.isRestoring = true;
        
        // Restore channel states
        Object.entries(state.channels).forEach(([channelName, channelState]) => {
          const tr = document.querySelector(`tr[data-channel="${channelName}"]`);
          if (tr) {
            const percentInput = tr.querySelector('.percent-input');
            const endInput = tr.querySelector('.end-input');
            const checkbox = tr._virtualCheckbox;
            
            if (percentInput) percentInput.value = channelState.percentage;
            if (endInput) endInput.value = channelState.endValue;
            
            // Update checkbox without triggering events
            if (checkbox) {
              checkbox.checked = channelState.enabled;
              
              // Update visual state directly instead of triggering change event
              tr.style.opacity = channelState.enabled ? '1' : '0.5';
              
              // Enable/disable form elements
              const inputs = tr.querySelectorAll('input, select');
              inputs.forEach(input => {
                input.disabled = !channelState.enabled;
              });
            }
            
            // Call refresh function to handle proper visual state transitions (disabled chips <-> enabled rows)
            if (tr.refreshDisplayFn) {
              tr.refreshDisplayFn();
            }
            
            // Restore curve data if available
            if (channelState.curveData) {
              // Ensure loadedQuadData structure exists
              if (!window.loadedQuadData) {
                window.loadedQuadData = { curves: {} };
              }
              if (!window.loadedQuadData.curves) {
                window.loadedQuadData.curves = {};
              }
              window.loadedQuadData.curves[channelName] = [...channelState.curveData];
            } else {
              // If no curve data in state, remove any existing curve data for this channel
              if (window.loadedQuadData?.curves?.[channelName]) {
                delete window.loadedQuadData.curves[channelName];
              }
            }
            
            // Call the individual channel's refreshDisplay function to handle compact/full display
            const refreshDisplay = tr.refreshDisplayFn;
            if (refreshDisplay) {
              refreshDisplay();
            }
          }
        });
        
        // Update compact channels list after all channels are restored
        setTimeout(() => updateCompactChannelsList(), 50);
        
        // Restore global linearization
        if (elements.globalLinearizationToggle) {
          elements.globalLinearizationToggle.checked = state.globalLinearization.enabled;
        }
        if (elements.globalLinearizationFilename) {
          elements.globalLinearizationFilename.textContent = state.globalLinearization.filename;
        }
        if (state.globalLinearization.data) {
          linearizationData = {...state.globalLinearization.data};
        } else {
          linearizationData = null;
        }
        linearizationApplied = state.globalLinearization.applied || false;
        // Refresh edited display state for global filename
        refreshGlobalLinearizationDisplay();
        
        // Restore per-channel linearization
        Object.assign(perChannelLinearization, state.perChannelLinearization);
        Object.assign(perChannelEnabled, state.perChannelEnabled);
        
        // Update UI and preview
        updateInterpolationControls();
        updatePreview();
        // Refresh processing details for all channels since global/per-channel state changed
        try {
          const channelNames = getCurrentPrinter().channels;
          channelNames.forEach((name) => {
            if (typeof updateProcessingDetail === 'function') updateProcessingDetail(name);
          });
        } catch {}
        
        // Clear flag after restore is complete
        this.isRestoring = false;
      },
      
      /**
       * Update undo button state
       */
      updateUndoButton() {
        const undoBtn = document.getElementById('undoBtn');
        if (undoBtn) {
          const canUndo = this.actionHistory.length > 0 || this.legacyHistory.length > 0;
          undoBtn.disabled = !canUndo;
          undoBtn.style.opacity = canUndo ? '1' : '0.5';
          
          if (canUndo) {
            // Show the most recent action from either history
            let mostRecentAction;
            if (this.actionHistory.length > 0 && this.legacyHistory.length > 0) {
              // Compare timestamps to find the most recent
              const lastChannel = this.actionHistory[this.actionHistory.length - 1];
              const lastLegacy = this.legacyHistory[this.legacyHistory.length - 1];
              mostRecentAction = lastChannel.timestamp > lastLegacy.timestamp ? 
                lastChannel.description : lastLegacy.action;
            } else if (this.actionHistory.length > 0) {
              mostRecentAction = this.actionHistory[this.actionHistory.length - 1].description;
            } else {
              mostRecentAction = this.legacyHistory[this.legacyHistory.length - 1].action;
            }
            undoBtn.title = `Undo: ${mostRecentAction}`;
          } else {
            undoBtn.title = 'No actions to undo';
          }
        }
      },

      /**
       * Update redo button state
       */
      updateRedoButton() {
        const redoBtn = document.getElementById('redoBtn');
        if (redoBtn) {
          redoBtn.disabled = this.redoHistory.length === 0;
          
          if (this.redoHistory.length > 0) {
            const nextAction = this.redoHistory[this.redoHistory.length - 1];
            // Handle both channel actions (have .description) and legacy actions (have .action)
            const actionName = nextAction.description || nextAction.action || 'Unnamed action';
            redoBtn.title = `Redo: ${actionName}`;
          } else {
            redoBtn.title = 'No actions to redo';
          }
        }
      },
      
      /**
       * Get history summary for AI
       */
      getHistorySummary() {
        return {
          totalStates: this.history.length,
          canUndo: this.history.length > 1,
          canRedo: this.redoHistory.length > 0,
          recentActions: this.history.slice(-5).map(state => ({
            action: state.action,
            timestamp: new Date(state.timestamp).toLocaleTimeString()
          }))
        };
      },
      
      /**
       * Clear history
       */
      clear() {
        this.actionHistory = [];
        this.legacyHistory = [];
        this.redoHistory = [];
        this.updateUndoButton();
        this.updateRedoButton();
      }
    };

    /**
     * Parse a .cube file string as a 1D LUT or route to 3D LUT parser.
     * Returns { domainMin, domainMax, samples } where samples are floats (usually 0..1).
     */
    function parseCube1D(cubeText) {
      const lines = cubeText.split(/\r?\n/);
      let domainMin = 0.0;
      let domainMax = 1.0;
      let declaredSize = null;
      const samples = [];

      // Check for 3D LUT indicators early - route to appropriate parser
      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;
        
        // Detect 3D LUT file format and route to 3D parser
        if (/^LUT_3D_SIZE/i.test(s)) {
          return parseCube3D(cubeText);
        }
      }

      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;

        if (/^LUT_1D_SIZE/i.test(s)) {
          const m = s.match(/LUT_1D_SIZE\s+(\d+)/i);
          if (m) declaredSize = parseInt(m[1], 10);
          continue;
        }
        if (/^DOMAIN_MIN/i.test(s)) {
          // 1 or 3 numbers; for 1D we take the first
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMin = parseFloat(parts[1]);
          continue;
        }
        if (/^DOMAIN_MAX/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMax = parseFloat(parts[1]);
          continue;
        }

        // Numeric row: could be 1–3 floats. For LUTs, many files still list RGB triplets.
        const nums = s.split(/\s+/).map(Number);
        if (nums.every((v) => Number.isFinite(v)) && nums.length >= 1 && nums.length <= 3) {
          samples.push(nums[0]); // take the first channel for 1D
        }
      }

      // After parsing, check if this looks like 3D LUT data
      if (samples.length > 100) {
        // LUTs with very high point counts may indicate parsing issues
        throw new Error("This file contains an unusually high number of data points. Please verify the file format and try again.");
      }

      if (declaredSize !== null && samples.length >= declaredSize) {
        samples.length = declaredSize;
      }
      if (!Number.isFinite(domainMin) || !Number.isFinite(domainMax) || domainMin === domainMax) {
        domainMin = 0.0; domainMax = 1.0;
      }
      if (!samples.length) {
        throw new Error("No 1D samples found in .cube text.");
      }

      // Apply both horizontal and vertical flips to match printing coordinate system
      // First: horizontal flip (reverse coordinate positions)
      const horizontallyFlipped = samples.map((sample, i) => {
        const inputPos = i / (samples.length - 1); // Current input position (0-1)
        const flippedInputPos = 1.0 - inputPos; // Horizontal flip
        const flippedInputIndex = Math.round(flippedInputPos * (samples.length - 1)); // Convert back to index
        const clampedIndex = Math.max(0, Math.min(samples.length - 1, flippedInputIndex));
        return samples[clampedIndex];
      });
      
      // Second: vertical flip (invert values so 0.0 becomes 1.0, 0.5 becomes 0.5, etc.)
      const flippedSamples = horizontallyFlipped.map(sample => 1.0 - sample);
      
      return { domainMin, domainMax, samples: flippedSamples, originalSamples: samples, format: '1DLUT' };
    }

    // Centralized policy for control point operations
    const ControlPolicy = {
      minGap: 0.01,
      yMin: 0,
      yMax: 100,
      defaultTolerance: 1.0,
      endpointsLocked: true,
      clampY(y) { return Math.max(this.yMin, Math.min(this.yMax, y)); },
      clampX(x) { return Math.max(0, Math.min(100, x)); }
    };

    // Facade for control point operations (AI set)
    const ControlPoints = {
      // Get current AI control points and interpolation for channel
      get(channelName) {
        const pts = window.loadedQuadData?.keyPoints?.[channelName] || null;
        const interpolation = window.loadedQuadData?.keyPointsMeta?.[channelName]?.interpolationType || 'smooth';
        return { points: pts ? pts.map(p => ({ input: p.input, output: p.output })) : null, interpolation };
      },
      // Normalize: clamp, sort by X, and enforce min gap
      normalize(points) {
        if (!Array.isArray(points)) return [];
        const clamped = points.map(p => ({
          input: ControlPolicy.clampX(Number(p.input)),
          output: ControlPolicy.clampY(Number(p.output))
        }));
        clamped.sort((a, b) => a.input - b.input);
        for (let i = 1; i < clamped.length; i++) {
          if (clamped[i].input <= clamped[i - 1].input) {
            clamped[i].input = Math.min(100, clamped[i - 1].input + ControlPolicy.minGap);
          }
        }
        return clamped;
      },
      // Persist to global storage
      persist(channelName, points, interpolation = 'smooth') {
        if (!window.loadedQuadData) window.loadedQuadData = {};
        if (!window.loadedQuadData.keyPoints) window.loadedQuadData.keyPoints = {};
        if (!window.loadedQuadData.keyPointsMeta) window.loadedQuadData.keyPointsMeta = {};
        window.loadedQuadData.keyPoints[channelName] = points.map(p => ({ input: p.input, output: p.output }));
        window.loadedQuadData.keyPointsMeta[channelName] = { interpolationType: (interpolation === 'linear' ? 'linear' : 'smooth') };
      },
      // Sample Y at X using current points and interpolation
      sampleY(points, interpolation, x) {
        const xs = points.map(p => p.input);
        const ys = points.map(p => p.output);
        const xi = ControlPolicy.clampX(x);
        if (interpolation === 'linear') {
          if (xi <= xs[0]) return ys[0];
          if (xi >= xs[xs.length - 1]) return ys[ys.length - 1];
          let i = 0; while (i < xs.length - 1 && xs[i + 1] < xi) i++;
          const x0 = xs[i], x1 = xs[i + 1];
          const y0 = ys[i], y1 = ys[i + 1];
          const t = (xi - x0) / (x1 - x0);
          return y0 + t * (y1 - y0);
        } else {
          // PCHIP via createPCHIPSpline requires monotonic xs
          const pchip = createPCHIPSpline(xs, ys);
          return pchip(xi);
        }
      },
      // Find nearest index to x within tolerance
      nearestIndex(points, x, tolerance = ControlPolicy.defaultTolerance) {
        const xi = ControlPolicy.clampX(x);
        let best = { index: -1, delta: Infinity, input: 0 };
        points.forEach((p, i) => {
          const d = Math.abs(p.input - xi);
          if (d < best.delta || (d === best.delta && p.input < best.input)) {
            best = { index: i, delta: d, input: p.input };
          }
        });
        if (best.index === -1 || best.delta > tolerance) return null;
        return best.index;
      }
    };

    // Adaptive key‑point extraction using Ramer–Douglas–Peucker on normalized (0..100) XY
    function _perpDist(p, a, b) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      if (dx === 0 && dy === 0) {
        const ux = p.x - a.x, uy = p.y - a.y;
        return Math.hypot(ux, uy);
      }
      return Math.abs(dy * p.x - dx * p.y + b.x * a.y - b.y * a.x) / Math.hypot(dx, dy);
    }

    function _rdp(points, eps) {
      const keep = new Array(points.length).fill(false);
      keep[0] = true; keep[points.length - 1] = true;
      (function simplify(first, last) {
        if (last <= first + 1) return;
        const a = points[first], b = points[last];
        let maxD = -1, idx = -1;
        for (let i = first + 1; i < last; i++) {
          const d = _perpDist(points[i], a, b);
          if (d > maxD) { maxD = d; idx = i; }
        }
        if (maxD > eps) {
          keep[idx] = true;
          simplify(first, idx);
          simplify(idx, last);
        }
      })(0, points.length - 1);
      const out = [];
      for (let i = 0; i < points.length; i++) if (keep[i]) out.push(points[i]);
      return out;
    }

    function extractAdaptiveKeyPointsFromValues(values, options = {}) {
      const maxErrorPercent = Math.max(0.05, Math.min(5, options.maxErrorPercent || KP_SIMPLIFY.maxErrorPercent || 1.0)); // 0.05%..5%
      const maxPoints = Math.max(2, Math.min(21, options.maxPoints || KP_SIMPLIFY.maxPoints || 21));
      const N = values.length;
      if (!Array.isArray(values) || N < 2) return [ { input: 0, output: 0 }, { input: 100, output: 100 } ];
      const peak = Math.max(0, ...values);
      if (peak <= 0) return [ { input: 0, output: 0 }, { input: 100, output: 100 } ];
      // Build normalized XY relative to peak so endpoint will be 100% for AI scaling logic
      const pts = new Array(N);
      for (let i = 0; i < N; i++) {
        const x = (i / (N - 1)) * 100;
        const y = Math.max(0, Math.min(100, (values[i] / peak) * 100));
        pts[i] = { x, y };
      }
      // Detect near-linear ramp (within tolerance across a few samples)
      let isLinear = false;
      const samples = [0, Math.floor((N - 1) * 0.25), Math.floor((N - 1) * 0.5), Math.floor((N - 1) * 0.75), (N - 1)];
      const EPS = 0.005; // 0.5%
      isLinear = samples.every(idx => {
        const expected = (idx / (N - 1));
        const actual = (values[idx] / peak);
        return Math.abs(actual - expected) <= EPS;
      });
      if (isLinear) {
        return [ { input: 0, output: 0 }, { input: 100, output: 100 } ];
      }
      // Adaptive simplify; increase epsilon if too many points
      let eps = maxErrorPercent; // in percent units (same XY scale)
      let simplified = _rdp(pts, eps);
      let guard = 0;
      while (simplified.length > maxPoints && guard < 8) {
        eps *= 1.3; // relax tolerance progressively
        simplified = _rdp(pts, eps);
        guard++;
      }
      // Map back to key points and normalize X gaps
      const keyPoints = simplified.map(p => ({ input: p.x, output: p.y }));
      return ControlPoints.normalize(keyPoints);
    }

    // Ensure AI key points exist for a channel; if not, create them from source data or current curve
    function ensureEditableKeyPointsForChannel(channelName, interpolationType = 'smooth') {
      try {
        const existing = ControlPoints.get(channelName).points;
        if (existing && existing.length >= 2) return { success: true };

        // Prefer per-channel linearization source
        let candidate = [];
        const per = perChannelLinearization[channelName];
        if (per) {
          const fmt = (per.format || '').toUpperCase();
          if (fmt === 'ACV' && Array.isArray(per.controlPointsTransformed) && per.controlPointsTransformed.length >= 2) {
            // Seed ACV anchors directly (cap via DIRECT_SEED_MAX_POINTS)
            if (per.controlPointsTransformed.length <= DIRECT_SEED_MAX_POINTS) {
              candidate = per.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
            } else {
              // Too many anchors — sample plotted curve and simplify
              const row = document.querySelector(`tr[data-channel="${channelName}"]`);
              const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
              const values = make256(endVal, channelName, true);
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmt.includes('LAB') || fmt.includes('MANUAL')) && Array.isArray(per.samples) && per.samples.length >= 2) {
            // LAB/Manual: when few measurements, seed at measured Patch % positions; else simplify plotted curve
            const row = document.querySelector(`tr[data-channel="${channelName}"]`);
            const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
            const values = make256(endVal, channelName, true);
            const orig = Array.isArray(per.originalData) ? per.originalData : null;
            if (orig && orig.length > 0 && orig.length <= DIRECT_SEED_MAX_POINTS) {
              // Seed at measured Patch % positions by sampling the plotted mapping
              const Nvals = values.length - 1;
              candidate = orig.map(d => {
                const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                const t = (x / 100) * Nvals;
                const i0 = Math.floor(t);
                const i1 = Math.min(Nvals, Math.ceil(t));
                const a = t - i0;
                const v = (1 - a) * values[i0] + a * values[i1];
                const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                return { input: x, output: outPct };
              });
            } else {
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmt === '1DLUT' || Array.isArray(per.samples)) && Array.isArray(per.samples) && per.samples.length >= 2) {
            // Seed from LUT samples (1D or neutral axis from 3D). Use exact points when modest in count; otherwise adaptively reduce.
            const K = per.samples.length;
            if (K <= DIRECT_SEED_MAX_POINTS) {
              candidate = per.samples.map((s, i) => ({
                input: (i / (K - 1)) * 100,
                output: Math.max(0, Math.min(100, s * 100))
              }));
            } else {
              // Too dense for direct seeding; derive a compact, edit-friendly set from the LUT curve
              const values = per.samples.map(v => Math.round(Math.max(0, Math.min(1, v)) * TOTAL));
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          }
        }
        // If no per-channel anchors, prefer global ACV anchors if available
        if (candidate.length < 2 && linearizationData) {
          const fmtG = (linearizationData.format || '').toUpperCase();
          if (fmtG === 'ACV' && Array.isArray(linearizationData.controlPointsTransformed) && linearizationData.controlPointsTransformed.length >= 2) {
            if (linearizationData.controlPointsTransformed.length <= DIRECT_SEED_MAX_POINTS) {
              candidate = linearizationData.controlPointsTransformed.map(p => ({ input: p.input, output: p.output }));
            } else {
              const row = document.querySelector(`tr[data-channel="${channelName}"]`);
              const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
              const values = make256(endVal, channelName, true);
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmtG.includes('LAB') || fmtG.includes('MANUAL')) && Array.isArray(linearizationData.samples) && linearizationData.samples.length >= 2) {
            // Global LAB/Manual: seed at measured Patch % when modest; else simplify plotted curve
            const row = document.querySelector(`tr[data-channel="${channelName}"]`);
            const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : TOTAL;
            const values = make256(endVal, channelName, true);
            const orig = Array.isArray(linearizationData.originalData) ? linearizationData.originalData : null;
            if (orig && orig.length > 0 && orig.length <= DIRECT_SEED_MAX_POINTS) {
              const Nvals = values.length - 1;
              candidate = orig.map(d => {
                const x = Math.max(0, Math.min(100, Number(d.input ?? d.GRAY ?? d.gray ?? 0)));
                const t = (x / 100) * Nvals;
                const i0 = Math.floor(t);
                const i1 = Math.min(Nvals, Math.ceil(t));
                const a = t - i0;
                const v = (1 - a) * values[i0] + a * values[i1];
                const outPct = Math.max(0, Math.min(100, (v / TOTAL) * 100));
                return { input: x, output: outPct };
              });
            } else {
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          } else if ((fmtG === '1DLUT' || Array.isArray(linearizationData.samples)) && Array.isArray(linearizationData.samples) && linearizationData.samples.length >= 2) {
            // Seed from global LUT samples (1D or neutral axis from 3D)
            const K = linearizationData.samples.length;
            if (K <= DIRECT_SEED_MAX_POINTS) {
              candidate = linearizationData.samples.map((s, i) => ({
                input: (i / (K - 1)) * 100,
                output: Math.max(0, Math.min(100, s * 100))
              }));
            } else {
              const values = linearizationData.samples.map(v => Math.round(Math.max(0, Math.min(1, v)) * TOTAL));
              candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
            }
          }
        }
        // If no direct anchors, sample from current displayed curve
        if (candidate.length < 2) {
          const row = document.querySelector(`tr[data-channel="${channelName}"]`);
          const e = row ? InputValidator.clampEnd(row.querySelector('.end-input').value) : TOTAL;
          const values = make256(e, channelName, true);
          // Use adaptive simplification (RDP) to create a compact, edit-friendly set
          candidate = extractAdaptiveKeyPointsFromValues(values, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
        }
        // If channel is disabled (End=0), persist key points only and avoid applying/enabling the channel
        try {
          const row = document.querySelector(`tr[data-channel="${channelName}"]`);
          const endVal = row ? InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0) : 0;
          if (endVal === 0) {
            ControlPoints.persist(channelName, candidate, interpolationType);
            return { success: true };
          }
        } catch {}
        // Otherwise, persist and apply curve normally
        const res = quadGenActions.setSmartKeyPoints(channelName, candidate, interpolationType);
        if (res && res.success) return { success: true };
        return { success: false, message: res?.message || 'Failed to create Smart key points' };
      } catch (e) {
        return { success: false, message: e.message };
      }
    }

    /**
     * Parse a 3D LUT (.cube) file and extract neutral axis for linearization.
     * Returns { domainMin, domainMax, samples } where samples represent the neutral axis (R=G=B) response.
     */
    function parseCube3D(cubeText) {
      const lines = cubeText.split(/\r?\n/);
      let domainMin = 0.0;
      let domainMax = 1.0;
      let lutSize = null;
      const lutData = [];

      // Parse header information
      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;

        if (/^LUT_3D_SIZE/i.test(s)) {
          const m = s.match(/LUT_3D_SIZE\s+(\d+)/i);
          if (m) lutSize = parseInt(m[1], 10);
          continue;
        }
        if (/^DOMAIN_MIN/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMin = parseFloat(parts[1]);
          continue;
        }
        if (/^DOMAIN_MAX/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMax = parseFloat(parts[1]);
          continue;
        }

        // Parse RGB data lines
        const parts = s.split(/\s+/);
        if (parts.length === 3) {
          const r = parseFloat(parts[0]);
          const g = parseFloat(parts[1]);
          const b = parseFloat(parts[2]);
          if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
            lutData.push([r, g, b]);
          }
        }
      }

      if (!lutSize) {
        throw new Error("3D LUT size not found. Expected LUT_3D_SIZE declaration.");
      }

      const expectedDataPoints = lutSize * lutSize * lutSize;
      if (lutData.length !== expectedDataPoints) {
        throw new Error(`3D LUT data mismatch. Expected ${expectedDataPoints} points, found ${lutData.length}.`);
      }

      // Extract neutral axis (diagonal where R=G=B)
      const neutralAxisSamples = [];
      const outputSteps = 256; // Generate 256 samples for consistency with other LUT processing

      for (let i = 0; i < outputSteps; i++) {
        const input = i / (outputSteps - 1); // 0 to 1
        const neutralRGB = [input, input, input]; // R=G=B for neutral gray
        
        // Trilinear interpolation in 3D LUT
        const outputRGB = trilinearInterpolate3D(neutralRGB, lutData, lutSize, domainMin, domainMax);
        
        // Convert RGB output to luminance (simple average for neutral axis)
        const luminance = (outputRGB[0] + outputRGB[1] + outputRGB[2]) / 3;
        neutralAxisSamples.push(luminance);
      }

      // Apply coordinate system transformations to match other LUT processing
      const horizontallyFlipped = neutralAxisSamples.map((sample, i) => {
        const inputPos = i / (neutralAxisSamples.length - 1);
        const flippedInputPos = 1.0 - inputPos;
        const flippedInputIndex = Math.round(flippedInputPos * (neutralAxisSamples.length - 1));
        const clampedIndex = Math.max(0, Math.min(neutralAxisSamples.length - 1, flippedInputIndex));
        return neutralAxisSamples[clampedIndex];
      });
      
      const flippedSamples = horizontallyFlipped.map(sample => 1.0 - sample);
      
      return { 
        domainMin, 
        domainMax, 
        samples: flippedSamples,
        is3DLUT: true,
        lutSize: lutSize,
        originalDataPoints: expectedDataPoints
      };
    }

    /**
     * Trilinear interpolation for 3D LUT sampling
     * @private
     */
    function trilinearInterpolate3D(inputRGB, lutData, lutSize, domainMin, domainMax) {
      const [r, g, b] = inputRGB;
      
      // Normalize input to LUT coordinates (0 to lutSize-1)
      const normalizedR = (r - domainMin) / (domainMax - domainMin);
      const normalizedG = (g - domainMin) / (domainMax - domainMin);
      const normalizedB = (b - domainMin) / (domainMax - domainMin);
      
      const lutR = Math.max(0, Math.min(lutSize - 1, normalizedR * (lutSize - 1)));
      const lutG = Math.max(0, Math.min(lutSize - 1, normalizedG * (lutSize - 1)));
      const lutB = Math.max(0, Math.min(lutSize - 1, normalizedB * (lutSize - 1)));
      
      // Get integer indices and fractional parts
      const r0 = Math.floor(lutR), r1 = Math.min(lutSize - 1, r0 + 1);
      const g0 = Math.floor(lutG), g1 = Math.min(lutSize - 1, g0 + 1);
      const b0 = Math.floor(lutB), b1 = Math.min(lutSize - 1, b0 + 1);
      
      const fr = lutR - r0;
      const fg = lutG - g0;
      const fb = lutB - b0;
      
      // Get the 8 corner values from the LUT cube
      const corners = [
        lutData[r0 * lutSize * lutSize + g0 * lutSize + b0], // (r0,g0,b0)
        lutData[r1 * lutSize * lutSize + g0 * lutSize + b0], // (r1,g0,b0)
        lutData[r0 * lutSize * lutSize + g1 * lutSize + b0], // (r0,g1,b0)
        lutData[r1 * lutSize * lutSize + g1 * lutSize + b0], // (r1,g1,b0)
        lutData[r0 * lutSize * lutSize + g0 * lutSize + b1], // (r0,g0,b1)
        lutData[r1 * lutSize * lutSize + g0 * lutSize + b1], // (r1,g0,b1)
        lutData[r0 * lutSize * lutSize + g1 * lutSize + b1], // (r0,g1,b1)
        lutData[r1 * lutSize * lutSize + g1 * lutSize + b1]  // (r1,g1,b1)
      ];
      
      // Trilinear interpolation
      const result = [0, 0, 0];
      for (let c = 0; c < 3; c++) {
        const c00 = corners[0][c] * (1 - fr) + corners[1][c] * fr;
        const c01 = corners[2][c] * (1 - fr) + corners[3][c] * fr;
        const c10 = corners[4][c] * (1 - fr) + corners[5][c] * fr;
        const c11 = corners[6][c] * (1 - fr) + corners[7][c] * fr;
        
        const c0 = c00 * (1 - fg) + c01 * fg;
        const c1 = c10 * (1 - fg) + c11 * fg;
        
        result[c] = c0 * (1 - fb) + c1 * fb;
      }
      
      return result;
    }

    // LAB processing summary: see docs/LAB_LINEARIZATION_WORKFLOW.md
    /**
     * Parse a LAB measurement data file (tab-separated format)
     * Expected format:
     * GRAY	LAB_L	LAB_A	LAB_B
     * 0	97.50	0.20	-0.50
     * 5	93.40	0.30	-0.70
     * ...
     * Returns { domainMin: 0, domainMax: 1, samples } where samples are normalized 0..1
     */
    function parseLabData(fileContent, filename) {
      const lines = fileContent.split(/\r?\n/);
      const dataPoints = [];

      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue; // skip empty
        if (trimmed.startsWith('#') || trimmed.startsWith('//')) continue;
        if (trimmed.toUpperCase().includes('GRAY') && trimmed.toUpperCase().includes('LAB_L')) continue; // header

        const parts = trimmed.split(/\s+/);
        if (parts.length >= 2) {
          const grayPercent = parseFloat(parts[0]);
          const labL = parseFloat(parts[1]);
          if (!isNaN(grayPercent) && !isNaN(labL) && grayPercent >= 0 && grayPercent <= 100 && labL >= 0 && labL <= 100) {
            dataPoints.push({ input: grayPercent, lab: labL });
          }
        }
      }

      if (dataPoints.length < 2) {
        throw new Error('Not enough valid LAB measurement data points found. Expected format: GRAY\tLAB_L\tLAB_A\tLAB_B');
      }

      // Sort and capture original data for overlays/metadata
      dataPoints.sort((a, b) => a.input - b.input);
      const originalDataPoints = [...dataPoints];

      // Build Gaussian Weighted Correction in printer space (density)
      const labValues = dataPoints.map(p => p.lab);
      const minLab = Math.min(...labValues);
      const maxLab = Math.max(...labValues);
      const labRange = Math.max(1e-9, maxLab - minLab);

      const correctionPoints = dataPoints.map(point => {
        const pos = Math.max(0, Math.min(1, point.input / 100));
        const actualDensity = 1.0 - ((point.lab - minLab) / labRange); // 0..1
        const expectedDensity = pos; // linear target
        return {
          position: pos,
          // Stable sign convention: expected minus actual
          correction: (expectedDensity - actualDensity),
          originalLab: point.lab,
          originalInput: point.input
        };
      });

      // Base influence radius; can be widened by smoothing control
      const influenceRadius = 0.15; // 15% of range

      const samples = [];
      for (let i = 0; i < 256; i++) {
        const position = i / 255;
        let weightedCorrection = 0;
        let totalWeight = 0;
        for (let j = 0; j < correctionPoints.length; j++) {
          const d = Math.abs(position - correctionPoints[j].position);
          const w = Math.exp(-(d * d) / (2 * influenceRadius * influenceRadius));
          weightedCorrection += correctionPoints[j].correction * w;
          totalWeight += w;
        }
        const baseline = position;
        const finalCorrection = totalWeight > 0 ? (weightedCorrection / totalWeight) : 0;
        const corrected = Math.max(0, Math.min(1, baseline + finalCorrection));
        samples.push(corrected);
      }
      // Anchor endpoints
      samples[0] = 0.0;
      samples[samples.length - 1] = 1.0;

      // Return LAB linearization object with optional Gaussian smoothing provider
      return {
        domainMin: 0.0,
        domainMax: 1.0,
        samples: samples,
        originalData: originalDataPoints,
        format: 'LAB Data',
        getSmoothingControlPoints: function(smoothingPercent) {
          // Dynamic radius: 0% => tight; 90% => wide
          const baseRadius = 0.08;
          const maxRadius = 0.25;
          const sp = Math.max(0, Math.min(90, Number(smoothingPercent) || 0));
          const radius = baseRadius + (sp / 100) * (maxRadius - baseRadius);
          const dyn = new Array(256);
          for (let i = 0; i < 256; i++) {
            const position = i / 255;
            let weightedCorrection = 0;
            let totalWeight = 0;
            for (let j = 0; j < correctionPoints.length; j++) {
              const d = Math.abs(position - correctionPoints[j].position);
              const w = Math.exp(-(d * d) / (2 * radius * radius));
              weightedCorrection += correctionPoints[j].correction * w;
              totalWeight += w;
            }
            const baseline = position;
            const finalCorrection = totalWeight > 0 ? (weightedCorrection / totalWeight) : 0;
            dyn[i] = Math.max(0, Math.min(1, baseline + finalCorrection));
          }
          dyn[0] = 0.0;
          dyn[dyn.length - 1] = 1.0;
          // Produce evenly spaced control points from dynamic curve
          const controlPointCount = Math.max(3, 21 - Math.floor(sp / 10));
          const cpY = [];
          const cpX = [];
          for (let i = 0; i < controlPointCount; i++) {
            const x = i / (controlPointCount - 1);
            const idx = Math.round(x * 255);
            cpX.push(x);
            cpY.push(dyn[idx]);
          }
        // Apply dual-axis transformation after interpolation to match industry-standard plot orientation
        // Signal to apply1DLUT() to perform horizontal + vertical flips on the final mapping
          return { samples: cpY, xCoords: cpX, controlPointCount, needsDualTransformation: false, influenceRadius: radius };
        }
      };
    }

    /**
     * Parse Adobe Photoshop .acv (curve) files
     * Binary format: version(int16), totalCurves(int16), then for each curve: pointCount(int16), point pairs(int16,int16)
     * Returns { domainMin: 0, domainMax: 1, samples } where samples are normalized 0..1
     */
    function parseACVFile(arrayBuffer) {
      const dataView = new DataView(arrayBuffer);
      let offset = 0;

      // Read version (2 bytes, big-endian)
      const version = dataView.getInt16(offset, false);
      offset += 2;

      // Read total curves count (2 bytes, big-endian)
      const totalCurves = dataView.getInt16(offset, false);
      offset += 2;

      if (totalCurves === 0) {
        throw new Error('ACV file contains no curves');
      }

      // Parse first curve (RGB composite curve)
      const pointCount = dataView.getInt16(offset, false);
      offset += 2;

      if (pointCount === 0) {
        throw new Error('ACV file RGB curve contains no points');
      }

      const curvePoints = [];
      for (let i = 0; i < pointCount; i++) {
        // Read output value (y-coordinate) - this is the correction value
        const output = dataView.getInt16(offset, false);
        offset += 2;
        // Read input value (x-coordinate) - this is the original value
        const input = dataView.getInt16(offset, false);
        offset += 2;

        curvePoints.push({
          input: input / 255,    // Normalize to 0-1
          output: output / 255   // Normalize to 0-1
        });
      }

      // Sort by input value to ensure proper curve order
      curvePoints.sort((a, b) => a.input - b.input);

      // Use cubic spline interpolation like Photoshop for smooth curves
      const xValues = curvePoints.map(p => p.input);
      const yValues = curvePoints.map(p => p.output);
      
      // Create cubic spline interpolator
      const splineInterpolator = createCubicSpline(xValues, yValues);
      
      // Convert to the format expected by quadGEN (256 samples)
      const samples = new Array(256);
      for (let i = 0; i < 256; i++) {
        const inputValue = i / 255;
        samples[i] = Math.max(0, Math.min(1, splineInterpolator(inputValue)));
      }

      // Apply the same orientation as .cube: horizontal flip then vertical inversion
      const horizontallyFlipped = samples.map((sample, i) => {
        const inputPos = i / (samples.length - 1);
        const flippedInputPos = 1.0 - inputPos;
        const flippedInputIndex = Math.round(flippedInputPos * (samples.length - 1));
        const clampedIndex = Math.max(0, Math.min(samples.length - 1, flippedInputIndex));
        return samples[clampedIndex];
      });
      const flippedSamples = horizontallyFlipped.map(sample => 1.0 - sample);

      // Also build transformed control points from the original ACV anchors
      // Transform: input' = 1 - input, output' = 1 - output, then scale to 0-100
      const controlPointsTransformed = curvePoints.map(p => ({
        input: (1 - p.input) * 100,
        output: (1 - p.output) * 100
      })).sort((a,b) => a.input - b.input);

      return {
        domainMin: 0,
        domainMax: 1,
        samples: flippedSamples,
        originalSamples: samples,
        format: 'ACV',
        controlPointsTransformed
      };
    }

    /**
     * Detect file type and parse appropriately
     * For text files, pass the file content as string
     * For binary files (.acv), pass the ArrayBuffer
     */
    async function parseLinearizationFile(fileContentOrFile, filename) {
      const extension = filename.toLowerCase().split('.').pop();
      
      if (extension === 'cube') {
        return parseCube1D(fileContentOrFile);
      } else if (extension === 'txt') {
        // Check if it's LAB measurement format by looking for the header
        if (fileContentOrFile.includes('GRAY') && fileContentOrFile.includes('LAB_L')) {
          return parseLabData(fileContentOrFile, filename);
        } else {
          throw new Error('TXT file format not recognized. Expected LAB measurement format with GRAY and LAB_L columns.');
        }
      } else if (extension === 'acv') {
        // .acv files are binary, so fileContentOrFile should be an ArrayBuffer
        if (!(fileContentOrFile instanceof ArrayBuffer)) {
          throw new Error('ACV files must be read as binary data');
        }
        return parseACVFile(fileContentOrFile);
      } else {
        throw new Error(`Unsupported file format: ${extension}. Use .cube, .txt, or .acv files.`);
      }
    }

    /**
     * Natural cubic spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCubicSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Use clamped cubic spline with estimated end derivatives for more curvature
      const h = new Array(n - 1);
      const alpha = new Array(n);
      const l = new Array(n);
      const mu = new Array(n);
      const z = new Array(n);
      const c = new Array(n);
      const b = new Array(n);
      const d = new Array(n);
      
      // Step 1: Calculate h
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
      }
      
      // Step 2: Set up alpha with clamped boundary conditions
      // Estimate end derivatives to allow more curvature
      const firstDerivative = (y[1] - y[0]) / h[0];
      const lastDerivative = (y[n-1] - y[n-2]) / h[n-2];
      
      alpha[0] = 3 * ((y[1] - y[0]) / h[0] - firstDerivative);
      alpha[n-1] = 3 * (lastDerivative - (y[n-1] - y[n-2]) / h[n-2]);
      
      for (let i = 1; i < n - 1; i++) {
        alpha[i] = (3 / h[i]) * (y[i + 1] - y[i]) - (3 / h[i - 1]) * (y[i] - y[i - 1]);
      }
      
      // Step 3: Solve tridiagonal system with clamped conditions
      l[0] = 2 * h[0];
      mu[0] = 0.5;
      z[0] = alpha[0] / l[0];
      
      for (let i = 1; i < n - 1; i++) {
        l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
        mu[i] = h[i] / l[i];
        z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
      }
      
      l[n - 1] = h[n - 2] * (2 - mu[n - 2]);
      z[n - 1] = (alpha[n - 1] - h[n - 2] * z[n - 2]) / l[n - 1];
      c[n - 1] = z[n - 1];
      
      // Step 4: Back substitution
      for (let j = n - 2; j >= 0; j--) {
        c[j] = z[j] - mu[j] * c[j + 1];
        b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
        d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
      }
      
      // Return interpolation function
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Evaluate cubic polynomial - clamped cubic spline interpolation
        const dt = t - x[i];
        return y[i] + b[i] * dt + c[i] * dt * dt + d[i] * dt * dt * dt;
      };
    }

    /**
     * Catmull-Rom spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCatmullRomSpline(x, y, tension = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Get the four control points (with boundary handling)
        const p0 = y[Math.max(0, i - 1)];
        const p1 = y[i];
        const p2 = y[Math.min(n - 1, i + 1)];
        const p3 = y[Math.min(n - 1, i + 2)];
        
        // Normalize t to 0-1 within the segment
        const t_norm = (t - x[i]) / (x[i + 1] - x[i]);
        const t2 = t_norm * t_norm;
        const t3 = t2 * t_norm;
        
        // Parameterized Catmull-Rom basis functions with tension control
        // tension = 0.0: very tight (close to linear)
        // tension = 0.5: standard Catmull-Rom
        // tension = 1.0: very loose/curvy
        const q0 = -tension * t3 + 2 * tension * t2 - tension * t_norm;
        const q1 = (2 - tension) * t3 + (tension - 3) * t2 + 1;
        const q2 = (tension - 2) * t3 + (3 - 2 * tension) * t2 + tension * t_norm;
        const q3 = tension * t3 - tension * t2;
        
        // Catmull-Rom interpolation with adjustable tension
        return p0 * q0 + p1 * q1 + p2 * q2 + p3 * q3;
      };
    }

    

    /**
     * PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) - Monotonic cubic spline
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createPCHIPSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate slopes (derivatives) at each point
      const slopes = new Array(n);
      const h = new Array(n - 1);
      const delta = new Array(n - 1);
      
      // Calculate intervals and finite differences
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
        delta[i] = (y[i + 1] - y[i]) / h[i];
      }
      
      // Calculate slopes using PCHIP method
      slopes[0] = delta[0]; // First point - use forward difference
      slopes[n - 1] = delta[n - 2]; // Last point - use backward difference
      
      for (let i = 1; i < n - 1; i++) {
        // Interior points - use monotonic slope calculation
        if (delta[i - 1] * delta[i] <= 0) {
          // Data changes direction - use zero slope to avoid overshooting
          slopes[i] = 0;
        } else {
          // Data is monotonic - use weighted harmonic mean for smooth monotonic interpolation
          const w1 = 2 * h[i] + h[i - 1];
          const w2 = h[i] + 2 * h[i - 1];
          slopes[i] = (w1 + w2) / (w1 / delta[i - 1] + w2 / delta[i]);
        }
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Normalize t within the interval
        const dt = t - x[i];
        const h_i = h[i];
        const t_norm = dt / h_i;
        
        // Hermite basis functions
        const h00 = 2 * t_norm * t_norm * t_norm - 3 * t_norm * t_norm + 1;
        const h10 = t_norm * t_norm * t_norm - 2 * t_norm * t_norm + t_norm;
        const h01 = -2 * t_norm * t_norm * t_norm + 3 * t_norm * t_norm;
        const h11 = t_norm * t_norm * t_norm - t_norm * t_norm;
        
        // PCHIP interpolation formula
        return y[i] * h00 + h_i * slopes[i] * h10 + y[i + 1] * h01 + h_i * slopes[i + 1] * h11;
      };
    }

    /**
     * Curve simplification algorithms for data point reduction
     */
    const CurveSimplification = {
      /**
       * Uniform sampling reduction - reduces points while maintaining even distribution
       * @param {number[]} samples - Original sample array
       * @param {number} reductionPercent - Percentage of points to remove (0-90)
       * @returns {number[]} Reduced sample array
       */
      uniformSampling: function(samples, reductionPercent) {
        if (reductionPercent === 0 || samples.length <= 3) return samples;
        
        const keepRatio = 1.0 - (reductionPercent / 100);
        const targetCount = Math.max(3, Math.round(samples.length * keepRatio));
        const step = (samples.length - 1) / (targetCount - 1);
        
      if (DEBUG_LOGS) console.log(`🔍 Uniform Sampling DEBUG:`, {
          originalPoints: samples.length,
          reductionPercent: reductionPercent,
          keepRatio: keepRatio,
          targetCount: targetCount,
          step: step
        });
        
        const reducedSamples = [];
        for (let i = 0; i < targetCount; i++) {
          const index = Math.round(i * step);
          reducedSamples.push(samples[index]);
        }
        
      if (DEBUG_LOGS) console.log(`✅ Uniform Sampling Result: ${samples.length} → ${reducedSamples.length} points`);
        return reducedSamples;
      },
      

      /**
       * Smoothing splines data reduction with automatic lambda selection
       * @param {number[]} samples - Original sample array
       * @param {number} reductionPercent - Percentage of points to remove (0-90)
       * @returns {number[]} Smoothed and reduced sample array
       */
      smoothingSplines: function(samples, reductionPercent) {
        if (reductionPercent === 0 || samples.length <= 3) return samples;
        
        const n = samples.length;
        const keepRatio = 1.0 - (reductionPercent / 100);
        const targetCount = Math.max(3, Math.round(n * keepRatio));
        
        // Create input points (x values are indices normalized to 0-1)
        const x = [];
        const y = [];
        for (let i = 0; i < n; i++) {
          x.push(i / (n - 1));
          y.push(samples[i]);
        }
        
        // Calculate smoothing parameter lambda based on reduction percentage
        // Higher reduction = more smoothing
        const dataRange = Math.max(...y) - Math.min(...y);
        const lambda = Math.pow(reductionPercent / 100, 2) * dataRange * 0.1;
        
      if (DEBUG_LOGS) console.log(`🔍 Smoothing Splines DEBUG:`, {
          originalPoints: samples.length,
          reductionPercent: reductionPercent,
          keepRatio: keepRatio,
          targetCount: targetCount,
          dataRange: dataRange,
          lambda: lambda
        });
        
        // Build smoothing spline system
        const splineCoefficients = this._buildSmoothingSpline(x, y, lambda);
        
        // Sample the smooth spline at target points
        const reducedSamples = [];
        for (let i = 0; i < targetCount; i++) {
          const t = i / (targetCount - 1);
          const value = this._evaluateSmoothingSpline(splineCoefficients, x, y, t);
          reducedSamples.push(value);
        }
        
      if (DEBUG_LOGS) console.log(`✅ Smoothing Splines Result: ${samples.length} → ${reducedSamples.length} points`);
        return reducedSamples;
      },

      /**
       * Build smoothing spline coefficients using penalized least squares
       * @private
       */
      _buildSmoothingSpline: function(x, y, lambda) {
        const n = x.length;
        if (n < 4) return { x, y, c: new Array(n).fill(0) };
        
        // For simplicity, use natural cubic spline with roughness penalty
        // This is a simplified implementation focused on data reduction
        const h = [];
        for (let i = 0; i < n - 1; i++) {
          h[i] = x[i + 1] - x[i];
        }
        
        // Build tridiagonal system for natural spline with smoothing
        const A = new Array(n).fill(null).map(() => new Array(n).fill(0));
        const b = new Array(n).fill(0);
        
        // Natural spline boundary conditions with smoothing penalty
        A[0][0] = 1 + lambda;
        A[n-1][n-1] = 1 + lambda;
        b[0] = y[0];
        b[n-1] = y[n-1];
        
        // Interior equations with roughness penalty
        for (let i = 1; i < n - 1; i++) {
          const hi_1 = h[i-1];
          const hi = h[i];
          
          // Data fidelity term
          A[i][i] = 1;
          b[i] = y[i];
          
          // Add smoothing penalty (simplified second derivative penalty)
          if (lambda > 0) {
            A[i][i] += lambda * (2 / (hi_1 + hi));
            if (i > 1) A[i][i-1] = -lambda / (hi_1 + hi);
            if (i < n - 2) A[i][i+1] = -lambda / (hi_1 + hi);
          }
        }
        
        // Solve system using Gaussian elimination
        const c = this._solveTridiagonal(A, b);
        
        return { x, y, c };
      },

      /**
       * Evaluate smoothing spline at parameter t
       * @private
       */
      _evaluateSmoothingSpline: function(spline, x, y, t) {
        const { x: sx, y: sy, c } = spline;
        const n = sx.length;
        
        // Clamp t to valid range
        t = Math.max(0, Math.min(1, t));
        
        // Find interval
        let i = 0;
        while (i < n - 1 && sx[i + 1] < t) i++;
        if (i >= n - 1) return sy[n - 1];
        
        // Linear interpolation with spline smoothing
        const h = sx[i + 1] - sx[i];
        const dt = t - sx[i];
        const ratio = h > 0 ? dt / h : 0;
        
        // Hermite interpolation with smoothing coefficient
        const y0 = sy[i];
        const y1 = sy[i + 1];
        const c0 = c[i];
        const c1 = c[i + 1];
        
        // Cubic Hermite interpolation
        const t2 = ratio * ratio;
        const t3 = t2 * ratio;
        
        const h00 = 2*t3 - 3*t2 + 1;  // (1+2t)(1-t)^2
        const h10 = t3 - 2*t2 + ratio; // t(1-t)^2
        const h01 = -2*t3 + 3*t2;      // t^2(3-2t)
        const h11 = t3 - t2;           // t^2(t-1)
        
        return h00 * y0 + h10 * h * c0 + h01 * y1 + h11 * h * c1;
      },

      /**
       * Solve tridiagonal system using simplified Gaussian elimination
       * @private
       */
      _solveTridiagonal: function(A, b) {
        const n = A.length;
        const x = new Array(n).fill(0);
        
        // Simple Gaussian elimination for small systems
        // Forward elimination
        for (let i = 0; i < n - 1; i++) {
          for (let j = i + 1; j < n; j++) {
            if (Math.abs(A[i][i]) < 1e-12) continue;
            const factor = A[j][i] / A[i][i];
            for (let k = i; k < n; k++) {
              A[j][k] -= factor * A[i][k];
            }
            b[j] -= factor * b[i];
          }
        }
        
        // Back substitution
        for (let i = n - 1; i >= 0; i--) {
          x[i] = b[i];
          for (let j = i + 1; j < n; j++) {
            x[i] -= A[i][j] * x[j];
          }
          if (Math.abs(A[i][i]) > 1e-12) {
            x[i] /= A[i][i];
          }
        }
        
        return x;
      },


      /**
       * Apply smoothing reduction using current algorithm
       * @param {number[]} samples - Original sample array
       * @param {number} reductionPercent - Percentage of points to remove (0-90)
       * @param {string} algorithm - 'uniform' or 'smoothing-splines'
       * @returns {number[]} Reduced sample array
       */
      applySmoothingReduction: function(samples, reductionPercent, algorithm = 'smoothing-splines') {
        if (reductionPercent === 0) return samples;
        
        switch (algorithm) {
          case 'smoothing-splines':
            return this.smoothingSplines(samples, reductionPercent);
          case 'uniform':
            return this.uniformSampling(samples, reductionPercent);
          default:
            return this.smoothingSplines(samples, reductionPercent);
        }
      }
    };

    /**
     * Determine the appropriate interpolation type for global linearization
     * @param {Object} linearizationData - The linearization data object
     * @param {string} selectedInterpolationType - User's selected interpolation method
     * @returns {string} Appropriate interpolation type ('linear' or selectedInterpolationType)
     */
    function getGlobalLinearizationInterpolationType(linearizationData, selectedInterpolationType) {
      // If no linearization data, use selected method
      if (!linearizationData) return selectedInterpolationType;
      
      const filename = linearizationData.filename || '';
      const format = linearizationData.format || '';
      
      // Check if data comes from Smart-generated curves (already smooth)
      const hasAICurves = window.loadedQuadData && window.loadedQuadData.curves;
      const hasMultipleAICurves = hasAICurves && Object.keys(window.loadedQuadData.curves).length > 1;
      
      // If multiple Smart Curves exist, use linear to avoid double-smoothing
      if (hasMultipleAICurves) {
      if (DEBUG_LOGS) console.log('DEBUG: Using linear for global linearization (Smart Curves detected)');
        return 'linear';
      }
      
      // Check for measurement data (needs proper smoothing)
      const isMeasurementData = filename.includes('LAB') || 
                               filename.includes('Color Muse') || 
                               filename.includes('Manual-L') || 
                               filename.includes('Sample Data');
      
      if (isMeasurementData) {
      if (DEBUG_LOGS) console.log('DEBUG: Using selected method for global linearization (measurement data detected)');
        return selectedInterpolationType; // Use user's choice (PCHIP/Linear)
      }
      
      // For pre-processed data (.cube, .acv), use selected method
      const isPreprocessed = format === '1DLUT' || format === 'ACV' || filename.includes('.cube');
      if (isPreprocessed) {
      if (DEBUG_LOGS) console.log('DEBUG: Using selected method for global linearization (preprocessed data detected)');
        return selectedInterpolationType;
      }
      
      // Default fallback: use selected method
      if (DEBUG_LOGS) console.log('DEBUG: Using selected method for global linearization (fallback)');
      return selectedInterpolationType;
    }

    /**
     * Apply a LUT to a list of integers using linear, cubic spline, Catmull-Rom, Bezier, or PCHIP interpolation.
     * Preserves the endpoint values - always starts at 0 and ends at the original max value.
     * @param {number[]} values - input integers in [0..maxValue]
     * @param {number[]} lut - samples (floats), typically 0..1
     * @param {number} domainMin - LUT input domain min (typically 0)
     * @param {number} domainMax - LUT input domain max (typically 1)
     * @param {number} maxValue - the maximum value from the original linear ramp
     * @param {string} interpolationType - 'cubic', 'catmull', or 'linear'
     * @returns {number[]} adjusted integer outputs with preserved endpoints
     */
    function apply1DLUT(values, lutOrData, domainMin = 0, domainMax = 1, maxValue = 64000, interpolationType = 'cubic', smoothingPercent = 0) {
      // Handle both direct samples array and linearization data object
      let processedLUT, lutX, needsDualTransformation = false;
      
      if (DEBUG_LOGS) console.log(`🔍 apply1DLUT DEBUG:`, {
        lutOrDataType: typeof lutOrData,
        isArray: Array.isArray(lutOrData),
        hasGetSmoothingMethod: lutOrData && typeof lutOrData === 'object' && !!lutOrData.getSmoothingControlPoints,
        lutOrDataKeys: lutOrData && typeof lutOrData === 'object' ? Object.keys(lutOrData) : 'N/A',
        samplesLength: Array.isArray(lutOrData) ? lutOrData.length : (lutOrData?.samples?.length || 'N/A'),
        smoothingPercent: smoothingPercent
      });
      
      if (Array.isArray(lutOrData)) {
        // Direct samples array
        if (smoothingPercent > 0) {
          // Apply smoothing using current algorithm
          const simplificationMethod = getSelectedSimplificationMethod();
          processedLUT = CurveSimplification.applySmoothingReduction(lutOrData, smoothingPercent, simplificationMethod);
          const K = processedLUT.length;
          lutX = new Array(K);
          for (let i = 0; i < K; i++) {
            lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
          }
        } else {
          processedLUT = lutOrData;
          const K = processedLUT.length;
          lutX = new Array(K);
          for (let i = 0; i < K; i++) {
            lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
          }
        }
      } else if (lutOrData && typeof lutOrData === 'object' && lutOrData.getSmoothingControlPoints) {
        // Linearization data object with smoothing method
        const controlPoints = lutOrData.getSmoothingControlPoints(smoothingPercent);
        if (controlPoints) {
          // Use sparse control points for interpolation
          processedLUT = controlPoints.samples;
          lutX = controlPoints.xCoords;
          needsDualTransformation = controlPoints.needsDualTransformation || false;
        } else {
          // Use original full-resolution samples (no smoothing)
          processedLUT = lutOrData.originalSamples || lutOrData.samples;
          const K = processedLUT.length;
          lutX = new Array(K);
          for (let i = 0; i < K; i++) {
            lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
          }
        }
      } else if (lutOrData && lutOrData.samples) {
        // Linearization data object without smoothing method
        processedLUT = smoothingPercent > 0 ? CurveSimplification.applySmoothingReduction(lutOrData.samples, smoothingPercent, getSelectedSimplificationMethod()) : lutOrData.samples;
        const K = processedLUT.length;
        lutX = new Array(K);
        for (let i = 0; i < K; i++) {
          lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
        }
      } else {
        // Fallback
        processedLUT = lutOrData;
        const K = processedLUT.length;
        lutX = new Array(K);
        for (let i = 0; i < K; i++) {
          lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
        }
      }
      
      const K = processedLUT.length;
      if (K < 2) return values; // Not enough points for interpolation
      
      // Ensure LUT starts at 0 and we know the end value
      const lutStart = processedLUT[0];
      const lutEnd = processedLUT[K - 1];
      
      let interpolationFunction;
      
      if (interpolationType === 'cubic') {
        // Cubic spline interpolation for smoothest curves - pure interpolation
        interpolationFunction = createCubicSpline(lutX, processedLUT);
      } else if (interpolationType === 'catmull') {
        // Catmull-Rom spline interpolation - passes through control points like GIMP
        const tension = elements.catmullTension.value / 100; // Convert 0-100 to 0-1
        interpolationFunction = createCatmullRomSpline(lutX, processedLUT, tension);
      } else if (interpolationType === 'pchip') {
        // PCHIP interpolation for monotonic, shape-preserving curves
        interpolationFunction = createPCHIPSpline(lutX, processedLUT);
      } else {
        // Linear interpolation for exact point-to-point behavior
        interpolationFunction = (t) => {
          // Handle edge cases
          if (t <= lutX[0]) return processedLUT[0];
          if (t >= lutX[K - 1]) return processedLUT[K - 1];
          
          // Find the correct interval in the potentially non-evenly spaced lutX array
          let i0 = 0;
          for (let i = 0; i < K - 1; i++) {
            if (t >= lutX[i] && t <= lutX[i + 1]) {
              i0 = i;
              break;
            }
          }
          
          const i1 = Math.min(i0 + 1, K - 1);
          const x0 = lutX[i0];
          const x1 = lutX[i1];
          const y0 = processedLUT[i0];
          const y1 = processedLUT[i1];
          
          // Linear interpolation between the two points
          if (x1 === x0) return y0; // Avoid division by zero
          const a = (t - x0) / (x1 - x0);
          return (1 - a) * y0 + a * y1;
        };
      }
      
      const result = values.map((v, index) => {
        // Forward mapping implementation: Input value → LUT output transformation
        const t = (v / maxValue) * (domainMax - domainMin) + domainMin;
        const lutValue = interpolationFunction(t);
        
        // Scale LUT value directly to maxValue range
        return Math.round(clamp01(lutValue) * maxValue);
      });
      
      // Apply dual transformation if needed (for LAB data with smoothing)
      if (needsDualTransformation) {
        // Convert result back to 0-1 range for transformation
        const normalizedResult = result.map(val => val / maxValue);
        
        // Apply same dual transformation as parseLabData (horizontal + vertical)
        const flippedSamples = normalizedResult.map((sample, i) => {
          const inputPos = i / (normalizedResult.length - 1); // Current input position (0-1)
          const flippedInputPos = 1.0 - inputPos; // Horizontal flip
          const flippedInputIndex = Math.round(flippedInputPos * (normalizedResult.length - 1)); // Convert back to index
          const clampedIndex = Math.max(0, Math.min(normalizedResult.length - 1, flippedInputIndex));
          const originalSample = normalizedResult[clampedIndex];
          const verticallyFlipped = 1.0 - originalSample; // Vertical flip
          return verticallyFlipped;
        });
        
        // Convert back to original scale
        return flippedSamples.map(val => Math.round(clamp01(val) * maxValue));
      }
      
      return result;
    }

    const debouncedPreviewUpdate = debounce(updatePreview, 300);

    // Optimized 256 value generation with optional linearization
    function make256(endValue, channelName, applyLinearization = false) {
      if (endValue === 0) return new Array(N).fill(0);
      
      if (DEBUG_LOGS) console.log('DEBUG: make256() called:', {
        endValue,
        channelName,
        applyLinearization,
        hasGlobalLinearizationData: !!linearizationData,
        globalLinearizationApplied: linearizationApplied,
        hasPerChannelLinearization: !!perChannelLinearization[channelName]
      });
      
      let arr;
      
      // Step 1: Start with base curve (loaded data or linear ramp)
      if (window.loadedQuadData && window.loadedQuadData.curves && window.loadedQuadData.curves[channelName]) {
        const loadedCurve = window.loadedQuadData.curves[channelName];

        if (Math.max(...loadedCurve) === 0) {
          return new Array(N).fill(0); // Handle edge case
        }

        // Distinguish Smart-generated curves vs. file-loaded .quad curves
        let isAICurve = isSmartCurve(channelName);
        // Fallback detection: if sources missing but curve looks like Smart (max≈TOTAL) and baseline exists,
        // treat as Smart to avoid mis-scaling to 100% after redo.
        if (!isAICurve) {
          try {
            const curveMax = Math.max(...loadedCurve);
            const baseline = window.loadedQuadData?.baselineEnd?.[channelName];
            if (curveMax >= TOTAL * 0.99 && typeof baseline === 'number' && baseline > 0) {
              isAICurve = true;
            }
          } catch {}
        }
        if (isAICurve) {
          // Scale Smart-generated curves to respect current endValue (ink limit)
          const scale = endValue / TOTAL;
          arr = loadedCurve.map(v => Math.round(v * scale));
        } else {
          // For file-loaded .quad curves, scale uniformly relative to the loaded baseline ink limit
          const baseline = (window.loadedQuadData.baselineEnd && window.loadedQuadData.baselineEnd[channelName])
            ? window.loadedQuadData.baselineEnd[channelName]
            : Math.max(...loadedCurve);
          const scale = baseline > 0 ? (endValue / baseline) : 0;
          arr = loadedCurve.map(v => Math.round(v * scale));
        }
      } else {
        // Generate linear ramp as base
        if (DEBUG_LOGS) console.log('make256 using linear ramp for', channelName, 'loadedQuadData available:', !!window.loadedQuadData, 'curves:', !!window.loadedQuadData?.curves);
        arr = new Array(N);
        const step = endValue / DENOM;
        
        for (let i = 0; i < N; i++) {
          arr[i] = Math.round(i * step);
        }
      }
      
      const interpolationType = elements.curveSmoothingMethod.value;
      const smoothingPercent = parseFloat(elements.smoothingSlider.value) || 0;
      
      // Step 2: Apply per-channel linearization on top of base curve
      if (channelName && perChannelLinearization[channelName] && perChannelEnabled[channelName]) {
        arr = apply1DLUT(arr, perChannelLinearization[channelName], perChannelLinearization[channelName].domainMin, perChannelLinearization[channelName].domainMax, endValue, interpolationType, smoothingPercent);
      }
      
      // Step 3: Apply global linearization on top of everything (skip when channel has a Smart Curve)
      const isAICurve = isSmartCurve(channelName);
      if (applyLinearization && linearizationData && linearizationApplied && !isAICurve) {
          if (DEBUG_LOGS) console.log('DEBUG: Applying global linearization in make256:', {
          linearizationDataStructure: {
            hasSamples: !!linearizationData.samples,
            samplesCount: linearizationData.samples?.length || 0,
            domainMin: linearizationData.domainMin,
            domainMax: linearizationData.domainMax,
            firstFewSamples: linearizationData.samples?.slice(0, 5) || []
          },
          arrBefore: arr.slice(0, 10).concat(['...'], arr.slice(-5)),
          arrMin: Math.min(...arr),
          arrMax: Math.max(...arr)
        });
        
        // Intelligently choose interpolation method based on data source
        const globalInterpolationType = getGlobalLinearizationInterpolationType(linearizationData, interpolationType);
        arr = apply1DLUT(arr, linearizationData, linearizationData.domainMin, linearizationData.domainMax, endValue, globalInterpolationType, smoothingPercent);
        
        if (DEBUG_LOGS) console.log('DEBUG: After applying global linearization:', {
          arrAfter: arr.slice(0, 10).concat(['...'], arr.slice(-5)),
          arrMin: Math.min(...arr),
          arrMax: Math.max(...arr),
          hasNaN: arr.some(v => isNaN(v)),
          hasInfinity: arr.some(v => !isFinite(v))
        });
      }
      
      return arr;
    }

    

    // Extract channel row creation
    function createChannelRow(name, printerKey) {
      // Set default values based on printer and channel
      let defaultPercent = 0; // Default to disabled
      let channelEnabled = false; // Default to disabled

      // Preferred default channel selection: prefer MK if available, otherwise K
      const cfg = PRINTERS[printerKey] || { channels: [] };
      const hasMK = Array.isArray(cfg.channels) && cfg.channels.includes('MK');
      const preferredDefault = hasMK ? 'MK' : 'K';
      if (name === preferredDefault) {
        defaultPercent = 100;
        channelEnabled = true;
      }
      
      const defaultEndValue = InputValidator.computeEndFromPercent(defaultPercent);
      
      const tr = document.createElement('tr');
      tr.className = "border-t border-gray-200 channel-row";
      tr.setAttribute('data-channel', name);
      tr.innerHTML = `
        <td class=\"px-1 pt-2 pb-1 text-center\">
        </td>
        <td class=\"px-1 pt-2 pb-1 font-medium align-middle text-left\">
          <span class=\"flex items-center gap-2 w-full\">
            <span class=\"inline-block w-3.5 h-3.5 rounded-sm border border-black/10 flex-shrink-0\" style=\"background-color: ${INK_COLORS[name] || '#000'}\"></span>
            <span class=\"w-8 channel-name\">${name}</span>
            <span class=\"text-xs text-gray-500 invisible\" data-disabled>(disabled)</span>
            <span class=\"text-sm text-blue-600 ml-2\" title=\"Processing details\">ⓘ</span>
            <span class=\"processing-label italic font-normal text-xs text-gray-600 ml-2 flex-1 min-w-0\" data-channel=\"${name}\" style=\"white-space: pre-wrap; word-break: break-word;\"></span>
          </span>
        </td>
        <td class="px-1 pt-2 pb-1">
          <div class="inline-flex items-center gap-2">
            <input type="file" id="perChannel_${name}" accept=".cube,.txt,.acv" class="hidden per-channel-file">
            <button class="per-channel-btn px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded transition-colors font-bold" data-channel="${name}" data-tooltip="Load LUT.cube, LABdata.txt, or .acv curve files">load file</button>
            <label class="slider-toggle" title="Enable/disable per-channel linearization">
              <input type="checkbox" class="per-channel-toggle" data-channel="${name}" disabled>
              <span class="slider"></span>
            </label>
          </div>
        </td>
        <td class="px-1 pt-2 pb-1">
          <input type="number" step="1" min="0" max="100" value="${defaultPercent}" class="percent-input w-20 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
        <td class="px-1 pt-2 pb-1">
          <input type="number" step="1" min="0" max="64000" value="${defaultEndValue}" class="end-input w-20 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
      `;
      
      return tr;
    }

    function setupChannelRow(tr) {
      const percentInput = tr.querySelector('.percent-input');
      const endInput = tr.querySelector('.end-input');
      const disabledTag = tr.querySelector('[data-disabled]');
      // Create virtual checkbox object since physical checkbox is removed
      // Chips section now handles enable/disable, but we need compatibility with existing logic
      const enableCheckbox = {
        checked: !tr.hasAttribute('data-user-disabled'),
        addEventListener: function(event, handler) {
          // Store the handler for later use by chips
          tr._checkboxChangeHandler = handler;
        },
        dispatchEvent: function(event) {
          if (tr._checkboxChangeHandler && event.type === 'change') {
            tr._checkboxChangeHandler();
          }
        }
      };
      // Store virtual checkbox on tr for chips access
      tr._virtualCheckbox = enableCheckbox;
      const perChannelBtn = tr.querySelector('.per-channel-btn');
      const perChannelFile = tr.querySelector('.per-channel-file');
      const perChannelToggle = tr.querySelector('.per-channel-toggle');
      const channelName = tr.dataset.channel;

      function refreshDisplay() {
        const endVal = InputValidator.clampEnd(endInput.value);
        endInput.value = String(endVal);
        
        const isUserDisabled = tr.hasAttribute('data-user-disabled');
        const isAtZero = endVal === 0;
        const percentValue = InputValidator.clampPercent(percentInput.value);
        
        // Show disabled label if channel is at 0 (either user-disabled or set to 0%)
        disabledTag.classList.toggle('invisible', !isAtZero);
        
        // Handle ultra-compact layout for disabled channels
        if (isAtZero) {
          // Hide from main table and show in compact view
          tr.setAttribute('data-compact', 'true');
          updateCompactChannelsList();
        } else {
          // Show in main table and remove from compact view
          tr.setAttribute('data-compact', 'false');
          updateCompactChannelsList();
          
          // Update normal table row styling for enabled channels
          const channelLabel = tr.querySelector('td:nth-child(2) span');
          channelLabel.style.opacity = '1';
          
          // Restore all visual states for enabled channels
          const linearizationCell = tr.querySelector('td:nth-child(3)');
          const percentCell = tr.querySelector('td:nth-child(4)');
          const endCell = tr.querySelector('td:nth-child(5)');
          
          linearizationCell.style.visibility = 'visible';
          percentCell.style.opacity = '1';
          endCell.style.opacity = '1';
        }
        
        // Update checkbox state based on channel status
        enableCheckbox.checked = !isAtZero;
      }
      
      // Store refreshDisplay function on the tr element for access from apply functions
      tr.refreshDisplayFn = refreshDisplay;

      // Initial refresh to set up display state
      refreshDisplay();

      // Channel enable/disable checkbox functionality
      const handleCheckboxChange = () => {
        const currentEndVal = InputValidator.clampEnd(endInput.value);
        const currentPercentVal = InputValidator.clampPercent(percentInput.value);
        const channelName = tr.dataset.channel;
        
        
        // Record the individual channel action only if not during batch operation
        if (!CurveHistory.isBatchOperation) {
          const actionType = enableCheckbox.checked ? 'enable' : 'disable';
          const oldValue = !enableCheckbox.checked; // Previous state (opposite of current)
          const newValue = enableCheckbox.checked;   // Current state
          CurveHistory.recordChannelAction(channelName, actionType, oldValue, newValue);
        }
        
        if (enableCheckbox.checked) {
          // Enable: restore previous values or default to 100%
          const previousValues = channelPreviousValues[channelName];
          
          if (previousValues && previousValues.percent > 0) {
            // Restore previous values
            percentInput.value = previousValues.percent.toString();
            endInput.value = previousValues.endValue.toString();
            showStatus(`Enabled ${channelName} (restored to ${previousValues.percent}%)`);
          } else {
            // Default to 100% if no previous value stored
            percentInput.value = '100';
            endInput.value = String(InputValidator.computeEndFromPercent(100));
            showStatus(`Enabled ${channelName} (set to default 100%)`);
          }
          
          tr.removeAttribute('data-user-disabled'); // Mark as not disabled by user
        } else {
          // Disable: store current values first, then set to 0
          channelPreviousValues[channelName] = {
            percent: currentPercentVal,
            endValue: currentEndVal
          };
          
          percentInput.value = '0';
          endInput.value = '0';
          tr.setAttribute('data-user-disabled', 'true'); // Mark as disabled by user
          showStatus(`Disabled ${channelName} (saved ${currentPercentVal}% for restore)`);
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
        try { if (elements.rows) elements.rows.dispatchEvent(new Event('channelsChanged', { bubbles: true })); } catch {}
      };
      
      enableCheckbox.addEventListener('change', handleCheckboxChange);

      // Track input changes with debounced action recording
      let percentHistoryTimeout = null;
      let endHistoryTimeout = null;
      let oldPercentValue = percentInput.value; // Store initial value
      let oldEndValue = endInput.value; // Store initial value
      
      const debouncedPercentActionRecord = (newValue) => {
        clearTimeout(percentHistoryTimeout);
        percentHistoryTimeout = setTimeout(() => {
          // Only record if the value actually changed and not during batch operation
          if (oldPercentValue !== newValue && !CurveHistory.isBatchOperation) {
            CurveHistory.recordChannelAction(channelName, 'percentage', oldPercentValue, newValue);
            oldPercentValue = newValue; // Update for next change
            // Also announce the change to the user
            const pct = parseFloat(newValue);
            if (!isNaN(pct)) {
              showStatus(`${channelName} ink limit changed to ${pct.toFixed(1)}%`);
            }
          }
        }, 1000); // Record action 1 second after user stops typing
      };
      
      const debouncedEndActionRecord = (newValue) => {
        clearTimeout(endHistoryTimeout);
        endHistoryTimeout = setTimeout(() => {
          // Only record if the value actually changed and not during batch operation
          if (oldEndValue !== newValue && !CurveHistory.isBatchOperation) {
            CurveHistory.recordChannelAction(channelName, 'end', oldEndValue, newValue);
            oldEndValue = newValue; // Update for next change
            // Also announce the change to the user (convert end ⇒ percent)
            const e = parseInt(newValue, 10);
            if (!isNaN(e)) {
              const pct = InputValidator.computePercentFromEnd(e);
              showStatus(`${channelName} ink limit changed to ${pct.toFixed(1)}%`);
            }
          }
        }, 1000); // Record action 1 second after user stops typing
      };

      // Use debounced updates to prevent excessive recalculations
      percentInput.addEventListener('input', () => {
        const newValue = percentInput.value;
        debouncedPercentActionRecord(newValue); // Record action after typing stops
        
        const p = InputValidator.validateInput(percentInput, InputValidator.clampPercent);
        const endVal = InputValidator.computeEndFromPercent(p);
        endInput.value = String(endVal);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (endVal > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (endVal > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: endVal
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      endInput.addEventListener('input', () => {
        const newValue = endInput.value;
        debouncedEndActionRecord(newValue); // Record action after typing stops
        
        const e = InputValidator.validateInput(endInput, InputValidator.clampEnd);
        const p = InputValidator.computePercentFromEnd(e);
        percentInput.value = p.toFixed(1);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (e > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (e > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: e
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      // Per-channel linearization button
      perChannelBtn.addEventListener('click', () => {
        perChannelFile.click();
      });
      
      // Per-channel file upload
      perChannelFile.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
          // Per-channel supports curves (.cube), LAB data (.txt), and Photoshop curves (.acv)
          const extension = file.name.toLowerCase().split('.').pop();
          let fileInput;
          if (extension === 'acv') {
            fileInput = await file.arrayBuffer();
          } else {
            fileInput = await file.text();
          }
          const parsed = await parseLinearizationFile(fileInput, file.name);
          // For EDN-style (.cube/.acv), store base samples and compute effective Positive mapping (reverse + invert)
          const isEDNStyle = ['cube','acv'].includes(extension);
          if (isEDNStyle && Array.isArray(parsed.samples)) {
            parsed._baseSamples = parsed.samples.slice();
            const eff = parsed._baseSamples.slice().reverse().map(v => 1 - v);
            parsed.samples = eff;
          }
          parsed.edited = false;
          perChannelLinearization[channelName] = parsed;
          perChannelEnabled[channelName] = true;
          perChannelFilenames[channelName] = file.name;
          
          // Enable and check toggle
          perChannelToggle.disabled = false;
          perChannelToggle.checked = true;
          
          // Update button tooltip with filename (respect edited flag)
          refreshPerChannelLinearizationDisplay(channelName);
          
          // Note: No auto-smoothing; base samples come from the chosen source. Smoothing is optional via slider.
          
          // Update interpolation controls since we now have linearization data
          updateInterpolationControls();
          
          // Show appropriate status message based on LUT type
          if (parsed.is3DLUT) {
            showStatus(`Loaded 3D LUT and extracted ${parsed.samples.length} neutral axis points for ${channelName} (${parsed.lutSize}³ grid)`);
          } else {
          showStatus(`Loaded per-channel correction for ${channelName}: ${parsed.samples.length} points`);
          }
          debouncedPreviewUpdate();
          // No intent mismatch warning (Positive-only workflow)
          
          // Update processing detail for this channel
          updateProcessingDetail(channelName);
        } catch (error) {
          console.error('Per-channel linearization file error:', error);
          showStatus(`Error loading ${channelName} linearization: ${error.message}`);
          
          // Reset state on error
          delete perChannelLinearization[channelName];
          delete perChannelFilenames[channelName];
          perChannelEnabled[channelName] = false;
          perChannelToggle.disabled = true;
          perChannelToggle.checked = false;
          
          // Reset button tooltip
          perChannelBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
          
          // Update interpolation controls since linearization may no longer be available
          updateInterpolationControls();
        }
      });
      
      // Per-channel toggle slider
      perChannelToggle.addEventListener('change', (e) => {
        if (perChannelLinearization[channelName]) {
          perChannelEnabled[channelName] = e.target.checked;
          if (perChannelEnabled[channelName]) {
            showStatus(`Enabled per-channel linearization for ${channelName}`);
          } else {
            showStatus(`Disabled per-channel linearization for ${channelName}`);
          }
          
          // Update filename to reflect current state
          updateFilename();
          
          // Update processing detail for this channel
          updateProcessingDetail(channelName);
          
          debouncedPreviewUpdate();
        }
      });
      
      // Initialize per-channel state
      perChannelEnabled[channelName] = false;
      
      // Initial sync
      const initialP = InputValidator.clampPercent(percentInput.value);
      percentInput.value = initialP.toString();
      endInput.value = String(InputValidator.computeEndFromPercent(initialP));
      refreshDisplay();
      // Populate the always-visible processing label
      updateProcessingDetail(channelName);
    }

    // Optimized setPrinter with DocumentFragment
    function setPrinter(key) {
      try {
        // Clear loaded quad data when switching printers (unless we're switching due to a quad load)
        if (!window.loadedQuadData || window.loadedQuadData.switchingPrinter !== true) {
          clearLoadedQuadData();
        }
        
        const p = PRINTERS[key];
        const fragment = document.createDocumentFragment();
        
        p.channels.forEach(ch => {
          const tr = createChannelRow(ch, key);
          tr.dataset.channel = ch; // Add channel name to dataset
          fragment.appendChild(tr);
        });
        
        // Clear and update DOM in one operation
        elements.rows.innerHTML = "";
        elements.rows.appendChild(fragment);
        
        // Add the no channels placeholder row with exact column structure
        const noChannelsRow = document.createElement('tr');
        noChannelsRow.id = 'noChannelsRow';
        noChannelsRow.className = 'hidden border-t border-gray-200';
        noChannelsRow.innerHTML = `
          <td class="px-1 pt-2 pb-1 text-center">
          </td>
          <td class="px-1 pt-2 pb-1 font-medium">
            <span class="inline-flex items-center gap-2 invisible">
              <span class="inline-block w-3.5 h-3.5 rounded-sm border border-black/10"></span>
              <span class="w-8 channel-name">XX</span>
              <span class="text-xs text-gray-500 invisible">(disabled)</span>
            </span>
            <div class="text-center text-gray-500 italic" style="margin-top: -24px;">No channels enabled</div>
          </td>
          <td class="px-1 pt-2 pb-1" style="width: 140px;">
            <div class="inline-flex items-center gap-2 invisible">
              <input type="file" class="hidden per-channel-file">
              <button class="px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded transition-colors font-bold">
                📁 Load
              </button>
              <span class="text-xs text-gray-500">No file</span>
            </div>
          </td>
          <td class="px-1 pt-2 pb-1">
            <input type="number" step="1" min="0" max="100" value="100" class="percent-input w-20 rounded-lg border border-gray-300 px-2 py-1 invisible" disabled>
          </td>
          <td class="px-1 pt-2 pb-1">
            <input type="number" step="1" min="0" max="64000" value="64000" class="end-input w-20 rounded-lg border border-gray-300 px-2 py-1 invisible" disabled>
          </td>
        `;
        elements.rows.appendChild(noChannelsRow);
        
        // Setup event listeners after DOM update
        Array.from(elements.rows.children).forEach(tr => {
          // Skip the placeholder row when setting up channel rows
          if (tr.id !== 'noChannelsRow') {
            setupChannelRow(tr);
          }
        });

        // Update compact channels display
        setTimeout(() => updateCompactChannelsList(), 100);

        // Repopulate Edit Curves channel dropdown to reflect new printer
        setTimeout(() => { try { edit_populateChannelSelect(); } catch {} }, 0);

        elements.channelInfo.innerHTML = "Channels: " + p.channels.map(ch => {
          const color = INK_COLORS[ch] || '#000000';
          return `<span class=\"inline-flex items-center mr-1\"><span style=\"color:${color}; margin-right:0px;\">■</span><strong>${ch}</strong></span>`;
        }).join("");
        elements.printerDescription.innerHTML = "";
        
        // Use requestAnimationFrame for smooth UI update
        requestAnimationFrame(() => {
          updatePreview();
          updateInkChart();
          updateFilename(); // Update filename when printer changes
        });
        showStatus(`Switched to ${p.name}`);
      } catch (error) {
        console.error('Error setting printer:', error);
        showStatus("Error changing printer");
      }
    }

    function buildLimitsSummary() {
      const lines = ["# Limits summary:"];
      
      Array.from(elements.rows.children).forEach((tr) => {
        // Skip the placeholder row
        if (tr.id === 'noChannelsRow') return;
        
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const e = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        const p = InputValidator.computePercentFromEnd(e);
        
        if (e === 0) {
          lines.push("#   " + name + ": disabled");
        } else {
          const isWhole = Math.abs(p - Math.round(p)) < 1e-9;
          const percentFormatted = isWhole ? String(Math.round(p)) : p.toFixed(1);
          lines.push("#   " + name + ": = " + percentFormatted + "%");
        }
      });
      
      return lines;
    }

    function buildFile() {
      const p = PRINTERS[elements.printerSelect.value];
      const lines = [
        "## QuadToneRIP " + p.channels.join(","),
        "# Printer: " + p.name,
        `# quadGEN ${APP_VERSION} by David Marsh`
      ];
      // Positive-only workflow: no Print Intent annotation
      
      // Add user notes if provided
      const userNotes = elements.userNotes.value.trim();
      if (userNotes) {
        lines.push("#");
        lines.push("# Notes:");
        // Split notes by lines and add # prefix to each non-empty line
        userNotes.split('\n').forEach(line => {
          const t = line.trim();
          lines.push(t ? ("# " + t) : "#");
        });
      }
      
      // Add linearization information
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      if (hasLinearization) {
        lines.push("#");
        lines.push("# Linearization Applied:");
        
        // Global linearization
        if (linearizationData && linearizationApplied) {
        const globalFilename = getEditedDisplayName(linearizationData.filename || "unknown file", !!linearizationData.edited);
        const globalCount = getBasePointCountLabel(linearizationData);
        lines.push(`# - Global: ${globalFilename} (${globalCount}, affects all channels)`);
          // Positive-only workflow: no intent notes
        }
        
        // Per-channel linearization
        const perChannelList = [];
        Object.keys(perChannelLinearization).forEach(channelName => {
          if (perChannelEnabled[channelName]) {
            const data = perChannelLinearization[channelName] || {};
            const baseName = perChannelFilenames[channelName] || "unknown file";
            const editedFlag = !!(perChannelLinearization[channelName] && perChannelLinearization[channelName].edited);
            const filename = getEditedDisplayName(baseName, editedFlag);
            const countLabel = getBasePointCountLabel(data);
            const measuredSuffix = data.measurementIntent ? ` (measured: ${data.measurementIntent})` : '';
            perChannelList.push(`${channelName}: ${filename} (${countLabel})${measuredSuffix}`);
          }
        });
        
        if (perChannelList.length > 0) {
          lines.push("# - Per-channel:");
          perChannelList.forEach(item => {
            lines.push(`#   ${item}`);
          });
        }
        
        // (Interpolation details removed from exported comments)
      }
      
      // Visually separate preceding sections from the limits summary
      lines.push("#");
      lines.push(...buildLimitsSummary());

      // Build channel blocks efficiently
      p.channels.forEach((ch, idx) => {
        const row = elements.rows.children[idx];
        const e = InputValidator.clampEnd(row.querySelector('.end-input').value);
        const arr = make256(e, ch, true); // Apply linearization if enabled
        lines.push("# " + ch + " curve");
        lines.push(...arr.map(String));
      });

      return lines.join("\n") + "\n";
    }

    


    // Undo button event handler
    document.getElementById('undoBtn').addEventListener('click', () => {
      const result = CurveHistory.undo();
      if (!result.success) {
        showStatus(`Undo failed: ${result.message}`);
      }
    });

    // Redo button event handler
    document.getElementById('redoBtn').addEventListener('click', () => {
      const result = CurveHistory.redo();
      if (!result.success) {
        showStatus(`Redo failed: ${result.message}`);
      }
    });

    // Download with enhanced error handling
    elements.downloadBtn.addEventListener('click', () => {
      try {
        const text = buildFile();
        const p = PRINTERS[elements.printerSelect.value];
        
        // Get custom filename or use default
        let filename;
        const customName = elements.filenameInput.value.trim();
        if (customName) {
          // Remove .quad extension if user added it, then sanitize
          const cleanName = customName.replace(/\.quad$/, '');
          const sanitizedName = sanitizeFilename(cleanName);
          
          // If sanitization removed everything, fall back to default (sanitized printer name)
          if (!sanitizedName) {
            const defaultBase = sanitizeFilename(p.name.replace(/\s+/g, '')) || 'quadGEN';
            filename = defaultBase + "_linear.quad";
            showStatus("Invalid filename, using default");
          } else {
            filename = sanitizedName + '.quad';
            
            // Show warning if filename was changed
            if (sanitizedName !== cleanName) {
              showStatus(`Filename sanitized: ${filename}`);
            }
          }
        } else {
          // Use default naming (sanitized printer name)
          const defaultBase = sanitizeFilename(p.name.replace(/\s+/g, '')) || 'quadGEN';
          filename = defaultBase + "_linear.quad";
        }
        
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus(`Downloaded ${filename}`);
      } catch (error) {
        console.error('Download error:', error);
        showStatus("Error downloading file");
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 's':
            e.preventDefault();
            elements.downloadBtn.click();
            break;
          case 'r':
            e.preventDefault();
            updatePreview();
            break;
        }
      }
    });

    // Note: No auto-smoothing. Wedgie-style inversion provides the base correction curve.
    // Optional smoothing can be applied via the slider, independent of data source.

    // Sample data loading functions
    function loadSampleData(type) {
      try {
        // Capture state before loading sample data for proper undo functionality
        CurveHistory.captureState('Before loading sample data');
        
        let correctionData;
        let filename;
        
        if (type === 'labData') {
          correctionData = parseLabData(SAMPLE_DATA.colorMuse, 'LAB-Data-sample.txt');
          // Positive-only workflow: record measurement intent as positive
          correctionData.measurementIntent = 'positive';
          filename = 'LAB-Data-sample.txt';
        } else if (type === 'cube') {
          correctionData = parseCube1D(SAMPLE_DATA.gammaCube);
          // For EDN-style sample LUT, compute effective Positive mapping (reverse + invert)
          if (Array.isArray(correctionData.samples)) {
            correctionData._baseSamples = correctionData.samples.slice();
            const eff = correctionData._baseSamples.slice().reverse().map(v => 1 - v);
            correctionData.samples = eff;
          }
          filename = 'LUT Sample Data';
        } else {
          throw new Error('Invalid sample data type');
        }
        
        // Apply the correction as global linearization
        correctionData.filename = filename;
        correctionData.edited = false;
        linearizationData = correctionData;
        linearizationApplied = true;
        
        // Update UI to show applied correction
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${filename}`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        
        // Show file info
        elements.globalLinearizationInfo.classList.remove('hidden');
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.add('hidden');
        refreshGlobalLinearizationDisplay();
        // Details: show only point count + simplified type label
        (function(){
          const ptsLabel = getBasePointCountLabel(correctionData);
          const fmtLower = String(correctionData.format || '').toLowerCase();
          let typeLabel = '';
          if (fmtLower.includes('lab')) typeLabel = 'LAB';
          else if (fmtLower === 'acv') typeLabel = 'curve';
          else if (fmtLower === '1dlut' || correctionData.is3DLUT) typeLabel = 'LUT';
          else typeLabel = (correctionData.format || '').toUpperCase();
          elements.globalLinearizationDetails.textContent = ` - ${ptsLabel} (${typeLabel})`;
        })();
        
        // Note: No auto-smoothing; base samples come from the chosen source. Smoothing is optional via slider.
        
        // Update interpolation controls
        updateInterpolationControls();
        updatePreview();
        
        // Update filename to reflect current state
        updateFilename();
        
        // Update processing details for all channels since global affects all
        const channelNames = getCurrentPrinter().channels;
        channelNames.forEach(channelName => {
          updateProcessingDetail(channelName);
        });
        
      showStatus(`Loaded sample data as a global correction: ${filename}`);
        
      } catch (error) {
        console.error('Error loading sample data:', error);
        showStatus(`Error loading sample data: ${error.message}`);
      }
    }


    // Initialize
    elements.printerSelect.addEventListener('change', (e) => setPrinter(e.target.value));
    
    // Add real-time filename validation
    elements.filenameInput.addEventListener('input', (e) => {
      const input = e.target;
      const value = input.value.trim();
      
      // Mark as user-edited if they've typed something different from auto-generated
      if (value !== generateFilename()) {
        input.dataset.userEdited = 'true';
      } else {
        delete input.dataset.userEdited;
      }
      
      if (value) {
        const cleanName = value.replace(/\.quad$/, '');
        const sanitized = sanitizeFilename(cleanName);
        const hasInvalidChars = sanitized !== cleanName;
        
        // Visual feedback for invalid characters
        input.classList.toggle('border-yellow-300', hasInvalidChars);
        input.classList.toggle('bg-yellow-50', hasInvalidChars);
        input.classList.toggle('border-gray-300', !hasInvalidChars);
        input.classList.toggle('bg-white', !hasInvalidChars);
        
        if (hasInvalidChars) {
          input.title = `Will be saved as: ${sanitized}.quad`;
        } else {
          input.title = '';
        }
      } else {
        input.classList.remove('border-yellow-300', 'bg-yellow-50');
        input.classList.add('border-gray-300', 'bg-white');
        input.title = '';
      }
    });

    // Positive-only workflow: no Print Intent control or warnings
    // (Intent mismatch warnings removed; EDN mapping fixed to Positive.)
    
    
    
    // Global linearization button click
    elements.globalLinearizationBtn.addEventListener('click', () => {
      elements.linearizationFile.click();
    });

    elements.linearizationFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Capture state before loading file for proper undo functionality
        CurveHistory.captureState('Before loading linearization file');
        // Read file content based on file type
        const extension = file.name.toLowerCase().split('.').pop();
        let fileInput;
        if (extension === 'acv') {
          fileInput = await file.arrayBuffer();
        } else {
          fileInput = await file.text();
        }
        
        const parsed = await parseLinearizationFile(fileInput, file.name);
        // For EDN-style (.cube/.acv), store base samples and compute effective Positive mapping (reverse + invert)
        const isEDNStyle = ['cube','acv'].includes(extension);
        if (isEDNStyle && Array.isArray(parsed.samples)) {
          parsed._baseSamples = parsed.samples.slice();
          const eff = parsed._baseSamples.slice().reverse().map(v => 1 - v);
          parsed.samples = eff;
        }
        parsed.filename = file.name; // Store filename for documentation
        linearizationData = parsed;
        linearizationApplied = true; // Auto-apply when file is loaded
        
        // Update button tooltip and enable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${file.name} (${getBasePointCountLabel(parsed)})`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        
        // Show file info below Data Source label
        // Set base filename and refresh display with edited prefix logic
        linearizationData.filename = file.name;
        linearizationData.edited = false;
        refreshGlobalLinearizationDisplay();
        // Details: show only point count + simplified type label
        const ptsLabel = getBasePointCountLabel(parsed);
        const fmtLower = String(parsed.format || '').toLowerCase();
        const nameLower = file.name.toLowerCase();
        let typeLabel = '';
        if (fmtLower.includes('lab')) typeLabel = 'LAB';
        else if (nameLower.endsWith('.acv') || fmtLower === 'acv') typeLabel = 'curve';
        else if (nameLower.endsWith('.cube') || fmtLower === '1dlut' || parsed.is3DLUT) typeLabel = 'LUT';
        else typeLabel = (parsed.format || '').toUpperCase();
        elements.globalLinearizationDetails.textContent = ` - ${ptsLabel} (${typeLabel})`;
        elements.globalLinearizationInfo.classList.remove('hidden');
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.add('hidden');
        
        // Note: No auto-smoothing; base samples come from the chosen source. Smoothing is optional via slider.
        
        // Update interpolation controls
        updateInterpolationControls();
        
        // Show appropriate status message based on LUT type
      if (parsed.is3DLUT) {
          showStatus(`Loaded 3D LUT and extracted ${parsed.samples.length} neutral axis points as a global correction from ${file.name} (${parsed.lutSize}³ grid)`);
          try { postGlobalDeltaChatSummary(); } catch {}
      } else {
          showStatus(`Loaded and applied ${parsed.samples.length} data points as a global correction from ${file.name}`);
          try { postGlobalDeltaChatSummary(); } catch {}
      }
        debouncedPreviewUpdate(); // Update preview to show the applied linearization
        
        // Update processing details for all channels since global affects all
        const channelNames = getCurrentPrinter().channels;
        channelNames.forEach(channelName => {
          updateProcessingDetail(channelName);
        });
      } catch (error) {
        console.error('Cube file parsing error:', error);
        showStatus(`Error loading file: ${error.message}`);
        linearizationData = null;
        linearizationApplied = false;
        
        // Update filename to reflect no corrections
        updateFilename();
        
        // Reset button tooltip and disable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', 'Load LUT.cube, LABdata.txt, or .acv curve files');
        elements.globalLinearizationToggle.disabled = true;
        elements.globalLinearizationToggle.checked = false;
        
        // Hide file info and show hint again
        elements.globalLinearizationInfo.classList.add('hidden');
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.remove('hidden');
        
        // Update interpolation controls
        updateInterpolationControls();
      }
    });

    // Global linearization toggle
    elements.globalLinearizationToggle.addEventListener('change', (e) => {
          if (DEBUG_LOGS) console.log('DEBUG: Global toggle change event fired:', {
        checked: e.target.checked,
        hasLinearizationData: !!linearizationData,
        linearizationDataSamples: linearizationData?.samples?.length || 0
      });
      
      if (linearizationData) {
        linearizationApplied = e.target.checked;
        if (linearizationApplied) {
          showStatus('Global linearization enabled');
          try { postGlobalDeltaChatSummary(); } catch {}
        } else {
          showStatus('Global linearization disabled');
        }
        
            if (DEBUG_LOGS) console.log('DEBUG: After toggle change:', {
          linearizationApplied,
          linearizationData: linearizationData
        });
        
        // Update processing details for all channels since global affects all
        const channelNames = getCurrentPrinter().channels;
        channelNames.forEach(channelName => {
          updateProcessingDetail(channelName);
        });
        
        // Update interpolation controls
        updateInterpolationControls();
        
        // Update filename to reflect current state
        updateFilename();
        
        debouncedPreviewUpdate();
      }
    });

    // Curve smoothing method selection
    elements.curveSmoothingMethod.addEventListener('change', (e) => {
      const method = e.target.value;
      
      // Update interpolation controls (including intensity slider visibility and description)
      updateInterpolationControls();
      
      if (hasAnyLinearization()) {
        const methodNames = {
          'cubic': 'Cubic Spline',
          'catmull': 'Catmull-Rom',
          'pchip': 'PCHIP (monotonic)',
          'linear': 'Linear (none)'
        };
        showStatus(`Curve method: ${methodNames[method]}`);
        debouncedPreviewUpdate(); // Update preview with new smoothing setting
      }
    });
    
    // Catmull-Rom tension slider
    elements.catmullTension.addEventListener('input', (e) => {
      if (hasAnyLinearization() && elements.curveSmoothingMethod.value === 'catmull') {
        const tension = Math.round(e.target.value);
        showStatus(`Catmull-Rom tension: ${tension}%`);
        debouncedPreviewUpdate(); // Update preview with new tension setting
      }
    });
    
    // Smoothing slider functionality
    elements.smoothingSlider.addEventListener('input', (e) => {
      if (hasAnyLinearization()) {
        const smoothingPercent = Math.round(e.target.value);
        elements.smoothingValue.textContent = `${smoothingPercent}%`;
        
        // Update warning visibility
        const showWarning = smoothingPercent > 0;
        if (showWarning) {
        elements.smoothingWarning.classList.remove('opacity-0', 'invisible');
      } else {
        elements.smoothingWarning.classList.add('opacity-0', 'invisible');
      }
        
        // Update status and preview
        if (smoothingPercent > 0) {
          showStatus(`Data point smoothing: ${smoothingPercent}%`);
        } else {
          showStatus(`Data point smoothing: off`);
        }
        debouncedPreviewUpdate(); // Update preview with new smoothing setting
      }
    });

    // Simplifier controls listeners
    // Legacy key-point simplifier listeners removed; replaced by Edit Curves panel
    
    // Notes toggle functionality
    if (elements.notesToggle && elements.notesContent && elements.notesChevron) {
      elements.notesToggle.addEventListener('click', () => {
        const isHidden = elements.notesContent.classList.contains('hidden');
        if (isHidden) {
          elements.notesContent.classList.remove('hidden');
          elements.notesChevron.style.transform = 'rotate(180deg)';
        } else {
          elements.notesContent.classList.add('hidden');
          elements.notesChevron.style.transform = 'rotate(0deg)';
        }
      });
    }

    // Live-preview user notes into the .quad File Preview
    if (elements.userNotes) {
      elements.userNotes.addEventListener('input', () => {
        // Debounce not necessary; buildFile is cheap. Keep UI snappy.
        updatePreview();
      });
    }

    // Lab Tech functionality (always visible console-style; no collapse/expand)

    // Initialize Lab Tech as ready (API key is handled by Cloudflare Worker)
    // Keep panel collapsed by default; compact input is primary
    if (elements.sendMessageBtn) elements.sendMessageBtn.disabled = false;
    if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.disabled = false;
    // Set initial Lab Tech icon state
    refreshLabTechIcon();
    
    // Initialize usage counter - disabled for now
    // updateUsageCounter();
    
    // Skip API key management - no longer needed
    /*
    elements.setApiKeyBtn.addEventListener('click', async () => {
      const apiKey = elements.apiKeyInput.value.trim();
      
      if (!apiKey) {
        addChatMessage('system', 'Please enter an API key.');
        elements.apiKeyInput.style.borderColor = '#ef4444';
        setTimeout(() => {
          elements.apiKeyInput.style.borderColor = '';
        }, 2000);
        return;
      }

      // Show validation in progress
      elements.setApiKeyBtn.disabled = true;
      elements.setApiKeyBtn.textContent = 'Validating...';
      if (elements.aiStatus) elements.aiStatus.textContent = 'Validating API key...';
      if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-blue-600';
      if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '⏳';

      try {
        // Validate the API key
        const validation = await claudeAssistant.validateApiKey(apiKey);
        
        if (validation.success) {
          // API key is valid - set it
          claudeAssistant.setApiKey(apiKey);
          elements.sendMessageBtn.disabled = false;
          elements.apiKeyInput.value = '';
          if (elements.aiStatus) elements.aiStatus.textContent = 'API key validated — Ready to chat!';
          if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-green-600';
          if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '✅';
          addChatMessage('system', `✅ ${validation.message}. You can now chat with Lab Tech!`);
        } else {
          // API key is invalid
          if (elements.aiStatus) elements.aiStatus.textContent = 'Invalid API key';
          if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
          if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '❌';
          addChatMessage('system', `❌ ${validation.message}`);
          
          // Flash the input field red
          elements.apiKeyInput.style.borderColor = '#ef4444';
          setTimeout(() => {
            elements.apiKeyInput.style.borderColor = '';
          }, 3000);
        }
      } catch (error) {
        if (elements.aiStatus) elements.aiStatus.textContent = 'Validation failed';
        if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
        if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '❌';
        addChatMessage('system', `❌ Could not validate API key: ${error.message}`);
      } finally {
        elements.setApiKeyBtn.disabled = false;
        elements.setApiKeyBtn.textContent = 'Set Key';
      }
    });

    elements.clearApiKeyBtn.addEventListener('click', () => {
      claudeAssistant.setApiKey(null);
      elements.sendMessageBtn.disabled = true;
      elements.apiKeyInput.value = '';
      if (elements.aiStatus) elements.aiStatus.textContent = 'API key required';
      if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
      if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '🔑';
      addChatMessage('system', 'API key cleared. Please set a new API key to continue chatting.');
    });

    // Force set API key without validation (for testing)
    elements.forceSetKeyBtn.addEventListener('click', () => {
      const apiKey = elements.apiKeyInput.value.trim();
      
      if (!apiKey) {
        addChatMessage('system', 'Please enter an API key.');
        elements.apiKeyInput.style.borderColor = '#ef4444';
        setTimeout(() => {
          elements.apiKeyInput.style.borderColor = '';
        }, 2000);
        return;
      }

      // Set the API key without validation
      claudeAssistant.setApiKey(apiKey);
      elements.sendMessageBtn.disabled = false;
      elements.apiKeyInput.value = '';
      if (elements.aiStatus) elements.aiStatus.textContent = 'API key set (unvalidated) — Try chatting';
      if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-yellow-600';
      if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '⚠️';
      addChatMessage('system', '⚠️ API key set WITHOUT validation. Try sending a message to test if it works.');
    });

    elements.testConnectionBtn.addEventListener('click', async () => {
      elements.testConnectionBtn.disabled = true;
      elements.testConnectionBtn.textContent = 'Testing...';
      
      try {
        const result = await claudeAssistant.testConnection();
        addChatMessage('system', `Connection test: ${result.message}`);
        elements.aiStatus.textContent = result.message;
        elements.aiStatus.className = result.success ? 'text-xs text-green-600' : 'text-xs text-red-600';
        elements.aiStatusIcon.textContent = result.success ? '🟢' : '🔴';
      } catch (error) {
        addChatMessage('system', `Connection test failed: ${error.message}`);
        if (elements.aiStatus) elements.aiStatus.textContent = 'Connection test failed';
        if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
        if (elements.aiStatusIcon) elements.aiStatusIcon.textContent = '🔴';
      } finally {
        elements.testConnectionBtn.disabled = false;
        elements.testConnectionBtn.textContent = 'Test';
      }
    });
    */

    // Update usage counter display
    function updateUsageCounter(serverHeaders = null) {
      // Try to use server-provided rate limit info first
      if (serverHeaders) {
        const limit = serverHeaders['x-ratelimit-limit'];
        const remaining = serverHeaders['x-ratelimit-remaining'];
        
        if (limit && remaining !== undefined) {
          const used = parseInt(limit) - parseInt(remaining);
          elements.usageCounter.textContent = `${used}/${limit} requests`;
          
          // Change color based on remaining
          const remainingNum = parseInt(remaining);
          if (remainingNum < 10) {
            elements.usageCounter.className = 'text-xs text-red-500 ml-auto';
          } else if (remainingNum < 25) {
            elements.usageCounter.className = 'text-xs text-orange-500 ml-auto';
          } else {
            elements.usageCounter.className = 'text-xs text-gray-500 ml-auto';
          }
          return;
        }
      }
      
      // Fall back to client-side tracking
      const stats = claudeAssistant.getUsageStats();
      const remaining = stats.remainingHourly;
      const used = stats.requestsLastHour;
      
      elements.usageCounter.textContent = `${used}/100 requests`;
      
      // Change color based on usage
      if (remaining < 10) {
        elements.usageCounter.className = 'text-xs text-red-500 ml-auto';
      } else if (remaining < 25) {
        elements.usageCounter.className = 'text-xs text-orange-500 ml-auto';
      } else {
        elements.usageCounter.className = 'text-xs text-gray-500 ml-auto';
      }
    }

    // Chat functionality
    async function sendChatMessage() {
      const srcEl = elements.aiInputCompact || elements.aiInput;
      const message = (srcEl && typeof srcEl.value === 'string') ? srcEl.value.trim() : '';
      if (!message) return;

      // Record command into history and add user message to chat
      try {
        if (message) {
          if (aiCommandHistory.length === 0 || aiCommandHistory[aiCommandHistory.length - 1] !== message) {
            aiCommandHistory.push(message);
          }
          aiHistoryIndex = aiCommandHistory.length; // reset pointer to one past end
        }
      } catch {}
      // Add user message to chat
      addChatMessage('user', message);
      // Show processing status in chat as well
      if (shouldShowAssistantStatus()) addChatMessage('system', 'Assistant: processing request…');
      if (srcEl) srcEl.value = '';
      if (elements.sendMessageBtn) elements.sendMessageBtn.disabled = true;
      if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.disabled = true;
      if (elements.aiStatus) {
        if (elements.aiStatus) elements.aiStatus.textContent = 'Assistant is thinking...';
        if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-blue-600';
      }

      try {
        const response = await claudeAssistant.sendMessage(message);
        
        // Add AI response to chat
        addChatMessage('assistant', response.response);
        
        // Suppress detailed AI function result lines in chat

        if (elements.aiStatus) {
          elements.aiStatus.textContent = response.actionsPerformed ? 'Assistant: actions completed!' : 'Assistant: response received';
          elements.aiStatus.className = response.success ? 'text-xs text-green-600' : 'text-xs text-red-600';
        }
        
        // Update usage counter with server headers if available - disabled for now
        // updateUsageCounter(response.rateLimitHeaders);

      } catch (error) {
        addChatMessage('system', `Error: ${error.message}`);
        if (elements.aiStatus) {
          if (elements.aiStatus) elements.aiStatus.textContent = 'Assistant: error occurred';
          if (elements.aiStatus) elements.aiStatus.className = 'text-xs text-red-600';
        }
        // Update usage counter even on error (request was still made) - disabled for now
        // updateUsageCounter();
      } finally {
        if (elements.sendMessageBtn) elements.sendMessageBtn.disabled = false;
        if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.disabled = false;
      }
    }

    function addChatMessage(role, message) {
      const messageDiv = document.createElement('div');
      // Tighten spacing to match .quad File Preview line height
      messageDiv.className = `${role === 'user' ? 'text-right' : ''} mb-0`;
      
      const bubble = document.createElement('div');
      const roleClass = (role === 'user') ? 'ml-auto' : (role === 'system') ? 'italic text-gray-400' : '';
      bubble.className = `inline-block px-1 py-0 rounded text-xs max-w-[80%] whitespace-pre-line font-mono text-white ${roleClass}`;
      
      // Convert basic markdown-style formatting to HTML for assistant messages
      if (role === 'assistant') {
        let formattedMessage = message
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // **bold**
          .replace(/\*(.*?)\*/g, '<em>$1</em>') // *italic*
          .replace(/^- (.+)$/gm, '• $1') // Convert "- item" to bullet points
          .replace(/^\* (.+)$/gm, '• $1') // Convert "* item" to bullet points
          .replace(/^(\d+\.\s)/gm, '$1'); // Preserve numbered lists
        bubble.innerHTML = formattedMessage;
      } else {
        bubble.textContent = message;
      }
      messageDiv.appendChild(bubble);
      
      elements.chatHistory.appendChild(messageDiv);
      elements.chatHistory.scrollTop = elements.chatHistory.scrollHeight;
      try {
        if (role === 'system' && typeof claudeAssistant?.addSystemContext === 'function') {
          claudeAssistant.addSystemContext(message);
        }
      } catch {}
    }

    if (elements.sendMessageBtn) elements.sendMessageBtn.addEventListener('click', sendChatMessage);
    if (elements.sendMessageBtnCompact) elements.sendMessageBtnCompact.addEventListener('click', sendChatMessage);

    // Expanded textarea: Enter sends, Shift+Enter inserts newline
    if (elements.aiInput) {
      elements.aiInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          if (!(elements.sendMessageBtn && elements.sendMessageBtn.disabled)) sendChatMessage();
        }
      });
    }

    // Compact input: Enter sends; ArrowUp/ArrowDown navigate command history
    if (elements.aiInputCompact) {
      elements.aiInputCompact.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !(elements.sendMessageBtnCompact && elements.sendMessageBtnCompact.disabled)) {
          e.preventDefault();
          sendChatMessage();
        }
      });
      elements.aiInputCompact.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (aiCommandHistory.length === 0) return;
            if (aiHistoryIndex > 0) aiHistoryIndex--;
            const cmd = aiCommandHistory[aiHistoryIndex] || '';
            elements.aiInputCompact.value = cmd;
            const len = cmd.length;
            elements.aiInputCompact.setSelectionRange(len, len);
          } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (aiCommandHistory.length === 0) return;
            if (aiHistoryIndex < aiCommandHistory.length - 1) {
              aiHistoryIndex++;
              const cmd = aiCommandHistory[aiHistoryIndex] || '';
              elements.aiInputCompact.value = cmd;
              const len = cmd.length;
              elements.aiInputCompact.setSelectionRange(len, len);
            } else {
              // Move to empty prompt
              aiHistoryIndex = aiCommandHistory.length;
              elements.aiInputCompact.value = '';
            }
          }
      });
    }

    elements.clearChatBtn.addEventListener('click', () => {
      elements.chatHistory.innerHTML = '<!-- Chat messages will appear here -->';
      claudeAssistant.clearHistory();
      addChatMessage('system', 'Chat history cleared.');
    });
    

    // Sample data button event listeners
    if (elements.loadSampleLabData) {
      elements.loadSampleLabData.addEventListener('click', () => {
        loadSampleData('labData');
      });
    }
    if (elements.loadSampleCube) {
      elements.loadSampleCube.addEventListener('click', () => {
        loadSampleData('cube');
      });
    }
    
    // Download sample data functionality
    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }
    
    // Download sample data event listeners
    const dlSampleLabEl = document.getElementById('downloadSampleLabData');
    if (dlSampleLabEl) {
      dlSampleLabEl.addEventListener('click', (e) => {
        e.preventDefault();
        downloadFile(SAMPLE_DATA.colorMuse, 'LAB-Data-sample.txt', 'text/plain');
      });
    }
    const dlSampleCubeEl = document.getElementById('downloadSampleCube');
    if (dlSampleCubeEl) {
      dlSampleCubeEl.addEventListener('click', (e) => {
        e.preventDefault();
        downloadFile(SAMPLE_DATA.gammaCube, 'LUT_sample.cube', 'text/plain');
      });
    }
    
    // Function to check if all channels are disabled and show/hide message
    function updateNoChannelsMessage() {
      const rows = Array.from(elements.rows.children);
      const noChannelsRow = document.getElementById('noChannelsRow');
      
      if (!noChannelsRow) return;
      
      // Get actual channel rows (excluding the noChannelsRow itself)
      const channelRows = rows.filter(tr => tr.id !== 'noChannelsRow');
      
      // Check if all channel rows have end value of 0
      const allDisabled = channelRows.length > 0 && channelRows.every(tr => {
        const endInput = tr.querySelector('.end-input');
        return parseInt(endInput.value) === 0;
      });
      
      if (allDisabled) {
        noChannelsRow.classList.remove('hidden');
      } else {
        noChannelsRow.classList.add('hidden');
      }
    }

    // Function to update the ultra-compact disabled channels list
    function updateCompactChannelsList() {
      const compactContainer = document.getElementById('disabledChannelsCompact');
      const compactRow = document.getElementById('disabledChannelsRow');
      
      if (!compactContainer || !compactRow) return;
      
      // Clear existing chips
      compactRow.innerHTML = '';
      
      // Find all channels (enabled and disabled)
      const allChannels = Array.from(elements.rows.children).filter(tr => 
        tr.getAttribute('data-channel') // Has a valid channel name
      );
      
      // Always show compact container since we always have channels
      compactContainer.classList.add('show');
      
      // Create chips for each channel
      allChannels.forEach(tr => {
        const channelName = tr.getAttribute('data-channel');
        if (!channelName) return;
        
        // Get channel elements directly from the row
        const percentInput = tr.querySelector('.percent-input');
        // Get virtual checkbox created in setupChannelRow
        const enableCheckbox = tr._virtualCheckbox || { checked: !tr.hasAttribute('data-user-disabled') };
        
        if (!percentInput) return;
        
        const channelColor = INK_COLORS[channelName] || '#000000';
        
        const chip = document.createElement('div');
        chip.className = 'disabled-channel-chip';
        
        // Add 'active' class if channel is enabled
        if (enableCheckbox.checked) {
          chip.classList.add('active');
        }
        
        chip.innerHTML = `
          <input type="checkbox" class="channel-checkbox" ${enableCheckbox.checked ? 'checked' : ''}>
          <div class="channel-color" style="background-color: ${channelColor}"></div>
          <span class="channel-name">${channelName}</span>
        `;
        
        // Add click handler to toggle channel
        chip.addEventListener('click', (e) => {
          e.stopPropagation();
          
          if (e.target.classList.contains('channel-checkbox')) {
            // Handle checkbox click directly
            enableCheckbox.checked = e.target.checked;
            
            // Update chip appearance
            if (e.target.checked) {
              chip.classList.add('active');
            } else {
              chip.classList.remove('active');
            }
            
            enableCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          } else {
            // Handle chip click - toggle channel
            const checkbox = chip.querySelector('.channel-checkbox');
            checkbox.checked = !checkbox.checked;
            enableCheckbox.checked = checkbox.checked;
            
            // Update chip appearance
            if (checkbox.checked) {
              chip.classList.add('active');
            } else {
              chip.classList.remove('active');
            }
            
            enableCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        
        compactRow.appendChild(chip);
      });
      
      // Update the no channels message
      updateNoChannelsMessage();
    }
    
    // Disable/Enable all channels functionality
    
    // Load .quad file functionality
    function parseQuadFile(content) {
      const lines = content.split('\n').map(line => line.trim());
      
      // Look for the QuadToneRIP header line to extract channel names
      let channels = [];
      let dataStartIndex = -1;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Look for QuadToneRIP header: ## QuadToneRIP K,C,M,Y,LC,LM,LK,LLK
        if (line.startsWith('## QuadToneRIP ')) {
          const channelPart = line.substring('## QuadToneRIP '.length);
          channels = channelPart.split(',').map(ch => ch.trim());
          continue;
        }
        
        // Find where numeric data starts (first line that starts with a digit)
        if (dataStartIndex === -1 && line && line.match(/^\d/)) {
          dataStartIndex = i;
          break;
        }
      }
      
      if (channels.length === 0) {
        throw new Error('Could not find QuadToneRIP header with channel names in .quad file');
      }
      
      if (dataStartIndex === -1) {
        throw new Error('Could not find numeric data in .quad file');
      }
      
      // Parse the actual numeric data portion
      // Skip to where numeric data starts and collect all numeric lines
      const numericLines = [];
      let invalidDataLines = [];
      
      for (let i = dataStartIndex; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line) {
          if (/^\d+$/.test(line)) {
            const value = parseInt(line, 10);
            
            // Validate reasonable value range for QuadToneRIP (0-65535)
            if (value < 0 || value > 65535) {
              throw new Error(`Invalid data value ${value} at line ${i + 1}. QuadToneRIP values must be 0-65535.`);
            }
            
            numericLines.push(value);
          } else if (!line.startsWith('#')) {
            // Track non-numeric, non-comment lines as potentially problematic
            invalidDataLines.push(`Line ${i + 1}: "${line}"`);
            if (invalidDataLines.length > 10) break; // Don't flood with errors
          }
        }
      }
      
      // Warn about mixed content if found
      if (invalidDataLines.length > 0) {
        const sampleLines = invalidDataLines.slice(0, 3).join(', ');
        console.warn(`Found ${invalidDataLines.length} non-numeric lines in data section: ${sampleLines}`);
      }
      
      // Each channel should have exactly 256 data points
      const expectedDataPoints = channels.length * 256;
      if (numericLines.length < expectedDataPoints) {
        throw new Error(`Insufficient data: found ${numericLines.length} values, expected ${expectedDataPoints} (${channels.length} channels × 256 points each)`);
      }
      
      // Extract all 256 data points for each channel
      const channelCurves = {};
      const values = []; // Final values for UI display
      
      for (let channelIdx = 0; channelIdx < channels.length; channelIdx++) {
        const channelName = channels[channelIdx];
        const channelStartIdx = channelIdx * 256;
        const channelEndIdx = channelStartIdx + 255; // 0-indexed, so 255 is the 256th value
        
        if (channelEndIdx >= numericLines.length) {
          throw new Error(`Not enough data for channel ${channelName}: need point ${channelEndIdx + 1}, have ${numericLines.length}`);
        }
        
        // Extract all 256 points for this channel
        const curveData = numericLines.slice(channelStartIdx, channelStartIdx + 256);
        channelCurves[channelName] = curveData;
        
        // Store the maximum value for UI display (percentage calculation)
        values.push(Math.max(...curveData));
      }
      
      return { channels, values, curves: channelCurves };
    }
    
    function findMatchingPrinter(channels) {
      for (const [printerId, config] of Object.entries(PRINTERS)) {
        if (config.channels.length === channels.length && 
            config.channels.every((ch, i) => ch === channels[i])) {
          return printerId;
        }
      }
      return null;
    }
    
    // Load .quad file button click handler
    elements.loadQuadBtn.addEventListener('click', () => {
      elements.quadFile.click();
    });
    
    // Load .quad file change handler
    elements.quadFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Check file type
        if (!file.name.toLowerCase().endsWith('.quad')) {
          throw new Error(`Unsupported file type. Expected .quad file, got: ${file.name}`);
        }
        
        // Check file size (reasonable limits)
        if (file.size > 10 * 1024 * 1024) { // 10MB limit
          throw new Error(`File too large: ${(file.size / (1024*1024)).toFixed(1)}MB. Maximum supported size is 10MB.`);
        }
        
        if (file.size < 100) { // Minimum reasonable size
          throw new Error(`File too small: ${file.size} bytes. This doesn't appear to be a valid .quad file.`);
        }
        
        // Clear all existing processing data before loading a new .quad
        clearAllProcessingData();

        const content = await file.text();
        
        // Check for reasonable file structure
        if (!content.includes('QuadToneRIP')) {
          throw new Error('File does not appear to be a valid .quad file (missing QuadToneRIP header).');
        }
        
        // Check for reasonable data content
        const numericLines = content.split('\n').filter(line => line.trim() && /^\d+$/.test(line.trim()));
        if (numericLines.length < 256) {
          throw new Error(`File appears corrupted or incomplete. Found only ${numericLines.length} data points, expected at least 256.`);
        }
        
        const parsed = parseQuadFile(content);
        
        // Store the complete curve data for use in generation
        window.loadedQuadData = {
          filename: file.name,
          curves: parsed.curves,
          channels: parsed.channels
        };
        // Normalize any legacy source tags immediately after load
        normalizeSmartSourcesInLoadedData();
        
        // Find matching printer
        const matchingPrinter = findMatchingPrinter(parsed.channels);
        if (!matchingPrinter) {
          const channelList = parsed.channels.join(', ');
          throw new Error(`No supported printer matches channels: ${channelList}. Supported printers: P400 (K,C,M,Y,LC,LM), x800-x890 (K,C,M,Y,LC,LM,LK,LLK), P4-6-8000 (K,C,M,Y,LC,LM,LK,LLK), P5-7-9000 (K,C,M,Y,LC,LM,LK,LLK,OR,GR), x900 (K,C,M,Y,LC,LM,LK,LLK,OR,GR), 3880-7880 (K,C,M,Y,LC,LM,LK,LLK), P600-P800 (K,C,M,Y,LC,LM,LK,LLK), P700-P900 (K,C,M,Y,LC,LM,LK,LLK,V,MK)`);
        }
        
        // Switch to matching printer (mark that we're switching due to quad load)
        if (window.loadedQuadData) window.loadedQuadData.switchingPrinter = true;
        elements.printerSelect.value = matchingPrinter;
        setPrinter(matchingPrinter);
        if (window.loadedQuadData) delete window.loadedQuadData.switchingPrinter;
        
        // Wait a moment for the channel table to rebuild
        setTimeout(() => {
          // Set the channel values
          const rows = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
          parsed.values.forEach((value, index) => {
            if (index < rows.length) {
              const row = rows[index];
              const endInput = row.querySelector('.end-input');
              const percentInput = row.querySelector('.percent-input');
              
              if (endInput && percentInput) {
                endInput.value = value.toString();
                const percent = InputValidator.computePercentFromEnd(value);
                percentInput.value = percent.toString();
                
                // Refresh the row display
                const refreshFn = row.refreshDisplayFn;
                if (refreshFn) refreshFn();
              }
            }
          });

          // Record baseline End per channel for scaling loaded .quad uniformly when End changes
          try {
            if (!window.loadedQuadData.baselineEnd) window.loadedQuadData.baselineEnd = {};
            const rows2 = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
            rows2.forEach((row) => {
              const ch = row.getAttribute('data-channel');
              const endVal = InputValidator.clampEnd(row.querySelector('.end-input')?.value || 0);
              if (ch) window.loadedQuadData.baselineEnd[ch] = endVal;
            });
          } catch (e) { console.warn('Baseline End capture failed:', e); }

          // Precompute editable AI key points from the loaded .quad curves using the same
          // adaptive method used on first edit. This avoids visible point “jumps” on first change.
          try {
            if (window.loadedQuadData && window.loadedQuadData.curves) {
              parsed.channels.forEach((ch) => {
                const curve = window.loadedQuadData.curves[ch];
                if (Array.isArray(curve) && curve.length === 256) {
                  const keyPoints = extractAdaptiveKeyPointsFromValues(curve, { maxErrorPercent: KP_SIMPLIFY.maxErrorPercent, maxPoints: KP_SIMPLIFY.maxPoints });
                  try { ControlPoints.persist(ch, keyPoints, 'smooth'); } catch (e) { console.warn('Persist precomputed KP failed:', ch, e); }
                }
              });
            }
          } catch (e) { console.warn('Precompute AI key points from .quad failed:', e); }
          
          updatePreview();
          
          // If no channels are enabled, enable the first available channel
          try {
            const rows3 = Array.from(elements.rows.children).filter(tr => tr.id !== 'noChannelsRow');
            const anyEnabled = rows3.some(tr => (InputValidator.clampEnd(tr.querySelector('.end-input')?.value || 0)) > 0);
            if (!anyEnabled && rows3.length > 0) {
              const firstCh = rows3[0].getAttribute('data-channel');
              if (firstCh && typeof quadGenActions?.enableDisableChannel === 'function') {
                quadGenActions.enableDisableChannel(firstCh, true);
              }
            }
          } catch {}
          
          // Refresh Edit Curves dropdown and set selection to first enabled channel in the .quad
          try {
            if (typeof edit_populateChannelSelect === 'function') edit_populateChannelSelect();
            if (elements.editChannelSelect && elements.editChannelSelect.options.length > 0) {
              const firstVal = elements.editChannelSelect.options[0].value;
              if (firstVal) {
                EDIT.selectedChannel = firstVal;
                EDIT.selectedOrdinal = 1;
                elements.editChannelSelect.value = firstVal;
                if (typeof edit_refreshState === 'function') edit_refreshState();
              }
            }
          } catch {}
          
          // Set the filename input to copy of the loaded file (remove .quad extension)
          const baseName = file.name.replace(/\.quad$/i, '');
          elements.filenameInput.value = `${baseName}_copy`;
          // Mark as user-edited so it won't be auto-generated over
          elements.filenameInput.dataset.userEdited = 'true';
          
          showStatus(`Loaded ${file.name} - switched to ${PRINTERS[matchingPrinter].name}`);
        }, 50);
        
      } catch (error) {
        console.error('Error loading .quad file:', error);
        showStatus(`Error loading .quad file: ${error.message}`);
      }
      
      // Clear the file input
      e.target.value = '';
    });
    
    // Manual L* entry functionality
    let lstarInputCount = 5;
    let lastLstarValues = []; // Store the last entered values
    
    // Convert CIE L* (0..100) to sRGB grayscale hex (approx).
    function lstarToHex(L) {
      const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
      const l = clamp(Number(L), 0, 100);
      // Convert L* to relative luminance Y
      let Y;
      if (l > 8) {
        const f = (l + 16) / 116;
        Y = f * f * f;
      } else {
        Y = l / 903.3;
      }
      // Linear to sRGB
      let s = (Y <= 0.0031308) ? (12.92 * Y) : (1.055 * Math.pow(Y, 1 / 2.4) - 0.055);
      s = clamp(s, 0, 1);
      const v = Math.round(s * 255);
      const hex = v.toString(16).padStart(2, '0');
      return `#${hex}${hex}${hex}`;
    }

    function createLstarInput(index, value = '') {
      const hasValue = (value !== '' && !isNaN(parseFloat(value)));
      const measuredColor = hasValue ? lstarToHex(value) : '#ffffff';
      // Default measured X position (evenly spaced)
      const total = Math.max(2, lstarInputCount);
      const defaultX = (index / (total - 1)) * 100;
      const targetFloor = 20; // Display-only floor for target L* swatch (most prints don't reach L* 0)
      const targetL = Math.max(targetFloor, 100 - defaultX);
      const targetColor = lstarToHex(targetL);
      return `
        <tr>
          <td class="px-2 py-1 w-8 text-xs text-gray-500">${index + 1}.</td>
          <td class="px-2 py-1 w-24">
            <input type="number" class="lstar-measured-x w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" value="${defaultX.toFixed(1)}" min="0" max="100" step="0.1" title="Patch % (0–100)">
          </td>
          <td class="px-2 py-1 w-24 text-center">
            <span class="inline-flex items-center justify-center gap-[2px]">
            <span class="lstar-target-swatch inline-flex items-center justify-center w-6 h-6 rounded border border-gray-300" style="background-color: ${targetColor};" title="Linear target preview (based on Patch %, min L* = 20)"></span>
              <span class="lstar-swatch inline-flex items-center justify-center w-6 h-6 rounded border border-gray-300 ${hasValue ? '' : 'border-dashed'}" style="${hasValue ? `background-color: ${measuredColor};` : 'background-image: repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px); background-color: #ffffff; border-style: dashed;'}" title="Measured L* preview">${hasValue ? '' : '<span class=\"text-[10px] text-gray-500\">—</span>'}</span>
            </span>
          </td>
          <td class="px-2 py-1 w-24">
            <input type="number" class="lstar-input w-24 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" 
                   placeholder="L*" 
                   min="0" max="100" step="0.1" value="${value}">
          </td>
        </tr>
      `;
    }
    
    function updateLstarInputs() {
      const container = elements.lstarInputs;
      container.innerHTML = '';
      
      for (let i = 0; i < lstarInputCount; i++) {
        const savedValue = lastLstarValues[i] || '';
        const inputHtml = createLstarInput(i, savedValue);
        container.insertAdjacentHTML('beforeend', inputHtml);
      }
      
      elements.lstarCountInput.value = lstarInputCount;
      elements.removeLstarInput.disabled = lstarInputCount <= 5;
      
      // Update validation
      validateLstarInputs();
    }

    
    function validateLstarInputs() {
      // Validate measured inputs and update measured swatches
      const inputs = elements.lstarInputs.querySelectorAll('input.lstar-input');
      const values = [];
      let hasErrors = false;
      let errorMessage = '';
      // Collect measured Xs
      const measuredXs = [];
      const measuredXInputs = elements.lstarInputs.querySelectorAll('.lstar-measured-x');
      Array.from(measuredXInputs).forEach((xInput) => {
        const row = xInput.closest('tr');
        const idx = Array.from(elements.lstarInputs.children).indexOf(row);
        const xv = parseFloat(xInput.value);
        if (!isNaN(xv) && xv >= 0 && xv <= 100) {
          measuredXs[idx] = xv;
          xInput.style.borderColor = '#d1d5db';
          // Update target swatch color (linear expectation = 100 - Patch%)
          const target = Math.max(20, 100 - xv); // clamp display to L* ≥ 20 (white remains 100)
          const targetSwatch = row ? row.querySelector('.lstar-target-swatch') : null;
          if (targetSwatch) targetSwatch.style.backgroundColor = lstarToHex(target);
        } else {
          xInput.style.borderColor = '#ef4444';
          // If invalid, leave target swatch as-is
        }
      });
      
      inputs.forEach((input, index) => {
        const value = parseFloat(input.value);
        // Update swatch color live
        const row = input.closest('tr');
        const swatch = row ? row.querySelector('.lstar-swatch') : null;
        if (input.value.trim() && !isNaN(value)) {
          if (value < 0 || value > 100) {
            hasErrors = true;
            errorMessage = 'L* values must be between 0 and 100';
            input.style.borderColor = '#d1d5db';
            if (swatch) {
              swatch.style.backgroundColor = '#ffffff';
              swatch.style.backgroundImage = 'repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px)';
              swatch.style.borderStyle = 'dashed';
              swatch.innerText = '—';
            }
          } else {
            values.push({ index, value });
            input.style.borderColor = '#d1d5db';
            if (swatch) {
              swatch.style.backgroundImage = 'none';
              swatch.style.borderStyle = 'solid';
              swatch.style.backgroundColor = lstarToHex(value);
              swatch.innerText = '';
            }
          }
        } else if (input.value.trim()) {
          hasErrors = true;
          errorMessage = 'Invalid L* value';
          input.style.borderColor = '#d1d5db';
          if (swatch) {
            swatch.style.backgroundColor = '#ffffff';
            swatch.style.backgroundImage = 'repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px)';
            swatch.style.borderStyle = 'dashed';
            swatch.innerText = '—';
          }
        } else {
          input.style.borderColor = '#d1d5db';
          if (swatch) {
            swatch.style.backgroundColor = '#ffffff';
            swatch.style.backgroundImage = 'repeating-linear-gradient(45deg, #f3f4f6 0, #f3f4f6 2px, #ffffff 2px, #ffffff 4px)';
            swatch.style.borderStyle = 'dashed';
            swatch.innerText = '—';
          }
        }
      });
      
      if (values.length < 5) {
        hasErrors = true;
        // No user-facing message; keep the button disabled without showing the old text
      }
      // Require all L* values to be provided for wedgie-like inversion
      const totalInputs = inputs.length;
      if (values.length !== totalInputs) {
        hasErrors = true;
        if (!errorMessage) errorMessage = 'All L* values must be set (0–100)';
      }
      // Validate monotonic increasing Xs for target and measured
      function isStrictlyIncreasing(arr) {
        for (let i = 1; i < arr.length; i++) if (!(arr[i] > arr[i - 1])) return false;
        return true;
      }
      if (measuredXs.length === inputs.length) {
        if (!isStrictlyIncreasing(measuredXs)) {
          hasErrors = true;
          if (!errorMessage) errorMessage = 'Patch % must be strictly increasing (0→100)';
        }
      } else {
        hasErrors = true;
        if (!errorMessage) errorMessage = 'All Patch % must be set (0–100)';
      }
      
      if (hasErrors) {
        elements.generateFromLstar.disabled = true;
        if (errorMessage) {
          elements.lstarValidation.textContent = errorMessage;
          // Center only the specific message requesting all L* values
          if (errorMessage === 'All L* values must be set (0–100)') {
            elements.lstarValidation.classList.add('text-center');
          } else {
            elements.lstarValidation.classList.remove('text-center');
          }
          elements.lstarValidation.classList.remove('hidden');
        } else {
          elements.lstarValidation.classList.add('hidden');
          elements.lstarValidation.classList.remove('text-center');
        }
      } else {
        elements.lstarValidation.classList.add('hidden');
        elements.lstarValidation.classList.remove('text-center');
        elements.generateFromLstar.disabled = false;
      }
      
      // Return aligned arrays in row order
      const measuredPairs = [];
      if (!hasErrors) {
        // values[] preserves row order via index, but to be explicit map per row
        const valueByIndex = new Map(values.map(v => [v.index, v.value]));
        elements.lstarInputs.querySelectorAll('tr').forEach((row, idx) => {
          const v = valueByIndex.get(idx);
          const xEl = row.querySelector('.lstar-measured-x');
          const xv = xEl ? parseFloat(xEl.value) : NaN;
          if (!isNaN(v) && !isNaN(xv)) measuredPairs.push({ x: xv, l: v });
        });
      }
      return { valid: !hasErrors, values, measuredX: measuredXs, measuredPairs };
    }
    
    function parseManualLstarData(validation) {
      const measuredPairs = validation.measuredPairs;
      // Build aligned arrays in row order
      const measuredXs = measuredPairs.map(p => p.x);
      const measured = measuredPairs.map(p => ({ value: p.l }));
      const N = measured.length;
      // Normalize X positions to 0..1
      const inputNormMeasured = measuredXs.map(v => Math.max(0, Math.min(100, v)) / 100);
      // Wedgie-like target: Target X% is linked to Measured X% and Target L* is linear 100→0
      // Therefore target L* = 100 - Target X% and target density = Target X% / 100
      const inputNormTarget = inputNormMeasured.slice();
      const targetDensity = inputNormTarget.slice();
      // Actual density from measured L* (normalized by measured min/max) then invert
      const mVals = measured.map(m => m.value);
      const minLab = Math.min(...mVals);
      const maxLab = Math.max(...mVals);
      const labRange = Math.max(1e-6, maxLab - minLab);
      const actualDensity = measured.map(m => 1.0 - ((m.value - minLab) / labRange));

      function targetAt(x) {
        // linear interpolation on (inputNormTarget, targetDensity)
        if (x <= inputNormTarget[0]) return targetDensity[0];
        if (x >= inputNormTarget[N - 1]) return targetDensity[N - 1];
        let lo = 0;
        let hi = N - 1;
        while (hi - lo > 1) {
          const mid = (lo + hi) >> 1;
          if (inputNormTarget[mid] <= x) lo = mid; else hi = mid;
        }
        const x0 = inputNormTarget[lo], x1 = inputNormTarget[hi];
        const y0 = targetDensity[lo], y1 = targetDensity[hi];
        const t = (x - x0) / Math.max(1e-9, (x1 - x0));
        return y0 * (1 - t) + y1 * t;
      }

      const samples = [];
      const minActual = Math.min(...actualDensity);
      const maxActual = Math.max(...actualDensity);
      for (let i = 0; i < 256; i++) {
        const x = i / 255;
        const desired = targetAt(x);
        let correctedInput = x;
        // Find bracket in actualDensity on measured input positions
        if (desired <= minActual) {
          correctedInput = inputNormMeasured[actualDensity.indexOf(minActual)];
        } else if (desired >= maxActual) {
          correctedInput = inputNormMeasured[actualDensity.indexOf(maxActual)];
        } else {
          for (let j = 0; j < N - 1; j++) {
            const a0 = actualDensity[j];
            const a1 = actualDensity[j + 1];
            const x0 = inputNormMeasured[j];
            const x1 = inputNormMeasured[j + 1];
            const minA = Math.min(a0, a1);
            const maxA = Math.max(a0, a1);
            if (desired >= minA && desired <= maxA) {
              const denom = (a1 - a0);
              const t = Math.abs(denom) > 1e-12 ? (desired - a0) / denom : 0;
              const tClamped = Math.max(0, Math.min(1, t));
              correctedInput = x0 * (1 - tClamped) + x1 * tClamped;
              break;
            }
          }
        }
        samples.push(correctedInput);
      }
      
      // Dual transformation application: Coordinate system alignment with industry standard
      const flippedSamples = samples.map((sample, i) => {
        const inputPos = i / 255; // Current input position (0-1)
        const flippedInputPos = 1.0 - inputPos; // Horizontal flip
        const flippedInputIndex = Math.round(flippedInputPos * 255); // Convert back to index
        const clampedIndex = Math.max(0, Math.min(255, flippedInputIndex));
        const originalSample = samples[clampedIndex];
        const verticallyFlipped = 1.0 - originalSample; // Vertical flip
        return verticallyFlipped;
      });
      
      // Capture original manual data for display/metadata
      const originalData = measured.map((m, i) => ({ input: measuredXs[i], lab: m.value }));

      return {
        domainMin: 0.0,
        domainMax: 1.0,
        samples: flippedSamples,
        originalData,
        format: 'Manual L* Entry'
      };
    }
    
    // Modal event handlers
    elements.manualLstarBtn.addEventListener('click', () => {
      updateLstarInputs();
      elements.lstarModal.classList.remove('hidden');
      try {
        document.documentElement.classList.add('overflow-hidden');
        document.body.classList.add('overflow-hidden');
      } catch {}
    });
    
    elements.closeLstarModal.addEventListener('click', () => {
      elements.lstarModal.classList.add('hidden');
      try {
        document.documentElement.classList.remove('overflow-hidden');
        document.body.classList.remove('overflow-hidden');
      } catch {}
    });
    
    elements.cancelLstar.addEventListener('click', () => {
      elements.lstarModal.classList.add('hidden');
      try {
        document.documentElement.classList.remove('overflow-hidden');
        document.body.classList.remove('overflow-hidden');
      } catch {}
    });
    
    elements.lstarModal.addEventListener('click', (e) => {
      if (e.target === elements.lstarModal) {
        elements.lstarModal.classList.add('hidden');
        try {
          document.documentElement.classList.remove('overflow-hidden');
          document.body.classList.remove('overflow-hidden');
        } catch {}
      }
    });
    
    elements.addLstarInput.addEventListener('click', () => {
      if (lstarInputCount < 50) { // Increased maximum for more measurement points
        lstarInputCount++;
        updateLstarInputs();
      }
    });
    
    elements.removeLstarInput.addEventListener('click', () => {
      if (lstarInputCount > 5) {
        lstarInputCount--;
        updateLstarInputs();
      }
    });
    
    // Live validation as user types
    elements.lstarInputs.addEventListener('input', validateLstarInputs);
    
    // Handle direct input in the count field
    elements.lstarCountInput.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      if (!isNaN(value) && value >= 5 && value <= 50) {
        lstarInputCount = value;
        updateLstarInputs();
      }
    });

    // Link toggle removed: Target X% is always linked to Measured X% in this simplified workflow
    
    elements.generateFromLstar.addEventListener('click', () => {
      const validation = validateLstarInputs();
      if (!validation.valid) return;
      
      try {
        const correctionData = parseManualLstarData(validation);
        
        // Apply the correction as global linearization
        correctionData.filename = `Manual-L-${validation.values.length}pts`;
        linearizationData = correctionData;
        linearizationApplied = true;
        
        // Update UI to show applied correction
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: Manual L* (${getBasePointCountLabel(correctionData)})`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        
        // Show file info
        elements.globalLinearizationInfo.classList.remove('hidden');
        elements.globalLinearizationFilename.textContent = `Manual L* Entry`;
        elements.globalLinearizationDetails.textContent = ` (${getBasePointCountLabel(correctionData)})`;
        if (elements.globalLinearizationHint) elements.globalLinearizationHint.classList.add('hidden');
        
        // Save the values for re-population
        const inputs = elements.lstarInputs.querySelectorAll('.lstar-input');
        lastLstarValues = Array.from(inputs).map(input => input.value);
        lstarInputCount = validation.values.length;
        
        // Update interpolation controls
        updateInterpolationControls();
        updatePreview();
        
        // Update filename to reflect current state
        updateFilename();
        
        elements.lstarModal.classList.add('hidden');
        
        showStatus(`Applied manual L* correction curve (${getBasePointCountLabel(correctionData)})`);
        try { postGlobalDeltaChatSummary(); } catch {}
      } catch (error) {
        console.error('Error processing L* values:', error);
        showStatus(`Error processing L* values: ${error.message}`);
      }
    });

    // Save Manual L* entries as a .txt file (Color-Muse format)
    elements.saveLstarTxt.addEventListener('click', () => {
      const validation = validateLstarInputs();
      if (!validation.valid) {
        // Prompt user to fix entries before saving
        elements.lstarValidation.textContent = 'Please fix errors and complete all fields before saving .txt';
        elements.lstarValidation.classList.remove('hidden');
        elements.lstarValidation.classList.remove('text-center');
        return;
      }
      const measuredPairs = validation.measuredPairs || [];
      // Header and columns match Color-Muse-Data.txt
      const header = 'GRAY\tLAB_L\tLAB_A\tLAB_B\n';
      const lines = measuredPairs.map(p => {
        const gray = Number(p.x).toFixed(2);
        const labL = Number(p.l).toFixed(2);
        return `${gray}\t${labL}\t0.00\t0.00`;
      });
      const content = header + lines.join('\n') + '\n';
      const filename = 'LAB-Data.txt';
      downloadFile(content, filename, 'text/plain');
    });
    
    // Function to populate changelog from main documentation
    function populateChangelog() {
      const changelogContent = document.getElementById('changelogContent');
      if (!changelogContent) return;
      
      // Build a clean, scannable About layout
      const licenseYear = new Date().getFullYear();
      const changelogHtml = `
        <div class="space-y-6">
          <div class="text-xs text-gray-500">
            MIT License — quadgen.html © ${licenseYear} David Marsh. HTML file only. Full text is in the page source.
          </div>
          <div>
            <p class="font-medium text-lg mb-2">Version History</p>
            ${generateAboutDialogVersionHistory()}
          </div>
        </div>
      `;
      
      changelogContent.innerHTML = changelogHtml;
      // About dialog shows version history and license notice.
    }
    
    // Log capturing system
    const logHistory = [];
    const originalConsoleLog = console.log;
    const originalConsoleError = console.error;
    const originalConsoleWarn = console.warn;
    
    console.log = function(...args) {
      const timestamp = new Date().toISOString();
      logHistory.push(`[${timestamp}] LOG: ${args.join(' ')}`);
      originalConsoleLog.apply(console, args);
    };
    
    console.error = function(...args) {
      const timestamp = new Date().toISOString();
      logHistory.push(`[${timestamp}] ERROR: ${args.join(' ')}`);
      originalConsoleError.apply(console, args);
    };
    
    console.warn = function(...args) {
      const timestamp = new Date().toISOString();
      logHistory.push(`[${timestamp}] WARN: ${args.join(' ')}`);
      originalConsoleWarn.apply(console, args);
    };

    // Help popup content
    function populateHelp() {
      const helpContent = document.getElementById('helpContent');
      if (!helpContent) return;
      const html = `
        <div class="space-y-6">
          <div>
            <p class="font-medium text-lg mb-2">Overview</p>
            <p class="text-sm text-gray-600">quadGEN helps you build and refine .quad curves for QuadToneRIP. Load measurement data or curve files, preview the tonal response, adjust channel limits, and export a corrected .quad for printing.</p>
            <div class="text-xs text-gray-600 mt-2">
              Default channel behavior: if the selected printer has an <code>MK</code> channel, MK starts enabled at 100%. Otherwise, <code>K</code> starts enabled at 100%. All other channels start disabled.
            </div>
          </div>
          <div>
            <p class="font-medium text-lg mb-2">Plot Semantics</p>
            <p class="text-sm text-gray-600">quadGEN plots ink mapping: Y = output ink level vs X = input ink level; Y = X means no correction. Too dark at input X → reduce ink → curve dips below diagonal; too light → add ink → curve rises above. Some tools mirror X (curves view) or plot luminance instead of ink, so features can appear at 1−X or on the opposite side of the diagonal.</p>
          </div>
          <div id="helpEditModeSection">
            <p class="font-medium text-lg mb-2">Edit Mode</p>
            <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
              <li>Toggle in the Edit Curves panel: “Enter Edit Mode” (slate) / “End Edit Mode” (black). Off by default.</li>
              <li>When ON: Selected channel draws on top; other enabled channels dim to 50%.</li>
              <li>Only the selected channel shows key‑point markers and ordinal labels; unselected channels hide both.</li>
              <li>Selected point label is bold and larger; marker outline matches the channel color.</li>
              <li>When OFF: Edits are disabled, key‑point overlays are hidden, and smoothing is disabled.</li>
            </ul>
          </div>
        </div>
      `;
      helpContent.innerHTML = html;
      // Wire sample buttons
      const helpLoadLab = document.getElementById('helpLoadSampleLab');
      if (helpLoadLab) helpLoadLab.addEventListener('click', () => loadSampleData('labData'));
      const helpLoadCube = document.getElementById('helpLoadSampleCube');
      if (helpLoadCube) helpLoadCube.addEventListener('click', () => loadSampleData('cube'));
      const helpDlLab = document.getElementById('helpDownloadSampleLab');
      if (helpDlLab) helpDlLab.addEventListener('click', (e) => { e.preventDefault(); downloadFile(SAMPLE_DATA.colorMuse, 'LAB-Data-sample.txt', 'text/plain'); });
      const helpDlCube = document.getElementById('helpDownloadSampleCube');
      if (helpDlCube) helpDlCube.addEventListener('click', (e) => { e.preventDefault(); downloadFile(SAMPLE_DATA.gammaCube, 'LUT_sample.cube', 'text/plain'); });
    }

    // Wire sample buttons in Global Correction Help popup
    function wireGlobalHelpSamples() {
      const helpLoadLab = document.getElementById('helpLoadSampleLab');
      if (helpLoadLab && !helpLoadLab._wired) {
        helpLoadLab.addEventListener('click', () => loadSampleData('labData'));
        helpLoadLab._wired = true;
      }
      const helpLoadCube = document.getElementById('helpLoadSampleCube');
      if (helpLoadCube && !helpLoadCube._wired) {
        helpLoadCube.addEventListener('click', () => loadSampleData('cube'));
        helpLoadCube._wired = true;
      }
      const helpDlLab = document.getElementById('helpDownloadSampleLab');
      if (helpDlLab && !helpDlLab._wired) {
        helpDlLab.addEventListener('click', (e) => { e.preventDefault(); downloadFile(SAMPLE_DATA.colorMuse, 'LAB-Data-sample.txt', 'text/plain'); });
        helpDlLab._wired = true;
      }
      const helpDlCube = document.getElementById('helpDownloadSampleCube');
      if (helpDlCube && !helpDlCube._wired) {
        helpDlCube.addEventListener('click', (e) => { e.preventDefault(); downloadFile(SAMPLE_DATA.gammaCube, 'LUT_sample.cube', 'text/plain'); });
        helpDlCube._wired = true;
      }
    }

    // Info popup functionality
    elements.infoBtn.addEventListener('click', () => {
      populateChangelog();
      elements.infoPopup.classList.remove('hidden');
    });
    
    elements.closeInfoBtn.addEventListener('click', () => {
      elements.infoPopup.classList.add('hidden');
    });
    
    // Close popup when clicking outside
    elements.infoPopup.addEventListener('click', (e) => {
      if (e.target === elements.infoPopup) {
        elements.infoPopup.classList.add('hidden');
      }
    });
    
    // Close popups with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !elements.infoPopup.classList.contains('hidden')) {
        elements.infoPopup.classList.add('hidden');
      }
      if (e.key === 'Escape' && elements.helpPopup && !elements.helpPopup.classList.contains('hidden')) {
        elements.helpPopup.classList.add('hidden');
      }
      if (e.key === 'Escape' && elements.globalCorrectionHelpPopup && !elements.globalCorrectionHelpPopup.classList.contains('hidden')) {
        elements.globalCorrectionHelpPopup.classList.add('hidden');
      }
      if (e.key === 'Escape' && elements.editModeHelpPopup && !elements.editModeHelpPopup.classList.contains('hidden')) {
        elements.editModeHelpPopup.classList.add('hidden');
      }
      // Re-enable body scroll if no help popups remain open
      try { unlockBodyScrollIfNoHelpOpen(); } catch {}
    });

    // Help popup functionality
    // Helpers to lock/unlock body scroll when help popups are open
    function lockBodyScroll(){ try { document.body.style.overflow = 'hidden'; } catch {} }
    function unlockBodyScrollIfNoHelpOpen(){
      try {
        const anyOpen = (
          (elements.helpPopup && !elements.helpPopup.classList.contains('hidden')) ||
          (elements.globalCorrectionHelpPopup && !elements.globalCorrectionHelpPopup.classList.contains('hidden')) ||
          (elements.editModeHelpPopup && !elements.editModeHelpPopup.classList.contains('hidden'))
        );
        if (!anyOpen) { document.body.style.overflow = ''; }
      } catch {}
    }

    if (elements.helpBtn) {
      elements.helpBtn.addEventListener('click', () => {
        populateHelp();
        if (elements.helpPopup) { elements.helpPopup.classList.remove('hidden'); lockBodyScroll(); }
      });
    }
    // Inline Edit Mode Help link under the Edit Curves panel
    const editModeHelpLink = document.getElementById('editModeHelpLink');
    if (editModeHelpLink) {
      editModeHelpLink.addEventListener('click', () => {
        populateHelp();
        if (elements.helpPopup) {
          elements.helpPopup.classList.remove('hidden');
          // Scroll to Edit Mode section once visible
          setTimeout(() => {
            try { document.getElementById('helpEditModeSection')?.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch {}
          }, 0);
        }
      });
    }
    if (elements.perChannelDeltaSelect) {
      elements.perChannelDeltaSelect.addEventListener('change', updatePerChannelDeltaSummary);
    }
    if (elements.closeHelpBtn) {
      elements.closeHelpBtn.addEventListener('click', () => {
        if (elements.helpPopup) { elements.helpPopup.classList.add('hidden'); unlockBodyScrollIfNoHelpOpen(); }
      });
    }
    if (elements.helpPopup) {
      elements.helpPopup.addEventListener('click', (e) => {
        if (e.target === elements.helpPopup) {
          elements.helpPopup.classList.add('hidden');
          unlockBodyScrollIfNoHelpOpen();
        }
      });
    }
    
    // Global Correction Help popup functionality
    if (elements.globalCorrectionHelpBtn && elements.globalCorrectionHelpPopup) {
      elements.globalCorrectionHelpBtn.addEventListener('click', () => {
        wireGlobalHelpSamples();
        elements.globalCorrectionHelpPopup.classList.remove('hidden');
        lockBodyScroll();
      });
    }
    if (elements.closeGlobalCorrectionHelpBtn && elements.globalCorrectionHelpPopup) {
      elements.closeGlobalCorrectionHelpBtn.addEventListener('click', () => {
        elements.globalCorrectionHelpPopup.classList.add('hidden');
        unlockBodyScrollIfNoHelpOpen();
      });
    }
    if (elements.globalCorrectionHelpPopup) {
      elements.globalCorrectionHelpPopup.addEventListener('click', (e) => {
        if (e.target === elements.globalCorrectionHelpPopup) {
          elements.globalCorrectionHelpPopup.classList.add('hidden');
          unlockBodyScrollIfNoHelpOpen();
        }
      });
    }
    // Edit Mode Help popup functionality
    if (elements.editModeHelpBtn && elements.editModeHelpPopup) {
      elements.editModeHelpBtn.addEventListener('click', () => {
        elements.editModeHelpPopup.classList.remove('hidden');
        lockBodyScroll();
      });
    }
    if (elements.closeEditModeHelpBtn && elements.editModeHelpPopup) {
      elements.closeEditModeHelpBtn.addEventListener('click', () => {
        elements.editModeHelpPopup.classList.add('hidden');
        unlockBodyScrollIfNoHelpOpen();
      });
    }
    if (elements.editModeHelpPopup) {
      elements.editModeHelpPopup.addEventListener('click', (e) => {
        if (e.target === elements.editModeHelpPopup) {
          elements.editModeHelpPopup.classList.add('hidden');
          unlockBodyScrollIfNoHelpOpen();
        }
      });
    }

    // Resizers for Lab Tech console and .quad File Preview
    (function initResizers(){
      const chat = document.getElementById('chatHistory');
      const chatResizer = document.getElementById('labTechResizer');
      const prev = document.getElementById('previewFull');
      const prevResizer = document.getElementById('previewResizer');
      if (chat && chatResizer) attachResizer(chatResizer, chat, { min: 120, max: 520, prop: 'height' });
      if (prev && prevResizer) attachResizer(prevResizer, prev, { min: 160, max: 640, prop: 'maxHeight' });
      
      function attachResizer(handle, target, opts){
        let startY = 0, startVal = 0, active = false;
        const getVal = ()=> parseInt(window.getComputedStyle(target)[opts.prop], 10) || (opts.prop==='height'?target.clientHeight:target.clientHeight);
        const setVal = (px)=> { target.style[camel(opts.prop)] = Math.max(opts.min, Math.min(opts.max, px)) + 'px'; };
        handle.addEventListener('mousedown', (e)=>{ active=true; startY=e.clientY; startVal=getVal(); document.body.classList.add('select-none'); e.preventDefault(); });
        window.addEventListener('mousemove', (e)=>{ if(!active) return; const dy=e.clientY-startY; setVal(startVal + dy); });
        window.addEventListener('mouseup', ()=>{ if(active){ active=false; document.body.classList.remove('select-none'); }});
      }
      function camel(prop){ return prop.replace(/-([a-z])/g,(_,c)=>c.toUpperCase()); }
    })();
    
    // Update version displays using centralized variable
    function updateVersionDisplays() {
      document.title = `quadGEN ${APP_VERSION}`;
      document.getElementById('appVersion').textContent = APP_VERSION;
      document.getElementById('infoPopupTitle').textContent = `quadGEN ${APP_VERSION}`;
    }
    
    // Initial setup with error handling
    try {
      updateVersionDisplays(); // Set all version displays
      setPrinter('P700P900');
      // Normalize any preexisting legacy source tags
      normalizeSmartSourcesInLoadedData();
      
      // Capture initial state for undo system
      setTimeout(() => {
        CurveHistory.captureState('Initial state');
        if (DEBUG_LOGS) console.log('📸 Initial state captured for undo system');
      }, 100); // Small delay to ensure UI is fully initialized
    } catch (error) {
      console.error('Initialization error:', error);
      showStatus("Initialization error. Please refresh the page.");
    }
  </script>

</body>
</html>
