<!doctype html>
<html lang="en">

<!--
================================================================================
QUADGEN DEVELOPMENT CONTINUATION DOCUMENT
================================================================================

CURRENT VERSION: v1.3
LAST UPDATED: 2025-08-28

================================================================================
OVERVIEW
================================================================================
quadGEN is a web-based tool for generating QuadToneRIP .quad files for Epson 
inkjet printers. It creates 256-step linearization curves with support for 
custom ink limits, linearization data, and various interpolation methods.

SUPPORTED PRINTERS:
- P800: 8 channels (K,C,M,Y,LC,LM,LK,LLK)
- P700-P900: 10 channels (K,C,M,Y,LC,LM,LK,LLK,V,MK)

================================================================================
KEY ARCHITECTURAL DECISIONS
================================================================================

CURVE GENERATION PIPELINE:
1. Base Curve: Either loaded .quad curve data OR generated linear ramp
2. Per-Channel Linearization: Applied if loaded (.cube files)
3. Global Linearization: Applied if loaded (.cube/.txt files)
4. Interpolation Method: Determines how sparse linearization data is interpolated

INTERPOLATION METHODS:
- Only enabled when linearization data with <256 points is loaded
- Disabled for loaded .quad files (already have 256 points)
- Methods: Cubic, Catmull-Rom (with tension), PCHIP, Linear

CHANNEL STATE MANAGEMENT:
- Channels can be enabled/disabled via checkboxes
- Disabled channels: Set to 0, remember previous values for restore
- Apply-to-all functions skip disabled channels
- Visual feedback: Compact layout, reduced opacity for disabled channels

FILE FORMAT SUPPORT:
- .quad files: Complete 256-point curves (input/output)
- .cube files: 1D LUTs for linearization corrections
- .txt files: Color Muse measurement data for linearization
- .acv files: REMOVED in v1.2 (limited open-source support)

================================================================================
VERSION HISTORY
================================================================================

v1.3 (2025-08-28) - Linearization Correction Fix:
FIXED:
- Color Muse linearization correction algorithm now matches industry standard
- Manual L* data entry linearization correction algorithm now matches industry standard  
- .cube file linearization corrected to use original samples directly
- Dual coordinate transformation applied to measurement data (Color Muse .txt files and manual L* entry)
- Removed erroneous inverse mapping logic from .cube file parsing

TECHNICAL:
- Color Muse & Manual L* Entry: Applied horizontal and vertical flip transformations
- .cube files: Use original samples without any coordinate transformation
- Different file types require different coordinate system treatments
- Added comprehensive documentation explaining why different treatments are necessary

VALIDATION:
- Empirically validated against industry standard tools using Color-Muse-Data.txt
- All linearization methods now produce correct industry-standard behavior

v1.2 (2025-01-27) - Major Feature Release:
ADDED:
- Complete .quad file loading with curve preservation
- Layered processing system (base curves + linearization)
- Enhanced file validation and error handling
- Info popup with version information
- Compact UI controls and improved UX

CHANGED:
- Merged P700/P900 into single "P700-P900" option (identical 10-channel config)
- Interpolation controls now properly disabled for loaded .quad files
- Apply-to-all functions respect disabled channel checkboxes
- Enhanced scrollbar styling for file preview (24px, bright white, 60px min)

REMOVED:
- ACV file support (Photoshop curve files)
- Smoothing intensity controls (pure interpolation preferred)

TECHNICAL:
- Loaded .quad data stored in loadedQuadData global variable
- make256() function checks for loaded curves before generating linear ramps
- hasAnyLinearization() determines when interpolation controls are relevant
- updateInterpolationControls() manages UI state and visual feedback

v1.1 (Previous):
- Catmull-Rom spline interpolation with tension parameter
- Channel memory system for disabled channels
- Cube file inverse mapping corrections
- Tension controls for spline customization

v1.0 (Initial):
- Basic linear ramp generation
- Printer configuration support
- File download functionality
- Chart visualization

================================================================================
IMPORTANT IMPLEMENTATION NOTES
================================================================================

CURVE DATA HANDLING:
- Linear ramps: Generated mathematically from 0 to endValue over 256 steps
- Loaded curves: Scaled proportionally when ink limits change
- Linearization: Applied as lookup table transformations
- All values clamped to 0-65535 range (QuadToneRIP standard)

INTERPOLATION BEHAVIOR:
- Only applies to linearization data with sparse control points
- Uses 1D LUT application via apply1DLUT() function
- Forward mapping: input value → LUT lookup → output value
- Different methods affect smoothness of sparse data expansion

CHANNEL MANAGEMENT:
- Each channel has: percentage, end value, enable/disable state
- Percentage and end value stay in sync (computed conversion)
- Disabled channels: checkbox unchecked, values = 0, previous values stored
- Channel memory: channelPreviousValues object stores values for restore

UI STATE MANAGEMENT:
- Interpolation controls enabled/disabled based on hasAnyLinearization()
- File info displayed for loaded .quad files
- Status messages provide user feedback
- Tooltips explain control functionality

FILENAME GENERATION:
- Auto-generated from: PrinterModel_Ch1Value_Ch2Value...
- User can override by editing (marked as userEdited)
- Loaded .quad files default to: originalname_copy
- Sanitized for filesystem compatibility

================================================================================
TESTING NOTES
================================================================================

KEY TEST SCENARIOS:
1. Load .quad file → verify curve preservation and limit scaling
2. Load .quad + add linearization → verify layered processing
3. Enable/disable channels → verify apply-to-all skips disabled
4. Switch printers → verify channel count and layout changes
5. File validation → verify error handling for corrupted/invalid files

EDGE CASES:
- Empty .quad files or corrupted data
- Linearization files with invalid ranges
- Channel limit changes on loaded curves
- Printer switching with loaded data
- File size limits and validation

================================================================================
LINEARIZATION CORRECTION PROCESSING
================================================================================

CRITICAL INSIGHT: Correction curve coordinate system differs from intuitive interpretation

COLOR MUSE DATA INTERPRETATION:
- Raw data format: GRAY% (0-100) → LAB_L* (measured lightness values)
- Intuitive reading: "GRAY% input produces LAB_L* output"
- ACTUAL industry standard: Requires coordinate transformation

CORRECTION ALGORITHMS BY FILE TYPE:

COLOR MUSE DATA (.txt files) & MANUAL L* ENTRY:
1. Convert measurements to density values (invert L* since higher L* = lighter = lower density)
2. Create density mapping: targetDensity (from GRAY%) → actualDensity (from L*)
3. Generate correction curve: for each target density, find what input produces it
4. Apply DUAL TRANSFORMATION to match industry standard:
   - Horizontal flip: flippedInputPos = 1.0 - inputPos (mirrors left-to-right)
   - Vertical flip: verticallyFlipped = 1.0 - originalSample (mirrors top-to-bottom)

CUBE FILES (.cube files):
1. Parse 1D LUT samples directly from file
2. Use samples WITHOUT any coordinate transformation
3. Return original samples as-is

WHY DIFFERENT TREATMENTS ARE NECESSARY:
- Color Muse data: Raw measurement data requiring coordinate system interpretation
- .cube files: Pre-processed correction curves already in correct coordinate system
- Industry tools use different coordinate system than mathematical intuition for measurement data
- Without transformation (Color Muse): crossing point at ~35% (incorrect)
- With dual transformation (Color Muse): crossing point at ~65% (matches industry standard)
- Direct use (.cube files): produces correct industry-standard behavior

KEY LESSONS LEARNED:
1. Relationship interpretation matters more than mathematical sophistication
2. Industry standards may override intuitive coordinate systems
3. Empirical validation against established tools is critical
4. Coordinate system transformation can be more important than algorithm choice
5. Historical printing workflow conventions influence modern digital tool behavior

VALIDATION APPROACH:
- Generate curves using Color-Muse-Data.txt in both quadGEN and industry standard tools
- Compare crossing points: should match at ~65% on linear diagonal
- Verify correction curve topology and amplitude match between tools

================================================================================
FUTURE CONSIDERATIONS
================================================================================

POTENTIAL ENHANCEMENTS:
- Additional printer model support
- Batch processing capabilities  
- Curve comparison tools
- Export format options
- Advanced curve editing features

ARCHITECTURAL NOTES:
- Single HTML file approach for simplicity and portability
- Client-side processing (no server dependencies)
- Tailwind CSS for styling consistency
- Vanilla JavaScript for maximum compatibility

================================================================================
-->

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>quadGEN v1.3</title>
  <meta name="description" content="quadGEN - Generate Epson P700-P900/P800 QuadToneRIP .quad files with 256-step ramps per channel." />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Always show number input arrows */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: inner-spin-button !important;
      opacity: 1 !important;
    }
    
    input[type="number"] {
      -moz-appearance: textfield;
    }
    
    input[type="number"]::-moz-number-spin-box {
      -moz-appearance: spin-textfield !important;
    }

    /* Slider toggle styles */
    .slider-toggle {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }

    .slider-toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #10b981;
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #10b981;
    }

    input:checked + .slider:before {
      transform: translateX(20px);
    }

    input:disabled + .slider {
      background-color: #e5e5e5;
      cursor: not-allowed;
    }

    input:disabled + .slider:before {
      background-color: #f5f5f5;
    }

    /* Custom checkbox styling with white checkmark */
    .channel-enable-checkbox {
      appearance: none;
      width: 16px;
      height: 16px;
      border: 2px solid #d1d5db;
      border-radius: 3px;
      background-color: white;
      cursor: pointer;
      position: relative;
    }
    
    .channel-enable-checkbox:checked {
      background-color: #10b981;
      border-color: #10b981;
    }
    
    .channel-enable-checkbox:checked::after {
      content: '✓';
      color: white;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      font-weight: bold;
    }

    /* Custom scrollbar styling for file preview */
    #previewFull::-webkit-scrollbar {
      width: 24px;
    }

    #previewFull::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 12px;
    }

    #previewFull::-webkit-scrollbar-thumb {
      background: #ffffff;
      border-radius: 12px;
      border: 3px solid #2d3748;
      min-height: 60px;
    }

    #previewFull::-webkit-scrollbar-thumb:hover {
      background: #f7fafc;
    }

    #previewFull::-webkit-scrollbar-thumb:active {
      background: #e2e8f0;
    }

    /* Instant tooltip for linearization buttons */
    .per-channel-btn, #globalLinearizationBtn {
      position: relative;
    }

    .per-channel-btn:hover::after, #globalLinearizationBtn:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #1f2937;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 1000;
      margin-bottom: 4px;
      pointer-events: none;
    }

    .per-channel-btn:hover::before, #globalLinearizationBtn:hover::before {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-top: 4px solid #1f2937;
      z-index: 1000;
      pointer-events: none;
    }

    /* Hide number input spinners */
    .lstar-input::-webkit-outer-spin-button,
    .lstar-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    .lstar-input[type=number] {
      -moz-appearance: textfield;
    }
  </style>
</head>
<body class="min-h-screen bg-gray-50 p-6">
  <main class="mx-auto max-w-6xl">
    <section class="bg-white rounded-2xl shadow-lg p-6 md:p-8">
      <header class="mb-6">
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 items-center mb-2">
          <div class="flex items-center gap-4 lg:col-span-2">
            <svg id="quadgenLogo" xmlns="http://www.w3.org/2000/svg" width="56" height="56" viewBox="0 0 160 160" role="img" aria-labelledby="quadgenTitle quadgenDesc">
              <title id="quadgenTitle">quadGEN icon (CMYK)</title>
              <desc id="quadgenDesc">Four CMYK bars with a rising Bezier-style curve and nodes, flat design.</desc>
              <!-- baseline -->
              <path d="M16 132H144" fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round"/>
              <!-- CMYK bars -->
              <rect id="cyanBar" x="20" y="90" width="20" height="40" rx="6" ry="6" fill="#00B5E2"/>
              <rect id="magentaBar" x="52" y="70" width="20" height="60" rx="6" ry="6" fill="#FF2A8A"/>
              <rect id="yellowBar" x="84" y="50" width="20" height="80" rx="6" ry="6" fill="#FFD400"/>
              <rect id="blackBar" x="116" y="22" width="20" height="110" rx="6" ry="6" fill="#1A1A1A"/>
              <!-- Bezier-like curve -->
              <path id="logoPath" d="M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 28, 126 18"
                    fill="none" stroke="#1A1A1A" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
              <!-- curve nodes -->
              <circle id="node1" cx="30" cy="88" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node2" cx="62" cy="68" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node3" cx="94" cy="48" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
              <circle id="node4" cx="126" cy="18" r="6" fill="white" stroke="#1A1A1A" stroke-width="2"/>
            </svg>
            <div>
              <h1 class="text-2xl md:text-3xl font-semibold tracking-tight">
                quadGEN
                <span class="text-gray-400 text-lg">v1.3</span>
              </h1>
              <p class="text-gray-400 text-sm -mt-1">by <a href="https://www.davidmarshprints.com/" target="_blank" rel="noopener noreferrer" class="hover:text-gray-600 underline">David Marsh</a></p>
            </div>
            
            <!-- Compact printer selector -->
            <div class="flex items-center gap-2 bg-gray-50 rounded-lg border border-gray-200 px-3 py-2 ml-auto">
              <label for="printerSelect" class="text-sm font-medium text-gray-700">Printer:</label>
              <select id="printerSelect" class="text-sm rounded border border-gray-300 px-2 py-1">
                <option value="P800">P800</option>
                <option value="P700P900" selected>P700-P900</option>
              </select>
              <p id="channelInfo" class="text-xs text-gray-600 ml-1"></p>
            </div>
          </div>
          
          <!-- Status Display -->
          <div class="lg:col-span-1">
            <div class="bg-gray-50 rounded-lg border border-gray-200 px-3 py-2 text-center flex items-center justify-between">
              <span></span>
              <span id="status" class="text-xs text-gray-600 font-medium transition-opacity duration-500 ease-in-out">&nbsp;</span>
              <button id="infoBtn" class="text-xs text-gray-400 hover:text-gray-600 border border-gray-300 rounded px-2 py-1 transition-colors hidden" title="Version info">
                Info
              </button>
            </div>
          </div>
        </div>
        <p id="printerDescription" class="text-gray-600 mt-1"></p>
      </header>

      <!-- Ink Limits Graph and Linearization -->
      <div class="mb-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- Graph Section -->
        <div class="lg:col-span-2">
          <div class="bg-white border border-gray-200 rounded-xl p-4">
            <div class="bg-gray-50 rounded-lg p-4">
              <canvas id="inkChart" width="950" height="700" class="w-full h-auto max-h-none"></canvas>
            </div>
          </div>
        </div>
        
        <!-- Linearization Section -->
        <div class="lg:col-span-1 space-y-4">
          <!-- Global Linearization -->
          <div class="bg-white border border-gray-200 rounded-xl p-3">
            <h3 class="text-lg font-semibold mb-2">Global Linearization Data</h3>
            <p class="text-xs text-gray-600 mb-2">Apply correction curves to modify all ink channels uniformly.</p>
            
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-2 mb-3">
              <p class="text-xs text-blue-800 font-medium mb-1">Linearization Options:</p>
              <p class="text-xs text-blue-700">
                <strong>.txt (Color Muse):</strong> Raw measurements → calculates correction curve<br>
                <strong>.cube:</strong> Pre-made correction curves → applies directly<br>
                <strong>Manual L* Entry:</strong> Enter measured L* values directly (see button below)
              </p>
            </div>
            
            <!-- Linearization Controls -->
            <div class="space-y-3">              
              <!-- File Upload -->
              <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Data Source</label>
                <div id="globalLinearizationInfo" class="text-xs text-gray-600 mb-2 hidden">
                  <span id="globalLinearizationFilename" class="font-medium"></span>
                  <span id="globalLinearizationDetails" class="text-gray-500"></span>
                </div>
                <div class="inline-flex items-center gap-2">
                  <input type="file" id="linearizationFile" accept=".cube,.txt" class="hidden">
                  <button id="globalLinearizationBtn" class="px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded border border-gray-300 transition-colors" data-tooltip="Load global linearization">load file</button>
                  <label class="slider-toggle" title="Enable/disable global linearization">
                    <input type="checkbox" id="globalLinearizationToggle" disabled>
                    <span class="slider"></span>
                  </label>
                </div>
                <p class="text-xs text-gray-500 mt-1">accepts .cube or .txt (Color Muse) files</p>
              </div>
            </div>
            
            <!-- Manual L* Entry Button -->
            <div class="mt-3 pt-3 border-t border-gray-200">
              <button id="manualLstarBtn" class="w-full px-3 py-2 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded border border-green-300 transition-colors">
                ✏️ Enter L* values manually
              </button>
            </div>
          </div>
          
          <!-- Interpolation Method -->
          <div class="bg-white border border-gray-200 rounded-xl p-3">
            <h3 class="text-lg font-semibold mb-2">Interpolation Method</h3>
            
            <div class="space-y-3">
              <!-- Smoothing Method -->
              <div>
                <select id="curveSmoothingMethod" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" disabled>
                  <option value="cubic">Cubic Spline</option>
                  <option value="catmull">Catmull-Rom</option>
                  <option value="pchip" selected>PCHIP (monotonic)</option>
                  <option value="linear">Linear (none)</option>
                </select>
                <p id="interpolationDescription" class="text-xs text-gray-500 mt-3">Monotonic interpolation preserves data trends</p>
                
                <!-- Catmull-Rom Tension Control -->
                <div class="mt-2" id="catmullTensionContainer" style="display: none;">
                  <label class="block text-sm font-medium text-gray-700 mb-1">Curve Tension</label>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-gray-500">Tight</span>
                    <input type="range" id="catmullTension" min="0" max="100" value="50" class="flex-1 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" disabled>
                    <span class="text-xs text-gray-500">Loose</span>
                  </div>
                  <p class="text-xs text-gray-500 mt-1">Adjust how curvy the interpolation becomes</p>
                </div>
                
              </div>
            </div>
          </div>
          
        </div>
      </div>

      <!-- Load Existing .quad File -->
      <div class="mt-6">
        <div class="bg-white border border-gray-200 rounded-xl p-2">
          <div class="flex items-center gap-3">
            <input type="file" id="quadFile" accept=".quad" class="hidden">
            <button id="loadQuadBtn" class="px-2 py-1 text-xs bg-blue-100 hover:bg-blue-200 text-blue-700 rounded border border-blue-300 transition-colors">
              📂 Load .quad file
            </button>
            <span id="quadFileInfo" class="text-xs text-gray-500 hidden">No file loaded</span>
          </div>
        </div>
      </div>

      <!-- Apply-to-all controls -->
      <div class="grid md:grid-cols-3 gap-4 items-end">
        <div>
          <label class="block text-sm font-medium text-gray-700">Apply percent to all (0–100)</label>
          <div class="flex gap-2">
            <input id="applyPercent" type="number" step="1" min="0" max="100" value="33" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
            <button id="btnApplyPercent" class="rounded-lg px-4 py-2 bg-black text-white hover:bg-black/90">Apply</button>
          </div>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700">Apply end value to all (0–64,000)</label>
          <div class="flex gap-2">
            <input id="applyEnd" type="number" step="1" min="0" max="64000" value="21120" class="w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
            <button id="btnApplyEnd" class="rounded-lg px-4 py-2 bg-black text-white hover:bg-black/90">Apply</button>
          </div>
        </div>
        <div class="text-sm text-gray-600">
          Edit either <em>Percent</em> or <em>End</em> – they stay in sync. A value of <strong>0</strong> disables the channel (all zeros).
        </div>
      </div>

      <!-- Channel table -->
      <div class="mt-6 overflow-auto">
        <table class="w-full text-sm border border-gray-200 rounded-xl overflow-hidden">
          <thead class="bg-gray-50 text-gray-700">
            <tr>
              <th class="text-center px-3 py-2">
                <button id="disableAllBtn" class="px-2 py-1 text-xs bg-red-100 text-red-700 hover:bg-red-200 rounded border border-red-300 transition-colors" title="Disable all channels (set all to 0)">
                  Disable All
                </button>
              </th>
              <th class="text-left px-3 py-2">Channel</th>
              <th class="text-left px-3 py-2">Curve</th>
              <th class="text-left px-3 py-2">Percent (0–100)</th>
              <th class="text-left px-3 py-2">End (0–64,000)</th>
            </tr>
          </thead>
          <tbody id="rows"></tbody>
        </table>
      </div>

      <!-- Actions -->
      <div class="mt-6">
        <div class="flex items-center gap-2">
          <button id="downloadBtn" class="inline-flex items-center justify-center rounded-lg px-5 py-2 font-medium shadow-sm bg-black text-white hover:bg-black/90">
            ↓ Download .quad
          </button>
          <label for="filenameInput" class="text-sm font-medium text-gray-700">Filename:</label>
          <input id="filenameInput" type="text" placeholder="P900_K33_C33_M33..." class="flex-1 rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400" />
          <span class="text-sm text-gray-500">.quad</span>
        </div>
      </div>

      <!-- Configuration Notes -->
      <div class="mt-6">
        <div class="bg-white border border-gray-200 rounded-xl p-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-lg font-semibold">📝 Configuration Notes</h3>
            <button id="notesToggle" class="px-2 py-1 bg-gray-100 hover:bg-gray-200 text-gray-600 hover:text-gray-800 rounded border transition-colors" title="Expand/collapse notes">
              <svg id="notesChevron" class="w-5 h-5 transform transition-transform duration-200" style="transform: rotate(180deg)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
              </svg>
            </button>
          </div>
          
          <div id="notesContent">
            <div>
              <textarea id="userNotes" placeholder="Add notes to be added as comments to the generated .quad file" class="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400 resize-none" rows="4"></textarea>
            </div>
          </div>
        </div>
      </div>

      <!-- Full Preview -->
      <div class="mt-8">
        <h2 class="text-lg font-semibold">Full file preview</h2>
        <p class="text-sm text-gray-600 mb-3">This shows the complete file exactly as it will be saved.</p>
        <div class="border border-gray-200 rounded-xl overflow-hidden">
          <div class="bg-gray-100 px-4 py-2 text-sm font-medium text-gray-700">Preview</div>
          <pre id="previewFull" class="p-4 text-sm leading-6 overflow-auto max-h-[70vh] bg-black text-white font-mono">–</pre>
        </div>
      </div>
    </section>
    
    <!-- Info Popup -->
    <div id="infoPopup" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-4">
      <div class="bg-white rounded-xl max-w-md w-full p-6 relative">
        <button id="closeInfoBtn" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600 transition-colors">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
        
        <h2 class="text-xl font-bold mb-4">quadGEN v1.3</h2>
        
        <div id="changelogContent" class="text-sm text-gray-700 space-y-4 max-h-96 overflow-y-auto">
          <!-- Changelog will be dynamically populated from main documentation -->
        </div>
      </div>
    </div>
  </main>

  <!-- Manual L* Entry Modal -->
  <div id="lstarModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
    <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4 max-h-[80vh] overflow-y-auto">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-semibold">Manual Luminosity (L*) Entry</h3>
        <button id="closeLstarModal" class="text-gray-500 hover:text-gray-700 text-xl">&times;</button>
      </div>
      
      <div class="mb-4 text-sm text-gray-600">
        <p>Enter L* values from your measurements. Values should be evenly spaced from white to black.</p>
        <div class="flex justify-between mt-2 text-xs">
          <span class="text-gray-400">⚪ White (L*=100)</span>
          <span class="text-gray-600">⚫ Black (L*=0)</span>
        </div>
      </div>

      <div class="flex items-center justify-between mb-4 p-3 bg-gray-50 rounded border">
        <div class="flex gap-2">
          <button id="addLstarInput" class="px-3 py-1 text-sm bg-green-100 hover:bg-green-200 text-green-700 rounded border">+ Add</button>
          <button id="removeLstarInput" class="px-3 py-1 text-sm bg-red-100 hover:bg-red-200 text-red-700 rounded border">- Remove</button>
        </div>
        <div class="flex items-center gap-2">
          <label class="text-sm text-gray-600">Fields:</label>
          <input type="number" id="lstarCountInput" min="3" max="50" value="5" class="w-16 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500">
        </div>
      </div>

      <div class="flex gap-4 mb-4">
        <!-- Gradient Bar -->
        <div class="w-12 bg-gradient-to-b from-white to-black rounded border border-gray-300 relative">
          <div class="absolute inset-0 flex flex-col justify-between text-xs text-gray-600 py-2">
            <div class="text-center bg-white bg-opacity-75 px-1 rounded">100</div>
            <div class="text-center bg-black bg-opacity-75 text-white px-1 rounded">0</div>
          </div>
        </div>
        
        <!-- L* Input Fields -->
        <div class="flex-1">
          <div id="lstarInputs" class="space-y-2">
            <!-- Dynamic inputs will be added here -->
          </div>
        </div>
      </div>

      <div id="lstarValidation" class="text-sm text-red-600 mb-4 hidden"></div>

      <div class="flex justify-end gap-3">
        <button id="cancelLstar" class="px-4 py-2 text-gray-600 hover:text-gray-800 border border-gray-300 rounded hover:bg-gray-50">Cancel</button>
        <button id="generateFromLstar" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded">Generate Correction</button>
      </div>
    </div>
  </div>

  <script>
    const TOTAL = 64000;
    const N = 256;
    const DENOM = N - 1;

    const PRINTERS = {
      P800: { name: "Epson P800", channels: ["K","C","M","Y","LC","LM","LK","LLK"] },
      P700P900: { name: "Epson P700-P900", channels: ["K","C","M","Y","LC","LM","LK","LLK","V","MK"] }
    };

    const INK_COLORS = {
      K: "#111111",
      C: "#00AEEF",
      M: "#EC008C",
      Y: "#FFF200",
      LC: "#8FD3FF",
      LM: "#FF9AD5",
      LK: "#777777",
      LLK: "#BBBBBB",
      V: "#7F00FF",
      MK: "#000000"
    };


    // Cache DOM elements
    const elements = {
      rows: document.getElementById('rows'),
      printerSelect: document.getElementById('printerSelect'),
      channelInfo: document.getElementById('channelInfo'),
      printerDescription: document.getElementById('printerDescription'),
      applyPercent: document.getElementById('applyPercent'),
      btnApplyPercent: document.getElementById('btnApplyPercent'),
      applyEnd: document.getElementById('applyEnd'),
      btnApplyEnd: document.getElementById('btnApplyEnd'),
      downloadBtn: document.getElementById('downloadBtn'),
      previewFull: document.getElementById('previewFull'),
      status: document.getElementById('status'),
      inkChart: document.getElementById('inkChart'),
      filenameInput: document.getElementById('filenameInput'),
      linearizationFile: document.getElementById('linearizationFile'),
      globalLinearizationBtn: document.getElementById('globalLinearizationBtn'),
      globalLinearizationToggle: document.getElementById('globalLinearizationToggle'),
      curveSmoothingMethod: document.getElementById('curveSmoothingMethod'),
      catmullTension: document.getElementById('catmullTension'),
      catmullTensionContainer: document.getElementById('catmullTensionContainer'),
      userNotes: document.getElementById('userNotes'),
      notesToggle: document.getElementById('notesToggle'),
      quadFile: document.getElementById('quadFile'),
      loadQuadBtn: document.getElementById('loadQuadBtn'),
      quadFileInfo: document.getElementById('quadFileInfo'),
      manualLstarBtn: document.getElementById('manualLstarBtn'),
      lstarModal: document.getElementById('lstarModal'),
      closeLstarModal: document.getElementById('closeLstarModal'),
      lstarInputs: document.getElementById('lstarInputs'),
      addLstarInput: document.getElementById('addLstarInput'),
      removeLstarInput: document.getElementById('removeLstarInput'),
      lstarCountInput: document.getElementById('lstarCountInput'),
      lstarValidation: document.getElementById('lstarValidation'),
      cancelLstar: document.getElementById('cancelLstar'),
      generateFromLstar: document.getElementById('generateFromLstar'),
      notesContent: document.getElementById('notesContent'),
      notesChevron: document.getElementById('notesChevron'),
      disableAllBtn: document.getElementById('disableAllBtn'),
      infoBtn: document.getElementById('infoBtn'),
      infoPopup: document.getElementById('infoPopup'),
      closeInfoBtn: document.getElementById('closeInfoBtn'),
      interpolationDescription: document.getElementById('interpolationDescription'),
      globalLinearizationInfo: document.getElementById('globalLinearizationInfo'),
      globalLinearizationFilename: document.getElementById('globalLinearizationFilename'),
      globalLinearizationDetails: document.getElementById('globalLinearizationDetails'),
    };

    // Input validation utilities
    class InputValidator {
      static clampPercent(p) { 
        const num = parseFloat(p);
        return isNaN(num) ? 0 : Math.min(100, Math.max(0, num)); 
      }
      
      static clampEnd(e) { 
        const num = parseInt(e);
        return isNaN(num) ? 0 : Math.min(64000, Math.max(0, num)); 
      }
      
      static computeEndFromPercent(p) { 
        return Math.round((TOTAL * p) / 100); 
      }
      
      static computePercentFromEnd(e) { 
        return (e / TOTAL) * 100; 
      }

      static validateInput(input, validator) {
        const originalValue = input.value;
        const validatedValue = validator(originalValue);
        const isValid = validatedValue.toString() === originalValue || Math.abs(parseFloat(originalValue) - validatedValue) < 0.01;
        
        input.classList.toggle('border-red-300', !isValid);
        input.classList.toggle('border-gray-300', isValid);
        
        if (!isValid) {
          input.value = validatedValue.toString();
        }
        
        return validatedValue;
      }
    }

    // Debounce function to prevent excessive updates
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function showStatus(message) {
      elements.status.textContent = message;
      elements.status.style.opacity = '1';
      setTimeout(() => {
        if (elements.status.textContent === message) {
          elements.status.style.opacity = '0';
          setTimeout(() => {
            if (elements.status.style.opacity === '0') {
              elements.status.innerHTML = "&nbsp;";
              elements.status.style.opacity = '1';
            }
          }, 500); // Wait for fade transition to complete
        }
      }, 6000);
    }
    
    function animateLogoBars() {
      const cyanBar = document.getElementById('cyanBar');
      const magentaBar = document.getElementById('magentaBar');
      const yellowBar = document.getElementById('yellowBar');
      const blackBar = document.getElementById('blackBar');
      const logoPath = document.getElementById('logoPath');
      const node1 = document.getElementById('node1');
      const node2 = document.getElementById('node2');
      const node3 = document.getElementById('node3');
      const node4 = document.getElementById('node4');
      
      if (!cyanBar || !magentaBar || !yellowBar || !blackBar) return;
      
      // Original values
      const originalHeights = { cyan: 40, magenta: 60, yellow: 80, black: 110 };
      const originalYs = { cyan: 90, magenta: 70, yellow: 50, black: 22 };
      
      let animationStep = 0;
      const maxSteps = 32; // Number of back-and-forth movements
      
      function animateStep() {
        if (animationStep >= maxSteps) {
          // Final return to original state
          cyanBar.setAttribute('height', originalHeights.cyan);
          cyanBar.setAttribute('y', originalYs.cyan);
          magentaBar.setAttribute('height', originalHeights.magenta);
          magentaBar.setAttribute('y', originalYs.magenta);
          yellowBar.setAttribute('height', originalHeights.yellow);
          yellowBar.setAttribute('y', originalYs.yellow);
          blackBar.setAttribute('height', originalHeights.black);
          blackBar.setAttribute('y', originalYs.black);
          logoPath.setAttribute('d', 'M30 88 C 44 84, 50 72, 62 68 S 86 50, 94 48 S 118 32, 126 22');
          node1.setAttribute('cy', '88');
          node2.setAttribute('cy', '68');
          node3.setAttribute('cy', '48');
          node4.setAttribute('cy', '18');
          return;
        }
        
        // Generate oscillating variations that get smaller over time
        const damping = 1 - (animationStep / maxSteps) * 0.7; // Reduce intensity over time
        const frequency = Math.sin(animationStep * 0.8) * damping; // Oscillating pattern
        
        const cyanVariation = originalHeights.cyan + frequency * 12;
        const magentaVariation = originalHeights.magenta + frequency * 15;
        const yellowVariation = originalHeights.yellow + frequency * 18;
        const blackVariation = originalHeights.black + frequency * 25;
        
        // Update bar heights and positions
        cyanBar.setAttribute('height', Math.max(5, cyanVariation));
        cyanBar.setAttribute('y', 132 - Math.max(5, cyanVariation));
        
        magentaBar.setAttribute('height', Math.max(5, magentaVariation));
        magentaBar.setAttribute('y', 132 - Math.max(5, magentaVariation));
        
        yellowBar.setAttribute('height', Math.max(5, yellowVariation));
        yellowBar.setAttribute('y', 132 - Math.max(5, yellowVariation));
        
        blackBar.setAttribute('height', Math.max(5, blackVariation));
        blackBar.setAttribute('y', 132 - Math.max(5, blackVariation));
        
        // Update curve and nodes to match bar heights
        const newCyanY = 132 - Math.max(5, cyanVariation) + 2;
        const newMagentaY = 132 - Math.max(5, magentaVariation) + 2;
        const newYellowY = 132 - Math.max(5, yellowVariation) + 2;
        const newBlackY = 132 - Math.max(5, blackVariation) + 2;
        
        // Update curve path
        const newPath = `M30 ${newCyanY} C 44 ${newCyanY-4}, 50 ${newMagentaY+4}, 62 ${newMagentaY} S 86 ${newYellowY+2}, 94 ${newYellowY} S 118 ${newBlackY+10}, 126 ${newBlackY}`;
        logoPath.setAttribute('d', newPath);
        
        // Update node positions
        node1.setAttribute('cy', newCyanY);
        node2.setAttribute('cy', newMagentaY);
        node3.setAttribute('cy', newYellowY);
        node4.setAttribute('cy', newBlackY);
        
        animationStep++;
        setTimeout(animateStep, 100); // 100ms between each step
      }
      
      animateStep(); // Start the animation sequence
    }
    

    function updatePreview() {
      requestAnimationFrame(() => {
        try {
          const fileText = buildFile();
          elements.previewFull.textContent = fileText;
          updateInkChart();
          updateFilename(); // Update filename when preview updates
          showStatus("Preview updated");
        } catch (error) {
          console.error('Preview update error:', error);
          showStatus("Error updating preview");
        }
      });
    }

    function updateInkChart() {
      if (elements.rows.children.length === 0) return;
      
      const canvas = elements.inkChart;
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Set up coordinate system
      const padding = 60;
      const leftPadding = padding - 6; // Shift chart 6px left
      const rightPadding = padding + 6; // Maintain total width
      const chartWidth = width - leftPadding - rightPadding;
      const chartHeight = height - 2 * padding;
      
      // Draw grid
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineWidth = 1;
      
      // Vertical grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      
      // Horizontal grid lines (every 10%)
      for (let i = 0; i <= 10; i++) {
        const y = padding + (i * chartHeight / 10);
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(leftPadding + chartWidth, y);
        ctx.stroke();
      }
      
      // Draw axes
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(leftPadding, padding);
      ctx.lineTo(leftPadding, height - padding);
      ctx.lineTo(leftPadding + chartWidth, height - padding);
      ctx.stroke();
      
      // Draw axis labels
      ctx.fillStyle = '#374151';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      
      // X-axis labels (0% to 100%)
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (i * chartWidth / 10);
        const value = i * 10;
        // Make 0 and 100 bold
        if (value === 0 || value === 100) {
          ctx.font = 'bold 12px system-ui';
        } else {
          ctx.font = '12px system-ui';
        }
        ctx.fillText(`${value}`, x, height - padding + 20);
      }
      
      // Y-axis labels (0% to 100%)
      ctx.textAlign = 'right';
      for (let i = 0; i <= 10; i++) {
        const y = height - padding - (i * chartHeight / 10);
        const value = i * 10;
        // Make 0 and 100 bold
        if (value === 0 || value === 100) {
          ctx.font = 'bold 12px system-ui';
        } else {
          ctx.font = '12px system-ui';
        }
        ctx.fillText(`${value}`, leftPadding - 10, y + 4);
      }
      
      // Axis titles
      ctx.textAlign = 'center';
      ctx.font = '14px system-ui';
      ctx.fillText('Input Level (1-100)', width / 2, height - 10);
      
      ctx.save();
      ctx.translate(15, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Ink Limit Percentage', 0, 0);
      ctx.restore();
      
      // Draw curves and collect label info
      const labels = [];
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      
      Array.from(elements.rows.children).forEach((row, index) => {
        const channelName = row.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(row.querySelector('.end-input').value);
        
        if (endVal === 0) return; // Skip disabled channels
        
        const percent = InputValidator.computePercentFromEnd(endVal);
        const inkColor = INK_COLORS[channelName] || '#000000';
        
        // Generate the 256 values with linearization
        const values = make256(endVal, channelName, true);
        const maxValue = TOTAL; // 64000
        
        // If linearization is applied, first draw a faded linear reference line
        if (hasLinearization) {
          // Generate linear values without linearization for comparison
          const linearValues = make256(endVal, channelName, false);
          
          // Draw faded linear reference line
          ctx.strokeStyle = inkColor;
          ctx.globalAlpha = 0.25; // Fade to 25% opacity
          ctx.lineWidth = 1;
          ctx.setLineDash([2, 2]); // Dotted line
          ctx.beginPath();
          
          for (let i = 0; i < linearValues.length; i++) {
            const x = leftPadding + (i / (linearValues.length - 1)) * chartWidth;
            const valuePercent = (linearValues[i] / maxValue) * 100;
            const y = height - padding - (valuePercent / 100) * chartHeight;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
          ctx.setLineDash([]); // Reset line dash
          ctx.globalAlpha = 1.0; // Reset opacity
        }
        
        // Draw the actual linearized curve
        ctx.strokeStyle = inkColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        // Plot the curve
        for (let i = 0; i < values.length; i++) {
          const x = leftPadding + (i / (values.length - 1)) * chartWidth;
          const valuePercent = (values[i] / maxValue) * 100;
          const y = height - padding - (valuePercent / 100) * chartHeight;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        
        // Store label info for later positioning
        const actualEndValue = values[values.length - 1];
        const actualEndPercent = (actualEndValue / maxValue) * 100;
        const endY = height - padding - (actualEndPercent / 100) * chartHeight;
        
        labels.push({
          channelName,
          percent: Math.round(percent),
          inkColor,
          endY
        });
      });
      
      // Draw labels with collision avoidance
      if (labels.length > 0) {
        labels.sort((a, b) => a.endY - b.endY); // Sort by Y position
        
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'left';
        
        const minSpacing = 20; // Minimum spacing between labels
        const endX = leftPadding + chartWidth; // Position labels at the right edge of chart
        
        // Adjust label positions to avoid overlaps
        for (let i = 0; i < labels.length; i++) {
          let labelY = labels[i].endY + 4;
          
          // Check for overlap with previous label
          if (i > 0) {
            const prevLabelY = labels[i-1].adjustedY || (labels[i-1].endY + 4);
            if (labelY - prevLabelY < minSpacing) {
              labelY = prevLabelY + minSpacing;
            }
          }
          
          // Store adjusted position
          labels[i].adjustedY = labelY;
          
          // Draw the label with background for better readability
          const labelText = `${labels[i].channelName} (${labels[i].percent}%)`;
          const textMetrics = ctx.measureText(labelText);
          const textWidth = textMetrics.width;
          const textHeight = 18; // Background height for 12px text with padding
          
          // Draw solid white background
          ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
          ctx.fillRect(endX, labelY - textHeight + 2, textWidth + 4, textHeight + 2);
          
          // Calculate centered text position within the background
          const textCenterY = labelY - (textHeight / 2) + 2 + (textHeight / 2);
          
          // Draw text shadow first
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillText(labelText, endX + 3, textCenterY + 1);
          
          // Draw the text
          ctx.fillStyle = labels[i].inkColor;
          ctx.fillText(labelText, endX + 2, textCenterY);
        }
      }
      
      // Animate logo bars when chart is redrawn
      animateLogoBars();
    }

    // Generate filename based on current settings
    function generateFilename() {
      const p = PRINTERS[elements.printerSelect.value];
      // Extract just the printer model (remove "Epson " prefix)
      const printerModel = p.name.replace(/^Epson\s+/, '').replace(/\s+/g, '');
      let parts = [printerModel]; // Start with printer model
      
      // Add active channels with their percentages
      Array.from(elements.rows.children).forEach((tr) => {
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const endVal = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        
        if (endVal > 0) {
          const percent = Math.round(InputValidator.computePercentFromEnd(endVal));
          parts.push(name + percent);
        }
      });
      
      // Add LINEAR suffix if any linearization is applied
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      if (hasLinearization) {
        parts.push('LINEAR');
      }
      
      return parts.join('_');
    }

    // Update filename input with current settings
    function updateFilename() {
      if (!elements.filenameInput.dataset.userEdited) {
        elements.filenameInput.value = generateFilename();
        // Trigger validation styling
        elements.filenameInput.dispatchEvent(new Event('input'));
      }
    }
    function sanitizeFilename(filename) {
      // Remove or replace invalid characters for Windows and Mac
      // Invalid: \ / : * ? " < > |
      return filename
        .replace(/[\\/:*?"<>|]/g, '_')  // Replace invalid chars with underscore
        .replace(/\s+/g, '_')          // Replace spaces with underscores
        .replace(/_{2,}/g, '_')        // Replace multiple underscores with single
        .replace(/^_+|_+$/g, '')       // Trim underscores from start/end
        .substring(0, 200);            // Limit length to 200 chars
    }

    // ---- Linearization utilities ----
    const clamp01 = (x) => Math.max(0, Math.min(1, x));

    // Linearization data storage
    let linearizationData = null;
    let linearizationApplied = false;
    let loadedQuadData = null; // Stores complete curve data from loaded .quad files
    
    // Clear loaded quad data
    function clearLoadedQuadData() {
      loadedQuadData = null;
      if (elements.quadFileInfo) {
        elements.quadFileInfo.classList.add('hidden');
      }
      // Update interpolation controls since loaded data is no longer available
      updateInterpolationControls();
    }
    
    // Check if any linearization is available that would benefit from interpolation
    function hasAnyLinearization() {
      return (linearizationData && linearizationApplied) || 
             Object.keys(perChannelLinearization).length > 0;
      // Note: Loaded .quad data alone doesn't need interpolation since it already has 256 points
    }
    
    // Update interpolation description based on selected method
    function updateInterpolationDescription() {
      const method = elements.curveSmoothingMethod.value;
      const hasLinearization = hasAnyLinearization();
      const hasLoadedQuad = loadedQuadData && loadedQuadData.curves;
      
      if (!hasLinearization && hasLoadedQuad) {
        // Show explanation when disabled due to loaded .quad file
        elements.interpolationDescription.textContent = 'Disabled: Loaded .quad file already contains processed curves';
        elements.interpolationDescription.className = 'text-xs text-gray-500 italic mt-3';
        elements.interpolationDescription.style.display = 'block';
      } else if (!hasLinearization) {
        // Show explanation when disabled due to no linearization
        elements.interpolationDescription.textContent = 'Disabled: No linearization data loaded';
        elements.interpolationDescription.className = 'text-xs text-gray-500 italic mt-3';
        elements.interpolationDescription.style.display = 'block';
      } else {
        // Hide description when enabled (controls are self-explanatory when active)
        elements.interpolationDescription.style.display = 'none';
      }
    }
    
    // Update interpolation controls based on linearization availability
    function updateInterpolationControls() {
      const hasLinearization = hasAnyLinearization();
      elements.curveSmoothingMethod.disabled = !hasLinearization;
      elements.catmullTension.disabled = !hasLinearization;
      
      // Update visual styling for disabled state
      if (!hasLinearization) {
        elements.curveSmoothingMethod.className = 'w-full rounded-lg border border-gray-300 px-3 py-2 text-gray-400 bg-gray-100 cursor-not-allowed';
      } else {
        elements.curveSmoothingMethod.className = 'w-full rounded-lg border border-gray-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-black/10 focus:border-gray-400';
      }
      
      // Show/hide tension control for Catmull-Rom
      const method = elements.curveSmoothingMethod.value;
      const showTension = hasLinearization && method === 'catmull';
      elements.catmullTensionContainer.style.display = showTension ? 'block' : 'none';
      
      // Update description
      updateInterpolationDescription();
    }
    
    // Per-channel linearization storage
    let perChannelLinearization = {};
    let perChannelEnabled = {};
    let perChannelFilenames = {};
    
    // Channel previous values storage (for restore after enable)
    let channelPreviousValues = {};

    /**
     * Parse a .cube file string as a 1D LUT.
     * Returns { domainMin, domainMax, samples } where samples are floats (usually 0..1).
     */
    function parseCube1D(cubeText) {
      const lines = cubeText.split(/\r?\n/);
      let domainMin = 0.0;
      let domainMax = 1.0;
      let declaredSize = null;
      const samples = [];

      // Check for 3D LUT indicators early
      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;
        
        // Detect 3D LUT file format
        if (/^LUT_3D_SIZE/i.test(s)) {
          throw new Error("3D LUT files are not supported. Please use a 1D LUT (.cube) file for linearization.");
        }
      }

      for (const raw of lines) {
        const s = raw.trim();
        if (!s || s.startsWith("#") || /^TITLE/i.test(s)) continue;

        if (/^LUT_1D_SIZE/i.test(s)) {
          const m = s.match(/LUT_1D_SIZE\s+(\d+)/i);
          if (m) declaredSize = parseInt(m[1], 10);
          continue;
        }
        if (/^DOMAIN_MIN/i.test(s)) {
          // 1 or 3 numbers; for 1D we take the first
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMin = parseFloat(parts[1]);
          continue;
        }
        if (/^DOMAIN_MAX/i.test(s)) {
          const parts = s.split(/\s+/);
          if (parts[1] !== undefined) domainMax = parseFloat(parts[1]);
          continue;
        }

        // Numeric row: could be 1–3 floats. For 1D LUTs, many files still list RGB triplets.
        const nums = s.split(/\s+/).map(Number);
        if (nums.every((v) => Number.isFinite(v)) && nums.length >= 1 && nums.length <= 3) {
          samples.push(nums[0]); // take the first channel for 1D
        }
      }

      // After parsing, check if this looks like 3D LUT data
      if (samples.length > 100) {
        // 3D LUTs typically have many more data points than 1D LUTs
        // 1D LUTs usually have 16-256 points, 3D LUTs have thousands
        throw new Error("This file contains too many data points for a 1D LUT. It appears to be a 3D LUT file which is not supported. Please use a 1D LUT file for ink linearization.");
      }

      if (declaredSize !== null && samples.length >= declaredSize) {
        samples.length = declaredSize;
      }
      if (!Number.isFinite(domainMin) || !Number.isFinite(domainMax) || domainMin === domainMax) {
        domainMin = 0.0; domainMax = 1.0;
      }
      if (!samples.length) {
        throw new Error("No 1D samples found in .cube text.");
      }

      // Try using .cube samples directly without any transformation
      // .cube files might have a different coordinate system than Color Muse data
      return { domainMin, domainMax, samples };
    }

    /**
     * Parse a Color Muse data file (tab-separated format)
     * Expected format:
     * GRAY	LAB_L	LAB_A	LAB_B
     * 0	97.50	0.20	-0.50
     * 5	93.40	0.30	-0.70
     * ...
     * Returns { domainMin: 0, domainMax: 1, samples } where samples are normalized 0..1
     */
    function parseColorMuseData(fileContent, filename) {
      const lines = fileContent.split(/\r?\n/);
      const dataPoints = [];
      let headerFound = false;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        // Skip empty lines
        if (!trimmed) continue;
        
        // Check for Color Muse header
        if (trimmed.includes('GRAY') && trimmed.includes('LAB_L')) {
          headerFound = true;
          continue;
        }
        
        // Skip other comment lines
        if (trimmed.startsWith('#') || trimmed.startsWith('//')) continue;
        
        // Parse data lines (tab-separated: GRAY LAB_L LAB_A LAB_B)
        const parts = trimmed.split(/\s+/);
        if (parts.length >= 2) {
          const grayPercent = parseFloat(parts[0]);
          const labL = parseFloat(parts[1]);
          
          // Validate the parsed values
          if (!isNaN(grayPercent) && !isNaN(labL) && 
              grayPercent >= 0 && grayPercent <= 100 && 
              labL >= 0 && labL <= 100) {
            dataPoints.push({ input: grayPercent, lab: labL });
          }
        }
      }
      
      if (dataPoints.length < 2) {
        throw new Error("Not enough valid Color Muse data points found. Expected format: GRAY\\tLAB_L\\tLAB_A\\tLAB_B");
      }
      
      // Sort by gray percentage
      dataPoints.sort((a, b) => a.input - b.input);
      
      // For linearization correction, we need to create a forward correction curve
      // The measured data shows: input% -> actual LAB L*
      // We want: input% -> corrected output% to achieve linear response
      
      // First, normalize L* values to full 0-100 range
      const labValues = dataPoints.map(p => p.lab);
      const minLab = Math.min(...labValues);
      const maxLab = Math.max(...labValues);
      const labRange = maxLab - minLab;
      
      // NEW APPROACH: What if we need to flip the relationship entirely?
      // Industry standard treats the measured L* as the "target" and GRAY% as what was actually achieved
      // This would mean: measured L* tells us what we want, GRAY% tells us what input produces it
      
      // Convert L* to density-like values (invert since higher L* = lighter = lower density)
      const densityPoints = dataPoints.map(point => ({
        // Target density (inverted from L*): 0% GRAY should be 0 density, 100% GRAY should be 1 density
        targetDensity: point.input / 100,
        // What density we actually got (invert L* so high L* becomes low density)
        actualDensity: labRange > 0 ? 1.0 - ((point.lab - minLab) / labRange) : 0.5
      }));
      
      // Sort by target density
      densityPoints.sort((a, b) => a.targetDensity - b.targetDensity);
      
      console.log('Density mapping:', densityPoints.slice(0, 5)); // Debug first few points
      
      // Create correction curve: for each target density, find what input density produces it
      const samples = [];
      
      for (let i = 0; i < 256; i++) {
        const targetDensity = i / 255; // What density we want (0 = highlight, 1 = shadow)
        let correctedInput = targetDensity; // fallback to linear
        
        // Find what actual input produces this target density
        for (let j = 0; j < densityPoints.length - 1; j++) {
          const d1 = densityPoints[j];
          const d2 = densityPoints[j + 1];
          
          // Check if target falls between these actual density values
          const minActual = Math.min(d1.actualDensity, d2.actualDensity);
          const maxActual = Math.max(d1.actualDensity, d2.actualDensity);
          
          if (targetDensity >= minActual && targetDensity <= maxActual) {
            // Interpolate to find what target density produces this actual density
            const denom = d2.actualDensity - d1.actualDensity;
            if (Math.abs(denom) > 1e-10) {
              const t = (targetDensity - d1.actualDensity) / denom;
              correctedInput = d1.targetDensity + t * (d2.targetDensity - d1.targetDensity);
            }
            break;
          }
        }
        
        // Handle edge cases
        if (targetDensity < Math.min(...densityPoints.map(p => p.actualDensity))) {
          const minPoint = densityPoints.reduce((min, p) => p.actualDensity < min.actualDensity ? p : min);
          correctedInput = minPoint.targetDensity;
        } else if (targetDensity > Math.max(...densityPoints.map(p => p.actualDensity))) {
          const maxPoint = densityPoints.reduce((max, p) => p.actualDensity > max.actualDensity ? p : max);
          correctedInput = maxPoint.targetDensity;
        }
        
        samples.push(correctedInput);
      }
      
      // Apply horizontal and vertical flips to match industry standard behavior
      const flippedSamples = samples.map((sample, i) => {
        const inputPos = i / 255; // Current input position (0-1)
        const flippedInputPos = 1.0 - inputPos; // Horizontal flip
        const flippedInputIndex = Math.round(flippedInputPos * 255); // Convert back to index
        const clampedIndex = Math.max(0, Math.min(255, flippedInputIndex));
        const originalSample = samples[clampedIndex];
        const verticallyFlipped = 1.0 - originalSample; // Vertical flip
        return verticallyFlipped;
      });
      
      // Create normalized input domain (0-1 corresponding to 0%-100%)
      const domainMin = 0.0;
      const domainMax = 1.0;
      
      return {
        domainMin,
        domainMax, 
        samples: flippedSamples,
        originalData: dataPoints, // Keep original for reference
        format: 'Color Muse'
      };
    }


    /**
     * Detect file type and parse appropriately
     * For text files, pass the file content as string
     */
    async function parseLinearizationFile(fileContentOrFile, filename) {
      const extension = filename.toLowerCase().split('.').pop();
      
      if (extension === 'cube') {
        return parseCube1D(fileContentOrFile);
      } else if (extension === 'txt') {
        // Check if it's Color Muse format by looking for the header
        if (fileContentOrFile.includes('GRAY') && fileContentOrFile.includes('LAB_L')) {
          return parseColorMuseData(fileContentOrFile, filename);
        } else {
          throw new Error('TXT file format not recognized. Expected Color Muse format with GRAY and LAB_L columns.');
        }
      } else {
        throw new Error(`Unsupported file format: ${extension}. Use .cube or .txt files.`);
      }
    }

    /**
     * Natural cubic spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCubicSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Use clamped cubic spline with estimated end derivatives for more curvature
      const h = new Array(n - 1);
      const alpha = new Array(n);
      const l = new Array(n);
      const mu = new Array(n);
      const z = new Array(n);
      const c = new Array(n);
      const b = new Array(n);
      const d = new Array(n);
      
      // Step 1: Calculate h
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
      }
      
      // Step 2: Set up alpha with clamped boundary conditions
      // Estimate end derivatives to allow more curvature
      const firstDerivative = (y[1] - y[0]) / h[0];
      const lastDerivative = (y[n-1] - y[n-2]) / h[n-2];
      
      alpha[0] = 3 * ((y[1] - y[0]) / h[0] - firstDerivative);
      alpha[n-1] = 3 * (lastDerivative - (y[n-1] - y[n-2]) / h[n-2]);
      
      for (let i = 1; i < n - 1; i++) {
        alpha[i] = (3 / h[i]) * (y[i + 1] - y[i]) - (3 / h[i - 1]) * (y[i] - y[i - 1]);
      }
      
      // Step 3: Solve tridiagonal system with clamped conditions
      l[0] = 2 * h[0];
      mu[0] = 0.5;
      z[0] = alpha[0] / l[0];
      
      for (let i = 1; i < n - 1; i++) {
        l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
        mu[i] = h[i] / l[i];
        z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
      }
      
      l[n - 1] = h[n - 2] * (2 - mu[n - 2]);
      z[n - 1] = (alpha[n - 1] - h[n - 2] * z[n - 2]) / l[n - 1];
      c[n - 1] = z[n - 1];
      
      // Step 4: Back substitution
      for (let j = n - 2; j >= 0; j--) {
        c[j] = z[j] - mu[j] * c[j + 1];
        b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
        d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
      }
      
      // Return interpolation function
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Evaluate cubic polynomial - clamped cubic spline interpolation
        const dt = t - x[i];
        return y[i] + b[i] * dt + c[i] * dt * dt + d[i] * dt * dt * dt;
      };
    }

    /**
     * Catmull-Rom spline interpolation
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createCatmullRomSpline(x, y, tension = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Get the four control points (with boundary handling)
        const p0 = y[Math.max(0, i - 1)];
        const p1 = y[i];
        const p2 = y[Math.min(n - 1, i + 1)];
        const p3 = y[Math.min(n - 1, i + 2)];
        
        // Normalize t to 0-1 within the segment
        const t_norm = (t - x[i]) / (x[i + 1] - x[i]);
        const t2 = t_norm * t_norm;
        const t3 = t2 * t_norm;
        
        // Parameterized Catmull-Rom basis functions with tension control
        // tension = 0.0: very tight (close to linear)
        // tension = 0.5: standard Catmull-Rom
        // tension = 1.0: very loose/curvy
        const q0 = -tension * t3 + 2 * tension * t2 - tension * t_norm;
        const q1 = (2 - tension) * t3 + (tension - 3) * t2 + 1;
        const q2 = (tension - 2) * t3 + (3 - 2 * tension) * t2 + tension * t_norm;
        const q3 = tension * t3 - tension * t2;
        
        // Catmull-Rom interpolation with adjustable tension
        return p0 * q0 + p1 * q1 + p2 * q2 + p3 * q3;
      };
    }

    /**
     * Bezier curve interpolation using cubic Bezier segments
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createBezierSpline(x, y, intensity = 0.5) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate control points for smooth Bezier curves
      const segments = [];
      
      for (let i = 0; i < n - 1; i++) {
        const p0 = { x: x[i], y: y[i] };
        const p3 = { x: x[i + 1], y: y[i + 1] };
        
        // Calculate control points based on neighboring points
        let p1, p2;
        
        if (i === 0) {
          // First segment - use forward difference
          const slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + slope * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - slope * dist };
        } else if (i === n - 2) {
          // Last segment - use backward difference
          const slope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + slope * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - slope * dist };
        } else {
          // Middle segments - use centered differences for smooth transitions
          const prevSlope = (y[i] - y[i - 1]) / (x[i] - x[i - 1]);
          const nextSlope = (y[i + 2] - y[i + 1]) / (x[i + 2] - x[i + 1]);
          const currentSlope = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
          
          // Smooth the slopes for continuity
          const smoothSlope1 = (prevSlope + currentSlope) / 2;
          const smoothSlope2 = (currentSlope + nextSlope) / 2;
          
          const dist = (x[i + 1] - x[i]) / 3;
          p1 = { x: x[i] + dist, y: y[i] + smoothSlope1 * dist };
          p2 = { x: x[i + 1] - dist, y: y[i + 1] - smoothSlope2 * dist };
        }
        
        segments.push({ p0, p1, p2, p3 });
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find the segment
        let segmentIndex = 0;
        while (segmentIndex < segments.length - 1 && x[segmentIndex + 1] < t) {
          segmentIndex++;
        }
        
        const segment = segments[segmentIndex];
        
        // Normalize t within the segment (0 to 1)
        const segmentT = (t - segment.p0.x) / (segment.p3.x - segment.p0.x);
        
        // Cubic Bezier formula: B(t) = (1-t)³P₀ + 3(1-t)²tP₁ + 3(1-t)t²P₂ + t³P₃
        const u = 1 - segmentT;
        const tt = segmentT * segmentT;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * segmentT;
        
        const interpolated = uuu * segment.p0.y +
               3 * uu * segmentT * segment.p1.y +
               3 * u * tt * segment.p2.y +
               ttt * segment.p3.y;
        
        // Blend between linear and interpolated based on intensity
        const linear = segment.p0.y + (segment.p3.y - segment.p0.y) * segmentT;
        return linear + intensity * (interpolated - linear);
      };
    }

    /**
     * PCHIP (Piecewise Cubic Hermite Interpolating Polynomial) - Monotonic cubic spline
     * @param {number[]} x - input points (typically 0, 1, 2, ..., n-1)
     * @param {number[]} y - output values at each point
     * @returns {function} interpolation function that takes a value and returns interpolated result
     */
    function createPCHIPSpline(x, y) {
      const n = x.length;
      if (n < 2) return (t) => y[0] || 0;
      
      // Calculate slopes (derivatives) at each point
      const slopes = new Array(n);
      const h = new Array(n - 1);
      const delta = new Array(n - 1);
      
      // Calculate intervals and finite differences
      for (let i = 0; i < n - 1; i++) {
        h[i] = x[i + 1] - x[i];
        delta[i] = (y[i + 1] - y[i]) / h[i];
      }
      
      // Calculate slopes using PCHIP method
      slopes[0] = delta[0]; // First point - use forward difference
      slopes[n - 1] = delta[n - 2]; // Last point - use backward difference
      
      for (let i = 1; i < n - 1; i++) {
        // Interior points - use monotonic slope calculation
        if (delta[i - 1] * delta[i] <= 0) {
          // Data changes direction - use zero slope to avoid overshooting
          slopes[i] = 0;
        } else {
          // Data is monotonic - use weighted harmonic mean for smooth monotonic interpolation
          const w1 = 2 * h[i] + h[i - 1];
          const w2 = h[i] + 2 * h[i - 1];
          slopes[i] = (w1 + w2) / (w1 / delta[i - 1] + w2 / delta[i]);
        }
      }
      
      return (t) => {
        if (t <= x[0]) return y[0];
        if (t >= x[n - 1]) return y[n - 1];
        
        // Find interval
        let i = 0;
        while (i < n - 1 && x[i + 1] < t) i++;
        
        // Normalize t within the interval
        const dt = t - x[i];
        const h_i = h[i];
        const t_norm = dt / h_i;
        
        // Hermite basis functions
        const h00 = 2 * t_norm * t_norm * t_norm - 3 * t_norm * t_norm + 1;
        const h10 = t_norm * t_norm * t_norm - 2 * t_norm * t_norm + t_norm;
        const h01 = -2 * t_norm * t_norm * t_norm + 3 * t_norm * t_norm;
        const h11 = t_norm * t_norm * t_norm - t_norm * t_norm;
        
        // PCHIP interpolation formula
        return y[i] * h00 + h_i * slopes[i] * h10 + y[i + 1] * h01 + h_i * slopes[i + 1] * h11;
      };
    }

    /**
     * Apply a 1D LUT to a list of integers using linear, cubic spline, Catmull-Rom, Bezier, or PCHIP interpolation.
     * Preserves the endpoint values - always starts at 0 and ends at the original max value.
     * @param {number[]} values - input integers in [0..maxValue]
     * @param {number[]} lut - samples (floats), typically 0..1
     * @param {number} domainMin - LUT input domain min (typically 0)
     * @param {number} domainMax - LUT input domain max (typically 1)
     * @param {number} maxValue - the maximum value from the original linear ramp
     * @param {string} interpolationType - 'cubic', 'catmull', or 'linear'
     * @returns {number[]} adjusted integer outputs with preserved endpoints
     */
    function apply1DLUT(values, lut, domainMin = 0, domainMax = 1, maxValue = 64000, interpolationType = 'cubic') {
      const K = lut.length;
      if (K < 2) return values; // Not enough points for interpolation
      
      // Ensure LUT starts at 0 and we know the end value
      const lutStart = lut[0];
      const lutEnd = lut[K - 1];
      
      // Create x coordinates for LUT points
      const lutX = new Array(K);
      for (let i = 0; i < K; i++) {
        lutX[i] = domainMin + (i / (K - 1)) * (domainMax - domainMin);
      }
      
      let interpolationFunction;
      
      if (interpolationType === 'cubic') {
        // Cubic spline interpolation for smoothest curves - pure interpolation
        interpolationFunction = createCubicSpline(lutX, lut);
      } else if (interpolationType === 'catmull') {
        // Catmull-Rom spline interpolation - passes through control points like GIMP
        const tension = elements.catmullTension.value / 100; // Convert 0-100 to 0-1
        interpolationFunction = createCatmullRomSpline(lutX, lut, tension);
      } else if (interpolationType === 'pchip') {
        // PCHIP interpolation for monotonic, shape-preserving curves
        interpolationFunction = createPCHIPSpline(lutX, lut);
      } else {
        // Linear interpolation for exact point-to-point behavior
        const denom = (domainMax - domainMin) || 1;
        interpolationFunction = (t) => {
          const tNorm = clamp01((t - domainMin) / denom);
          const u = tNorm * (K - 1);
          const i0 = Math.floor(u);
          const i1 = Math.min(i0 + 1, K - 1);
          const a = u - i0;
          return (1 - a) * lut[i0] + a * lut[i1];
        };
      }
      
      return values.map((v, index) => {
        // FORWARD APPLICATION: Use input value to look up LUT output directly
        const t = (v / maxValue) * (domainMax - domainMin) + domainMin;
        const lutValue = interpolationFunction(t);
        
        // Scale LUT value directly to maxValue range
        return Math.round(clamp01(lutValue) * maxValue);
      });
    }

    const debouncedPreviewUpdate = debounce(updatePreview, 300);

    // Optimized 256 value generation with optional linearization
    function make256(endValue, channelName, applyLinearization = false) {
      if (endValue === 0) return new Array(N).fill(0);
      
      let arr;
      
      // Step 1: Start with base curve (loaded data or linear ramp)
      if (loadedQuadData && loadedQuadData.curves && loadedQuadData.curves[channelName]) {
        // Use loaded curve data as the starting point
        const loadedCurve = loadedQuadData.curves[channelName];
        const originalEndValue = loadedCurve[255]; // Original final value
        
        if (originalEndValue === 0) {
          return new Array(N).fill(0); // Handle edge case
        }
        
        // Scale the loaded curve to the new end value
        const scaleFactor = endValue / originalEndValue;
        arr = loadedCurve.map(value => Math.round(value * scaleFactor));
      } else {
        // Generate linear ramp as base
        arr = new Array(N);
        const step = endValue / DENOM;
        
        for (let i = 0; i < N; i++) {
          arr[i] = Math.round(i * step);
        }
      }
      
      const interpolationType = elements.curveSmoothingMethod.value;
      
      // Step 2: Apply per-channel linearization on top of base curve
      if (channelName && perChannelLinearization[channelName] && perChannelEnabled[channelName]) {
        arr = apply1DLUT(arr, perChannelLinearization[channelName].samples, perChannelLinearization[channelName].domainMin, perChannelLinearization[channelName].domainMax, endValue, interpolationType);
      }
      
      // Step 3: Apply global linearization on top of everything
      if (applyLinearization && linearizationData && linearizationApplied) {
        arr = apply1DLUT(arr, linearizationData.samples, linearizationData.domainMin, linearizationData.domainMax, endValue, interpolationType);
      }
      
      return arr;
    }

    // Randomized starting ink limits for visual variety
    function getRandomInkLimit(inkName) {
      // Define realistic ranges for different ink types - all with 100% upper bound for maximum variation
      const inkRanges = {
        K: [30, 100],     // Black: 30-100%
        C: [35, 100],     // Cyan: 35-100%
        M: [30, 100],     // Magenta: 30-100%
        Y: [40, 100],     // Yellow: 40-100%
        LC: [20, 100],    // Light Cyan: 20-100%
        LM: [20, 100],    // Light Magenta: 20-100%
        LK: [25, 100],    // Light Black: 25-100%
        LLK: [15, 100],   // Light Light Black: 15-100%
        V: [25, 100],     // Violet: 25-100%
        MK: [20, 100]     // Matte Black: 20-100%
      };
      
      const range = inkRanges[inkName] || [25, 45]; // Default range if ink not found
      const min = range[0];
      const max = range[1];
      
      // Generate random percentage within range
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // Extract channel row creation
    function createChannelRow(name) {
      const randomPercent = getRandomInkLimit(name);
      const randomEndValue = InputValidator.computeEndFromPercent(randomPercent);
      
      const tr = document.createElement('tr');
      tr.className = "border-t border-gray-200";
      tr.innerHTML = `
        <td class="px-3 py-2 text-center">
          <input type="checkbox" class="channel-enable-checkbox w-4 h-4" title="Enable/disable channel" checked>
        </td>
        <td class="px-3 py-2 font-medium">
          <span class="inline-flex items-center gap-2">
            <span class="inline-block w-3.5 h-3.5 rounded-sm border border-black/10" style="background-color: ${INK_COLORS[name] || '#000'}"></span>
            <span class="w-8">${name}</span>
            <span class="text-xs text-gray-500 invisible" data-disabled>(disabled)</span>
          </span>
        </td>
        <td class="px-3 py-2">
          <div class="inline-flex items-center gap-2">
            <input type="file" id="perChannel_${name}" accept=".cube" class="hidden per-channel-file">
            <button class="per-channel-btn px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 text-gray-600 rounded border border-gray-300 transition-colors" data-channel="${name}" data-tooltip="Load per-channel linearization">load file</button>
            <label class="slider-toggle" title="Enable/disable per-channel linearization">
              <input type="checkbox" class="per-channel-toggle" data-channel="${name}" disabled>
              <span class="slider"></span>
            </label>
          </div>
        </td>
        <td class="px-3 py-2">
          <input type="number" step="1" min="0" max="100" value="${randomPercent}" class="percent-input w-28 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
        <td class="px-3 py-2">
          <input type="number" step="1" min="0" max="64000" value="${randomEndValue}" class="end-input w-28 rounded-lg border border-gray-300 px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500">
        </td>
      `;
      
      return tr;
    }

    function setupChannelRow(tr) {
      const percentInput = tr.querySelector('.percent-input');
      const endInput = tr.querySelector('.end-input');
      const disabledTag = tr.querySelector('[data-disabled]');
      const enableCheckbox = tr.querySelector('.channel-enable-checkbox');
      const perChannelBtn = tr.querySelector('.per-channel-btn');
      const perChannelFile = tr.querySelector('.per-channel-file');
      const perChannelToggle = tr.querySelector('.per-channel-toggle');
      const channelName = tr.dataset.channel;

      function refreshDisplay() {
        const endVal = InputValidator.clampEnd(endInput.value);
        endInput.value = String(endVal);
        
        const isUserDisabled = tr.hasAttribute('data-user-disabled');
        const isAtZero = endVal === 0;
        
        // Show disabled label if channel is at 0 (either user-disabled or set to 0%)
        disabledTag.classList.toggle('invisible', !isAtZero);
        
        // Update channel label opacity and row compactness
        const channelLabel = tr.querySelector('td:nth-child(2) span');
        const allCells = tr.querySelectorAll('td');
        const linearizationCell = tr.querySelector('td:nth-child(3)');
        const percentCell = tr.querySelector('td:nth-child(4)');
        const endCell = tr.querySelector('td:nth-child(5)');
        
        if (isAtZero) {
          channelLabel.style.opacity = '0.33';
          // Make row more compact when disabled
          allCells.forEach(cell => {
            cell.className = cell.className.replace('py-2', 'py-1');
          });
          // Hide linearization controls when disabled
          linearizationCell.style.visibility = 'hidden';
          // Reduce input sizes when disabled
          percentCell.style.opacity = '0.5';
          endCell.style.opacity = '0.5';
        } else {
          channelLabel.style.opacity = '1';
          // Restore normal padding when enabled
          allCells.forEach(cell => {
            cell.className = cell.className.replace('py-1', 'py-2');
          });
          // Show linearization controls when enabled
          linearizationCell.style.visibility = 'visible';
          // Restore input opacity when enabled
          percentCell.style.opacity = '1';
          endCell.style.opacity = '1';
        }
        
        // Update checkbox state based on channel status
        enableCheckbox.checked = !isAtZero;
      }
      
      // Store refreshDisplay function on the tr element for access from apply functions
      tr.refreshDisplayFn = refreshDisplay;

      // Channel enable/disable checkbox functionality
      const handleCheckboxChange = () => {
        const currentEndVal = InputValidator.clampEnd(endInput.value);
        const currentPercentVal = InputValidator.clampPercent(percentInput.value);
        
        if (enableCheckbox.checked) {
          // Enable: restore previous values or default to 33%
          const channelName = tr.dataset.channel;
          const previousValues = channelPreviousValues[channelName];
          
          if (previousValues && previousValues.percent > 0) {
            // Restore previous values
            percentInput.value = previousValues.percent.toString();
            endInput.value = previousValues.endValue.toString();
            showStatus(`Enabled ${channelName} (restored to ${previousValues.percent}%)`);
          } else {
            // Default to 33% if no previous value stored
            percentInput.value = '33';
            endInput.value = String(InputValidator.computeEndFromPercent(33));
            showStatus(`Enabled ${channelName} (set to default 33%)`);
          }
          
          tr.removeAttribute('data-user-disabled'); // Mark as not disabled by user
        } else {
          // Disable: store current values first, then set to 0
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: currentPercentVal,
            endValue: currentEndVal
          };
          
          percentInput.value = '0';
          endInput.value = '0';
          tr.setAttribute('data-user-disabled', 'true'); // Mark as disabled by user
          showStatus(`Disabled ${channelName} (saved ${currentPercentVal}% for restore)`);
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      };
      
      enableCheckbox.addEventListener('change', handleCheckboxChange);

      // Use debounced updates to prevent excessive recalculations
      percentInput.addEventListener('input', () => {
        const p = InputValidator.validateInput(percentInput, InputValidator.clampPercent);
        const endVal = InputValidator.computeEndFromPercent(p);
        endInput.value = String(endVal);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (endVal > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (endVal > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: endVal
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      endInput.addEventListener('input', () => {
        const e = InputValidator.validateInput(endInput, InputValidator.clampEnd);
        const p = InputValidator.computePercentFromEnd(e);
        percentInput.value = p.toFixed(1);
        
        // If user manually changes from 0 to non-0, clear disabled state
        if (e > 0 && tr.hasAttribute('data-user-disabled')) {
          tr.removeAttribute('data-user-disabled');
        }
        
        // Update stored previous values with current manual change (if not disabled)
        if (e > 0 && !tr.hasAttribute('data-user-disabled')) {
          const channelName = tr.dataset.channel;
          channelPreviousValues[channelName] = {
            percent: p,
            endValue: e
          };
        }
        
        refreshDisplay();
        debouncedPreviewUpdate();
      });

      // Per-channel linearization button
      perChannelBtn.addEventListener('click', () => {
        perChannelFile.click();
      });
      
      // Per-channel file upload
      perChannelFile.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
          // Per-channel only supports pre-made curves (.cube)
          const extension = file.name.toLowerCase().split('.').pop();
          
          if (extension === 'txt') {
            throw new Error('TXT files (Color Muse) are not supported for per-channel linearization. Use only .cube files with pre-calculated corrections.');
          }
          
          const fileInput = await file.text();
          const parsed = await parseLinearizationFile(fileInput, file.name);
          perChannelLinearization[channelName] = parsed;
          perChannelEnabled[channelName] = true;
          perChannelFilenames[channelName] = file.name;
          
          // Enable and check toggle
          perChannelToggle.disabled = false;
          perChannelToggle.checked = true;
          
          // Update button tooltip with filename
          perChannelBtn.setAttribute('data-tooltip', `Loaded: ${file.name} (${parsed.samples.length} points)`);
          
          // Update interpolation controls since we now have linearization data
          updateInterpolationControls();
          
          showStatus(`Loaded per-channel linearization for ${channelName}: ${parsed.samples.length} points`);
          debouncedPreviewUpdate();
        } catch (error) {
          console.error('Per-channel cube file error:', error);
          showStatus(`Error loading ${channelName} linearization: ${error.message}`);
          
          // Reset state on error
          delete perChannelLinearization[channelName];
          delete perChannelFilenames[channelName];
          perChannelEnabled[channelName] = false;
          perChannelToggle.disabled = true;
          perChannelToggle.checked = false;
          
          // Reset button tooltip
          perChannelBtn.setAttribute('data-tooltip', 'Load per-channel linearization');
          
          // Update interpolation controls since linearization may no longer be available
          updateInterpolationControls();
        }
      });
      
      // Per-channel toggle slider
      perChannelToggle.addEventListener('change', (e) => {
        if (perChannelLinearization[channelName]) {
          perChannelEnabled[channelName] = e.target.checked;
          if (perChannelEnabled[channelName]) {
            showStatus(`Enabled per-channel linearization for ${channelName}`);
          } else {
            showStatus(`Disabled per-channel linearization for ${channelName}`);
          }
          debouncedPreviewUpdate();
        }
      });
      
      // Initialize per-channel state
      perChannelEnabled[channelName] = false;
      
      // Initial sync
      const initialP = InputValidator.clampPercent(percentInput.value);
      percentInput.value = initialP.toString();
      endInput.value = String(InputValidator.computeEndFromPercent(initialP));
      refreshDisplay();
    }

    // Optimized setPrinter with DocumentFragment
    function setPrinter(key) {
      try {
        // Clear loaded quad data when switching printers (unless we're switching due to a quad load)
        if (!loadedQuadData || loadedQuadData.switchingPrinter !== true) {
          clearLoadedQuadData();
        }
        
        const p = PRINTERS[key];
        const fragment = document.createDocumentFragment();
        
        p.channels.forEach(ch => {
          const tr = createChannelRow(ch);
          tr.dataset.channel = ch; // Add channel name to dataset
          fragment.appendChild(tr);
        });
        
        // Clear and update DOM in one operation
        elements.rows.innerHTML = "";
        elements.rows.appendChild(fragment);
        
        // Setup event listeners after DOM update
        Array.from(elements.rows.children).forEach(setupChannelRow);

        elements.channelInfo.innerHTML = "Channels: " + p.channels.map(ch => `<strong>${ch}</strong>`).join(", ");
        elements.printerDescription.innerHTML = "";
        
        // Use requestAnimationFrame for smooth UI update
        requestAnimationFrame(() => {
          updatePreview();
          updateInkChart();
          updateFilename(); // Update filename when printer changes
        });
        showStatus(`Switched to ${p.name}`);
      } catch (error) {
        console.error('Error setting printer:', error);
        showStatus("Error changing printer");
      }
    }

    function buildLimitsSummary() {
      const lines = ["# Limits summary:"];
      
      Array.from(elements.rows.children).forEach((tr) => {
        const name = tr.querySelector('td span span:nth-child(2)').textContent.trim();
        const e = InputValidator.clampEnd(tr.querySelector('.end-input').value);
        const p = InputValidator.computePercentFromEnd(e);
        
        if (e === 0) {
          lines.push("#   " + name + ": disabled");
        } else {
          const isWhole = Math.abs(p - Math.round(p)) < 1e-9;
          const percentFormatted = isWhole ? String(Math.round(p)) : p.toFixed(1);
          lines.push("#   " + name + ": = " + percentFormatted + "%");
        }
      });
      
      return lines;
    }

    function buildFile() {
      const p = PRINTERS[elements.printerSelect.value];
      const lines = [
        "## QuadToneRIP " + p.channels.join(","),
        "# Printer: " + p.name,
        "# quadGEN v1.3 by David Marsh"
      ];
      
      // Add user notes if provided
      const userNotes = elements.userNotes.value.trim();
      if (userNotes) {
        lines.push("#");
        // Split notes by lines and add # prefix to each line
        userNotes.split('\n').forEach(line => {
          lines.push("# " + line.trim());
        });
      }
      
      // Add linearization information
      const hasLinearization = (linearizationData && linearizationApplied) || Object.keys(perChannelLinearization).length > 0;
      if (hasLinearization) {
        lines.push("#");
        lines.push("# Linearization Applied:");
        
        // Global linearization
        if (linearizationData && linearizationApplied) {
          const globalFilename = linearizationData.filename || "unknown file";
          lines.push(`# - Global: ${globalFilename} (${linearizationData.samples.length} points, affects all channels)`);
        }
        
        // Per-channel linearization
        const perChannelList = [];
        Object.keys(perChannelLinearization).forEach(channelName => {
          if (perChannelEnabled[channelName]) {
            const filename = perChannelFilenames[channelName] || "unknown file";
            const points = perChannelLinearization[channelName].samples.length;
            perChannelList.push(`${channelName}: ${filename} (${points} points)`);
          }
        });
        
        if (perChannelList.length > 0) {
          lines.push("# - Per-channel:");
          perChannelList.forEach(item => {
            lines.push(`#   ${item}`);
          });
        }
        
        // Interpolation method
        const method = elements.curveSmoothingMethod.value;
        const methodNames = {
          'cubic': 'Cubic Spline',
          'pchip': 'PCHIP (monotonic)',
          'linear': 'Linear (none)'
        };
        lines.push(`# - Interpolation: ${methodNames[method]}`);
        
        // Cubic splines now use pure interpolation (no intensity control)
      }
      
      lines.push(...buildLimitsSummary());

      // Build channel blocks efficiently
      p.channels.forEach((ch, idx) => {
        const row = elements.rows.children[idx];
        const e = InputValidator.clampEnd(row.querySelector('.end-input').value);
        const arr = make256(e, ch, true); // Apply linearization if enabled
        lines.push("# " + ch + " curve");
        lines.push(...arr.map(String));
      });

      return lines.join("\n") + "\n";
    }

    // Apply-to-all with improved performance and error handling
    elements.btnApplyPercent.addEventListener('click', () => {
      try {
        const val = InputValidator.clampPercent(elements.applyPercent.value);
        const endVal = InputValidator.computeEndFromPercent(val);
        
        Array.from(elements.rows.children).forEach(tr => {
          // Skip channels that are disabled (check both checkbox state and user-disabled attribute)
          const enableCheckbox = tr.querySelector('.channel-enable-checkbox');
          if (tr.hasAttribute('data-user-disabled') || (enableCheckbox && !enableCheckbox.checked)) {
            return;
          }
          
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          percentInput.value = val.toString();
          endInput.value = String(endVal);
          
          // Trigger proper display update using the row's refreshDisplay function
          // We need to manually call refreshDisplay for each row
          const refreshDisplay = tr.refreshDisplayFn;
          if (refreshDisplay) {
            refreshDisplay();
          }
        });
        
        updatePreview();
        showStatus(`Applied ${val}% to all channels`);
      } catch (error) {
        console.error('Error applying percentage:', error);
        showStatus("Error applying percentage");
      }
    });

    elements.btnApplyEnd.addEventListener('click', () => {
      try {
        const val = InputValidator.clampEnd(elements.applyEnd.value);
        const percentVal = InputValidator.computePercentFromEnd(val);
        
        Array.from(elements.rows.children).forEach(tr => {
          // Skip channels that are disabled (check both checkbox state and user-disabled attribute)
          const enableCheckbox = tr.querySelector('.channel-enable-checkbox');
          if (tr.hasAttribute('data-user-disabled') || (enableCheckbox && !enableCheckbox.checked)) {
            return;
          }
          
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          endInput.value = String(val);
          percentInput.value = percentVal.toFixed(1);
          
          // Trigger proper display update using the row's refreshDisplay function
          const refreshDisplay = tr.refreshDisplayFn;
          if (refreshDisplay) {
            refreshDisplay();
          }
        });
        
        updatePreview();
        showStatus(`Applied ${val} end value to all channels`);
      } catch (error) {
        console.error('Error applying end value:', error);
        showStatus("Error applying end value");
      }
    });

    // Download with enhanced error handling
    elements.downloadBtn.addEventListener('click', () => {
      try {
        const text = buildFile();
        const p = PRINTERS[elements.printerSelect.value];
        
        // Get custom filename or use default
        let filename;
        const customName = elements.filenameInput.value.trim();
        if (customName) {
          // Remove .quad extension if user added it, then sanitize
          const cleanName = customName.replace(/\.quad$/, '');
          const sanitizedName = sanitizeFilename(cleanName);
          
          // If sanitization removed everything, fall back to default
          if (!sanitizedName) {
            filename = p.name.replace(/\s+/g, '') + "_linear.quad";
            showStatus("Invalid filename, using default");
          } else {
            filename = sanitizedName + '.quad';
            
            // Show warning if filename was changed
            if (sanitizedName !== cleanName) {
              showStatus(`Filename sanitized: ${filename}`);
            }
          }
        } else {
          // Use default naming
          filename = p.name.replace(/\s+/g, '') + "_linear.quad";
        }
        
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus(`Downloaded ${filename}`);
      } catch (error) {
        console.error('Download error:', error);
        showStatus("Error downloading file");
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 's':
            e.preventDefault();
            elements.downloadBtn.click();
            break;
          case 'r':
            e.preventDefault();
            updatePreview();
            break;
        }
      }
    });


    // Initialize
    elements.printerSelect.addEventListener('change', (e) => setPrinter(e.target.value));
    
    // Add real-time filename validation
    elements.filenameInput.addEventListener('input', (e) => {
      const input = e.target;
      const value = input.value.trim();
      
      // Mark as user-edited if they've typed something different from auto-generated
      if (value !== generateFilename()) {
        input.dataset.userEdited = 'true';
      } else {
        delete input.dataset.userEdited;
      }
      
      if (value) {
        const cleanName = value.replace(/\.quad$/, '');
        const sanitized = sanitizeFilename(cleanName);
        const hasInvalidChars = sanitized !== cleanName;
        
        // Visual feedback for invalid characters
        input.classList.toggle('border-yellow-300', hasInvalidChars);
        input.classList.toggle('bg-yellow-50', hasInvalidChars);
        input.classList.toggle('border-gray-300', !hasInvalidChars);
        input.classList.toggle('bg-white', !hasInvalidChars);
        
        if (hasInvalidChars) {
          input.title = `Will be saved as: ${sanitized}.quad`;
        } else {
          input.title = '';
        }
      } else {
        input.classList.remove('border-yellow-300', 'bg-yellow-50');
        input.classList.add('border-gray-300', 'bg-white');
        input.title = '';
      }
    });

    // Linearization event listeners
    
    // Global linearization button click
    elements.globalLinearizationBtn.addEventListener('click', () => {
      elements.linearizationFile.click();
    });

    elements.linearizationFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Read file content as text
        const extension = file.name.toLowerCase().split('.').pop();
        const fileInput = await file.text();
        
        const parsed = await parseLinearizationFile(fileInput, file.name);
        parsed.filename = file.name; // Store filename for documentation
        linearizationData = parsed;
        linearizationApplied = true; // Auto-apply when file is loaded
        
        // Update button tooltip and enable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: ${file.name} (${parsed.samples.length} points)`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        
        // Show file info below Data Source label
        elements.globalLinearizationFilename.textContent = file.name;
        const formatInfo = parsed.format ? ` (${parsed.format})` : '';
        elements.globalLinearizationDetails.textContent = ` - ${parsed.samples.length} points${formatInfo}`;
        elements.globalLinearizationInfo.classList.remove('hidden');
        
        // Update interpolation controls
        updateInterpolationControls();
        
        showStatus(`Loaded and applied ${parsed.samples.length} data points from ${file.name}`);
        debouncedPreviewUpdate(); // Update preview to show the applied linearization
      } catch (error) {
        console.error('Cube file parsing error:', error);
        showStatus(`Error loading file: ${error.message}`);
        linearizationData = null;
        linearizationApplied = false;
        
        // Reset button tooltip and disable toggle
        elements.globalLinearizationBtn.setAttribute('data-tooltip', 'Load global linearization');
        elements.globalLinearizationToggle.disabled = true;
        elements.globalLinearizationToggle.checked = false;
        
        // Hide file info
        elements.globalLinearizationInfo.classList.add('hidden');
        
        // Update interpolation controls
        updateInterpolationControls();
      }
    });

    // Global linearization toggle
    elements.globalLinearizationToggle.addEventListener('change', (e) => {
      if (linearizationData) {
        linearizationApplied = e.target.checked;
        if (linearizationApplied) {
          showStatus('Global linearization enabled');
        } else {
          showStatus('Global linearization disabled');
        }
        
        // Update interpolation controls
        updateInterpolationControls();
        
        debouncedPreviewUpdate();
      }
    });

    // Curve smoothing method selection
    elements.curveSmoothingMethod.addEventListener('change', (e) => {
      const method = e.target.value;
      
      // Update interpolation controls (including intensity slider visibility and description)
      updateInterpolationControls();
      
      if (hasAnyLinearization()) {
        const methodNames = {
          'cubic': 'Cubic Spline',
          'catmull': 'Catmull-Rom',
          'pchip': 'PCHIP (monotonic)',
          'linear': 'Linear (none)'
        };
        showStatus(`Curve method: ${methodNames[method]}`);
        debouncedPreviewUpdate(); // Update preview with new smoothing setting
      }
    });
    
    // Catmull-Rom tension slider
    elements.catmullTension.addEventListener('input', (e) => {
      if (hasAnyLinearization() && elements.curveSmoothingMethod.value === 'catmull') {
        const tension = Math.round(e.target.value);
        showStatus(`Catmull-Rom tension: ${tension}%`);
        debouncedPreviewUpdate(); // Update preview with new tension setting
      }
    });
    
    // Notes toggle functionality
    elements.notesToggle.addEventListener('click', () => {
      const isHidden = elements.notesContent.classList.contains('hidden');
      
      if (isHidden) {
        // Expand
        elements.notesContent.classList.remove('hidden');
        elements.notesChevron.style.transform = 'rotate(180deg)';
      } else {
        // Collapse
        elements.notesContent.classList.add('hidden');
        elements.notesChevron.style.transform = 'rotate(0deg)';
      }
    });
    
    // Disable all channels functionality
    elements.disableAllBtn.addEventListener('click', () => {
      try {
        let disabledCount = 0;
        
        Array.from(elements.rows.children).forEach(tr => {
          const percentInput = tr.querySelector('.percent-input');
          const endInput = tr.querySelector('.end-input');
          const channelName = tr.dataset.channel;
          
          // Store current values before disabling (if not already 0)
          const currentEndVal = InputValidator.clampEnd(endInput.value);
          const currentPercentVal = InputValidator.clampPercent(percentInput.value);
          
          if (currentEndVal > 0) {
            channelPreviousValues[channelName] = {
              percent: currentPercentVal,
              endValue: currentEndVal
            };
          }
          
          // Set to 0 and mark as user-disabled
          percentInput.value = '0';
          endInput.value = '0';
          tr.setAttribute('data-user-disabled', 'true');
          
          // Use proper state management
          const refreshDisplay = tr.refreshDisplayFn;
          if (refreshDisplay) {
            refreshDisplay();
          }
          
          disabledCount++;
        });
        
        updatePreview();
        showStatus(`Disabled all ${disabledCount} channels`);
      } catch (error) {
        console.error('Error disabling all channels:', error);
        showStatus("Error disabling channels");
      }
    });
    
    // Load .quad file functionality
    function parseQuadFile(content) {
      const lines = content.split('\n').map(line => line.trim());
      
      // Look for the QuadToneRIP header line to extract channel names
      let channels = [];
      let dataStartIndex = -1;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Look for QuadToneRIP header: ## QuadToneRIP K,C,M,Y,LC,LM,LK,LLK
        if (line.startsWith('## QuadToneRIP ')) {
          const channelPart = line.substring('## QuadToneRIP '.length);
          channels = channelPart.split(',').map(ch => ch.trim());
          continue;
        }
        
        // Find where numeric data starts (first line that starts with a digit)
        if (dataStartIndex === -1 && line && line.match(/^\d/)) {
          dataStartIndex = i;
          break;
        }
      }
      
      if (channels.length === 0) {
        throw new Error('Could not find QuadToneRIP header with channel names in .quad file');
      }
      
      if (dataStartIndex === -1) {
        throw new Error('Could not find numeric data in .quad file');
      }
      
      // Parse the actual numeric data portion
      // Skip to where numeric data starts and collect all numeric lines
      const numericLines = [];
      let invalidDataLines = [];
      
      for (let i = dataStartIndex; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line) {
          if (/^\d+$/.test(line)) {
            const value = parseInt(line, 10);
            
            // Validate reasonable value range for QuadToneRIP (0-65535)
            if (value < 0 || value > 65535) {
              throw new Error(`Invalid data value ${value} at line ${i + 1}. QuadToneRIP values must be 0-65535.`);
            }
            
            numericLines.push(value);
          } else if (!line.startsWith('#')) {
            // Track non-numeric, non-comment lines as potentially problematic
            invalidDataLines.push(`Line ${i + 1}: "${line}"`);
            if (invalidDataLines.length > 10) break; // Don't flood with errors
          }
        }
      }
      
      // Warn about mixed content if found
      if (invalidDataLines.length > 0) {
        const sampleLines = invalidDataLines.slice(0, 3).join(', ');
        console.warn(`Found ${invalidDataLines.length} non-numeric lines in data section: ${sampleLines}`);
      }
      
      // Each channel should have exactly 256 data points
      const expectedDataPoints = channels.length * 256;
      if (numericLines.length < expectedDataPoints) {
        throw new Error(`Insufficient data: found ${numericLines.length} values, expected ${expectedDataPoints} (${channels.length} channels × 256 points each)`);
      }
      
      // Extract all 256 data points for each channel
      const channelCurves = {};
      const values = []; // Final values for UI display
      
      for (let channelIdx = 0; channelIdx < channels.length; channelIdx++) {
        const channelName = channels[channelIdx];
        const channelStartIdx = channelIdx * 256;
        const channelEndIdx = channelStartIdx + 255; // 0-indexed, so 255 is the 256th value
        
        if (channelEndIdx >= numericLines.length) {
          throw new Error(`Not enough data for channel ${channelName}: need point ${channelEndIdx + 1}, have ${numericLines.length}`);
        }
        
        // Extract all 256 points for this channel
        const curveData = numericLines.slice(channelStartIdx, channelStartIdx + 256);
        channelCurves[channelName] = curveData;
        
        // Store the final value for UI display (percentage calculation)
        values.push(curveData[255]);
      }
      
      return { channels, values, curves: channelCurves };
    }
    
    function findMatchingPrinter(channels) {
      for (const [printerId, config] of Object.entries(PRINTERS)) {
        if (config.channels.length === channels.length && 
            config.channels.every((ch, i) => ch === channels[i])) {
          return printerId;
        }
      }
      return null;
    }
    
    // Load .quad file button click handler
    elements.loadQuadBtn.addEventListener('click', () => {
      elements.quadFile.click();
    });
    
    // Load .quad file change handler
    elements.quadFile.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        // Check file type
        if (!file.name.toLowerCase().endsWith('.quad')) {
          throw new Error(`Unsupported file type. Expected .quad file, got: ${file.name}`);
        }
        
        // Check file size (reasonable limits)
        if (file.size > 10 * 1024 * 1024) { // 10MB limit
          throw new Error(`File too large: ${(file.size / (1024*1024)).toFixed(1)}MB. Maximum supported size is 10MB.`);
        }
        
        if (file.size < 100) { // Minimum reasonable size
          throw new Error(`File too small: ${file.size} bytes. This doesn't appear to be a valid .quad file.`);
        }
        
        const content = await file.text();
        
        // Check for reasonable file structure
        if (!content.includes('QuadToneRIP')) {
          throw new Error('File does not appear to be a valid .quad file (missing QuadToneRIP header).');
        }
        
        // Check for reasonable data content
        const numericLines = content.split('\n').filter(line => line.trim() && /^\d+$/.test(line.trim()));
        if (numericLines.length < 256) {
          throw new Error(`File appears corrupted or incomplete. Found only ${numericLines.length} data points, expected at least 256.`);
        }
        
        const parsed = parseQuadFile(content);
        
        // Store the complete curve data for use in generation
        loadedQuadData = {
          filename: file.name,
          curves: parsed.curves,
          channels: parsed.channels
        };
        
        // Find matching printer
        const matchingPrinter = findMatchingPrinter(parsed.channels);
        if (!matchingPrinter) {
          const channelList = parsed.channels.join(', ');
          throw new Error(`No supported printer matches channels: ${channelList}. Supported printers: P800 (K,C,M,Y,LC,LM,LK,LLK), P700-P900 (K,C,M,Y,LC,LM,LK,LLK,V,MK)`);
        }
        
        // Switch to matching printer (mark that we're switching due to quad load)
        if (loadedQuadData) loadedQuadData.switchingPrinter = true;
        elements.printerSelect.value = matchingPrinter;
        setPrinter(matchingPrinter);
        if (loadedQuadData) delete loadedQuadData.switchingPrinter;
        
        // Wait a moment for the channel table to rebuild
        setTimeout(() => {
          // Set the channel values
          const rows = Array.from(elements.rows.children);
          parsed.values.forEach((value, index) => {
            if (index < rows.length) {
              const row = rows[index];
              const endInput = row.querySelector('.end-input');
              const percentInput = row.querySelector('.percent-input');
              
              if (endInput && percentInput) {
                endInput.value = value.toString();
                const percent = InputValidator.computePercentFromEnd(value);
                percentInput.value = percent.toString();
                
                // Refresh the row display
                const refreshFn = row.refreshDisplayFn;
                if (refreshFn) refreshFn();
              }
            }
          });
          
          updatePreview();
          
          // Show file info
          elements.quadFileInfo.textContent = `${file.name} - ${PRINTERS[matchingPrinter].name}`;
          elements.quadFileInfo.classList.remove('hidden');
          
          // Set the filename input to copy of the loaded file (remove .quad extension)
          const baseName = file.name.replace(/\.quad$/i, '');
          elements.filenameInput.value = `${baseName}_copy`;
          // Mark as user-edited so it won't be auto-generated over
          elements.filenameInput.dataset.userEdited = 'true';
          
          showStatus(`Loaded ${file.name} - switched to ${PRINTERS[matchingPrinter].name}`);
        }, 50);
        
      } catch (error) {
        console.error('Error loading .quad file:', error);
        showStatus(`Error loading .quad file: ${error.message}`);
      }
      
      // Clear the file input
      e.target.value = '';
    });
    
    // Manual L* entry functionality
    let lstarInputCount = 5;
    let lastLstarValues = []; // Store the last entered values
    
    function createLstarInput(index, value = '') {
      return `
        <div class="flex items-center gap-2">
          <span class="w-6 text-xs text-gray-500">${index + 1}.</span>
          <input type="number" class="lstar-input w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-green-500 focus:border-green-500" 
                 placeholder="L*" 
                 min="0" max="100" step="0.1" value="${value}">
        </div>
      `;
    }
    
    function updateLstarInputs() {
      const container = elements.lstarInputs;
      container.innerHTML = '';
      
      for (let i = 0; i < lstarInputCount; i++) {
        const savedValue = lastLstarValues[i] || '';
        const inputHtml = createLstarInput(i, savedValue);
        container.insertAdjacentHTML('beforeend', inputHtml);
      }
      
      elements.lstarCountInput.value = lstarInputCount;
      elements.removeLstarInput.disabled = lstarInputCount <= 3;
      
      // Update validation
      validateLstarInputs();
    }
    
    function validateLstarInputs() {
      const inputs = elements.lstarInputs.querySelectorAll('.lstar-input');
      const values = [];
      let hasErrors = false;
      let errorMessage = '';
      
      inputs.forEach((input, index) => {
        const value = parseFloat(input.value);
        if (input.value.trim() && !isNaN(value)) {
          if (value < 0 || value > 100) {
            hasErrors = true;
            errorMessage = 'L* values must be between 0 and 100';
            input.style.borderColor = '#ef4444';
          } else {
            values.push({ index, value });
            input.style.borderColor = '#d1d5db';
          }
        } else if (input.value.trim()) {
          hasErrors = true;
          errorMessage = 'Invalid L* value';
          input.style.borderColor = '#ef4444';
        } else {
          input.style.borderColor = '#d1d5db';
        }
      });
      
      if (values.length < 3) {
        hasErrors = true;
        errorMessage = 'At least 3 L* values are required';
      }
      
      if (hasErrors) {
        elements.lstarValidation.textContent = errorMessage;
        elements.lstarValidation.classList.remove('hidden');
        elements.generateFromLstar.disabled = true;
      } else {
        elements.lstarValidation.classList.add('hidden');
        elements.generateFromLstar.disabled = false;
      }
      
      return { valid: !hasErrors, values };
    }
    
    function parseManualLstarData(lstarValues) {
      // Sort values by L* (highest to lowest for white to black)
      const sortedValues = lstarValues.sort((a, b) => b.value - a.value);
      
      // Create data points assuming even spacing from 0% to 100% input
      const dataPoints = sortedValues.map((item, index) => {
        const inputPercent = (index / (sortedValues.length - 1)) * 100;
        return { input: inputPercent, lab: item.value };
      });
      
      // Normalize L* values to full 0-1 density range
      const labValues = dataPoints.map(p => p.lab);
      const minLab = Math.min(...labValues);
      const maxLab = Math.max(...labValues);
      const labRange = maxLab - minLab;
      
      // NEW APPROACH: Flip the relationship like in parseColorMuseData
      // Convert L* to density-like values (invert since higher L* = lighter = lower density)
      const densityPoints = dataPoints.map(point => ({
        // Target density (from input): 0% should be 0 density, 100% should be 1 density
        targetDensity: point.input / 100,
        // What density we actually got (invert L* so high L* becomes low density)
        actualDensity: labRange > 0 ? 1.0 - ((point.lab - minLab) / labRange) : 0.5
      }));
      
      // Sort by target density
      densityPoints.sort((a, b) => a.targetDensity - b.targetDensity);
      
      console.log('Manual L* density mapping:', densityPoints.slice(0, 5)); // Debug first few points
      
      // Create correction curve: for each target density, find what input density produces it
      const samples = [];
      
      for (let i = 0; i < 256; i++) {
        const targetDensity = i / 255; // What density we want (0 = highlight, 1 = shadow)
        let correctedInput = targetDensity; // fallback to linear
        
        // Find what actual input produces this target density
        for (let j = 0; j < densityPoints.length - 1; j++) {
          const d1 = densityPoints[j];
          const d2 = densityPoints[j + 1];
          
          // Check if target falls between these actual density values
          const minActual = Math.min(d1.actualDensity, d2.actualDensity);
          const maxActual = Math.max(d1.actualDensity, d2.actualDensity);
          
          if (targetDensity >= minActual && targetDensity <= maxActual) {
            // Interpolate to find what target density produces this actual density
            const denom = d2.actualDensity - d1.actualDensity;
            if (Math.abs(denom) > 1e-10) {
              const t = (targetDensity - d1.actualDensity) / denom;
              correctedInput = d1.targetDensity + t * (d2.targetDensity - d1.targetDensity);
            }
            break;
          }
        }
        
        // Handle edge cases
        if (targetDensity < Math.min(...densityPoints.map(p => p.actualDensity))) {
          const minPoint = densityPoints.reduce((min, p) => p.actualDensity < min.actualDensity ? p : min);
          correctedInput = minPoint.targetDensity;
        } else if (targetDensity > Math.max(...densityPoints.map(p => p.actualDensity))) {
          const maxPoint = densityPoints.reduce((max, p) => p.actualDensity > max.actualDensity ? p : max);
          correctedInput = maxPoint.targetDensity;
        }
        
        samples.push(correctedInput);
      }
      
      // Apply horizontal and vertical flips to match industry standard behavior
      const flippedSamples = samples.map((sample, i) => {
        const inputPos = i / 255; // Current input position (0-1)
        const flippedInputPos = 1.0 - inputPos; // Horizontal flip
        const flippedInputIndex = Math.round(flippedInputPos * 255); // Convert back to index
        const clampedIndex = Math.max(0, Math.min(255, flippedInputIndex));
        const originalSample = samples[clampedIndex];
        const verticallyFlipped = 1.0 - originalSample; // Vertical flip
        return verticallyFlipped;
      });
      
      return {
        domainMin: 0.0,
        domainMax: 1.0,
        samples: flippedSamples,
        originalData: dataPoints,
        format: 'Manual L* Entry'
      };
    }
    
    // Modal event handlers
    elements.manualLstarBtn.addEventListener('click', () => {
      updateLstarInputs();
      elements.lstarModal.classList.remove('hidden');
    });
    
    elements.closeLstarModal.addEventListener('click', () => {
      elements.lstarModal.classList.add('hidden');
    });
    
    elements.cancelLstar.addEventListener('click', () => {
      elements.lstarModal.classList.add('hidden');
    });
    
    elements.lstarModal.addEventListener('click', (e) => {
      if (e.target === elements.lstarModal) {
        elements.lstarModal.classList.add('hidden');
      }
    });
    
    elements.addLstarInput.addEventListener('click', () => {
      if (lstarInputCount < 50) { // Increased maximum for more measurement points
        lstarInputCount++;
        updateLstarInputs();
      }
    });
    
    elements.removeLstarInput.addEventListener('click', () => {
      if (lstarInputCount > 3) {
        lstarInputCount--;
        updateLstarInputs();
      }
    });
    
    // Live validation as user types
    elements.lstarInputs.addEventListener('input', validateLstarInputs);
    
    // Handle direct input in the count field
    elements.lstarCountInput.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      if (!isNaN(value) && value >= 3 && value <= 50) {
        lstarInputCount = value;
        updateLstarInputs();
      }
    });
    
    elements.generateFromLstar.addEventListener('click', () => {
      const validation = validateLstarInputs();
      if (!validation.valid) return;
      
      try {
        const correctionData = parseManualLstarData(validation.values);
        
        // Apply the correction as global linearization
        correctionData.filename = `Manual-L-${validation.values.length}pts`;
        linearizationData = correctionData;
        linearizationApplied = true;
        
        // Update UI to show applied correction
        elements.globalLinearizationBtn.setAttribute('data-tooltip', `Loaded: Manual L* (${validation.values.length} points)`);
        elements.globalLinearizationToggle.disabled = false;
        elements.globalLinearizationToggle.checked = true;
        
        // Show file info
        elements.globalLinearizationInfo.classList.remove('hidden');
        elements.globalLinearizationFilename.textContent = `Manual L* Entry`;
        elements.globalLinearizationDetails.textContent = ` (${validation.values.length} points)`;
        
        // Save the values for re-population
        const inputs = elements.lstarInputs.querySelectorAll('.lstar-input');
        lastLstarValues = Array.from(inputs).map(input => input.value);
        lstarInputCount = validation.values.length;
        
        // Update interpolation controls
        updateInterpolationControls();
        updatePreview();
        
        // Update filename to include LINEAR suffix if not user-edited
        if (!elements.filenameInput.dataset.userEdited) {
          const currentPrinter = elements.printerSelect.value;
          const p = PRINTERS[currentPrinter];
          const sanitizedName = p.name.replace(/\s+/g, '');
          elements.filenameInput.value = sanitizedName + '_LINEAR.quad';
        }
        
        elements.lstarModal.classList.add('hidden');
        
        showStatus(`Applied manual L* correction curve (${validation.values.length} points)`);
      } catch (error) {
        console.error('Error processing L* values:', error);
        showStatus(`Error processing L* values: ${error.message}`);
      }
    });
    
    // Function to populate changelog from main documentation
    function populateChangelog() {
      const changelogContent = document.getElementById('changelogContent');
      if (!changelogContent) return;
      
      // Since the changelog is in HTML comments, create it directly here
      // This ensures the info modal always shows the current changelog
      const changelogHtml = `
        <div>
          <p class="font-medium">v1.3 (2025-08-28) - Linearization Correction Fix:</p>
          <ul class="list-disc list-inside space-y-1 ml-2 mt-2">
            <li>Color Muse linearization correction algorithm now matches industry standard</li>
            <li>Manual L* data entry linearization correction algorithm now matches industry standard</li>
            <li>.cube file linearization corrected to use original samples directly</li>
            <li>Dual coordinate transformation applied to measurement data (Color Muse .txt files and manual L* entry)</li>
            <li>Removed erroneous inverse mapping logic from .cube file parsing</li>
            <li>Added comprehensive documentation explaining why different treatments are necessary</li>
          </ul>
        </div>
        
        <div>
          <p class="font-medium">v1.2 (2025-01-27) - Major Feature Release:</p>
          <ul class="list-disc list-inside space-y-1 ml-2 mt-2">
            <li>Complete .quad file loading with curve preservation</li>
            <li>Layered processing system (base curves + linearization)</li>
            <li>Enhanced UI with compact controls and better UX</li>
            <li>Robust file validation and error handling</li>
            <li>Streamlined printer options (P700-P900 merged)</li>
            <li>Removed ACV file support (limited open-source support)</li>
          </ul>
        </div>
        
        <div>
          <p class="font-medium">v1.1 (Previous):</p>
          <ul class="list-disc list-inside space-y-1 ml-2 mt-2">
            <li>Catmull-Rom spline interpolation with tension parameter</li>
            <li>Channel memory system for disabled channels</li>
            <li>Cube file inverse mapping corrections</li>
          </ul>
        </div>
      `;
      
      changelogContent.innerHTML = changelogHtml;
    }
    
    // Info popup functionality
    elements.infoBtn.addEventListener('click', () => {
      populateChangelog();
      elements.infoPopup.classList.remove('hidden');
    });
    
    elements.closeInfoBtn.addEventListener('click', () => {
      elements.infoPopup.classList.add('hidden');
    });
    
    // Close popup when clicking outside
    elements.infoPopup.addEventListener('click', (e) => {
      if (e.target === elements.infoPopup) {
        elements.infoPopup.classList.add('hidden');
      }
    });
    
    // Close popup with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !elements.infoPopup.classList.contains('hidden')) {
        elements.infoPopup.classList.add('hidden');
      }
    });
    
    // Initial setup with error handling
    try {
      setPrinter('P700P900');
    } catch (error) {
      console.error('Initialization error:', error);
      showStatus("Initialization error. Please refresh the page.");
    }
  </script>

</body>
</html>